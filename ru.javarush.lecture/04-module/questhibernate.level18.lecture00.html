Проблемы параллельных транзакций
<p>----------------------------------------</p>
Введение.
Потерянное обновление.
«Грязное» чтение.
Неповторяющееся чтение.
Чтение «фантомов».
<p>----------------------------------------</p>
<h2>1.1 Введение </h2>

<p>А теперь начнется самое интересное – теория работы транзакций. Как сохранить работоспособность системы, когда у вас меняются одни и те же данные в разных потоках? Или хочется выполнить одну транзакцию в другой? Ответы на эти вопросы мы начнем искать с изучения изолированности транзакций… </p>

<p><strong>Уровень изолированности транзакций</strong> — условное значение, определяющее, в какой мере в результате выполнения логически параллельных транзакций в СУБД допускается получение несогласованных данных. Шкала уровней изолированности транзакций содержит ряд значений, про ранжированных от низшего до наивысшего; более высокий уровень изолированности соответствует лучшей согласованности данных, но его использование может снижать количество физически параллельно выполняемых транзакций.  </p>

<p>И наоборот, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных. Таким образом, выбирая используемый уровень изолированности транзакций, разработчик информационной системы в определённой мере обеспечивает выбор между скоростью работы и обеспечением гарантированной согласованности получаемых из системы данных. </p>

<h3>Проблемы параллельного доступа с использованием транзакций </h3>

<p>При параллельном выполнении транзакций возможны следующие проблемы: </p>

<ul>
<li><strong>потерянное обновление</strong> (англ. lost update) — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего; </li>
<li><strong>«грязное» чтение (англ. dirty read)</strong> — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится); </li>
<li><strong>неповторяющееся чтение (англ. non-repeatable read)</strong> — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными; </li>
<li><strong>фантомное чтение (англ. phantom reads)</strong> — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк. </li>
</ul>

<p>Рассмотрим ситуации, в которых возможно возникновение данных проблем. </p>

<h2>1.2 Потерянное обновление </h2>

<p>Ситуация, когда при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется. </p>

<p>Предположим, имеются две транзакции, выполняемые одновременно: </p>

<table>
<tbody>
<tr>
<th>Транзакция 1 </th>
<th>Транзакция 2 </th>
</tr>
<tr>
<td><strong>UPDATE tbl1 SET f2=f2+20 WHERE f1=1; </strong></td>
<td><strong>UPDATE tbl1 SET f2=f2+25 WHERE f1=1; </strong></td>
</tr>
</tbody>
</table>
 
<p>В обеих транзакциях изменяется значение поля f2, по их завершении значение поля должно быть увеличено на 45. В действительности может возникнуть следующая последовательность действий: </p>

<ol>
<li>Обе транзакции одновременно читают текущее состояние поля. Точная физическая одновременность здесь не обязательна, достаточно, чтобы вторая по порядку операция чтения выполнилась до того, как другая транзакция запишет свой результат. </li>
<li>Обе транзакции вычисляют новое значение поля, прибавляя, соответственно, 20 и 25 к ранее прочитанному значению. </li>
<li>Транзакции пытаются записать результат вычислений обратно в поле f2. Поскольку физически одновременно две записи выполнить невозможно, в реальности одна из операций записи будет выполнена раньше, другая позже. При этом вторая операция записи перезапишет результат первой. </li>
</ol>

<p>В результате значение поля f2 по завершении обеих транзакций может увеличиться не на 45, а на 20 или 25, то есть одна из изменяющих данные транзакций «пропадёт». </p>
 
<h2>1.3 «Грязное» чтение </h2>

<p>Чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится). </p>

<p>Предположим, имеются две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы: </p>

<table>
<tbody>
<tr>
<th>Транзакция 1 </th>
<th>Транзакция 2 </th>
</tr>
<tr>
<td><strong>UPDATE tbl1 SET f2=f2+1 WHERE f1=1; </strong></td>
<td></td>
</tr>
<tr> 
<td></td> 
<td><strong>SELECT f2 FROM tbl1 WHERE f1=1; </strong></td>
</tr>
<tr>
<td>ROLLBACK WORK; </td>
 <td></td>
</tr>
</tbody>
</table>
 
<p>В транзакции 1 изменяется значение поля f2, а затем в транзакции 2 выбирается значение этого поля. После этого происходит откат транзакции 1. В результате значение, полученное второй транзакцией, будет отличаться от значения, хранимого в базе данных.  </p>
 
<h2>1.4 Неповторяющееся чтение </h2>

<p>Ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными. </p>

<p>Предположим, имеются две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы: </p>

<table>
<tbody>
<tr>
<th>Транзакция 1 </th>
<th>Транзакция 2 </th>
</tr>
<tr>
<td></td>
<td><strong>SELECT f2 FROM tbl1 WHERE f1=1; </strong></td>
</tr>
<tr>
<td><strong>UPDATE tbl1 SET f2=f2+3 WHERE f1=1; </strong></td>
<td></td>
</tr>
<tr>
<td><strong>COMMIT; </strong></td>
<td></td>
</tr>
<tr> 
<td></td> 
<td><strong>SELECT f2 FROM tbl1 WHERE f1=1; </strong></td>
</tr>
</tbody>
</table>

<p>В транзакции 2 выбирается значение поля f2, затем в транзакции 1 изменяется значение поля f2. При повторной попытке выбора значения из поля f2 в транзакции 2 будет получен другой результат. Эта ситуация особенно неприемлема, когда данные считываются с целью их частичного изменения и обратной записи в базу данных.</p>
 
<h2>1.5 Чтение «фантомов» </h2>

<p>Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк. </p>

<p>Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы: </p>

<table>
<tbody>
<tr>
<th>Транзакция 1 </th>
<th>Транзакция 2 </th>
</tr>
<tr>
<td></td> 
<td><strong>SELECT SUM(f2) FROM tbl1; </strong></td>
</tr>
<tr>
<td><strong>INSERT INTO tbl1 (f1,f2) VALUES (15,20); </strong></td>
<td></td>
</tr>
<tr> 
<td><strong>COMMIT; </strong></td>
 <td></td>
</tr>
<tr>
<td></td>
<td><em>SELECT SUM(f2) FROM tbl1; </em></td>
</tr>
</tbody>
</table>
 
<p>В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. Такая ситуация называется чтением фантома (фантомным чтением). От неповторяющегося чтения оно отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.</p>