Apache Cassandra
<p>----------------------------------------</p>
Описание. 
Модель данных. 
Типы данных.
<p>----------------------------------------</p>
<h2>4.1 Описание </h2>

<p><strong>Apache Cassandra</strong> — распределённая система управления базами данных, относящаяся к классу NoSQL-систем и рассчитанная на создание высокомасштабируемых и надёжных хранилищ огромных массивов данных, представленных в виде хэша. </p>

<img data-max-width="256" data-id="3f1932c4-0cbf-42a9-a763-73770a3ad298" src="https://cdn.javarush.com/images/article/3f1932c4-0cbf-42a9-a763-73770a3ad298/original.jpeg" alt="">
 
<p>Изначально проект был разработан в недрах Facebook и в 2009 году передан под крыло фонда Apache Software Foundation, эта организация продолжает развитие проекта. Промышленные решения на базе Cassandra развёрнуты для обеспечения сервисов таких компаний, как Cisco, IBM, Cloudkick, Reddit, Digg, Rackspace, Huawei, Netflix, Apple, Instagram, GitHub, Twitter и Spotify. К 2011 году крупнейший кластер серверов, обслуживающий единую базу данных под управлением Cassandra, насчитывал более 400 машин и содержал данные размером более 300 ТБ. </p>

<p>Написана на <strong>языке Java</strong>, реализует распределённую хэш-систему, сходную с DynamoDB, что обеспечивает практически линейную масштабируемость при увеличении объёма данных. Использует модель хранения данных на базе семейства столбцов, чем отличается от систем, подобных MemcacheDB, которые хранят данные только в связке «ключ — значение», возможностью организовать хранение хэшей с несколькими уровнями вложенности.  </p>

<p>Относится к категории отказоустойчивых СУБД: помещённые в базу данные автоматически реплицируются на несколько узлов распределённой сети или даже равномерно распределяются в нескольких дата-центрах. При сбое узла его функции на лету подхватываются другими узлами, добавление новых узлов в кластер и обновление версии Cassandra производится на лету, без дополнительного ручного вмешательства и переконфигурации других узлов.  </p>

<p>Тем не менее настоятельно рекомендуется заново сгенерировать ключи (метки) для каждого узла, включая существующие, чтобы сохранить качество распределения нагрузки. Генерации ключей для существующих узлов можно избежать в случае кратного увеличения количества узлов (в 2 раза, в 3 раза и так далее). </p>

<img data-max-width="1024" data-id="fa60ab89-22de-439d-a6bf-931a891933c6" src="https://cdn.javarush.com/images/article/fa60ab89-22de-439d-a6bf-931a891933c6/original.jpeg" alt="">
 
<h2>4.2 Модель данных </h2>

<p>В терминологии кассандры приложение работает с пространством ключей (keyspace), что соответствует понятию схемы базы данных (database schema) в реляционной модели. В этом пространстве ключей могут находиться несколько колоночных семейств (column family), что соответствует понятию реляционной таблицы.  </p>

<p>В свою очередь, колоночные семейства содержат колонки (column), которые объединяются при помощи ключа (row key) в записи (row). Колонка состоит из трех частей: имени (column name), метки времени (timestamp) и значения (value). Колонки в пределах записи упорядочены. В отличие от реляционной БД, никаких ограничений на то, чтобы записи (а в терминах БД это строки) содержали колонки с такими же именами, как и в других записях — нет.  </p>

<p>Колоночные семейства могут быть нескольких видов, но в этой статье мы будем опускать эту детализацию. Также в последних версиях кассандры появилась возможность выполнять запросы определения и изменения данных (DDL, DML) при помощи языка CQL, а также создавать вторичные индексы (secondary indices). </p>

<img data-max-width="1024" data-id="7c17039f-c0a3-4e11-9afb-abf68be2d8f6" src="https://cdn.javarush.com/images/article/7c17039f-c0a3-4e11-9afb-abf68be2d8f6/original.jpeg" alt="">
 
<p>Конкретное значение, хранимое в кассандре, идентифицируется: </p>

<ul>
<li><strong>пространством ключей</strong> — это привязка к приложению (предметной области). Позволяет на одном кластере размещать данные разных приложений; </li>
<li><strong>колоночным семейством</strong> — это привязка к запросу; </li>
<li><strong>ключом</strong> — это привязка к узлу кластера. От ключа зависит на какие узлы попадут сохранённые колонки; </li>
<li><strong>именем колонки</strong> — это привязка к атрибуту в записи. Позволяет в одной записи хранить несколько значений. </li>
</ul>

<p>С каждым значением связана метка времени — задаваемое пользователем число, которое используется для разрешения конфликтов во время записи: чем больше число, тем колонка считается новее, а при сравнении перетирает старые колонки.</p>
 
<h2>4.3 Типы данных </h2>

<p>По типам данных: пространство ключей и колоночное семейство — это строки (имена); метка времени — это 64-битное число; а ключ, имя колонки и значение колонки — это массив байтов. Также кассандра имеет понятие типов данных (data type). Эти типы могут по желанию разработчика (опционально) задаваться при создании колоночного семейства.  </p>

<p>Для имён колонок это называется сравнителем (comparator), для значений и ключей — валидатором (validator). Первый определяет какие байтовые значения допустимы для имён колонок и как их упорядочить. Второй — какие байтовые значение допустимы для значений колонок и ключей.  </p>

<p>Если эти типы данных не заданы, то кассандра хранит значения и сравнивает их как байтовые строки (BytesType) так как, по сути, они сохраняются внутри. </p>

<o>Типы данных бывают такими: </p>

<ul>
<li><strong>BytesType</strong>: любые байтовые строки (без валидации) </li>
<li><strong>AsciiType</strong>: ASCII строка </li>
<li><strong>UTF8Type</strong>: UTF-8 строка </li>
<li><strong>IntegerType</strong>: число с произвольным размером </li>
<li><strong>Int32Type</strong>: 4-байтовое число </li>
<li><strong>LongType</strong>: 8-байтовое число </li>
<li><strong>UUIDType</strong>: UUID 1-ого или 4-ого типа </li>
<li><strong>TimeUUIDType</strong>: UUID 1-ого типа </li>
<li><strong>DateType</strong>: 8-байтовое значение метки времени </li>
<li><strong>BooleanType</strong>: два значения: true = 1 или false = 0 </li>
<li><strong>FloatType</strong>: 4-байтовое число с плавающей запятой </li>
<li><strong>DoubleType</strong>: 8-байтовое число с плавающей запятой </li>
<li><strong>DecimalType</strong>: число с произвольным размером и плавающей запятой </li>
<li><strong>CounterColumnType</strong>: 8-байтовый счётчик </li>
</ul>

<p>В кассандре все операции записи данных это всегда операции перезаписи, то есть, если в колоночную семью приходит колонка с таким же ключом и именем, которые уже существуют, и метка времени больше, чем та которая сохранена, то значение перезаписывается. Записанные значения никогда не меняются, просто приходят более новые колонки с новыми значениями. </p>

<p>Запись в кассандру работает с большей скоростью, чем чтение. Это меняет подход, который применяется при проектировании. Если рассматривать кассандру с точки зрения проектирования модели данных, то проще представить колоночное семейство не как таблицу, а как материализованное представление (materialized view) — структуру, которая представляет данные некоторого сложного запроса, но хранит их на диске. </p>
 
<p>Вместо того, чтобы пытаться как-либо скомпоновать данные при помощи запросов, лучше постараться сохранить в коночное семейство все, что может понадобиться для этого запроса. То есть, подходить необходимо не со стороны отношений между сущностями или связями между объектами, а со стороны запросов: какие поля требуются выбрать; в каком порядке должны идти записи; какие данные, связанные с основными, должны запрашиваться совместно — всё это должно уже быть сохранено в колоночное семейство.  </p>

<p>Количество колонок в записи ограничено теоретически 2 миллиардами. Это краткое отступление, а подробней — в статье о техниках проектирования и оптимизации. А теперь давайте углубимся в процесс сохранения данных в кассандру и их чтения.</p>