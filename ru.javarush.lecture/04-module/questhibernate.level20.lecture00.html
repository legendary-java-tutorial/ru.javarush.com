Шардирование
<p>----------------------------------------</p>
Что такое шардирование? 
Делим неделимое. 
Простой пример «как сделать руками». 
Amdahl law.
<p>----------------------------------------</p>
<h2>1.1 Что такое шардирование? </h2>

<p>Если упорно гуглить, то выяснится, что между так называемым партиционированием и так называемым шардингом достаточно размытая граница. Каждый называет все, что хочет, чем хочет. Одни люди различают горизонтальное партиционирование и шардинг. Другие говорят, что шардинг — это определенный вид горизонтального партиционирования. </p>

<p>Единого терминологического стандарта, который был бы одобрен отцами-основателями и в ISO сертифицирован, я не нашел. Личное внутреннее убеждение примерно такое: Partitioning в среднем — это «режем базу на куски» произвольно взятым образом.  </p>

<ul>
<li><strong>Vertical partitioning</strong> — поколоночно. Например, есть гигантская таблица на пару миллиардов записей в 60 колонок. Вместо того, чтобы держать одну такую гигантскую таблицу, держим 60 не менее гигантских таблиц по 2 млрд записей — и это не поколоночная база, а вертикальное партиционирование (как пример терминологии). </li>
<li><strong>Horizontal partitioning</strong> — режем построчно, может быть, внутри сервера. </li>
</ul>

<p>Неловкий момент здесь в тонком отличии между горизонтальным партиционированием и шардированием. Меня можно на куски резать, но я уверенно вам не скажу, в чем оно заключается. Есть ощущение, что шардирование и горизонтальное партиционирование — это примерно одно и то же. </p>

<p><strong>Шардирование</strong> — это в целом, когда большая таблица в терминах баз или проколлекция документов, объектов, если у вас не совсем база данных, а document store, режется именно по объектам. То есть из 2 млрд объектов выбираются куски не важно, какого размера. Объекты сами по себе внутри каждого объекта не разрезаем на куски, на отдельные колонки не раскладываем, а именно пачками раскладываем в разные места. </p>

<p>Дальше уже пошли тонкие терминологические отличия. Например, условно говоря, разработчики на Postgres могут сказать, что горизонтальное партиционирование — это когда все таблицы, на которые разделена основная таблица, лежат в одной и той же схеме, а когда на разных машинах — это уже шардирование. </p>

<p>В общем смысле, не привязываясь к терминологии конкретной базы данных и конкретной системы управления данными, есть ощущение, что <strong>шардирование — это просто нарезка построчно/подокументно</strong> и так далее — и все. </p>

<p>Подчеркиваю, типично. В том смысле, что мы все это делаем не просто так, чтобы нарезать 2 млрд документов на 20 таблиц, каждая из которых была бы более manageable, а для того, чтобы распределить это на много ядер, много дисков или много разных физических или виртуальных серверов.</p>
 
<h2>1.2 Делим неделимое </h2>

<p>Подразумевается, что мы это делаем для того, чтобы каждый шард — каждый кусок данных — многократно реплицировать. Но на самом деле, нет. </p>

<pre><code>INSERT INTO docs00 
SELECT * FROM documents WHERE (id%16)=0 
... 
 
INSERT INTO docs15 
SELECT * FROM documents WHERE (id%16)=15 
</code></pre>
 
<p>На самом деле, если вы сделаете такую нарезку данных, и из одной гигантской SQL таблицы на MySQL на своем доблестном ноутбуке сгенерируете 16 маленьких табличек, не выходя за рамки ни одного ноутбука, ни одной схемы, ни одной базы данных, и т.д. и т.п. — все, у вас уже шардирование. </p>

<p>Это приводит к следующему: </p>

<ul>
<li>Увеличивается bandwidth — пропускная способность. </li>
<li>Latency не меняется, то есть каждый, так сказать, worker или consumer в данном случае, получает свое. Разные запросы обслуживаются примерно за одно время. </li>
<li>Либо и то, и другое, и еще high availability (репликация). </li>
</ul>

<p><strong>Зачем bandwidth?</strong> У нас иногда могут возникать такие объемы данных, которые не влазят — не понятно куда, но не влазят — на 1 {ядро | диск | сервер | ...}. Просто не хватает ресурсов и все. Для того, чтобы с этим большим датасетом работать, надо его нарезать. </p>

<p><strong>Зачем latency?</strong> На одном ядре просканировать таблицу из 2 млрд строк в 20 раз медленнее, чем просканировать 20 таблиц на 20 ядрах, делая это параллельно. Данные слишком медленно обрабатываются на одном ресурсе. </p>

<p><strong>Зачем high availability?</strong> Либо нарезаем данные, для того чтобы делать и одно, и другое одновременно, и заодно несколько копий каждого шарда — репликация обеспечивает высокую доступность. </p>
 
<h2>1.3 Простой пример «как сделать руками» </h2>

<p>Условный шардинг можно выпилить посредством тестовой таблицы test.documents на 32 документа, и генерацией из этой таблицы 16 тестовых таблиц примерно по 2 документа test.docs00, 01, 02, ..., 15. </p>

<pre><code>INSERT INTO docs00 
SELECT * FROM documents WHERE (id%16)=0 
... 
 
INSERT INTO docs15 
SELECT * FROM documents WHERE (id%16)=15 
</code></pre>
 
<p>Почему примерно? Потому что априори мы не знаем, как распределены id, если от 1 до 32 включительно, то будет ровно по 2 документа, иначе — нет. </p>

<p><strong>Делаем мы это вот зачем.</strong> После того, как мы сделали 16 таблиц, мы можем «захавать» 16 того, что нам нужно. Вне зависимости от того, во что мы уперлись, мы можем на эти ресурсы распараллелиться. Например, если не хватает дискового пространства, будет иметь смысл разложить эти таблицы по отдельным дискам. </p>

<p>Все это, к несчастью, не бесплатно. Подозреваю, что в случае с каноническим SQL-стандартом (давно не перечитывал SQL-стандарт, возможно, его давно не обновляли), нет официального стандартизированного синтаксиса для того, чтобы любому SQL-серверу сказать: «Дорогой SQL-сервер, сделай мне 32 шарда и разложи их на 4 диска». Но в отдельно взятых реализациях зачастую есть конкретный синтаксис для того, чтобы сделать в принципе то же самое. В PostgreSQL есть механизмы для партиционирования, в MySQL MariaDB есть, Oracle наверняка это все сделал уже давным-давно. </p>

<p>Тем не менее, если мы это делаем руками, без поддержки базы данных и в рамках стандарта, то <strong>платим условно сложностью доступа к данным</strong>. Там, где было простое SELECT * FROM documents WHERE id=123, теперь 16 x SELECT * FROM docsXX. И хорошо, если мы пытались доставать запись по ключу. Значительно более интересно, если мы пытались доставать ранний диапазон записей. Теперь (если мы, подчеркиваю, как бы дураки, и остаемся в рамках стандарта) результаты этих 16 SELECT * FROM придется объединять в приложении. </p>

<p><strong>Какого изменения производительности ожидать? </strong></p>

<ul>
<li>Интуитивно — линейного.</li> 
<li>Теоретически — сублинейного, потому что Amdahl law. </li>
<li>Практически — может быть, почти линейно, может быть, нет. </li>
</ul>

<p>На самом деле, правильный ответ — неизвестно. Ловким применением техники шардирования можно добиться значительного сверхлинейного ухудшения работы вашего приложения, да еще DBA прибежит с раскаленной кочергой. </p>

<p>Посмотрим, как этого можно добиться. Понятно, что просто поставить настройку в PostgreSQL shards=16, а дальше оно само взлетело — это не интересно. Давайте подумаем, как можно добиться того, чтобы от шардирования в 16 раз мы бы затормозили в 32 — это интересно с той точки зрения, как бы этого не делать.</p>
 
<p>Наши попытки ускориться либо затормозить всегда будут упираться в классику — в старый добрый закон Амдала (Amdahl law), который говорит, что не бывает идеальной распараллелизации любого запроса, всегда есть некая последовательная часть. </p>
 
<h2>1.4 Amdahl law </h2>

<p><span class="text-green">Всегда есть serialized часть. </span></p>

<p>Всегда есть часть исполнения запроса, которая параллелится, и всегда есть часть, которая не параллелится. Даже если вам кажется, что идеально параллелещийся запрос, как минимум сбор строки результата, которую вы собираетесь отослать на клиента, из строк, полученных с каждого шарда, всегда есть, и он всегда последовательный. </p>

<p>Всегда есть какая-то последовательная часть. Она может быть крохотной, абсолютно незаметной на общем фоне, она может быть гигантской и, соответственно, сильно влияющей на параллелизацию, но она есть всегда. </p>

<p>Кроме того, её влияние меняется и может ощутимо подрасти, например, если мы нарежем нашу таблицу — давайте поднимем ставки — из 64 записей на 16 таблиц по 4 записи, эта часть изменится. Конечно же, судя по таким гигантским объемам данных, мы работаем на мобильном телефоне и 86 процессоре 2 МГц, у нас и файлов-то не хватает, которые можно одновременно держать открытыми. Видимо, с такими вводными, мы по одному файлу за раз открываем. </p>

<ul>
<li>Было <strong>Total = Serial + Parallel</strong>. Где, например, parallel — это вся работа внутри DB, а serial —отправка результата в клиента. </li>
<li>Стало <strong>Total2 = Serial + Parallel/N + Xserial</strong>. Например, когда общий ORDER BY, Xserial>0. </li>
</ul>

<p>Этим нехитрым примером я пытаюсь показать, что появляется некое Xserial. Кроме того, что всегда есть сериализованная часть, и того, что мы пытаемся работать с данными параллельно, появляется дополнительная часть для обеспечения этой нарезки данных. Грубо говоря, нам может понадобиться: </p>

<ul>
<li>найти во внутреннем словаре базы данных эти 16 таблиц; </li>
<li>открыть файлы; </li>
<li>аллоцировать память; </li>
<li>разаллоцировать память; </li>
<li>смерджить результаты; </li>
<li>синхронизироваться между ядрами.</li>
</ul>
 
<p>Какие-то рассинхронизационные эффекты все равно обязательно появляются. Они могут быть ничтожными и занимать одну миллиардную от общего времени, но всегда ненулевые и всегда есть. С их-то помощью мы и можем резко потерять в производительности после шардирования. </p>

<img data-max-width="1024" data-id="271eab10-2784-46cd-bc06-65a0aa0211c7" src="https://cdn.javarush.com/images/article/271eab10-2784-46cd-bc06-65a0aa0211c7/original.png" alt="">
 
<p>Это стандартная картинка про закон Амдала. Тут важно то, что линии, которые должны в идеале быть прямыми и линейно расти, упираются в асимптоту. Но поскольку график из интернета нечитаемый, я изготовил, на мой взгляд, более наглядные таблицы с цифрами. </p>

<p>Предположим, что у нас есть некая сериализованная часть обработки запроса, которая занимает всего 5%: <strong>serial = 0.05 = 1 / 20</strong>. </p>

<p>Интуитивно казалось бы, что при сериализованной части, которая занимает всего 1/20 от обработки запроса, если мы распараллелим обработку запроса на 20 ядер, она станет примерно в 20, в худшем случае в 18, раз быстрее. </p>

<p>На самом деле <strong>математика — штука бессердечная</strong>: </p>

<p>wall = 0.05 + 0.95/num_cores, speedup = 1 / (0.05 + 0.95/num_cores) </p>

<p>Оказывается, что если аккуратно посчитать, при сериализованной части в 5%, ускорение будет в 10 раз (10,3), а это 51% по сравнению с теоретическим идеальным. </p>
 
<table>
<tbody>
<tr>
<td>8 cores </td>
<td>= 5.9 </td>
<td>= 74% </td>
</tr>
<tr>
<td>10 cores </td>
<td>= 6.9 </td>
<td>= 69% </td>
</tr>
<tr>
<td>20 cores </td>
<td>= 10.3 </td>
<td>= 51% </td>
</tr>
<tr>
<td>40 cores </td>
<td>= 13.6 </td>
<td>= 34% </td>
</tr>
<tr>
<td>128 cores </td>
<td>= 17.4 </td>
<td>= 14% </td>
</tr>
</tbody>
</table>
 
<p>Использовав 20 ядер (20 дисков, если угодно) на ту задачу, над которой раньше трудилось одно, мы даже теоретически ускорение больше 20 раз никогда не получим, а практически — гораздо меньше. Причем, с увеличением числа параллелей, неэффективность сильно растет. </p>
 
<p>Когда остается только 1% сериализованной работы, а 99 % параллелится, значения ускорения несколько улучшаются: </p>

<table>
<tbody>
<tr>
<td>8 cores </td>
<td>= 7.5 </td>
<td>= 93% </td>
</tr>
<tr>
<td>16 cores </td>
<td>= 13.9 </td>
<td>= 87% </td>
</tr>
<tr>
<td>32 cores </td>
<td>= 24.4 </td>
<td>= 76% </td>
</tr>
<tr>
<td>64 cores </td>
<td>= 39.3 </td>
<td>= 61% </td>
</tr>
</tbody>
</table>
 
<p>Для совершенно термоядерного запроса, который натурально часами исполняется, и подготовительная работа и сборка результата занимают очень мало времени (serial = 0.001), мы увидим уже хорошую эффективность: </p>

<table>
<tbody>
<tr>
<td>8 cores </td>
<td>= 7.94 </td>
<td>= 99% </td>
</tr>
<tr>
<td>16 cores </td>
<td>= 15.76 </td>
<td>= 99% </td>
</tr>
<tr>
<td>32 cores </td>
<td>= 31.04 </td>
<td>= 97% </td></td>
</tr>
<tr>
<td>64 cores </td>
<td>= 60.20 </td>
<td>= 94% </td>
</tr>
</tbody>
</table>
 
<p>Обратите внимание, <strong>100% мы не увидим никогда</strong>. В особо хороших случаях можно увидеть, например, 99,999%, но не ровно 100%.</p>