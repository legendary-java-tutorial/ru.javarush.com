Object Relational Mapping
<p>----------------------------------------</p>
Маппинг классов на таблицы
Появление Hibernate
Появление JPA
Maven для Hibernate
<p>----------------------------------------</p>
<h2>1.1 Маппинг классов на таблицы</h2>
<p>После изучения JDBC у тебя скорее всего сложилось мнение, что работать с базой данных из Java-приложения — то еще удовольствие. А что если я скажу, что всю это работу можно сделать в 10 раз проще?</p>
<p>В чем главное преимущество языка SQL? Это декларативный язык — он описывает, что мы хотим получить, и совсем ничего не говорит о том, как это сделать. Как — это уже забота SQL-сервера.</p>
<p>Тот же подход можно использовать и при работе с базами данных.</p>
<p>В идеальном мире мы могли бы просто писать SQL-запросы к базе, а в ответ нам бы приходили готовые Java-объекты, ну или коллекции Java-объектов, если мы запросили несколько штук.</p>
<p>Что сказать, именно так подумали несколько ребят в 2000 году и решили написать свой ORM framework.</p>
<img data-max-width="800" data-id="b796a58f-f10c-46d2-af0c-6da048ec2bca" src="https://cdn.javarush.com/images/article/b796a58f-f10c-46d2-af0c-6da048ec2bca/800.jpeg" alt="">
<p><strong>ORM</strong> расшифровывается как <strong>Object-Relational Mapping</strong> и по сути является маппингом Java-объектов на SQL-запросы.</p>
<p>Ребята придумали очень простую вещь — <span class="text-green">каждой таблице в базе данных должен соответствовать какой-то класс в Java-приложении</span>. В Java приложении мы оперируем объектами, а эти объекты уже умеют сами сохранять себя в базу данных.</p>
<p>Было три подхода к решению этой задачи, и выглядели они примерно так:</p>
<ol>
	<li>Объект сам себя сохраняет в базу данных и обновляет свои поля на основе информации из БД.</li>
	<li>Объект умеет сохранять себя в базу данных, но никогда не выступает инициатором этого дела.</li>
	<li>Объект содержит только данные, и кто-то его сохраняет в базу данных и загружает из БД.</li>
</ol>
<p>Изначально доминировал первый подход, тогда были популярны Application-сервера и Enterprise Java Beans. Был даже целый класс бинов, которые назывались Persistence EJB, которые умели себя сохранять в базу сами.</p>
<p>Но однажды все изменилось…</p>
<h2>1.2 Появление Hibernate</h2>
<p>В 2001 году была выпущена первая версия фреймворка Hibernate. Это был очень простой фреймворк, но он позволял использовать обычные "глупые объекты", которые ничего не знали о том, как их нужно сохранять в базу или загружать оттуда.</p>
<img data-max-width="512" data-id="2898bb0c-234c-4863-bd67-43401f7e5757" src="https://cdn.javarush.com/images/article/2898bb0c-234c-4863-bd67-43401f7e5757/512.jpeg" alt="">
<p>Маппинг полей Java-классов и колонок в таблице в базе задавался с помощью XML-файла. И иногда они были довольно громоздкими. Ладно, кого я обманываю. Это были здоровенные полотна XML-кода. И ситуацию спасало только то, что 20 лет назад не было таких гигантских баз данных, как сейчас.</p>
<p>Но на самом деле самым сильным решением было <strong>наконец-то отделить объект, который нужно сохранять в базу, от кода, который его туда сохранял</strong>. Это решение на самом деле неочевидное. Потому как принцип инкапсуляции утверждает, что объект лучше всех знает о том, как его нужно сохранять и загружать.</p>
<img data-max-width="800" data-id="62e2da06-e135-48f9-bea6-1c57f934870b" src="https://cdn.javarush.com/images/article/62e2da06-e135-48f9-bea6-1c57f934870b/800.jpeg" alt="">
<p>И подход ORM действительно ломает эту концепцию. Data-класс выставляет наружу свое внутреннее устройство, зато оперировать группами объектов разных типов стало значительно проще.</p>
<p><span class="text-green">Серьезный прорыв случился после выхода Java 5</span>, когда в JDK появились две вещи:</p>
<ul>
	<li><strong>Аннотации</strong></li>
	<li><strong>Proxy</strong></li>
</ul>
<p><mark class="green">Аннотации</mark> быстро вытеснили XML, и теперь прямо в Java-классе можно было легко указать все нужные настройки для маппинга Java-класса на таблицу в базе данных.</p>
<p><mark class="green">Прокси</mark> не так заметны для пользователя Hibernate, но их вклад был еще серьезнее. Когда ты запрашиваешь определённый объект или объекты у Hibernate, он просто возвращает тебе заглушку (proxy), и перехватывает все обращения к ее методам.</p>
<p>Это позволило реализовать различные механизмы Lazy Loading’а и подняло скорость и эффективность работы Hibernate на совсем заоблачный уровень для того времени. Hibernate стал не просто стандартом отрасли де-факто — его начали переводить на другие языки. Так, например для C# появился Framework NHibernate.</p>
<h2>1.3 Появление JPA</h2>
<p>За де-факто пришло и признание де-юре. Разработчики JDK решили создать спецификацию по тому, как правильно мапить объекты на таблицы в базе данных. Эта спецификация называется <mark class="orange">JPA</mark> — Java Persistence API.</p>
<p>Это именно спецификация. Она описывает, как все должно работать и какими аннотациями нужно отмечать различные части класса, если мы хотим, чтобы его объекты сохранялись в базу данных.</p>
<p>Такое ощущение, что ребята просто взяли за основу Hibernate и поменяли у него имена пакетов. Потому что все аннотации, которые были в Hibernate, почти один в один переехали в JPA.</p>
<img data-max-width="512" data-id="4c4522ec-1832-4222-8570-f2ce8b948a5f" src="https://cdn.javarush.com/images/article/4c4522ec-1832-4222-8570-f2ce8b948a5f/512.jpeg" alt="">
<p>На сегодняшний день Hibernate полностью реализует всю спецификацию JPA, а также некоторые дополнительные возможности, которые делают работу с ним еще комфортнее. Поэтому с точки зрения стандартизации можно сказать, что у Hibernate есть два набора функций:</p>
<ul>
	<li><strong>JPA-стандарт</strong></li>
	<li><strong>Hibernate Native API</strong> (дополнительная функциональность)</li>
</ul>
<p>В официальной документации Hibernate это описывается так:</p>
<img data-max-width="512" data-id="b41f7eb8-4a43-44d0-9f24-d8c423051a0c" src="https://cdn.javarush.com/images/article/b41f7eb8-4a43-44d0-9f24-d8c423051a0c/512.jpeg" alt="">
<p>Но и на основе своего опыта, и после повторного прочтения документации по Hibernate я могу сказать, что JPA и Hibernate API совпадают на 95%. Это просто тождественные понятия.</p>
<h2>1.4 Maven для Hibernate</h2>
<p>Раз уж я так сильно расхвалил Hibernate, думаю, настало время перейти к работе с ним немного поплотнее.</p>
<p>Во-первых, есть официальный сайт, где просто куча англоязычной документации. Она, конечно, имеет уклон в справочную информацию, а не в обучающую. Но все равно лучше так, чем дебажить исходники, верно? :)</p>
<p>Инструкция:</p>
<ol>
	<li>Открываешь <a href="https://hibernate.org/orm/" target="_blank">ссылку</a>.</li>
	<li>Долго на нее смотришь.</li>
	<li>Возвращаешься на JavaRush.</li>
	<li>Читаешь мои дальнейшие лекции.</li>
</ol>
<p>Моя работа и состоит в том, чтобы упрощать сложные вещи и объяснять их простыми словами. И если ты дошел до этого уровня, значит, у меня это получается.</p>
<p>Ну, а чтобы приступить к работе с Hibernate, тебе нужно добавить его в свой pom.xml. На сегодняшний день доступна уже 6-я версия Hibernate, а точнее 6.1.1, так что будем учиться работать с самой последней версией.</p>
<p>Просто добавь в свой pom.xml такие строки:</p>
<pre class='line-numbers'><code>
&lt;dependency&gt;
	&lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
	&lt;version&gt;6.1.1.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Если ты читаешь эту лекцию и за окном 2023+ год, тогда новую версию можно <a href="https://mvnrepository.com/artifact/org.hibernate/hibernate-core" target="_blank">скачать тут</a>.</p>
<p><strong>Важно!</strong> Некоторые библиотеки, которые использует Hibernate, были исключены из JDK 11 и JDK 17, поэтому если у тебя возникают проблемы с запуском проекта, то добавь в него такие зависимости:</p>
<pre class='line-numbers'><code>
  	&lt;dependency&gt;
        &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;
      	&lt;version&gt;4.0.0&lt;/version&gt;
  	&lt;/dependency&gt;
 
  	&lt;dependency&gt;
        &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
      	&lt;version&gt;4.0.0&lt;/version&gt;
  	&lt;/dependency&gt;
 
  	&lt;dependency&gt;
        &lt;groupId&gt;org.javassist&lt;/groupId&gt;
        &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;version&gt;3.29.0-GA&lt;/version&gt;
  	&lt;/dependency&gt;

</code></pre>

