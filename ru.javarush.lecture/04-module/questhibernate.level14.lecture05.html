Настройка кэша второго уровня
<p>----------------------------------------</p>
Стратегии параллельного доступа. 
Хранение данных в кэше. 
CacheMode.
<p>----------------------------------------</p>
<h2>Стратегии параллельного доступа</h2>

<p>После того, как ты включаешь в Hibernate кеширование второго уровня, тебе нужно объяснить Hibernate, какие Entity-объекты мы хотим кешировать и как.</p>

<p>Для этого у Hibernate есть специальная аннотация для Entity-классов — <span class="text-yellow"><span class="text-bold">@Cache</span></span>. Пример:</p>
 
    <div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>
<span class="text-red">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span></code></pre>
    </div> 

<p>Эту аннотацию нужно писать у каждой Entity-сущности, для которой мы хотим задействовать кэш второго уровня. Пример:</p>

<pre class='language-java line-numbers'><code>
@Entity
@Table(name = "employee")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Employee {
    @Id
    private Integer id;
    private Set&lt;Task> tasks;
}
</code></pre>

<p>У Hibernate есть 4 возможных стратегии доступа для кэшируемой сущности, если к ней обращаются из разных потоков:</p>

<ul>
<li>read-only</li>
<li>read-write</li>
<li>nonstrict-read-write</li>
<li>transactional</li>
</ul>

<p><strong>Только для чтения</strong> (read-only). Стратегия параллелизма, подходящая для данных, которая никогда не изменяется. Hibernate будет просто хранить эти объекты у себя в памяти. Используй его только для справочных данных.</p>

<p>В базах данных хранится очень много информации, которая никогда не меняется. Например, таблица хранит список событий, которые только добавляются, но никогда не изменяются и не удаляются. Если тебе нужно работать с этой таблицей через Hibernate, то тебе подойдет стратегия кэширования read-only.</p>

<p><strong>Чтение-запись</strong> (read-write). Используй эту стратегию для данных, предназначенных главным образом для чтения. Однако Hibernate будет отслеживать попытки изменения этих данных, хотя и рассчитывает, что они будут очень редкими.</p>

<p>Кешировать нужно в основном те объекты, которые редко меняются и часто читаются/запрашиваются. Если у тебя есть такие объекты, то для них нужно использовать стратегию read-write.</p>

<p><strong>Nonstrict-read-write</strong>. Эта стратегия не гарантирует согласованности между кэшем и базой данных. Используй эту стратегию, если данные почти никогда не изменяются и небольшая вероятность устаревших данных не является критической проблемой.</p>

<p>В отличии от стратегии read-write, эта стратегия подразумевает, что изменяемые данные не лочатся на чтение. Это может привести к тому, что объект изменился в одном месте, а в другом кто-то читает его старую версию.</p>

<p>Например, пользователь изменил свой комментарий, но остальные пользователи еще какое-то время видят его старую версию. Если для тебя это не является проблемой, тогда используй стратегию nonstrict-read-write.</p>

<p><strong>Транзакционный</strong>. Используй эту стратегию для данных, предназначенных главным образом для чтения, где важно предотвратить устаревшие данные в параллельных транзакциях в редких случаях обновления.</p>

<h2>Хранение данных в кэше</h2>

<p>Еще одна важная деталь про кэш второго уровня, про которую стоило бы вспомнить, — Hibernate не хранит сами объекты твоих классов. Он хранит информацию в виде массивов строк, чисел и т. д.</p>

<p>И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. Можно представить себе это так:</p>
 
<pre><code>1 -> { "Иванов", 1, null , {1,2,5} }
2 -> { "Петров", 2, null , {1,2,5} }
3 -> { "Сидоров", 3, null , {1,2,5} }</code></pre>
 
<p>Что есть очень разумно, учитывая, сколько лишней памяти занимает каждый объект.</p>

<p>Помимо вышесказанного, следует помнить — зависимости твоего Entity-класса по умолчанию также не кэшируются. Например, если рассмотреть класс выше, <span class="code"><span class="text-green">Employee</span></span>, то при выборке коллекция tasks будет <span class="text-green">доставаться из БД</span>, а <span class="text-red">не из кэша второго уровня</span>.</p>

<p>Если ты хочешь также кешировать и зависимости, то класс должен выглядеть так:</p>

<pre class='language-java line-numbers'><code>
@Entity
@Table(name = "employee")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Employee {
    @Id
    private Integer id;
 
   @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
   private Set&lt;Task> tasks;
}
</code></pre>

<p>И последняя деталь — чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.</p>

<h2>CacheMode</h2>

<p>Hibernate позволяет очень гибко управлять кешированием. Ты можешь настроить режим кеширования для каждой отдельной сессии или даже для каждого запроса к базе данных.</p>

<p>Всего таких режимов пять:</p>

<ul>
<li><strong>GET</strong></li>
<li><strong>IGNORE</strong></li>
<li><strong>NORMAL</strong></li>
<li><strong>PUT</strong></li>
<li><strong>REFRESH</strong></li>
</ul>

<p>В таблице ниже описана их работа:</p>

<table>
<tbody>
<tr>
<th>CacheMode</th>
<th>Описание</th>
</tr>
<tr>
<td>GET</td>
<td>Данные читаются из кэша, но не добавляются в него.</td>
</tr>
<tr>
<td>IGNORE</td>
<td>Сессия не взаимодействует с кэшем.</td>
</tr>
<tr>
<td>NORMAL</td>
<td>Данные читаются из кэша и добавляются в него.</td>
</tr>
<tr>
<td>PUT</td>
<td>Данные никогда не берутся из кэша, но добавляются в него.</td>
</tr>
<tr>
<td>REFRESH</td>
<td>Данные никогда не берутся из кэша, но добавляются в него. В этом режиме дополнительно используется настройка hibernate.cache.use_minimal_puts.</td>
</tr>
</tbody>
</table>
 
<p>Пример установки режима кэширования для сессии:
 
<pre class='language-java line-numbers'><code>
session.setCacheMode(CacheMode.GET);
Employee director = session.createQuery("from Employee where id = 4").uniqueResult();
</code></pre>
 
<p>А также пример установки режима для сессии и запроса:</p>
<pre class='language-java line-numbers'><code>
session.setCacheMode(CacheMode.GET);
Query query = session.createQuery("from Employee where id = 4");
query.setCacheMode(CacheMode.IGNORE); // Игнорирует работу с кэшем для этого запроса
Employee director = query.uniqueResult();
</code></pre>