Кеширование данных в Hibernate
<p>----------------------------------------</p>
Никогда не пишите свое решение по кешированию. 
Кеширование в базе данных. 
Виды кеширования в Hibernate. 
Кэширование второго уровня.
<p>----------------------------------------</p>
<h2>Никогда не пишите свое решение по кешированию</h2>

<p>Еще один способ ускорить работу с базой данных — это кешировать объекты, которые мы уже запрашивали раннее.</p>

<p><strong>Важно!</strong> Никогда не пиши свое решение по кешированию. Эта задача имеет столько подводных камней, что тебе и не снилось.</p>

<p>Проблема 1 — <strong>сброс кэша</strong>. Иногда происходят события, когда нужно удалить объект из кэша или обновить его в нем. Единственный способ сделать это грамотно — пропускать все запросы к базе через движок кэша. Иначе тебе каждый раз придется явно указывать кэшу, какие объекты в нем стоит удалить или обновить.</p>

<p>Проблема 2 — <strong>нехватка памяти</strong>. Кеширование кажется отличной идеей, пока ты не столкнёшься с тем, что объекты в памяти занимают много места. Тебе нужны дополнительно десятки гигабайт памяти для эффективной работы кэша серверного приложения.</p>

<p>А так как памяти всегда не хватает, то нужна эффективная стратегия удаления объектов из кэша. Это чем-то напоминает сборщик мусора в Java. И как ты помнишь, уже десятки лет лучшие умы изобретают различные способы маркировки объектов по поколениям и т. п.</p>

<p>Проблема 3 — <strong>различные стратегии</strong>. Как показывает практика, для разных объектов эффективны различные стратегии хранения и обновления в кэше. Эффективная система кэширования не может обойтись одой стратегией для всех объектов.</p>

<p>Проблема 4 — <strong>эффективное хранение объектов</strong>. Нельзя просто хранить объекты в кэше. Объекты слишком часто содержат ссылки на другие объекты и т. п. Такими темпами тебе не понадобится сборщик мусора: ему просто будет нечего удалять.</p>

<p>Поэтому вместо того, чтобы хранить сами объекты, иногда гораздо эффективнее хранить значения их полей-примитивов. И системы быстрого конструирования объектов по ним.</p>

<p>На выходе ты получишь целую виртуальную СУБД в памяти, которая должна быстро работать и потреблять мало памяти.</p>

<h2>Кеширование в базе данных</h2>

<p>Кроме кеширования прямо в Java-программе еще часто организовывают кеширование прямо в базе данных.</p>

<p>Там есть четыре больших подхода:</p>

<p>Подход первый — <strong>денормализация базы данных</strong>. SQL-сервер у себя в памяти хранит данные не так, как они храниться в таблицах.</p>

<p>Когда данные хранятся на диске в таблицах, то очень часто разработчики стараются по максимуму избежать дублирования данных — такой процесс называется нормализацией базы данных. Так вот, для ускорения работы с данными в памяти выполняется обратный процесс — денормализация базы данных. Куча связанных таблиц может храниться уже в объединённом виде — в виде большущих таблиц и т. п.</p>

<p>Второй подход — <strong>кэширование запросов</strong>. И результатов запросов.</p>

<p>СУБД видит, что очень часто к ней приходят одинаковые или похожие запросы. Тогда она начинает просто кешировать эти запросы и ответы на них. Но при этом нужно четко следить за тем, чтобы из кэша своевременно удалялись строки, которые изменились в базе.</p>

<p>Этот подход может быть очень эффективным при участии человека, который может проанализировать запросы и помочь СУБД понять, как их лучше кэшировать.</p>

<p>Третий подход — <strong>база данных в памяти</strong>.</p>

<p>Еще один часто используемый подход. Между сервером и СУБД ставится еще одна база, которая хранит все свои данные только в памяти. Ее еще называют In-Memory-DB.
Если у тебя много разных серверов обращаются к одной базе данных, то с помощью In-Memory-DB можно организовать кэширование, ориентированное на тип конкретного сервера.</p>

<p>Пример:</p>

<img data-max-width="1024" data-id="9f2582a5-e5db-4280-88ff-6f605c256bdf" src="https://cdn.javarush.com/images/article/9f2582a5-e5db-4280-88ff-6f605c256bdf/original.png" alt="">

<p>Подход 4 — <strong>кластер баз данных</strong>. Несколько read-only баз.</p>

<p>Еще одно решение — использование кластера: несколько СУБД одного типа содержат идентичные данные. При этом читать данные можно из всех баз, а писать — только в одну. Которая потом синхронизируется с остальными базами.</p>

<p>Это очень хорошее решение, потому что его легко конфигурировать и оно работает на практике. Обычно на один запрос к базе на изменение данных к ней приходит 10-100 запросов на чтение данных.</p>

<h2>Виды кеширования в Hibernate</h2>

<p>Hibernate поддерживает три уровня кэширования:</p>

<ul>
<li>Кеширование на уровне сессии (Session)</li>
<li>Кеширование на уровне SessionFactory</li>
<li>Кеширование запросов (и их результатов)</li>
</ul>

<p>Эту системы можно попробовать представить в виде такого рисунка:</p>

<img data-max-width="800" data-id="63696278-18d4-4dc4-ba87-fc9f4bc24c11" src="https://cdn.javarush.com/images/article/63696278-18d4-4dc4-ba87-fc9f4bc24c11/original.png" alt="">

<p>Самый простой вид кеширования (его еще называют <strong>кэшем первого уровня</strong>) реализован на уровне Hibernate-сессии. <span class="text-green">Hibernate всегда по умолчанию использует этот кэш</span> и <span class="text-red">его нельзя отключить</span>.</p>

<p>Давай сразу рассмотрим следующий пример:</p>

<pre class='language-java line-numbers'><code>
Employee director1 = session.get(Employee.class, 4);
Employee director2 = session.get(Employee.class, 4);
 
assertTrue(director1 == director2);
</code></pre>
 
<p>Может показаться, что тут будет выполнено два запроса в базу, однако это не так. После первого запроса в базу объект Employee будет закэширован. И если ты снова выполнишь запрос объекта в той же сессии, то Hibernate вернет тот же Java-объект.</p>

<p>Тот же объект — это значит, что даже ссылки на объекты будут идентичными. Это реально один и тот же объект.</p>

<p>При использовании методов <span class="code text-orange">save()</span>, <span class="code text-orange">update()</span>, <span class="code text-orange">saveOrUpdate()</span>, <span class="code text-orange">load()</span>, <span class="code text-orange">get()</span>, <span class="code text-orange">list()</span>, <span class="code text-orange">iterate()</span> и <span class="code text-orange">scroll()</span> всегда будет задействован кэш первого уровня. Собственно, тут нечего больше добавить.</p>

<h2>Кэширование второго уровня</h2>

<p>Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту <mark class="green">SessionFactory</mark>. Что означает, что видимость объектов в этом кэше гораздо шире, чем в кэше первого уровня.</p>

<p>Пример:</p>

<pre class='language-java line-numbers'><code>
Session session = factory.openSession();
Employee director1 = session.get(Employee.class, 4);
session.close();
 
Session session = factory.openSession();
Employee director2 = session.get(Employee.class, 4);
session.close();
 
assertTrue(director1 != director2);
assertTrue(director1.equals(director2));
</code></pre>
 
<p>В этом примере будет выполнено два запроса в базу. Hibernate вернет идентичные объекты, но это будет не тот же объект — они будут иметь разные ссылки.</p>

<p><strong>Кэширование второго уровня по умолчанию <span class="text-red">отключено</span></strong>. Поэтому мы имеем два запроса к базе вместо одного.</p>

<p>Чтобы его включить, нужно в файле hibernate.cfg.xml написать такие строчки:</p>
 
<pre class='language-java line-numbers'><code>
&lt;property name="hibernate.cache.provider_class" value="net.sf.ehcache.hibernate.SingletEhCacheProvider"/>
&lt;property name="hibernate.cache.use_second_level_cache" value="true"/>
</code></pre>
 
<p>После включения кэширования второго уровня поведение Hibernate немного изменится:</p>

<pre class='language-java line-numbers'><code>
Session session = factory.openSession();
Employee director1 = session.get(Employee.class, 4);
session.close();
 
Session session = factory.openSession();
Employee director2 = session.get(Employee.class, 4);
session.close();
 
assertTrue(director1 == director2);
</code></pre>
 
<p>Только после всех этих манипуляций кэш второго уровня будет включен, и в примере выше будет выполнен только один запрос в базу.</p>