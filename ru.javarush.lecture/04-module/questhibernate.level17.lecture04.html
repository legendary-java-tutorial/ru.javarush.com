Ключи в базе данных
<p>----------------------------------------</p>
Primary key
Foreign key
Custom Key
<p>----------------------------------------</p>
<h2>5.1 Введение</h2>
<p>В Интернете полно догматических заповедей о том, как нужно выбирать и использовать ключи в реляционных базах данных. Иногда споры даже переходят в холивары: и <strong>спользовать естественные или искусственные ключи? Автоинкрементные целые или UUID?</strong> </p>
<p>Прочитав шестьдесят четыре статьи, пролистав разделы пяти книг и задав кучу вопросов в IRC и StackOverflow, я (автор оригинальной статьи Joe «begriffs» Nelson), как мне кажется, собрал куски паззла воедино и теперь смогу примирить противников. Многие споры относительно ключей возникают, на самом деле, из-за неправильного понимания чужой точки зрения.</p>
<p>Давайте разделим проблему на части, а в конце соберём её снова. Для начала зададим вопрос – что же такое «ключ»?</p>
<p>Забудем на минуту о первичных ключах, нас интересует более общая идея. Ключ — это колонка (column) или колонки, <span class="text-red">не имеющие в строках дублирующих значений</span>. Кроме того, колонки должны быть неприводимо уникальными, то есть никакое подмножество колонок не обладает такой уникальностью.</p>
<p>Но для начала немного теории:</p>
<p><strong>Первичный ключ</strong></p>
<p><mark class="green">Primary key</mark> непосредственно применяется для идентификации строк в таблице. Он должен соответствовать следующим ограничениям:</p>
<ul>
	<li>Первичный ключ должен быть <strong>уникальным</strong> все время.</li>
	<li>Он должен <strong>постоянно присутствовать</strong> в таблице и иметь значение.</li>
	<li>Он не должен часто менять свое значение. В идеале он вообще <strong>не должен изменять значение</strong>.</li>
</ul>
<p>Как правило, первичный ключ представляет один столбец таблицы, но также может быть составным и состоять из нескольких столбцов.</p>
<p><strong>Составной ключ</strong></p>
<p><mark class="green">Custom Key</mark> - комбинация атрибутов (столбцов), которые уникально идентифицируют каждую строку таблицы. Это могут быть и все столбцы, и несколько, и один. При этом строки, которые содержат значения этих атрибутов, не должны повторяться.</p>
<p><strong>Потенциальный ключ</strong></p>
<p><mark class="green">Candidate key</mark> - представляет собой минимальный составной ключ отношения (таблицы), то есть набор атрибутов, который удовлетворяет ряду условий:</p>
<ul>
	<li><strong>Неприводимость</strong>: он не может быть сокращен, он содержит минимально возможный набор атрибутов.</li>
	<li><strong>Уникальность</strong>: он должен иметь уникальные значения вне зависимости от изменения строки.</li>
	<li><strong>Наличие значения</strong>: он не должен иметь значения NULL, то есть он обязательно должен иметь значение.</li>
</ul>
<h2>5.2 Любопытный случай первичных ключей</h2>
<p>То, что в предыдущем разделе мы назвали просто «ключами», обычно называется «потенциальными ключами» (candidate keys). Термин «candidate» подразумевает, что все такие ключи конкурируют за почётную роль «первичного ключа» (primary key), а оставшиеся назначаются «альтернативными ключами» (alternate keys).</p>
<p>Потребовалось какое-то время, чтобы в реализациях SQL пропало несоответствие ключей и реляционной модели, самые ранние базы данных были заточены под низкоуровневую концепцию первичного ключа. Первичные ключи в таких базах требовались для идентификации физического расположения строки на носителях с последовательным доступом к данным. Вот как это объясняет Джо Селко:</p>
<p><span class="text-green">Термин «ключ» означал ключ сортировки файла, который был нужен для выполнения любых операций обработки в последовательной файловой системе. Набор перфокарт считывался в одном и только в одном порядке; невозможно было «вернуться назад». Первые накопители на магнитных лентах имитировали такое же поведение и не позволяли выполнять двунаправленный доступ. Т.е., первоначальный Sybase SQL Server для чтения предыдущей строки требовал «перемотки» таблицы на начало.</span></p>
<p>В современном SQL не нужно ориентироваться на физическое представление информации, таблицы моделируют связи и внутренний порядок строк вообще не важен. Однако, и сейчас SQL-сервер по умолчанию создаёт кластерный индекс для первичных ключей и, по старой традиции, физически выстраивает порядок строк.</p>
<p>В большинстве баз данных первичные ключи сохранились как пережиток прошлого, и едва ли обеспечивают что-то, кроме отражения или определения физического расположения. Например, в таблице PostgreSQL объявление первичного ключа автоматически накладывает ограничение <code>NOT NULL</code> и определяет внешний ключ по умолчанию. К тому же первичные ключи являются предпочтительными столбцами для оператора <code>JOIN</code>.</p>
<p>Первичный ключ не отменяет возможности объявления и других ключей. В то же время, если ни один ключ не назначен первичным, то таблица все равно будет нормально работать. Молния, во всяком случае, в вас не ударит.</p>
<h2>5.3 Нахождение естественных ключей</h2>
<p>Рассмотренные выше ключи называются «естественными», потому что они являются свойствами моделируемого объекта интересными сами по себе, даже если никто не стремится сделать из них ключ.</p>
<img data-max-width="800" data-id="eadd7f32-0792-44f1-9ab2-483666f8f44c" src="https://cdn.javarush.com/images/article/eadd7f32-0792-44f1-9ab2-483666f8f44c/800.jpeg" alt="">
<p>Первое, что стоит помнить при исследовании таблицы на предмет возможных естественных ключей — нужно стараться не перемудрить. Пользователь sqlvogel на StackExchange даёт следующий совет:</p>
<p><span class="text-green">
У некоторых людей возникают сложности с выбором «естественного» ключа из-за того, что они придумывают гипотетические ситуации, в которых определённый ключ может и не быть уникальным. Они не понимают самого смысла задачи. Смысл ключа в том, чтобы определить правило, по которому атрибуты в любой момент времени должны быть и всегда будут уникальными в конкретной таблице. Таблица содержит данные в конкретном и хорошо понимаемом контексте (в «предметной области» или в «области дискурса») и единственное значение имеет применение ограничения в этой конкретной области.
</span></p>
<p>Практика показывает, что нужно вводить ограничение по ключу, когда колонка уникальна при имеющихся значениях и будет оставаться такой при вероятных сценариях. А при необходимости ограничение можно устранить (если это вас беспокоит, то ниже мы расскажем о стабильности ключа.)</p>
<p>Например, база данных членов хобби-клуба может иметь уникальность в двух колонках — <code>first_name</code>, <code>last_name</code>. При небольшом объёме данных дубликаты маловероятны, и до возникновения реального конфликта использовать такой ключ вполне разумно.</p>
<p>С ростом базы данных и увеличением объёма информации, выбор естественного ключа может стать сложнее. Хранимые нами данные являются упрощением внешней реальности, и не содержат в себе некоторые аспекты, которыми различаются объекты в мире, такие как их изменяющиеся со временем координаты. Если у объекта отсутствует какой-либо код, то как различить две банки с напитком или две коробки с овсянкой, кроме как по их расположению в пространстве или по небольшим различиям в весе или упаковке?</p>
<p>Именно поэтому органы стандартизации создают и наносят на продукцию различительные метки. На автомобилях штампуется <strong>Vehicle Identification Number (VIN)</strong>, в книгах печатается <strong>ISBN</strong>, на упаковке пищевых товаров есть <strong>UPC</strong>. Вы можете возразить, что эти числа не кажутся естественными. Так почему же я называю их естественными ключами?</p>
<p>Естественность или искусственность уникальных свойств в базе данных относительна к внешнему миру. Ключ, который при своём создании в органе стандартизации или государственном учреждении был искусственным, становится для нас естественным, потому что в целом мире он становится стандартом и/или печатается на объектах.</p>
<p>Существует множество отраслевых, общественных и международных стандартов для различных объектов, в том числе для валют, языков, финансовых инструментов, химических веществ и медицинских диагнозов. Вот некоторые из значений, которые часто используются в качестве естественных ключей: </p>
<ul>
	<li>Коды стран по ISO 3166</li>
	<li>Коды языков по ISO 639</li>
	<li>Коды валют по ISO 4217</li>
	<li>Биржевые обозначения ISIN</li>
	<li>UPC/EAN, VIN, GTIN, ISBN</li>
	<li>имена логинов</li>
	<li>адреса электронной почты</li>
	<li>номера комнат</li>
	<li>mac-адрес в сети</li>
	<li>широта, долгота для точек на поверхности Земли</li>
</ul>
<p>Рекомендую объявлять ключи, когда это возможно и разумно, может быть, даже несколько ключей на таблицу. Но помните, что у всего вышеперечисленного могут быть исключения.</p>
<ul>
	<li>Не у всех есть адрес электронной почты, хотя в некоторых условиях использования базы данных это может быть приемлемо. Кроме того, люди время от времени меняют свои электронные адреса. (Подробнее о стабильности ключей позже.)</li>
	<li>Биржевые обозначения ISIN время от времени изменяются, например, символы GOOG и GOOGL не точно описывают реорганизацию компании из Google в Alphabet. Иногда может возникнуть путаница, как, например, с TWTR и TWTRQ, некоторые инвесторы ошибочно покупали последние во время IPO Twitter.</li>
	<li>Номера социального страхования используются только гражданами США, имеют ограничения конфиденциальности и повторно используются после смерти. Кроме того, после кражи документов люди могут получить новые номера. Наконец, один и тот же номер может идентифицировать и лицо, и идентификатор налога на прибыль.</li>
	<li>Почтовые индексы — плохой выбор для городов. У некоторых городов общий индекс, или наоборот в одном городе бывает несколько индексов.</li>
</ul>
<h2>5.4 Искусственные ключи</h2>
<p>С учётом того, что ключ – это колонка, в каждой строке которой находятся уникальные значения, одним из способов его создания является жульничество – в каждую строку можно записать выдуманные уникальные значения. Это и есть искусственные ключи: придуманный код, используемый для ссылки на данные или объекты.</p>
<img data-max-width="800" data-id="e0feb953-16ae-4313-ba14-37c9f8fb7eba" src="https://cdn.javarush.com/images/article/e0feb953-16ae-4313-ba14-37c9f8fb7eba/800.jpeg" alt="">
<p>Очень важно то, что код генерируется из самой базы данных и неизвестен никому, кроме пользователей базы данных. Именно это отличает искусственные ключи от стандартизированных естественных ключей.</p>
<p>Преимущество естественных ключей заключается в защите от дублирования или противоречивости строк таблицы, искусственные же ключи полезны потому, что они позволяют людям или другим системам проще ссылаться на строку, а также повышают скорость операций поиска и объединения, так как не используют сравнения строковых (или многостолбцовых) ключей.</p>
<h3>Суррогаты</h3>
<p><span class="text-green">Искусственные ключи используются в качестве привязки – вне зависимости от изменения правил и колонок, одну строку всегда можно идентифицировать одинаковым способом. Искусственный ключ, используемый для этой цели, называется «суррогатным ключом» и требует особого внимания. Суррогаты мы рассмотрим ниже.</span></p>
<p>Не являющиеся суррогатами искусственные ключи удобны для ссылок на строку снаружи базы данных. Искусственный ключ кратко идентифицирует данные или объект: он может быть указан как URL, прикреплён к счёту, продиктован по телефону, получен в банке или напечатан на номерном знаке. (Номерной знак автомобиля для нас является естественным ключом, но разработан государством как искусственный ключ.)</p>
<p>Искусственные ключи нужно выбирать, учитывая возможные способы их передачи, чтобы минимизировать опечатки и ошибки. Надо учесть, что ключ могут произносить, читать напечатанным, отправлять по SMS, читать написанным от руки, вводить с клавиатуры и встраивать в URL. Дополнительно, некоторые искусственные ключи, например номера кредитных карт, содержат контрольную сумму, чтобы при возникновении определённых ошибок их можно было хотя бы распознать.</p>
<p>Примеры:</p>
<ul>
	<li>Для номерных знаков США существуют правила об использовании неоднозначных признаков, например O и 0.</li>
	<li>Больницы и аптеки должны быть особенно аккуратны, учитывая почерк врачей.</li>
	<li>Передаёте эсэмэской код подтверждения? Не выходите за пределы набора символов GSM 03.38.</li>
	<li>В отличие от Base64, кодирующего произвольные байтовые данные, Base32 использует ограниченный набор символов, который удобно использовать людям и обрабатывать на старых компьютерных системах.</li>
	<li>Proquints – это читаемые, записываемые и произносимые идентификаторы. Это произносимые (PRO-nouncable) пятёрки (QUINT-uplets) однозначно понимаемых согласных и гласных букв.</li>
</ul>
<p>Учтите, что как только вы познакомите мир со своим искусственным ключом, люди странным образом начнут придавать ему особое внимание. Достаточно посмотреть на «блатные» номерные знаки или на систему создания произносимых идентификаторов, которая превратилась в печально известный автоматизированный генератор ругательств.</p>
<p>Даже, если ограничиться числовыми ключами, есть табу типа тринадцатого этажа. Несмотря на то, что proquints обладают большей плотностью информации на произносимый слог, числа тоже неплохи во многих случаях: в URL, пин-клавиатурах и написанных от руки записях, если получатель знает, что ключ состоит только из цифр.</p>
<p>Однако, обратите внимание, что не стоит использовать последовательный порядок в публично открытых числовых ключах, поскольку это позволяет рыться в ресурсах (/videos/1.mpeg, /videos/2.mpeg, и так далее), а также создаёт утечку информации о количестве данных. Наложите на последовательность чисел сеть Фейстеля и сохраните уникальность, скрыв при этом порядок чисел.</p>
<p>Единственным аргументом против объявления дополнительных ключей является то, что каждый новый несёт за собой ещё один уникальный индекс и увеличивает затраты на запись в таблицу. Конечно, зависит от того, насколько вам важна корректность данных, но, скорее всего, ключи все же стоит объявлять.</p>
<p>Также стоит объявлять несколько искусственных ключей, если они есть. Например, у организации есть кандидаты на работу (Applicants) и сотрудники (Employees). Каждый сотрудник когда-то был кандидатом, и относится к кандидатам по своему собственному идентификатору, который также должен быть и ключом сотрудника. Ещё один пример, можно задать идентификатор сотрудника и имя логина как два ключа в Employees.</p>
<h2>5.5 Суррогатные ключи</h2>
<p>Как уже упоминалось, важный тип искусственного ключа называется «суррогатный ключ». Он не должен быть кратким и передаваемым, как другие искусственные ключи, а используется как внутренняя метка, всегда идентифицирующая строку. Он используется в SQL, но приложение не обращается к нему явным образом.</p>
<img data-max-width="800" data-id="43b5ec60-2937-43f2-9431-b18c81e9a442" src="https://cdn.javarush.com/images/article/43b5ec60-2937-43f2-9431-b18c81e9a442/800.jpeg" alt="">
<p>Если вам знакомы системные колонки (system columns) из PostgreSQL, то вы можете воспринимать суррогаты почти как параметр реализации базы данных (вроде ctid), который, однако, никогда не меняется. Значение суррогата выбирается один раз для каждой строки и потом никогда не изменяется.</p>
<p>Суррогатные ключи отлично подходят в качестве внешних ключей, при этом необходимо указать каскадные ограничения <code>ON UPDATE RESTRICT</code>, чтобы соответствовать неизменности суррогата.</p>
<p>С другой стороны, внешние ключи к публично передаваемым ключам должны быть помечены <code>ON UPDATE CASCADE</code>, чтобы обеспечить максимальную гибкость. Каскадное обновление выполняется на том же уровне изоляции, что и окружающая его транзакция, поэтому не беспокойтесь о проблемах с параллельным доступом – база данных справится, если выбрать строгий уровень изоляции.</p>
<p>Не делайте суррогатные ключи «естественными». Как только вы покажете значение суррогатного ключа конечным пользователям, или, что хуже, позволите им работать с этим значением (в частности, через поиск), то фактически придадите ключу значимость. Потом показанный ключ из вашей базы данных может стать естественным ключом в чьей-то чужой БД.</p>
<p>Принуждение внешних систем к использованию других искусственных ключей, специально предназначенных для передачи, позволяет нам при необходимости изменять эти ключи в соответствии с меняющимися потребностями, в то же время поддерживая внутреннюю целостность ссылок с помощью суррогатов.</p>
<h3>Автоинкрементные INT/BIGINT</h3>
<p>Чаще всего для суррогатных ключей используют автоинкрементную колонку <strong>«bigserial»</strong>, также известную как <strong>IDENTITY</strong>. (На самом деле, PostgreSQL 10 теперь, как и Oracle, поддерживает конструкцию IDENTITY, см. CREATE TABLE.)</p>
<p>Однако, я считаю, что автоинкрементное целое плохой выбор для суррогатных ключей. Такое мнение непопулярно, поэтому позвольте мне объясниться.</p>
<p>Недостатки последовательных ключей:</p>
<ul>
	<li>Если все последовательности начинаются с 1 и постепенно увеличиваются, то у строк из разных таблиц будут одинаковые значения ключей. Такой вариант неидеален, предпочтительнее все же использовать непересекающиеся множества ключей в таблицах, чтобы, например, запросы не смогли бы случайно перепутать константы в <code>JOIN</code> и вернуть неожиданные результаты. (Как вариант для обеспечения отсутствия пересечений, можно составить каждую последовательность из чисел, кратных различным простым, но это будет довольно трудоёмко.)</li>
	<li>Вызов <code>nextval() </code>для генерации последовательности в современных распределённых SQL, приводит к тому, что вся система хуже масштабируется.</li>
	<li>Поглощение данных из базы данных, в которой тоже использовались последовательные ключи, приведет к конфликтам, потому что последовательные значения не будут уникальными в разных системах.</li>
	<li>С философской точки зрения последовательное увеличение чисел связано со старыми системами, в которых подразумевался порядок строк. Если же вы теперь хотите упорядочить строки, то делайте это явным образом, с помощью колонки меток времени или чего-то имеющего смысл в ваших данных. В противном случае нарушается первая нормальная форма.</li>
	<li>Слабая причина, но эти короткие идентификаторы так и тянет сообщить кому-нибудь.</li>
</ul>
<h3>UUID</h3>
<p>Давайте рассмотрим другой вариант: использование больших целых чисел (128-битных), генерируемых в соответствии со случайным шаблоном. Алгоритмы генерации таких универсальных уникальных идентификаторов (universally unique identifier, UUID) имеют чрезвычайно малую вероятность выбора одного значения дважды, даже при одновременном выполнении на двух разных процессорах.</p>
<p>В таком случае <strong>UUID</strong> кажутся естественным выбором для использования в качестве суррогатных ключей, не правда ли? Если вы хотите пометить строки уникальным образом, то ничто не сравнится с уникальной меткой!</p>
<p>Так почему же все не пользуются ими в PostgreSQL? На это есть несколько надуманных причин и одна логичная, которую можно обойти, и я представлю бенчмарки, чтобы проиллюстрировать свое мнение.</p>
<p>Для начала, расскажу о надуманных причинах. Некоторые люди думают, что UUID — это строки, потому что они записываются в традиционном шестнадцатеричном виде с дефисом: <code>5bd68e64-ff52-4f54-ace4-3cd9161c8b7f</code>. Действительно, некоторые базы данных не имеют компактного (128-битного) типа uuid, но в PostgreSQL он есть и имеет размер двух <code>bigint</code>, т.е., по сравнению с объёмом прочей информации в базе данных, издержки незначительны.</p>
<p>Ещё UUID незаслуженно обвиняется в громоздкости, но кто будет их произносить, печатать или читать? Мы говорили, что это имеет смысл для показываемых искусственных ключей, но никто (по определению) не должен увидеть суррогатный UUID. Возможно, с UUID будет иметь дело разработчик, запускающий команды SQL в psql для отладки системы, но на этом всё. А разработчик может ссылаться на строки и с помощью более удобных ключей, если они заданы.</p>
<p><span class="text-red">Реальная проблема с UUID в том, что сильно рандомизированные значения приводят к увеличению объёма записи (write amplification) из-за записей полных страниц в журнал с упреждающей записью (write-ahead log, WAL)</span>. Однако, на самом деле снижение производительности зависит от алгоритма генерации UUID. </p>
<p>Давайте измерим <strong>write amplification</strong>. По правде говоря, проблема в старых файловых системах. Когда PostgreSQL выполняет запись на диск, она изменяет «страницу» на диске. При отключении питания компьютера большинство файловых систем всё равно сообщит об успешной записи ещё до того, как данные безопасно сохранились на диске. Если PostgreSQL наивно воспримет такое действие завершённым, то при последующей загрузке системы база данных будет повреждена.</p>
<p>Раз PostgreSQL не может доверять большинству ОС/файловых систем/конфигураций дисков в вопросе обеспечения неразрывности, база данных сохраняет полное состояние изменённой дисковой страницы в журнал с упреждающей записью (write-ahead log), который можно будет использовать для восстановления после возможного сбоя. Индексирование сильно рандомизированных значений наподобие UUID обычно затрагивает кучу различных страниц диска и приводит к записи полного размера страницы (обычно 4 или 8 КБ) в WAL для каждой новой записи. Это так называемая полностраничная запись (full-page write, FPW).</p>
<p>Некоторые алгоритмы генерации UUID (такие, как «snowflake» от Twitter или uuid_generate_v1() в расширении uuid-ossp для PostgreSQL) создают на каждой машине монотонно увеличивающиеся значения. Такой подход консолидирует записи в меньшее количество страниц диска и снижает FPW.</p>
<h2>5.6 Итоги и рекомендации</h2>
<p>Теперь, когда мы познакомились с различными типами ключей и вариантами их использования, я хочу перечислить мои рекомендации по применению их в ваших базах данных.</p>
<p>Для каждой таблицы:</p>
<ul>
	<li>Определите и объявите все естественные ключи.</li>
	<li>Создайте суррогатный ключ <code>&lt;table_name&gt;_id</code> типа <strong>UUID</strong> со значением по умолчанию в <code>uuid_generate_v1()</code>. Можете даже пометить его как первичный ключ. Если добавить в этот идентификатор название таблицы, это упростит <code>JOIN</code>, т.е. получите <code>JOIN foo USING (bar_id)</code> вместо <code>JOIN foo ON (foo.bar_id = bar.id)</code>. Не передавайте этот ключ клиентам и вообще не выводите за пределы базы данных.</li>
	<li>Для промежуточных таблиц, через которые происходит <code>JOIN</code>, объявляйте все колонки внешних ключей как единый составной первичный ключ.</li>
	<li>При необходимости добавьте искусственный ключ, который можно использовать в URL или других указаниях ссылки на строку. Используйте <strong>сетку Фейстеля</strong> или <strong>pg_hashids</strong>, чтобы замаскировать автоинкрементные целые.</li>
	<li>Указывайте каскадное ограничение <code>ON UPDATE RESTRICT</code>, используя суррогатные UUID в качестве внешних ключей, а для внешних искусственных ключей – <code>ON UPDATE CASCADE</code>. Выбирайте естественные ключи, исходя из собственной логики.</li>
</ul>
<p>Такой подход обеспечивает стабильность внутренних ключей, в то же время допуская и даже защищая естественные ключи. К тому же, видимые искусственные ключи не становятся к чему-либо привязанными. Правильно во всем разобравшись, можно не зацикливаться только на «первичных ключах» и пользоваться всеми возможностями применения ключей.</p>
