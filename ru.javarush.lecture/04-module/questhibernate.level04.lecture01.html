Числовые функции
<p>----------------------------------------</p>
Список числовых функций. 
Арифметические операции. 
Битовые операции. 
Функции округления.
<p>----------------------------------------</p>
<h2>Список числовых функций </h2>
 
<p>Как мы говорили выше, для СУБД мало просто хранить данные определенного типа, нужно еще поддерживать обширный набор супербыстрых операций над данными этих типов.</p>
 
<p>И, как ты знаешь, все СУБД поддерживают разнообразные числовые типы и операции над ними. Сегодня ты познакомишься с самыми популярными из них. </p>
 
<p>Все числовые функции в MySQL можно условно разделить на 5 групп: </p>

<ul>
<li>Арифметически операции</li>
<li>Битовые операции</li>
<li>Функции округления</li>
<li>Алгебраические функции</li>
<li>Тригонометрические функции</li>
</ul>

<p>Кстати, с очень многими из них ты знаком благодаря языку Java, так что думаю они не станут для тебя сюрпризом. Но начнем по порядку.</p>
 
<p>Полный список функций можно найти <a href="https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html" target="_blank">по ссылке</a>.</p>

<h2>Арифметические операции</h2>
 
<p>Тут в принципе ничего неожиданного, все те же стандартные операции, как и везде: </p>

<table>
<tbody>
<tr>
<th>#</th> 
<th></th>
<th>Пример </th>
<th></th>
</tr>
<tr>
<td>1</td> 
<td>+, -, *, /  </td>
<td>2+2*2 </td>
<td>Сложение, вычитание, умножение, деление (не нацело!) </td>
</tr>
<tr> 
<td>2 </td>
<td>%  </td>
<td>13 % 5 </td>
<td>Остаток от деления  </td>
</tr>
<tr>
<td>3 </td>
<td>MOD </td>
<td>13 MOD 5 </td>
<td>Остаток от деления </td>
</tr>
<tr>
<td>4 </td>
<td>DIV </td>
<td>13 DIV 5 </td>
<td>Деление нацело  </td>
</tr>
</tbody>
</table>
 
<p>Из интересного: при делении двух целых чисел получится вещественно число. Для деления нацело нужно использовать оператор DIV. </p>
 
<p>Если ты хочешь получить остаток от деления нацело, то нужно использовать или оператор MOD или % как в языке Java. Примеров приводить не буду, как по мне тут и так все очевидно. </p>

<h2>Битовые операции</h2>
 
<p>Над числами в SQL можно также проводить битовые операции, примерно, как и в языке Java. Хотя есть нюансы. Список доступных битовых операций представлен в таблице ниже:  </p>

<table>
<tbody>
<tr>
<th>#</th> 
<th></th>
<th>Пример </th>
<th>Примечание </th>
</tr>
<tr>
<td>1 </td>
<td>&  </td>
<td>0b1111 & 0b1000 </td>
<td>Побитовый AND </td>
</tr>
<tr>
<td>2 </td>
<td>|  </td>
<td>0b1111 | 0b0001 </td>
<td>Битовый OR </td>
</tr>
<tr>
<td>3 </td>
<td>^  </td>
<td>0b1111 ^ 0b1111 </td>
<td>Битовый XOR </td>
</tr>
<tr>
<td>4 </td>
<td>~  </td>
<td>~0b1111 </td>
<td>Побитовая инверсия </td>
</tr>
<tr>
<td> 
<td> 
<td> 
<td>
</tr>
<tr>
<td>5 </td>
<td>&gt;&gt;  </td>
<td>128 &gt;&gt; 5 </td>
<td>Битовый сдвиг вправо </td>
</tr>
<tr>
<td>6 </td>
<td>&lt;&lt;  </td>
<td>2 &lt;&lt; 5 </td>
<td>Битовый сдвиг влево </td>
<td></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td></td>
</tr>
<tr> 
<td>7 </td>
<td>BIT_COUNT()  </td>
<td>BIT_COUNT(255) </td>
<td>Возвращает количество бит, которые равны 1</td>
</tr>
</tbody> 
</table>
 
<p>В MySQL до версии 8.0 такие операции можно было выполнять только с типом данных BIGINT, который состоял из 64 бит и был аналогичен типу long в Java. Однако в MySQL 8.0 (который мы и рассматриваем) концепция поменялась. Теперь эти операции можно выполнять над специальными двоичными типами: </p>

<ul>
<li>BINARY</li>
<li>VARBINARY</li>
<li>А также над типами BLOB (которые представляют из себя массив байт)</li>
</ul>

<p>Все остальные типы просто приводятся к типу BIGINT и операции выполняются, как и ранее (только над первыми 64 битами). </p>

<h2>Функции округления </h2>

<p>Для округления в MySQL используются до боли знакомые тебе функции. Список их приведен в таблице ниже: </p>

<table>
<tbody>
<tr>
<th>#</th> 
<th></th>
<th>Пример</th> 
<th>Примечание </th>
</tr>
<tr>
<td>1 </td>
<td>CEIL(), CEILING() </td>
<td>CEIL (5.1) = 6 </td>
<td>Округляет вещественное число вверх </td>
</tr>
<tr>
<td>2 </td>
<td>FLOOR() </td>
<td>FLOOR (5.9) = 5 </td>
<td>Округляет вещественное число вниз </td>
</tr>
<tr>
<td>3 </td>
<td>ROUND() </td>
<td>ROUND(4.1) = 4 </td>
<td>Округляет вещественное число до ближайшего целого </td>
</tr>
<tr>
<td>4 </td>
<td>TRUNCATE() </td>
<td>TRUNCATE(4.123, 2) = 4.12 </td>
<td>Обрезает число до N знаков после запятой</td>
</tr>
<tr>
<td>5 </td>
<td>RAND() </td>
<td>0.61914388706828 </td>
<td>Возвращает случайное вещественное число в диапазоне от 0 до 1 </td>
</tr>
<tr>
<td>6 </td>
<td>RAND(N) </td>
<td>0.93845168309142 </td>
<td>Возвращает случайное вещественное число в диапазоне от 0 до 1. N используется как seed value </td>
</tr>
</tbody>
</table>
 
<p>Со всеми функциями округления ты знаком еще со времен первого квеста в Java. Интерес тут может представлять только функция TRUNCATE() и RANDOM(N).</p>
 
<p>Функция <strong>TRUNCATE</strong> (число, количество) принимает в качестве первого параметра вещественное число, а в качестве второго – количество знаков поле запятой, которое должно оставаться. Число обрезается до нужного количества знаков после запятой.</p>
 
<p>Что касается функции RAND(N) все немного сложнее. Как ты, наверное, знаешь, компьютер не может генерировать случайные числа. Вместо этого он генерирует так называемую последовательность псевдослучайных чисел. То есть глядя на одно число не понятно – случайное оно или нет, а вот последовательность чисел уже может быть похожей на случайную. Этим и пользуются разработчики, генерируя последовательность чисел, которая очень похожа на случайную.</p>
  
<p>При этом <span class="text-green">каждое новое число последовательности генерируется по хитрому правилу на основе предыдущего числа этой последовательности</span>. Поэтому если ты передашь в алгоритм генерации случайных чисел некое стартовое число (его еще называют seed), то <span class="text-user">каждый раз будешь получать одну и ту же последовательность случайных чисел</span>.</p>