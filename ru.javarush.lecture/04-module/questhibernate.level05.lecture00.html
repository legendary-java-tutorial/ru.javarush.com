Продвинутое знакомство с базами данных
<p>----------------------------------------</p>
Принцип построения лекций
SQL и все, все, все
За скобками
<p>----------------------------------------</p>
<h2>1.1 Принцип построения лекций </h2>
<p>Мы с тобой начали знакомство с базами данных <strong>снизу</strong>. Это особенность моего личного подхода к обучению людей. Говоря о новых темах, я всегда сначала рассказываю, как пользоваться теми или иными инструментами на практике. И уже когда я знаю, что человек умеет их использовать, я начинаю рассказывать, как все устроено. </p>
<p>Причин такого подхода несколько, но основная состоит в том, что <strong>самым ценным и самым недостающим ресурсом в процессе обучения является мотивация студента</strong>. </p>
<p>Этот подход немного отличается от привычного нам, который используется в школах и в вузах. НоТам все понятно: когда ты учишься в школе или вузе, у тебя правильно расставлены приоритеты: учеба — самая важная вещь в жизни в этот момент. </p>
<p>Если же ты занимаешься самообразованием во взрослом возрасте, то зачастую уже приходится совмещать учебу с работой, домашними делами, заботой о детях или престарелых родителях. И тут часто учеба станет далеко не первым приоритетом.</p>
<p>Все дело именно в приоритетах. Есть даже такая концепция в мире стартаперов — <strong>Fail Fast, провалиться как можно быстрее</strong>. Звучит странно, хотя на самом деле в этом очень много смысла: задача стартапера — быстро проверить, верна ли его гипотеза. И если она не верна, то не нужно тратить на нее годы своей жизни, лучше как можно раньше понять, что на определенную услугу или продукт нет спроса. </p>
<p>При обучении Java и SQL я использую тот же подход: я даю возможность как можно раньше понять, <strong>прет тебя от программирования или нет</strong>. Если прет, и тебе нравится программировать, и ты сам смог разобраться, как работать с циклами и массивами, то при помощи менторов и грамотно составленной программы у тебя есть все шансы закончить обучение и найти работу. </p>
<p>Но не менее важен и другой факт: за пару выходных ты можешь понять, что программирование — это не твое. <strong>Оно может быть тебе просто не интересно, и это нормально</strong>. Значит, не нужно тратить на него месяцы своей жизни.</p>
<p>Только 40% выпускников работают по специальности, которую они получили в вузе. Вдумайся, люди учились 5-6 лет, и 60% из них решили не работать по специальности.  Да, часть полученных знаний они все равно используются, но где-то половину – нет. </p>
<p>В этом и ценность концепции Fail Fast – как можно раньше понять, что тебе не подходит определенная профессия, определенный человек или определенное хобби. И не тратить на них свое время и силы. В долгосрочной перспективе это очень хорошая стратегия.  </p>
<h2>1.2 SQL и все, все, все </h2>
<p>С философским вступлением мы закончили, вернемся к изучению SQL.</p>
<p>Язык SQL и СУБД – это немного разные вещи. Сам язык SQL – это некий стандарт, который описывает, что можно писать в SQL-запросах к базе данных. СУБД – это уже реализации этого стандарта. Какая-то СУБД реализует одни функции стандарта, вторая — другие и так далее. </p>
<p>Чем дороже СУБД, тем больше возможностей стандарта она реализует. Так же многие СУБД часто реализуют свои собственные уникальные возможности вне стандартов SQL. Иногда это приводит к проблемам с переносимостью: SQL запросы, написанные для одной СУБД, могут плохо работать на другой. </p>
<p>В Java тоже есть похожая ситуация. Если Java-программа написана под Windows, то на Linux она нормально работать не будет. Чтобы решить эту проблему, в Java вводят специальные классы, которые имеют различные реализации под разные операционные системы. Пример: класс Path, который имеет реализации WindowsPath, LinuxPath и т. д.</p>
<p>Вторую часть проблемы решают с помощью версионирования. Все удачные нововведения из разных языков или СУБД добавляются в новый стандарт JDK или SQL. Ты уже знаешь, что есть разные версии JDK, и чем версия новее, тем в ней больше функций. С языком SQL то же самое. </p>
<p>В языке SQL существует несколько версий его стандарта, которые называются по годам: </p>
<ul>
	<li>SQL:1999</li>
	<li>SQL:2003 </li>
	<li>SQL:2006 </li>
	<li>SQL:2011</li>
	<li>SQL:2016</li>
	<li>SQL:2019 </li>
</ul>
<p><strong>Хорошая новость</strong>: изучать эти стандарты мы не будем. Во-первых, чтобы все это изучить и освоить, понадобятся годы. А во-вторых, эти стандарты — как версии Android: только через 5-10 лет после выхода стандарт становиться массово распространенным. 
</p>
<p>В базах данных при больших объемах данных людям нужна надежность и стабильность. “Работает – не трогай” — это девиз всех, кто работает с базами данных. И переход на новую версию баз данных делается раз в 5 лет, когда все преимущества такого решения уже очевидны. </p>
<h2>1.3 За скобками </h2>
<p>Как я уже говорил выше, для того, чтобы стать профессионалом в области баз данных, нужны годы. Профессионал знает кучу всего, что мы изучать не будем. Но о том, что еще есть в базах данных, я немного расскажу. </p>
<p>Почти все современные базы данных поддерживают: </p>
<h4>1 Procedural Language (PL) </h4>
<p>СУБД поддерживают возможность писать процедуры и функции, которые выполняются на SQL-сервере и могут много чего делать с данными во время запросов. Например, когда-то я писал запросы на PL SQL к серверу Oracle, который в ответ на запрос генерировал… HTML-страницу с данными. Да, можно и так.</p>
<h4>2 События (Triggers) </h4>
<p>Все современные СУБД поддерживают механизм событий, которые в языке SQL называются триггерами. Триггер возникает как ответ на какое-то действие. Например, можно перехватывать все попытки записи в базу и добавлять в новые строчки точное время их изменения. </p>
<h4>3 Журналирование (log)  </h4>
<p>Современные базы данных стараются работать супербыстро, поэтому часто все изменения (новые строки, удаленные, измененные) сначала записываются в специальный файл, журнал. И только спустя какое-то время SQL-сервер объединит эти записи с основной базой данных. </p>
<p>Чем-то это похоже на поведение Garbage Collector в Java: он тоже сначала просто помечает объекты как удаленные, а во времена простоя выполняет очистку и оптимизацию памяти.  </p>
<h4>4 Расширения (Plugins) </h4>
<p>К СУБД, как и ко многим программам, можно писать свои плагины. Такие плагины позволяют добавлять уникальные типы данных, функции для работы с ними, или менять стандартное поведение СУБД. Такое бывает особенно полезно, когда ты работаешь с СУБД с открытым исходным кодом и там есть какие-то баги. </p>
<h4>5 Распределенная работа (кластеры) </h4>
<p>Типичный сценарий работы современного SQL-сервера – это кластер из нескольких серверов. Самый простой вариант — это когда данные пишутся на один сервер, а читаются с группы серверов. При этом можно настраивать различные сценарии синхронизации баз данных между SQL-серверами. </p>
<h4>6 Шардирование </h4>
<p>Когда данных очень много, их начинают разбивать по разным базам данных. Вплоть до того, что одна таблица может храниться по частям в разных базах данных.  </p>
<p>Шардирование бывает вертикальным и горизонтальным. Вертикальное шардирование означает, что таблицу как бы разрезают вертикальными линиями, а горизонтальное – по горизонтальным.  </p>
<p>Например, мы решили все данные в таблице поделить по годам: для 2019 — года одна таблица, для данных 2020 года — вторая и так далее. Это будет горизонтальное шардирование. </p>
<h4>7 Впихнуть невпихуемое </h4>
<p>На определенном этапе развития баз данных в них начали добавлять все больше бизнес-логики. Все началось с процедур, функций, генерации web-страниц серверами, а закончилось тем, что в СУБД добавили поддержку почти всех популярных языков: Python, JavaScript, и даже Java и С++. </p>
<p>Звучит круто, пока не начинаешь изучать детали: ты действительно хочешь писать бизнес-логику своего веб-приложения на Java, которая будет выполняться внутри SQL-сервера, где нет JDK, java-библиотек, фреймворков, мало памяти и еще куча ограничений?  </p>