Зависимости между таблицами в базе данных
<p>----------------------------------------</p>
Отношение one to one
Отношение one to many
Отношение many to many
<p>----------------------------------------</p>
<h2>4.1 Введение </h2>
<p>Преобразовав таблицы базы данных в обычные таблицы, вы теперь можете проанализировать имеющиеся между ними связи. Количество элементов, взаимодействующих между двумя связанными таблицами, называется кардинальностью. Кардинальность поможет вам проконтролировать, насколько эффективно вы разбили данные на таблицы. </p>
<p>Теоретически, все сущности могут поддерживать между собой связи, однако на практике выделяется три разновидности связей между сущностями: </p>
<ul>
	<li><strong>Один к одному </strong> </li>
	<li><strong>Один ко многим</strong> </li>
	<li><strong>Многие ко многим</strong> </li>
</ul>
<h2>4.2 Связь «один к одному»</h2>
<p>Если на каждый экземпляр сущности Б приходится только один экземпляр сущности А, считается, что между ними существует связь «один к одному» (которая часто обозначается «1:1»). На ER-диаграммах такая связь обозначается линией с небольшой чертой на каждом конце: </p>
<img data-max-width="800" data-id="0f4b8ae1-8f1d-4b91-beee-42a7dc7a6d43" src="https://cdn.javarush.com/images/article/0f4b8ae1-8f1d-4b91-beee-42a7dc7a6d43/800.jpeg" alt="">
<p>Связь 1:1, как правило, указывает на то, что, если у вас нет весомых причин держать их по отдельности, данные двух таблиц лучше всего объединить в одну. </p>
<p>Тем не менее, в некоторых обстоятельствах использования таблиц со связями 1:1 вполне целесообразно. Если в ваших таблицах имеются поля с необязательными данными, например описаниями, и во многих случаях они пустуют, есть смысл перенести все описания в отдельную таблицу, что позволит вам избавиться от частых пробелов и повысить эффективность работы своей базы данных. </p>
<p>Затем, чтобы правильно сопоставить данные, вам придется включить как минимум один идентичный столбец в каждую таблицу (для этого лучше всего выбрать первичный ключ).</p>
<h2>4.3 Связь «один ко многим» </h2>
<p>Отношения такого рода возникают, когда запись одной таблицы связана с несколькими сущностями другой. К примеру, один и тот же клиент мог разместить несколько заказов, а посетитель библиотеки — за один визит позаимствовать сразу несколько книг. Связи «один ко многим» (или сокращенно «1:М») выражаются на схеме в виде нотации «вороньи лапки», как показано на примере ниже: </p>
<img data-max-width="800" data-id="5aba6739-39b5-407d-9b73-d6f34e433100" src="https://cdn.javarush.com/images/article/5aba6739-39b5-407d-9b73-d6f34e433100/800.jpeg" alt="">
<p>Чтобы применить связь 1:М при планировании базы данных, просто добавьте первичный ключ из таблицы «один» в качестве атрибута к таблице «многие». Если первичный ключ находится в другой таблице, он носит название «внешний ключ». Таблица «один» считается родительской, тогда как таблица «многие» — дочерней.</p>
<h2>4.4 Связь «многие ко многим» </h2>
<p>Когда несколько сущностей одной таблицы могут быть соединены с несколькими сущностями другой, считается, что между ними существует связь типа «многие ко многим» (или «М:М»). Например, такая связь существует между студентами и занятиями, поскольку каждый студент может посетить несколько разных занятий, а на каждое занятие, соответственно, может прийти множество студентов. </p>
<p>На ER-диаграмме этот тип связи отображается следующим образом: </p>
<img data-max-width="800" data-id="f93e6b36-0af0-4b54-ad91-e742f312fb84" src="https://cdn.javarush.com/images/article/f93e6b36-0af0-4b54-ad91-e742f312fb84/800.jpeg" alt="">
<p>К сожалению, напрямую реализовать такую связь в базе данных невозможно. Поэтому ее придется разбить на две связи типа «один ко многим». </p>
<p>Для этого вам понадобится создать новую сущность между двумя таблицами. Если связь М:М установлена между продажами и товарами, новую сущность можно назвать «проданные товары», так как в ней будет представлено содержимое каждой продажи. </p>
<p>С «проданными товарами» и у таблицы «продажи», и у таблицы «товары» будет установлена связь по типу 1:М. В разных моделях такие промежуточные сущности называются по-разному — «связующие таблицы», «ассоциативные сущности» или «узловые таблицы». </p>
<p>Каждая запись связующей таблицы соединяет между собой две разных сущности соседних таблиц (а также может содержать дополнительную информацию). Например, связующая таблица между студентами и занятиями может выглядеть вот так: </p>
<img data-max-width="800" data-id="32d7695b-e54e-4dc9-8179-3bf0bd4dcc07" src="https://cdn.javarush.com/images/article/32d7695b-e54e-4dc9-8179-3bf0bd4dcc07/800.jpeg" alt="">
<h2>4.5 Обязательно или нет?</h2>
<p>Еще один подход к анализу связей заключается том, чтобы установить, какая из соединенных сущностей является обязательным условием наличия другой сущности. Необязательная сторона связи отмечается кругом на соединительной линии. </p>
<p>Например, чтобы у государства был собственный представитель в ООН, оно должно существовать на карте мира, однако утверждение об обратном будет ложным: </p>
<img data-max-width="800" data-id="e52ad077-5f55-4bc5-8d3f-b04bc75394ea" src="https://cdn.javarush.com/images/article/e52ad077-5f55-4bc5-8d3f-b04bc75394ea/800.jpeg" alt="">
<p>Две сущности могут быть взаимозависимыми (то есть одна не может существовать без другой).</p>
<h4>Рекурсивные связи </h4>
<p>Иногда таблица может ссылаться на себя же. Например, в таблице сотрудников может присутствовать атрибут «менеджер», который будет отсылать нас к другому сотруднику в той же таблице. Это и есть рекурсивная связь. </p>
<h4>Лишние связи </h4>
<p>Связи считаются лишними, если они выражаются более одного раза. Как правило, одну из них можно удалить без потери важной информации. К примеру, если сущность «студенты» связана с сущностью «преподаватели» не только напрямую, но и косвенно через «занятия», есть смысл удалить связь между сущностями «студенты» и «преподаватели». Обосновано это решение тем, что назначить студентов преподавателям можно только посредством занятий. </p>
<h2>4.6 Ссылочная целостность данных </h2>
<p>При изменении первичных и внешних ключей следует соблюдать такой аспект как <strong>ссылочная целостность данных</strong> (referential integrity). Ее основная идея состоит в том, чтобы две таблице в базе данных, которые хранят одни и те же данные, поддерживали их согласованность.</p>
<p> Целостность данных представляет правильно выстроенные отношения между таблицами с корректной установкой ссылок между ними. В каких случаях целостность данных может нарушаться: </p>
<ul>
	<li><strong>Аномалия удаления</strong> (deletion anomaly). Возникает при удалении строки из главной таблицы. В этом случае внешний ключ из зависимой таблицы продолжает ссылаться на удаленную строку из главной таблицы.
</li>
	<li><strong>Аномалия вставки</strong> (insertion anomaly). Возникает при вставке строки в зависимую таблицу. В этом случае внешний ключ из зависимой таблицы не соответствует первичному ключу ни одной из строк из главной таблицы.</li>
	<li><strong>Аномалии обновления</strong> (update anomaly). При подобной аномалии несколько строк одной таблицы могут содержать данные, которые принадлежат одному и тому же объекту. При изменении данных в одной строке они могу прийти в противоречие с данными из другой строки. </li>
</ul>
<h4>Аномалия удаления </h4>
<p>Для решения аномалии удаления для внешнего ключа следует устанавливать одно из двух ограничений: </p>
<p>Если строка из зависимой таблицы обязательно требует наличия строки из главной таблицы, то для внешнего ключа устанавливается каскадное удаление. То есть при удалении строки из главной таблицы происходит удаление связанной строки (строк) из зависимой таблицы. </p>
<p>Если строка из зависимой таблицы допускает отсутствие связи со строкой из главной таблицы (то есть такая связь необязательна), то для внешнего ключа при удалении связанной строки из главной таблицы задается установка значения NULL. При этом столбец внешнего ключа должен допускать значение NULL. </p>
<h4>Аномалия вставки </h4>
<p>Для решения аномалии вставки при добавлении в зависимую таблицу данных столбец, который представляет внешний ключ, должен допускать значение NULL. И таким образом, если добавляемый объект не имеет связи с главной таблицей, то в столбце внешнего ключа будет стоять значение NULL. </p>
<h4>Аномалии обновления </h4>
<p>Для решения проблемы аномалии обновления применяется нормализация, которая была рассмотрена ранее. </p>
