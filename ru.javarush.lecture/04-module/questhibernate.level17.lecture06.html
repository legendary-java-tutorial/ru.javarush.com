Кеширование в MySQL
<p>----------------------------------------</p>
Кеширование на стороне БД
Текущий статус кеширования
Эффективность кеширования
Где кэш не используется
<p>----------------------------------------</p>
<h2>7.1 Кеширование на стороне БД</h2>
<p>MySQL при работе с таблицами использует хорошо масштабируемые алгоритмы, так что MySQL может работать даже при малых объемах памяти. Естественно для лучшей производительности нужно больше оперативной памяти.</p>
<p>Для просмотра текущих настроек подключаемся к базе</p>
<pre><code>
#mysq -u root -p

mysql> show variables like 'query_cache%';
+------------------------------+-----------+
| Variable_name                | Value     |
+------------------------------+-----------+
| query_cache_limit            | 1048576   |
| query_cache_min_res_unit     | 4096      |
| query_cache_size             | 134217728 |
| query_cache_type             | ON        |
| query_cache_wlock_invalidate | OFF       |
+------------------------------+-----------+
5 rows in set (0.00 sec)
</code></pre>

<p>Во-первых, убедимся, что кеширование включено. Переменная:</p>
<ul>
	<li><code>query_cache_type</code> должна иметь значение ON (1) или DEMAND (2) </li>
	<li><code>query_cache_limit</code> – определяет максимальный размер результата который попадет в кэш</li>
	<li><code>query_cache_size</code> быть отличной от нуля. При использовании DEMAND кешироваться будут только запросы, в которых есть директива <code>SQL_CACHE;</code> </li>
	<li><code>query_cache_min_res_unit</code> минимальный размер выделяемого блока памяти для хранения результатов кешированного запроса. MySQL не хранит кеш в одном большом куске памяти, вместо этого по требованию выделяются блоки с минимальным размером <code>query_cache_min_res_unit</code> (=4KB по умолчанию). Последний такой блок обрезается до размера данных, а оставшаяся память освобождается.</li>
</ul>
<p>Эффект кэширования в том что сервер получая запрос смотрит есть ли хэш запроса в кэше. Если хэш совпадает – сервер сразу отдает результат – не производя разбор запроса, оптимизацию и т.д. накладные расходы – в сопровождении механизма кэширования – просмотр кэша, запись результата запроса в кэш и т.д.</p>
<p>И если у вас много небольших запросов в кэше, то это может привести к фрагментации памяти из-за большого количества свободных блоков. А это, в свою очередь, вызывает удаление кэшированных записей из-за недостатка памяти. В таком случае имеет смысл уменьшить значение <code>query_cache_min_res_unit</code>. Если большинство ваших запросов порождают большой результат, то увеличение этого параметра может повысить производительность.</p>
<p>Попробуем оценить эффект. Смотрим как меняются показания счетчиков попаданий в кэш (Qcahe_hits), количество запросов объявленных недействительными из-за нехватки памяти (Qcache_lowmem_prunes), общее количество запросов типа SELECT (а кэшируются только они):</p>
<pre><code>
#mysq -u root -p
mysql> show status like 'Qcache%';
+-------------------------+-----------+
| Variable_name           | Value     |
+-------------------------+-----------+
| Qcache_free_blocks      | 715       |
| Qcache_free_memory      | 130369640 |
| Qcache_hits             | 24209     |
| Qcache_inserts          | 16215     |
| Qcache_lowmem_prunes    | 0         |
| Qcache_not_cached       | 444       |
| Qcache_queries_in_cache | 1740      |
| Qcache_total_blocks     | 4225      |
+-------------------------+-----------+
8 rows in set (0.00 sec)
</code></pre>

<h2>7.2 Текущий статус кеширования</h2>
<p>Для мониторинга <strong>query cache</strong> используется <code>SHOW STATUS</code>:</p>
<pre><code>
mysql> SHOW STATUS LIKE 'Qcache_%';
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| Qcache_free_blocks      | 10       |
| Qcache_free_memory      | 16755496 |
| Qcache_hits             | 49812    |
| Qcache_inserts          | 103999   |
| Qcache_lowmem_prunes    | 0        |
| Qcache_not_cached       | 180      |
| Qcache_queries_in_cache | 6        |
| Qcache_total_blocks     | 28       |
+-------------------------+----------+
8 rows in set (0.00 sec)
</code></pre>
<ul>
	<li><code>Qcache_free_blocks</code> показывает сколько свободных блоков есть в кеше (будет уменьшаться по мере увеличения скэшированных запросов);</li>
	<li><code>Qcache_total_blocks</code> — количество занятых блоков;</li>
	<li><code>Qcache_free_memory</code> — показывает свободную «доступную» память для кэширования;</li>
	<li><code>Qcache_hits</code> — количество запросов, результаты которых были взяты из кеша, без реального обращения к базе данных;</li>
	<li><code>Qcache_inserts</code> — количество запросов, которые были добавлены в кеш;</li>
	<li><code>Qcache_lowmem_prunes</code> — количество запросов, которые были удалены из кеша из-за нехватки памяти;</li>
	<li><code>Qcache_not_cached</code> — количество запросов, которые не были записаны в кеш из-за использования функций работы со временем и т.п.;</li>
	<li><code>Qcache_queries_in_cache</code> — количество запросов, которые находятся в кеше.</li>
</ul>
<p>Можно просмотреть общее количество запросов SELECT:</p>
<pre><code>
mysql> show status like 'Com_select';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Com_select    | 16719 |
+---------------+-------+
1 row in set (0.00 sec)
</code></pre>
<h2>7.3 Эффективность кеширования</h2>
<span class="text-viola"><p>«Оценивать эффективность кэша рекомендуют делением значения переменной <code>Qcache_hits на Qcache_hits + Com_select</code>, поскольку при обработке запроса увеличивается счётчик Qcache_hits (если запрос обработан из кэша) или Com_select (если запрос не кэширован). Такой способ предлагают в «Mysql оптимизация производительности» O’reilly</p>
<p>В сети есть другой способ </p>
<pre><code>qcache_hit_ratio = qcache_hits / (qcache_hits + qcache_inserts + qcache_not_cached)
</code></pre>
<p>Если это значение > 0.8, то значит 80% ваших запросов попадают в кэш, это очень хороший показатель.</p>
<p>Если <code>%</code> попадания в кэш низкий, то необходимо увеличить значение<code> query_cache_size</code>.»</p></span>
<p>Текущее значение можно посмотреть так:</p>
<pre><code>SHOW VARIABLES LIKE 'query_cache_size';
</code></pre>
<p>Опять же возникает вопрос: как выбрать адекватное значение <code>query_cache_size?</code> </p>
<p>В этом поможет <code>Qcache_lowmem_prunes</code>. В этой переменной хранится число запросов, которые были убраны из кэша из-за необходимости кэширования новых запросов. Необходимо стремится к такому размеру кэша, при котором <code>Qcache_lowmem_prunes</code> будет лишь незначительно увеличиваться. Для этого, рекомендуется сравнить разницу значений <code>Qcache_lowmem_prunes</code> за час и кол-во запросов, поступивших на mysql за этот же час.</p>
<span class="text-viola"><p>«На практике, для расчета query_cache_size можно использовать одну из 2-х формул:</p>
<pre><code>query_cache_size = (число запросов за 10 минут)*(средний объем ответа на запрос) * 1,2
</code></pre>
<p>или</p>
<pre><code>query_cache_size = (число запросов за 10 минут)*(средний объем ответа на запрос) * 1,2
</code>query_cache_size = (объем трафика за 10 минут) * 1,2 » </pre></span>
<p>Это позволит закэшировать запросы на 10 минут + дать дополнительные 20% памяти на фрагментацию кэша и дополнительный резерв кэширования</p>
<p>Подсчитать количество и средний объем ответа на запрос можно использую переменные <strong>Bytes_sent</strong> соответственно</p>
<p>И так значения <code>query_cache_size</code> мы увеличили, после чего стоит обратить внимание на значения <code>Qcache_total_blocks</code>, <code>Qcache_free_blocks</code> и <code>Qcache_queries_in_cache</code>. MySQL хранит кэш в блоках. На 1 запрос необходимо 2 блока: один для самого текста запроса, второй для результата.</p>
<p>Если рассмотреть таблицу со значения <code>Qcache%</code> </p>
<p>Общее количество блоков кэша <code>Qcache_total_blocks – 28</code> </p>
<p>Закешировано сейчас 6 запрос, а значит занят 6*2 = 12 блоков</p>
<p>Cвободно блоков <code>Qcache_free_blocks – 10</code>. Чем больше незадействованных <code>Qcache_free_blocks</code>, тем больше степень "фрагментации" кэша.</p>
<p>Если большинство запросов имеют небольшой объем результирующих данных, то стоит уменьшить минимальный размер блока кэша <code>query_cache_min_res_unit</code>, который по умолчанию равен 4 Кб.</p>
<p>Если же большинство запросов возвращают много данных – то стоит увеличить размер блока кэша.</p>
<p>Главное – это добиться минимального значения <code>Qcache_free_blocks</code>.</p>
<p>Если счетчик <code>Qcache_not_cached</code> велик, можно попробоавть увеличить переменную <code>query_cache_limit</code> – она позволит увеличить лимит и помещать в кэш результаты запросов которые «не помещаются».</p>
<p>За использование кеша запросов отвечают следующие конфигурационные переменные:</p>

<ul>


	<li><code>query_cache_size</code> — размер кеша запросов. <code>query_cache_size = 0</code> отключает использование кеша;</li>
	<li><code>query_cache_limit</code> — размер максимальной выборки, хранимой в кеше;</li>
	<li><code>query_cache_wlock_invalidate</code> — определяет будут ли данные браться из кеша, если таблица, к которым они относятся заблокирована на чтение.</li>=
</ul>
<p>Чтобы включить кэширование запросов mysql достаточно добавить строки в <strong>my.cnf </strong>(Секция [mysqld]):</p>
<pre><code>
query_cache_size = 268435456
query_cache_type =1 
query_cache_limit =1 048576
</code></pre>
<p>И перезапустить сервис.</p>
<h2>7.4 Где кэш не используется</h2>
<p><strong>Не кэшируются:</strong></p>
<ul>
	<li>Запросы с <code>SQL_NO_CACHE</code> </li>
	<li>Подготовленные запросы <code>(Prepared statements);</code> </li>
	<li>Запросы, которые являются подзапросами внешнего запроса;</li>
	<li>Запросы внутри хранимых процедур и функций;</li>
	<li>Запросы, в которых используются функции:
		<p><code>BENCHMARK ()</code>, <code>CONNECTION_ID ()</code>, <code>CONVERT_TZ ()</code>, <code>CURDATE ()</code>, <code>CURRENT_DATE ()</code>, <code>CURRENT_TIME ()</code>, <code>CURRENT_TIMESTAMP ()</code>, <code>CURTIME ()</code>, <code>DATABASE ()</code>, <code>ENCRYPT ()</code> с одним аргументом, <code>FOUND_ROWS ()</code>, <code>GET_LOCK ()</code>,<code> LAST_INSERT_ID ()</code>, <code>LOAD_FILE ()</code>, <code>MASTER_POS_WAIT ()</code>, <code>NOW ()</code>, <code>RAND ()</code>, <code>RELEASE_LOCK ()</code>, <code>SLEEP ()</code>, <code>SYSDATE ()</code>, <code>UNIX_TIMESTAMP ()</code> без аргументов, <code>USER ()</code>, <code>UUID ();</code> </p>
	</li>
	<li>Запросы использующие хранимые функции, пользовательские переменные или ссылающиеся на таблицы в системных базах <strong>mysql</strong> или <strong>INFORMATION_SCHEMA;</strong> </li>
	<li>•	Запросы имеющие следующие формы:</li>
		<ul>
			<li><code>SELECT ... IN SHARE MODE</code></li>
			<li><code>SELECT ... FOR UPDATE</code></li>
			<li><code>SELECT ... INTO OUTFILE ...</code></li>
			<li><code>SELECT ... INTO DUMPFILE ...</code></li>
			<li><code>SELECT * FROM ... WHERE autoincrement_col IS NULL</code></li>
		</ul>
	<li>Запросы с временными таблицами или вовсе не использующие таблицы;</li>
	<li>Запросы генерирующие предупреждения(warnings);</li>
</ul>
<p><strong>Дефрагментировать кэш можно командой:</strong> </p>
<pre><code>mysql>flush query cache;
</code></pre>
<p>Очистить – командой:</p>
<pre><code>mysql>flush query cache;
</code></pre>
<p>Самое важное</p>
<p><mark class="red">Никогда не работайте на production с настройками по умолчанию</mark>. Это приведет к неиспользованию большинства ресурсов сервера. Правильная настройка MySQL может повысить производительность базы данных в несколько раз. Это позволит не только ускорить работу приложения, но и справиться с большой нагрузкой.</p>