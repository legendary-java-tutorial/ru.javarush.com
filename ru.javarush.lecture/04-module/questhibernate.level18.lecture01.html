Уровни изоляции транзакций
<p>----------------------------------------</p>
Read uncommitted
Read committed
Repeatable read
Serializable
Поддержка изоляции транзакций в реальных СУБД
<p>----------------------------------------</p>
<h2>2.1 Read uncommitted</h2>
<p>Под «уровнем изоляции транзакций» понимается степень обеспечиваемой внутренними механизмами СУБД (то есть не требующей специального программирования) защиты от всех или некоторых вышеперечисленных видов несогласованности данных, возникающих при параллельном выполнении транзакций. Стандарт SQL-92 определяет шкалу из четырёх уровней изоляции: </p>
<ul>
	<li><strong>Read uncommitted</strong> </li>
	<li><strong>Read committed</strong> </li>
	<li><strong>Repeatable read</strong> </li>
	<li><strong>Serializable</strong> </li>
</ul>
<p>Первый из них является самым слабым, последний — самым сильным, каждый последующий включает в себя все предыдущие.</p>
<p>Низший (первый) уровень изоляции. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.</p>
<p>Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполнятся последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.</p>
<h2>2.2 Read committed</h2>
<p>Большинство промышленных СУБД, в частности, Microsoft SQL Server, PostgreSQL и Oracle, по умолчанию используют именно этот уровень. На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных.</p>
<p>Реализация завершённого чтения может основываться на одном из двух подходов: блокировании или версионности.</p>
<p><strong>Блокирование читаемых и изменяемых данных.</strong> </p>
<p>Заключается в том, что пишущая транзакция блокирует изменяемые данные для читающих транзакций, работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким образом, «грязному» чтению, а данные, блокируемые читающей транзакцией, освобождаются сразу после завершения операции <code>SELECT</code> (таким образом, ситуация «неповторяющегося чтения» может возникать на данном уровне изоляции).</p>
<p><strong>Сохранение нескольких версий параллельно изменяемых строк.</strong> </p>
<p>При каждом изменении строки СУБД создаёт новую версию этой строки, с которой продолжает работать изменившая данные транзакция, в то время как любой другой «читающей» транзакции возвращается последняя зафиксированная версия. Преимущество такого подхода в том, что он обеспечивает большую скорость, так как предотвращает блокировки. Однако он требует, по сравнению с первым, существенно большего расхода оперативной памяти, которая тратится на хранение версий строк. </p>
<p>Кроме того, при параллельном изменении данных несколькими транзакциями может создаться ситуация, когда несколько параллельных транзакций произведут несогласованные изменения одних и тех же данных (поскольку блокировки отсутствуют, ничто не помешает это сделать). Тогда та транзакция, которая зафиксируется первой, сохранит свои изменения в основной БД, а остальные параллельные транзакции окажется невозможно зафиксировать (так как это приведёт к потере обновления первой транзакции). Единственное, что может в такой ситуации СУБД — это откатить остальные транзакции и выдать сообщение об ошибке «Запись уже изменена».</p>
<p>Конкретный способ реализации выбирается разработчиками СУБД, а в ряде случаев может настраиваться. Так, по умолчанию MS SQL использует блокировки, но (в версии 2005 и выше) при установке параметра <code>READ_COMMITTED_SNAPSHOT</code> базы данных переходит на стратегию версионности, Oracle исходно работает только по версионной схеме. В Informix можно предотвратить конфликты между читающими и пишущими транзакциями, установив параметр конфигурации <code>USELASTCOMMITTED</code> (начиная с версии 11.1), при этом читающая транзакция будет получать последние подтвержденные данные.</p>
<h2>2.3 Repeatable read</h2>
<p>Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.</p>
<p>Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. </p>
<p>Учитывая то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень параллелизма ниже, чем при уровне изоляции <code>READ COMMITTED</code>. Поэтому пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется.  </p>
<h2>2.4 Serializable</h2>
<p>Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».</p>
<h2>2.5 Поддержка изоляции транзакций в реальных СУБД</h2>
<p>СУБД, обеспечивающие транзакционность, не всегда поддерживают все четыре уровня, а также могут вводить дополнительные. Возможны также различные нюансы в обеспечении изоляции.</p>
<p>Так, Oracle в принципе не поддерживает нулевой уровень, так как его реализация транзакций исключает «грязные чтения», и формально не позволяет устанавливать уровень Repeatable read, то есть поддерживает только <code>Read committed</code> (по умолчанию) и <code>Serializable</code>. При этом на уровне отдельных команд он, фактически, гарантирует повторяемость чтения (если команда <code>SELECT</code> в первой транзакции выбирает из базы набор строк, и в это время параллельная вторая транзакция изменяет какие-то из этих строк, то результирующий набор, полученный первой транзакцией, будет содержать неизменённые строки, как будто второй транзакции не было). Также Oracle поддерживает так называемые <code>READ-ONLY</code> транзакции, которые соответствуют <code>Serializable</code>, но при этом не могут сами изменять данные.</p>
<p>А <strong>Microsoft SQL Server</strong> поддерживает все четыре стандартных уровня изоляции транзакций, а дополнительно — уровень SNAPSHOT, на котором транзакция видит то состояние данных, которое было зафиксировано до её запуска, а также изменения, внесённые ею самой, то есть ведёт себя так, как будто получила при запуске моментальный снимок данных БД и работает с ним. Отличие от Serialized состоит в том, что не используются блокировки, но в результате фиксация изменений может оказаться невозможной, если параллельная транзакция изменила те же самые данные раньше; в этом случае вторая транзакция при попытке выполнить <code>COMMIT</code> вызовет сообщение об ошибке и будет отменена. </p>
<p></p>