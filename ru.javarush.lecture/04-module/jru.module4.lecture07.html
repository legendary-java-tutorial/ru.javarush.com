Проект по теме: Hibernate (2)
<p>----------------------------------------</p>
Проект по теме: Hibernate (2)
<p>----------------------------------------</p>
<h3>Сегодня наша задача – выполнить второй проект по теме Hibernate. Его суть – разобраться в структуре БД, сделать маппинг энтити на существующие таблицы, и добавить минимальный функционал для проверки что маппинг выполнен правильно.</h3>
<p><strong>Теперь подробнее: </strong></p>
<ol>
	<li> <a href="https://javarush.com/downloads/ide/javarush/dump-hibernate-2.sql" target="_blank">Скачать дамп-файл</a> и развернуть его у себя на локальной машине. В качестве БД мы будем использовать тестовую БД, которая распространяется в качестве примера вместе с установочным пакетом MySQL. Дамп нужен для того, чтоб зафиксировать состояние БД, т. к. мы не можем гарантировать, что она не изменится через день-месяц-год. </li>
	<li>Темплита проекта у нас не будет, поэтому проект создавай самостоятельно. Это должен быть maven проект со всеми необходимыми зависимостями (<strong>hibernate-core-jakarta</strong>, <strong>mysql-connector-java</strong>, <strong>p6spy</strong>). </li>
	<li>Подключи в Идее нашу локальную развернутую БД как datasource. После этого во вкладке Database поставь курсор на схему movie и нажми комбинацию клавиш <code>Alt+Ctrl+Shift+U</code> (работает только в Ultimate версии). Это покажет структуру всей схемы movie (с названием колонок, ключами и т .). Выглядит примерно так: 
	<img data-max-width="1024" data-id="2b71a9bb-4d0b-4693-81fb-b1119978a0e3" src="https://cdn.javarush.com/images/article/2b71a9bb-4d0b-4693-81fb-b1119978a0e3/1024.jpeg" alt="">
	<p>Согласен, смотреть не очень удобно. Отключи показ названия всех колонок и комментариев: </p>
	<img data-max-width="512" data-id="24c31d79-1015-41a8-90d4-5c4e0a3513c3" src="https://cdn.javarush.com/images/article/24c31d79-1015-41a8-90d4-5c4e0a3513c3/512.jpeg" alt="">
	<p>В результате получишь схему БД, которую уже можно анализировать: </p>
	<img data-max-width="1024" data-id="85a773a5-42a9-4cb9-b885-f05e859df442" src="https://cdn.javarush.com/images/article/85a773a5-42a9-4cb9-b885-f05e859df442/1024.jpeg" alt="">
	</li>
	<li>Схема выглядит сложно, но не все так плохо. Для анализа структуры БД нужно найти с чего начать. Единого правильного ответа нет, но я б рекомендовал начать с таблицы <code>film</code>. Давай рассмотрим несколько взаимосвязей в качестве примера: 
		<ul>
			<li>Связь между таблицами <code>film</code> и <code>film_text</code> – это явная связь <strong>OneToOne</strong>, потому что в таблице <code>film_text</code> есть поле <code>film_id</code>, которое <mark class="red">НЕ</mark> ссылается на <strong>ID</strong> из таблицы <code>film</code> (нет foreign key). Но по названию и логике, эта связь должна быть. Кроме того, в таблице <code>film_text</code> поле <code>film_id</code> выступает первичным ключом, что гарантирует что одному «фильму» соответствует не более чем один «текст фильма». </li>
			<li>Теперь давай посмотрим на таблицы <code>film</code> и <code>category</code>. С точки зрения логики, у фильма может быть несколько категорий. И одна категория, может быть, у разных фильмов. Кроме этого, между этими двумя таблицами есть промежуточная таблица связи <code>film_category</code>. Исходя из всего вышеперечисленного – это явная связь <strong>ManyToMany</strong>. </li>
			<li>Смотрим на таблицы <code>film</code> и <code>language</code>. С точки зрения логики, у фильма, может быть, перевод на разные языки и разные фильмы могут быть на одном языке. То есть, напрашивается <strong>ManyToMany</strong>. Но если посмотреть на содержимое таблицы <code>film</code>, мы можем заметить, что каждая строка таблицы – это уникальный фильм. И в строке есть только одно поле <strong>language_id</strong> (Есть еще original_language_id, но во всех записях оно null, поэтому можем пренебречь им). То есть, у одного фильма может быть только один язык. И один язык, может быть, у разных фильмов. Связь – <strong>ManyToOne</strong> (связь направлена от film к language). </li>
		</ul>
	</li>
	<li>Теперь основное задание – нужно создать все необходимые энтити классы и замапить их на таблицы схемы <code>movie</code>. </li>
	<li>Добавить метод, который умеет создавать нового покупателя (таблица customer) со всеми зависимыми полями. Не забудь сделать чтоб метод был транзакционным (чтоб не попасть в ситуацию что адрес покупателя записали в БД, а самого покупателя – нет). </li>
	<li>Добавить транзакционный метод, который описывает событие «покупатель пошел и вернул ранее арендованный фильм». Покупателя и событие аренды выбери любое на свое усмотрение. Рейтинг фильма пересчитывать не нужно. </li>
	<li>Добавить транзакционный метод, который описывает событие «покупатель сходил в магазин (store) и арендовал (rental) там инвентарь (inventory). При этом он сделал оплату (payment) у продавца (staff)». Фильм (через инвентарь) выбери на свое усмотрение. Единственное ограничение – фильм должен быть доступен для аренды. То есть либо в rental не должно быть вообще записей по инвентарю, либо должна быть заполнена колонка <strong>return_date</strong> таблицы <code>rental</code> для последней аренды этого инвентаря. </li>
	<li>Добавить транзакционный метод, который описывает событие «сняли новый фильм, и он стал доступен для аренды». Фильм, язык, актеров, категории и т д выбери на свое усмотрение. </li>
	<li>Структуру таблиц менять нельзя. Но внести свои предложения по улучшению – нужно. Одно проблемное место мы выявили в п.4 (отсутствие <strong>foreign key</strong> в таблице <code>film_text</code> на поле <code>film_id</code> таблицы <code>film</code>). Посмотри, есть ли еще в структуре БД такие «ляпы». Если да – добавь readme файл в корень проекта и опиши эти ляпы. </li>
</ol>

<hr>
<p>Разбор проекта:</p>
<ul>
<li><a href="https://youtu.be/QIdL2bZI4jY" target="_blank">Часть 1</a></li>
<li><a href="https://youtu.be/vKxB8S43otI" target="_blank">Часть 2</a></li>
<li><a href="https://youtu.be/QvfmO82iV98" target="_blank">Часть 3</a></li>
</ul>