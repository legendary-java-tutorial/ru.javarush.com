Оптимизация скорости выборки данных
<p>----------------------------------------</p>
Индексы
Денормализация таблиц
Оптимизация запросов: примеры
Кеширование
<p>----------------------------------------</p>
<h2>6.1 Введение</h2>
<p>А теперь перейдем от теории к практике. </p>
<center><span class="text-green">«В теории между теорией и практикой отличий нет. На практике они есть.»</span></center>
<p>Мы живем в реальном мире и все программные продукты создаются в конечном счете для живых людей. И этих живых людей очень раздражают сайты, которые медленно грузятся, и программы, которые подтормаживают.</p>
<p>И если запрос к базе данных выполняется больше секунды – это <strong>неприемлемо</strong>. Пользователи просто не будут пользоваться таким продуктом, где есть страницы/функционал, который настолько тормозит.</p>
<p>А ведь часто, чтобы отобразить одну страницу, нужно выполнить несколько десятков запросов к базе. И если они выполняются последовательно, то лимит у вас уже не секунда, а скажем 100мс на запрос.</p>
<p>Ниже я приведу 5 основных способов, которыми программисты ускоряют работу запросов к базе данных:</p>
<ol>
	<li>Добавляем индексы к таблицам в базе данных.</li>
	<li>Переписываем и оптимизируем запросы.</li>
	<li>Включаем (и настраиваем) кеширование на стороне БД.</li>
	<li>Включаем кеширование на стороне клиента.</li>
	<li>Выполняем денормализацию базы данных.</li>
</ol>
<p>Вы уже по большей части знакомы со всеми этими вещами, поэтому дальше будут только практические советы.</p>
<h2>6.2 Индексы</h2>
<p>Ни для кого не секрет, что работа с базой данных занимает большую часть работы практически любого сайта. И именно работа с БД чаще всего является узким местом веб-приложений.</p>
<p>В этой статье хотелось бы дать практические советы использования MySQL.</p>
<p>Сразу оговорюсь:</p>
<ul>
	<li>данная статья написана про MySQL, хотя общие вещи скорее всего справедливы для любой СУБД.</li>
	<li>все написанное в статье является моей личной точкой зрения, и не является истиной в последней инстанции.</li>
	<li>советы не претендуют на новизну и являются результатом обобщения прочтенной литературы и личного опыта.</li>
	<li>в рамках данной статьи я не буду касаться вопросов конфигурирования MySQL.</li>
</ul>
<p>Проблемы при использовании MySQL можно разделить на следующие три группы (в порядке значимости):</p>
<ol>
	<li>Неиспользование или неправильное использование индексов.</li>
	<li>Неправильная структура БД.</li>
	<li>Неправильные \ неоптимальные SQL запросы.</li>
</ol>
<p>Остановимся на каждой из этих групп подробнее.</p>
<h3>Использование индексов</h3>
<p>Неиспользование или неправильное использование индексов — это то, что чаще всего замедляет запросы. Для тех, кто мало знаком с механизмом работы индексов или еще не читал об этом в мануале, очень советую почитать.</p>
<p><strong>Советы по использованию индексов:</strong> </p>
<ul>
	<li><span class="text-red">Не нужно индексировать все подряд</span>. Довольно часто, не понимая смысла, люди просто индексируют все поля таблицы. Индексы ускоряют выборки, но замедляют вставки и обновления строк, поэтому выбор каждого индекса должен быть осмыслен.</li>
	<li>Один из основных параметров, характеризующий индекс — селективность (selectivity) — количество разных элементов в индексе. Нет смысла индексировать поле, в котором два-три возможных значения. Пользы от такого индекса будет мало.</li>
	<li>Выбор индексов должен начинаться с анализа всех запросов к данной таблице. Очень часто после такого анализа вместо трех-четырех индексов можно сделать один составной.</li>
	<li>При использовании составных индексов порядок полей в индексе имеет определяющее значение.</li>
	<li>Не забывайте про покрывающие(covering) индексы. Если все данные в запросе могут быть получены из индекса, то MySQL не будет обращаться непосредственно к таблице. Подобные запросы будут выполняться очень быстро. Например для запроса <code>SELECT name FROM user WHERE login='test'</code> при наличии индекса (login, name) обращения к таблице не потребуется. Порой имеет смысл добавить в составной индекс дополнительное поле, которое сделает индекс покрывающим и ускорит запросы.</li>
	<li>Для индексов по строкам часто достаточно индексировать лишь часть строки. Это может значительно уменьшить размер индекса.</li>
	<li>Если <code>%</code> стоит в начале <code>LIKE(SELECT * FROM table WHERE field LIKE '%test')</code> индексы использоваться не будут.</li>
	<li><strong>FULLTEXT</strong> индекс используется только с синтаксисом <strong>MATCH</strong> … <strong>AGAINST</strong>.</li>
</ul>
<h2>6.3 Структура БД</h2>
<p>Грамотно спроектированная БД — залог быстрой и эффективной работы с базой. С другой стороны, плохо продуманная БД — это всегда головная боль для разработчиков.</p>
<p><strong>Советы по проектированию БД:</strong> </p>
<ol>
	<li>Используйте минимально возможные типы данных. Чем больше тип данных, тем больше таблица, тем больше обращений к дискам нужно для получения данных. Используйте очень удобную процедуру: <code>SELECT * FROM table_name PROCEDURE ANALYSE();</code> для определения минимально возможных типов данных.</li>
	<li>На этапе проектирования соблюдайте нормальные формы. Часто программисты прибегают к денормализации уже на этом этапе. Однако в большинстве случаев в начале проекта далеко не очевидно, чем это может вылиться. Денормализовать таблицу гораздо проще, чем страдать от неоптимально денормализованной. Да и <code>JOIN</code> порой работает быстрее, чем неверно денормализованные таблицы.</li>
	<li>Не используйте <code>NULL</code> столбцы кроме случаев, когда они вам осознанно нужны.</li>
</ol>
<h2>6.4 SQL запросы.</h2>
<p>Так же часто возникает желание переписать все запросы на native SQL, чтобы запрос был максимально быстрым.  Если вы решитесь на такое, то вот вам несколько советов:</p>
<ol>
	<li>Избегайте запросов в цикле. SQL — язык множеств и к написанию запросов нужно подходить не языком функций, а языком множеств.</li>
	<li>Избегайте <code>*</code> (звездочки) в запросах. Не поленитесь перечислить именно те поля, которые вы выбираете. Это сократит количество выбираемых и пересылаемых данных. Кроме этого, не забывайте про покрывающие индексы. Даже если вы действительно выбираете все поля в таблице, лучше их перечислить. <strong>Во-первых</strong>, это повышает читабельность кода. При использовании звездочек невозможно узнать какие поля есть в таблице без заглядывания в нее. <strong>Во-вторых</strong>, сегодня в вашей таблице пять <strong>INT</strong> столбцов, а через месяц добавилось еще одно <strong>TEXT</strong> и <strong>BLOB</strong>, а звездочка как была, так и осталась.</li>
	<li>При постраничном выборе для получения общего количества записей используйте <code>SQL_CALC_FOUND_ROWS</code> и <code>SELECT FOUND_ROWS();</code> При использовании <code>SQL_CALC_FOUND_ROWS MySQL</code> кеширует выбранное количество строк(до применения LIMIT) и при <code>SELECT FOUND_ROWS()</code> только отдает это закешированное значение без необходимости повторного выполнения запроса.</li>
	<li>Не забывайте, что у <code>INSERT</code> есть синтаксис для множественной вставки. Один запрос будет выполняться на порядок быстрее, чем множество запросов в цикле.</li>
	<li>Используйте <code>LIMIT</code> там, где вам не нужны все данные.</li>
	<li>Используйте <code>INSERT… ON DUPLICATE KEY UPDATE…</code> вместо выборки и <code>INSERT</code> или <code>UPDATE</code> после нее, а также часто вместо <code>REPLACE</code>.</li>
	<li>Не забывайте про замечательную функцию <code>GROUP_CONCAT</code>. Она может выручить при сложных запросах.</li>
</ol>
