SortedMap
<p>----------------------------------------</p>
В этой лекции мы изучим интерфейс SortedMap. Рассмотрим новые методы, которые присутствуют в этом интерфейсе, а также особенности одной из имплементаций SortedMap — TreeMap и их отличия...
<p>----------------------------------------</p>
    <h2>SortedMap</h2>

    <p>В этой лекции мы изучим интерфейс <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>. Рассмотрим новые методы, которые присутствуют в этом интерфейсе, а также особенности одной из имплементаций <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> — <span class="code text-green"><span class="text-bold">TreeMap</span></span> и их отличия, а также преимущества по сравнению с <span class="code text-green"><span class="text-bold">HashMap</span></span>.</p>

    <p>Давай посмотрим, как устроена иерархия карт. Обрати особое внимание на интерфейс <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> и его реализацию <span class="code text-green"><span class="text-bold">TreeMap</span></span>, о которых мы говорим сегодня:</p>

    <img data-max-width="512" data-id="70e5b349-6779-49de-b9ee-da3fc67451ab" src="https://cdn.javarush.com/images/article/70e5b349-6779-49de-b9ee-da3fc67451ab/original.png" alt="">

    <p>Интерфейс <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> — это расширение интерфейса <span class="text-neon"><span class="text-bold"><em>Map</em></span></span>. Он во многом похож на <span class="text-neon"><span class="text-bold"><em>SortedSet</em></span></span> (который в свою очередь расширяет <span class="text-neon"><span class="text-bold"><em>Set</em></span></span>), так они оба описывают аналогичную функциональность по хранению и использованию отсортированных значений. </p>

    <p><span class="text-neon"><span class="text-bold"><em>SortedSet</em></span></span> работает и хранит <span class="code">&lt;TЗначение&gt;</span>, SortedMap SortedMap</em></span></span> — пары <span class="code">&lt;TКлюч, TЗначение&gt;</span>. Это карта, в которой все элементы отсортированы в порядке возрастания их ключей.</p>

    <p>Интерфейс <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> расширяет <span class="text-neon"><span class="text-bold"><em>Map</em></span></span>. Дополнительно в нем объявлены такие методы:</p>

    <table>
        <tbody>
            <tr>
                <th>Метод</th><th>Описание</th>
            </tr>
            <tr>
                <td><span class="code text-orange">TКлюч firstKey()</span></td>
                <td>Возвращает ключ первого элемента карты</td>
            </tr>
            <tr>
                <td><span class="code text-orange">TКлюч lastKey()</span></td>
                <td>Возвращает ключ последнего элемента карты</td>
            </tr>
            <tr>
                <td><span class="code text-orange">SortedMap&lt;TКлюч, TЗначение&gt; headMap(TКлюч end)</span></td>
                <td>Возвращает карту <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, которая содержит все элементы оригинального <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> вплоть (т.е, не включительно) до элемента с ключом <span class="text-user">end</span></td>
            </tr>
            <tr>
                <td><span class="code text-orange">SortedMap&lt;TКлюч, TЗначение&gt; tailMap(K start)</span></td>
                <td>Возвращает карту <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, которая содержит все элементы оригинального <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, начиная с элемента с ключом <span class="text-user">start</span> (включительно)</td>
            </tr>
            <tr>
                <td><span class="code text-orange">SortedMap&lt;TКлюч, TЗначение&gt; subMap(TКлюч start, TКлюч end)</span></td>
                <td>Возвращает карту <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, которая содержит все элементы оригинального <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> вплоть от элемента с ключом <span class="text-user">start</span> до элемента с ключом <span class="text-user">end</span> (<span class="text-user">end — не включительно)</td>
            </tr>
        </tbody>
    </table>

    <h2>Класс TreeMap</h2>

    <p>Класс <span class="code"><span class="text-green">TreeMap</span></span> это имплементация интерфейса <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>. То есть, в <span class="code"><span class="text-green">TreeMap</span></span> реализованы все дополнительные методы <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> и стандартные с интерфейса <span class="text-neon"><span class="text-bold"><em>Map</em></span></span>.</p>

    <p>Создать объект типа <span class="code"><span class="text-green">TreeMap</span></span> можно с помощью команд вида:</p>

    <ul>
        <li><p><span class="code text-orange">TreeMap()</span>: создает пустую карту в виде дерева;</li></p>
        <li><p><span class="code text-orange">TreeMap(Map&lt;? extends TКлюч,​? extends TЗначение&gt; map)</span>: создает дерево, в которое добавляет все элементы из карты map;</li></p>
        <li><p><span class="code text-orange">TreeMap(SortedMap&lt;TКлюч, ? extends TЗначение&gt; smap)</span>: создает дерево, в которое добавляет все элементы из карты smap;</li></p>
        <li><p><span class="code text-orange">TreeMap(Comparator&lt;? super TКлюч&gt; comparator)</span>: создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы компаратором.</li></p>
    </ul>

    <p>Где <em>TКлюч</em> — это тип ключей из пары элементов, <em>TЗначение</em> — тип значений в паре элементов, которые будут храниться в карте <span class="code text-green"><span class="text-bold">TreeMap</span></span>.</p>

    <p><span class="text-neon"><span class="text-bold"><em>Comparator</em></span></span> — довольно важная вещь для <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>/<span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span>. Он предоставляет информацию о том, по каким правилам нам нужно сортировать — то есть, выстраивать порядок в нашей карте. Если он не предоставлен при создании <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, то будет использоваться естественный порядок нашего ключа.</p>

    <h3>Добавление элементов в TreeMap</h3>

    <p>Элементы добавляются в карту сразу парами: для этого используется метод <span class="code text-orange">put()</span>. Первым в него передается ключ, вторым — значение. Например, мы хотим создать список учеников и их оценок.</p>

    <pre class='language-java line-numbers'><code>
SortedMap&lt;String, Integer&gt; map =new TreeMap &lt;String,Integer&gt;();

map.put("Антон", 5);
map.put("Сергей", 5);
map.put("Руслан", 5);
map.put("Юрий", 4);
map.put("Николай", 4);
map.put("Олег", 3);
map.put("Олег", 5);

System.out.println(map);
</code></pre>

    <p>Результат: </p>

    <div class="terminal">{Антон=5, Николай=4, Олег=5, Руслан=5, Сергей=5, Юрий=4}</div>

    <p>Если при добавлении элемента выяснится, что элемент с таким ключом уже есть, старое значение ключа заменится на новое. Это показано на примере двух пар элементов — <span class="text-bold">("Олег",3)</span> и <span class="text-bold">("Олег",5)</span>.</p>

    <p>Рассмотрим пример с созданным <span class="text-neon"><span class="text-bold"><em>Comparator</em></span></span>-ом. Допустим, нам нужно хранить элементы в отсортированном виде по длине ключа-строки. Если длина ключей равна, дальше идет сравнение основываясь на алфавитном порядке (натуральный порядок для строк): </p>

    <pre class='language-java line-numbers'><code>
class LengthComparator implements Comparator&lt;String&gt; {
  public int compare(String o1, String o2) {
    Integer lenghComparedResult = Integer.compare(o1.length(), o2.length());
    return lenghComparedResult != 0 ? lenghComparedResult : o1.compareTo(o2);
  }
}

SortedMap&lt;String, Integer&gt; lengthComaredMap = new TreeMap&lt;String,Integer&gt;(new LengthComparator());

lengthComaredMap.put("Юрий",4);
lengthComaredMap.put("Олег",5);
lengthComaredMap.put("Руслан",4);
lengthComaredMap.put("Ян",4);
</code></pre>

    <p>Последовательность будет следующая:</p>

    <div class="terminal">lenghComaredMap: {Ян=4, Олег=5, Юрий=4, Руслан=4}</div>

    <p>Такое поведение делает <span class="code text-green"><span class="text-bold">TreeMap</span></span> похожим на отсортированный массив или список, если бы у них в качестве индексов выступали слова (<span class="text-orange">String</span>), а не числа.</p>

    <table>
        <tbody>
            <tr>
                <td>Важно: в качестве Типа-Ключа и Типа-Значения могут выступать практически любые типы. Есть небольшие дополнительные требования к Типу-Ключу, но о них вы узнаете при детальном изучении коллекций.</td>
            </tr>
        </tbody>
    </table>

    <h2>Методы SortedMap на примере класса TreeMap</h2>

    <ol>

        <li>
            <p>Если тебе нужно получить ключ первого ученика, можно воспользоваться методом <span class="code text-orange">firstKey()</span>:</p>

            <pre class='language-java line-numbers'><code>
String firstKey = map.firstKey();
	System.out.println("Первый ключ → " + firstKey);
</code></pre>

            <p>Результат: <span class="code">Первый ключ → Антон</span></p>
        </li>

        <li>
                <p>Если тебе нужно получить ключ последнего ученика, можно воспользоваться методом <span class="code text-orange">lastKey()</span>:</p>

            <pre class='language-java line-numbers'><code>
String lastKey = map.lastKey();
System.out.println("Последний ключ → " + lastKey);
</code></pre>

            <p>Результат: <span class="code">Последний ключ → Юрий</span></p>
        </li>

        <li>
            <p>Получить все объекты, которые стоят после объекта с ключом “<em>Сергей</em>”:</p>

<pre class='language-java line-numbers'><code>
Map&lt;String, Integer&gt; tailMap = map.tailMap("Сергей");
         	System.out.println("tailMap: " + tailMap);
</code></pre>

            <p>Результат: <span class="code">tailMap: {Сергей=5, Юрий=4}</span></p>
        </li>

        <li>
            <p>Получить все объекты, которые стоят до объекта с ключом “<em>Николай</em>”:</p>

            <pre class='language-java line-numbers'><code>
System.out.println("headMap: " + headMap);
 Map&lt;String, Integer&gt; headMap = map.headMap("Николай");
</code></pre>
         	
            <p>Результат: <span class="code">headMap: {Антон=5}</span></p>
        </li>

        <li>
            <p>Получить все объекты, которые стоят после объекта с ключом “<em>Олег</em>”, но которые стоят до объекта с ключом “<em>Сергей</em>”:</p>

            <pre class='language-java line-numbers'><code>
Map&lt;String, Integer&gt; subMap = map.subMap("Олег", "Сергей");	
System.out.println("subMap: " + subMap);
</code></pre>

            <p>Результат: <span class="code">subMap: {Олег=5, Руслан=5}</span></p>
        </li>

    </ol>

    <h2>СравнениеHashMap и SortedMap/TreeMap</h2>

    <p>Давай поговорим о последовательности и порядке хранения элементов:</p>

    <ul>
        <li><p>Так как <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> не дает нам никаких гарантий относительно порядка итераций, он будет полностью изменяться при добавлении новых элементов.</p></li>

        <li><p>В <span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span> порядок будет в соответствии с "natural order" ключей в соответствии с их методом <span class="code text-orange">compareTo()</span> (или внешне поставляемым <span class="text-neon"><span class="text-bold"><em>Comparator</em></span></span>). Также не стоит забывать, что <span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span> реализует интерфейс <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, который содержит методы, зависящие от этого порядка сортировки.</p></li>
    </ul>

    <p>Если говорить о производительности и быстродействии:</p>

    <ul>
        <li><p><span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> — карта, основанная на хешировании ключей. Она поддерживает операции вставки и получения элементов за фиксированное время <span class="text-bold">O(1)</span>. Для этого ключи должны иметь реализации <span class="code text-orange">hashCode()</span> и <span class="code text-orange">equals()</span>.</p></li>

        <li><p><span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span> — карта, построенная на основе дерева. Её операции вставки и получения занимают логарифмическое время, которое зависит от количества элементов в карте <span class="text-bold">O(log n)</span>. Это необходимо, чтобы у элементов был некоторый механизм сравнения, предоставленный либо нашим ключом, либо внешним Компаратором. Порядок итераций определяется этим механизмом.</p></li>
    </ul>

    <p>На этих факторах и базируется наше решение о том, что и когда лучше использовать. </p>

    <p>Если нам необходимо хранить значения в каком-либо порядке, выбор очевиден — нам нужна карта <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>. Хоть она и работает немного медленнее по сравнению с <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span>, она выполняет важные для нас задачи.</p>

    <p>Как уже сказано ранее, с <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> мы можем получить первый (или последний) ключ, либо значение, либо пару ключ-значение в нашей карте, независимо от того, когда это значение добавили. С реализацией <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> мы этого сделать не можем.</p>

    <p>Рассмотрим это на примере, когда у нас есть карта с ключами (Имена студентов) и значениями (их оценки за зачёт). Допустим, нам желательно работать со списком в обратном алфавитном порядке.</p>

    <p>1.</p>

    <pre class='language-java line-numbers'><code>
SortedMap&lt;String, Integer&gt; sorted = new TreeMap&lt;String,Integer&gt;(Comparator.reverseOrder());
sorted.put("Антон", 5);
sorted.put("Сергей", 5);
sorted.put("Юрий", 4);

String firstKeyFromSortedMapVariant = sorted.firstKey();

Integer markFromSortedMap = sorted.get(firstKeyFromSortedMapVariant);
System.out.println(firstKeyFromSortedMapVariant + " - " + markFromSortedMap);
</code></pre>

    <p>2.</p>

    <pre class='language-java line-numbers'><code>
HashMap&lt;String, Integer&gt; hash = new HashMap&lt;String,Integer&gt;();
hash.put("Антон", 5);
hash.put("Сергей", 5);
hash.put("Юрий", 4);

SortedSet&lt;String&gt; keySetOfHashMap = new TreeSet&lt;String&gt;(Comparator.reverseOrder());
// Или сортировать вручную, сохраняя элементы в массив или список (с сохранением порядка вставки)
keySetOfHashMap.addAll(hash.keySet());
String firstKeyFromHashMapVariant = keySetOfHashMap.first();


Integer markFromHashMap = hash.get(firstKeyFromHashMapVariant);
System.out.println(firstKeyFromHashMapVariant + " - " + markFromHashMap);
</code></pre>

    <p>На примере видно: при использовании <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> задача выглядит сложнее, так как <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> не гарантирует нам ни порядка хранения, ни порядка получения элементов с карты.</p>