Знакомство с коллекцией LinkedList
<p>----------------------------------------</p>
История LinkedList В Java есть еще один класс-коллекция, который достался Java в наследство от языка C++. Это класс LinkedList, что переводится как «Связный Список». Внешне LinkedList – это такой же список как ArrayList. У класса LinkedList есть все те же методы, что и класса ArrayList. И в прин
<p>----------------------------------------</p>
<div class="lesson-carousel lesson-carousel--comics lesson-carousel--desktop">
    <div class="lesson-carousel__list">
        <div class="lesson-carousel__item">
            <img data-id="b1b1d5d4-9627-47d3-9d10-5644e26ca5f0" src="https://cdn.javarush.com/images/article/b1b1d5d4-9627-47d3-9d10-5644e26ca5f0/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="83634873-20c2-4b3b-9cb1-586c51ed0b8b" src="https://cdn.javarush.com/images/article/83634873-20c2-4b3b-9cb1-586c51ed0b8b/original.png" alt="">
        </div>
    </div>
</div>
<div class="lesson-carousel lesson-carousel--comics lesson-carousel--mobile">
    <div class="lesson-carousel__list">
        <div class="lesson-carousel__item">
            <img data-id="c47e97b0-879d-4e83-82fd-2af77bb97aae" src="https://cdn.javarush.com/images/article/c47e97b0-879d-4e83-82fd-2af77bb97aae/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="94e31b29-e5ee-4393-977c-f37bf0b34c9d" src="https://cdn.javarush.com/images/article/94e31b29-e5ee-4393-977c-f37bf0b34c9d/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="c3012a1e-4589-4706-9de6-448f4716bb06" src="https://cdn.javarush.com/images/article/c3012a1e-4589-4706-9de6-448f4716bb06/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="a14ec8a9-8496-44a6-8515-e11092f7e9fe" src="https://cdn.javarush.com/images/article/a14ec8a9-8496-44a6-8515-e11092f7e9fe/original.png" alt="">
        </div>
    </div>
</div>
<hr>
<h2>1. История <code>LinkedList</code></h2>
<p>В Java есть еще один класс-коллекция, который достался Java в наследство от языка C++. Это класс <code>LinkedList</code>, что переводится как «Связный Список».</p>
<p>Внешне <code>LinkedList</code> — это такой же список, как и <code>ArrayList</code>. <span class="text-green">У класса <code>LinkedList</code> есть все те же методы, что и у класса <code><span class="text-green">ArrayList</span></code>.</span> И в принципе вы всегда можете использовать <code>LinkedList</code> вместо <code>ArrayList</code>, и все будет работать.</p>
<p>Так зачем же нужен еще один класс-список?</p>
<p>Все дело во внутреннем устройстве класса <code>LinkedList</code>. Вместо массива там используется <span class="term">двусвязный список</span>. Что это такое, расскажем немного позже.</p>
<p>Но за счет другого внутреннего устройства у класса <code>LinkedList</code> — самая быстрая операция вставки элементов в середину списка.</p>
<p>В интернете часто можно найти такое сравнение классов <code>ArrayList</code> и <code>LinkedList</code>:</p>
<table>
    <tbody>
    <tr>
        <th>Операция</th>
        <th>Метод</th>
        <th>ArrayList</th>
        <th>LinkedList</th>
    </tr>
    <tr>
        <td><strong>Добавление элемента</strong></td>
        <td>
            <pre class="language-java"><code>add(value)</code></pre>
        </td>
        <td><span class="text-orange">Быстро</span></td>
        <td><span class="text-green">Очень быстро</span></td>
    </tr>
    <tr>
        <td><strong>Вставка элемента</strong></td>
        <td>
            <pre class="language-java"><code>add(index, value)</code></pre>
        </td>
        <td><span class="text-red">Медленно</span></td>
        <td><span class="text-green">Очень быстро</span></td>
    </tr>
    <tr>
        <td><strong>Получение элемента</strong></td>
        <td>
            <pre class="language-java"><code>get(index)</code></pre>
        </td>
        <td><span class="text-green">Очень быстро</span></td>
        <td><span class="text-red">Медленно</span></td>
    </tr>
    <tr>
        <td><strong>Изменение элемента</strong></td>
        <td>
            <pre class="language-java"><code>set(index, value)</code></pre>
        </td>
        <td><span class="text-green">Очень быстро</span></td>
        <td><span class="text-red">Медленно</span></td>
    </tr>
    <tr>
        <td><strong>Удаление элемента</strong></td>
        <td>
            <pre class="language-java"><code>remove(index)</code></pre>
        </td>
        <td><span class="text-red">Медленно</span></td>
        <td><span class="text-green">Очень быстро</span></td>
    </tr>
    </tbody>
</table>
<p>Вроде бы все понятно: если нужно вставлять элементы в список часто, используйте <code>LinkedList</code>, если редко, то ArrayList. Однако реальность немного другая.</p>
<hr>
<h2>2. Никто не использует <code>LinkedList</code></h2>
<p>Никто не использует <code>LinkedList</code>.</p>
<p>Недавно даже сам автор кода класса <code>LinkedList</code> в твиттере написал пост: «Ребята, кто-нибудь вообще использует <code>LinkedList</code>? За 20 лет я не использовал его ни разу!».</p>
<p>Так в чем же дело?</p>
<p>Во-первых, <strong>класс <code>ArrayList</code> стал вставлять элементы в середину списка очень быстро.</strong> При добавлении элемента в середину списка нужно сдвинуть все элементы после нужного на 1 в сторону конца списка. Раньше это занимало время.</p>
<p>Но сейчас все поменялось. Все элементы массива находятся рядом в одном блоке памяти, поэтому операция по сдвигу элементов массива выполняется очень быстрой низкоуровневой командой <code><span class="text-viola">System</span>.<span class="text-red">arraycopy</span>()</code>.</p>
<p>К тому же, сейчас у процессоров большой кэш, и обычно весь массив попадает в такой кэш, поэтому элементы массива сдвигаются даже не в памяти, а в кэше процессора. Миллион элементов легко сдвигается за одну миллисекунду.</p>
<p>Во-вторых, <strong>класс <code>LinkedList</code> быстро вставляет элементы, если вы вставляете их с помощью итератора.</strong> Если вы с помощью итератора проходитесь по списку <code>LinkedList</code> и постоянно вставляете новые элементы (или удаляете существующие), это действительно супербыстрая операция.</p>
<p>Если же вы просто в цикле добавляете элементы внутрь класса <code>LinkedList</code>, к каждой быстрой операции вставки добавляется медленная операция «получение элемента».</p>
<p>Реальность гораздо ближе к такой ситуации:</p>
<table>
    <tbody>
    <tr>
        <th>Операция</th>
        <th>Метод</th>
        <th>ArrayList</th>
        <th>LinkedList</th>
    </tr>
    <tr>
        <td><strong>Добавление элемента</strong></td>
        <td>
            <pre class="language-java"><code>add(value)</code></pre>
        </td>
        <td><span class="text-orange">Быстро</span></td>
        <td><span class="text-green">Очень быстро</span></td>
    </tr>
    <tr>
        <td><strong>Вставка элемента</strong></td>
        <td>
            <pre class="language-java"><code>add(index, value)</code></pre>
        </td>
        <td><span class="text-red">Медленно</span></td>
        <td><span class="text-red">Очень медленно</span></td>
    </tr>
    <tr>
        <td><strong>Получение элемента</strong></td>
        <td>
            <pre class="language-java"><code>get(index)</code></pre>
        </td>
        <td><span class="text-green">Очень быстро</span></td>
        <td><span class="text-red">Очень медленно</span></td>
    </tr>
    <tr>
        <td><strong>Изменение элемента</strong></td>
        <td>
            <pre class="language-java"><code>set(index, value)</code></pre>
        </td>
        <td><span class="text-green">Очень быстро</span></td>
        <td><span class="text-red">Очень медленно</span></td>
    </tr>
    <tr>
        <td><strong>Удаление элемента</strong></td>
        <td>
            <pre class="language-java"><code>remove(index)</code></pre>
        </td>
        <td><span class="text-red">Медленно</span></td>
        <td><span class="text-red">Очень медленно</span></td>
    </tr>
    <tr>
        <td><strong>Вставка через итератор</strong></td>
        <td>
            <pre class="language-java"><code>it.add(value)</code></pre>
        </td>
        <td><span class="text-red">Медленно</span></td>
        <td><span class="text-green">Очень быстро</span></td>
    </tr>
    <tr>
        <td><strong>Удаление через итератор</strong></td>
        <td>
            <pre class="language-java"><code>it.remove()</code></pre>
        </td>
        <td><span class="text-red">Медленно</span></td>
        <td><span class="text-green">Очень быстро</span></td>
    </tr>
    </tbody>
</table>
<p>Почему же операция получения элемента в <code>LinkedList</code> такая медленная?</p>
<p>Ответ на этот вопрос вы узнаете, если немного ознакомитесь с устройством <code>LinkedList</code></p>
<hr>
<h2>3. Устройство <code>LinkedList</code></h2>
<p><code>LinkedList</code> имеет альтернативное внутреннее устройство, если сравнивать его с <code>ArrayList</code>. Массива для хранения элементов у него внутри нет. Вместо этого он использует структуру данных под названием <span class="term">двусвязный список.</span></p>
<p>Каждый элемент двусвязного списка хранит ссылки на предыдущий и следующий элемент. Это чем-то напоминает очередь, где каждый человек запоминает того, кто стоит перед ним, и того, кто стоит после него.</p>
<p>Вот как выглядит такой список в памяти:</p>
<p><img data-id="d442f51e-462d-4b3d-b27a-06223b6fa87c" src="https://cdn.javarush.com/images/article/d442f51e-462d-4b3d-b27a-06223b6fa87c/original.png" alt="Устройство LinkedList"></p>
<p>По бокам (серый фон) переменные <code>first</code> и <code>last</code>, которые хранят ссылки на объекты типа <code>Node</code>.</p>
<p>В середине вы видите цепочку объектов (именно объектов, не переменных) типа <code>Node</code>. Каждый из них состоит их трех полей:</p>
<ul>
    <li><code>prev</code> — хранит <strong>ссылку</strong> на предыдущий объект типа <code>Node</code> (желтый фон).</li>
    <li><code>value</code> — хранит <strong>значение</strong> &#8211; элемент списка (зеленый фон).</li>
    <li><code>next</code> — хранит <strong>ссылку</strong> на следующий объект типа <code>Node</code> (синий фон)</li>
</ul>
<p>Второй объект (адрес == F24) является следующим (<code>next</code>) для первого и предыдущим (<code>prev</code>) для третьего. Желтое поле третьего объекта содержит ссылку F24 и синее поле первого объекта содержит ссылку F24.</p>
<p>Стрелки с первого и третьего объектов указывают на один и тот же второй объект. Поэтому более правильно было бы нарисовать стрелки так.</p>
<p><img data-id="fddcb230-5458-4e57-a634-7c33ac221276" src="https://cdn.javarush.com/images/article/fddcb230-5458-4e57-a634-7c33ac221276/original.png" alt="Устройство LinkedList 1"></p>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task13.task1313"></div>
<hr>
<h2>4. Вставка элемента в связный список</h2>
<p>Чтобы добавить человека в такую очередь, нужно просто согласие двух соседних людей. Первый из них запоминает новичка как нового: «этот человек за мной», а второй — как нового «этот человек передо мной».</p>
<p>Всего-то и нужно изменить ссылки двух соседних объектов:</p>
<p><img data-id="27db3545-28c0-4b56-995e-7c901fa6cad8" src="https://cdn.javarush.com/images/article/27db3545-28c0-4b56-995e-7c901fa6cad8/original.png" alt="Вставка элемента в связный список"></p>
<p>Мы добавили в наш список новый элемент и поменяли ссылки второго и третьего объектов. Теперь новичок, следующий за вторым и предыдущий для третьего. Ну и у самого объекта-новичка нужно прописать правильные ссылки: предыдущий объект — второй, следующий объект — третий.</p>
<p>Удаление еще проще. Если мы хотим удалить, допустим 100-й объект из списка, нужно просто у 99-го объекта поменять next, чтобы он указывал на 101-й объект, а у 101-го объекта поменять <code>prev</code>, чтобы он указывал на 99. И все.</p>
<p>Вот только получить 100-й объект не так просто.</p>
<hr>
<h2>5. Получение элемента списка</h2>
<p>Чтобы получить 100-й элемент связного списка, нужно:</p>
<p>Получить 1-й объект: на него ссылается переменная <code>first</code> у объекта <code>LinkedList</code>. У 1-го объекта есть ссылка (поле <code>next</code>) на 2-й объект. С ее помощью получаем второй объект. У 2-го объекта есть ссылка на третий, и т.д.</p>
<p>Если нам нужно получить ссылку на 100-й объект, нам нужно последовательно пройтись по всем объектам с 1-го до 100-го. А если нам нужен миллионный элемент списка, нужно последовательно перебрать миллион объектов!</p>
<p>А ведь если эти объекты добавлялись в список в разное время, они находятся в разных частях памяти и вряд ли одновременно попадают в кэш процессора. А это значит, что последовательный перебор элементов связного списка — вещь не просто медленная, а очень медленная.</p>
<p>Такие дела.</p>
<p>Так зачем мы тут учим, как устроен этот медленный <code>LinkedList</code>?</p>
<p>Все дело в том, что на собеседовании вас обязательно спросят, <strong>чем <code>LinkedList</code> отличается от <code>ArrayList</code>.</strong> Обязательно.</p>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task13.task1314"></div>