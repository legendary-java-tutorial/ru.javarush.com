Git
<p>----------------------------------------</p>
Сегодня поговорим о системе контроля версий — Git (читается как ГИТ). Без знания и понимания этого инструмента невозможно быть программистом. Само собой, для постоянной работы не нужно держать в голове все команды и возможности. Нужно знать набор команд, которые помогут понимать все, что происходит...
<p>----------------------------------------</p>
    <h1>1. Подробный гайд по Git для новичков</h1>

    <p>Сегодня поговорим о системе контроля версий — Git (читается как ГИТ). </p>

    <p>Без знания и понимания этого инструмента невозможно быть программистом. Само собой, для постоянной работы не нужно держать в голове все команды и возможности. Нужно знать набор команд, которые помогут понимать все, что происходит.</p>

    <h2>Основы Git</h2>

    <p>Git — это распределенная система контроля версий нашего кода. Зачем она нам? Для команды нужна какая-то система управления работы. Она нужна, чтобы отслеживать изменения, которые происходят со временем. </p>

    <p>То есть шаг за шагом мы видим, какие файлы изменились и как. Особенно это важно, когда анализируешь, что было проделано в рамках одной задачи: это дает возможность возвращаться назад.</p>

    <p>Представим себе ситуацию: был работающий код, всё в нем было хорошо, но мы решили что-то улучшить или подправить. Все ничего, но такое улучшение поломало половину функционала, сделало невозможным работу. И что дальше? Без Гита нужно было бы часами сидеть и вспоминать, как же все было изначально. А так мы просто откатываемся на коммит назад — и все. </p>

    <p>Или что делать, если есть два разработчика, которые делают одновременно свои изменения в коде? Без Гита это выглядит так: они скопировали код из оригинала, сделали что нужно. Наступает момент, и оба хотят добавить свои изменения в главную папку. И что делать в этой ситуации?.. </p>

    <p>Таких проблем не будет вовсе, если пользоваться Гитом. </p>

    <h2>Установка Git</h2>

    <p>Установим гит на компьютер. Для разных OS этот процесс немного отличается.</p>

    <h3>Установка для Windows</h3>

    <p>Как обычно, нужно скачать exe файл и запустить его. Здесь все просто: жмем на <a href="https://git-scm.com/downloads" target="_blank">первую ссылку гугла</a>, устанавливаем и всё. Для работы будем использовать bash консоль, которую они предоставляют.</p>

    <p>Чтобы работать в Windows, нужно запустить Git Bash. Вот как он выглядит в меню пуск:</p>

<img data-max-width="800" data-id="f517966f-a576-4570-91ab-0054c1f2151a" src="https://cdn.javarush.com/images/article/f517966f-a576-4570-91ab-0054c1f2151a/original.png" alt="">

    <p>И это уже консоль, в которой можно работать.</p>

    <p>Чтобы не переходить каждый раз в папку с проектом, чтобы там открыть гит, можно в папке правой кнопкой мыши открыть консоль с нужным нам путем:</p>

<img data-max-width="1024" data-id="d7e783c4-6136-4fc0-b98b-a567cd552f15" src="https://cdn.javarush.com/images/article/d7e783c4-6136-4fc0-b98b-a567cd552f15/original.png" alt="">

    <h3>Установка для Linux</h3>

    <p>Обычно git уже установлен и есть в дистрибутивах линукса, так как это инструмент, первоначально написанный для разработки ядра линукса. Но бывают ситуации, когда его нет. Чтобы проверить это, нужно открыть терминал и прописать: git --version. Если будет вразумительный ответ, ничего устанавливать не нужно.</p>

    <p>Открываем терминал и устанавливаем. Для Ubuntu нужно написать: sudo apt-get install git. И все: теперь в любом терминале можно пользоваться гитом.</p>

    <h3>Установка на macOS</h3>

    <p>Здесь также для начала нужно проверить, есть ли уже гит (смотри выше, как на линуксе).</p>

    <p>Если все же нет, самый простой путь — это <a href="https://sourceforge.net/projects/git-osx-installer/files/" target="_blank">скачать последнюю версию</a>. Если установлен XCode, то гит уже точно будет автоматически установлен.</p>

    <h3>Настройка Git</h3>

    <p>У гита есть настройка пользователя, от которого будет идти работа. Это разумная и необходимая вещь, так как когда создается коммит, гит берет именно эту информацию для поля Author.</p>

    <p>Чтобы настроить имя пользователя и пароль для всех проектов, нужно прописать следующие команды:</p>

<div class="terminal">git config --global user.name ”Ivan Ivanov”
git config --global user.email ivan.ivanov@gmail.com</div>

    <p>Если есть необходимость для конкретного проекта поменять автора (для личного проекта, например), можно убрать --global, и так получится:</p>

<div class="terminal">git config user.name ”Ivan Ivanov”
git config user.email ivan.ivanov@gmail.com</div>

    <h3>Немного теории</h3>

    <p>Чтобы быть в теме, желательно добавить в свое обращение несколько новых слов и действий… А то говорить будет не о чем. Конечно, это некий жаргон и калька с английского, поэтому я буду добавлять значения на английском.</p>

    <p>Какие слова и действия?</p>

    <ul>
        <li>гит репозиторий (git repository);</li>
        <li>коммит (commit);</li>
        <li>ветка (branch);</li>
        <li>смерджить (merge);</li>
        <li>конфликты (conflicts);</li>
        <li>спулить (pull);</li>
        <li>запушить (push);</li>
        <li>как игнорировать какие-то файлы (.gitignore).</li>
    </ul>

    <p>И так далее.</p>

    <h3>Состояния в Git</h3>

    <p>У Гита есть несколько состояний, которые нужно понять и запомнить:</p>

    <ul>
        <li>неотслеживаемое (untracked);</li>
        <li>измененное (modified);</li>
        <li>подготовленное (staged);</li>
        <li>закомиченное (committed).</li>
    </ul>

    <h4>Как это понимать?</h4>

    <p>Это состояния, в которых находятся файлы из нашего кода. То есть, их жизненный путь обычно выглядит так:</p>

    <ul>
        <li>Файл, который создан и не добавлен в репозиторий, будет в состоянии untracked.</li>
        <li>Делаем изменения в файлах, которые уже добавлены в гит репозиторий — находятся в состоянии modified.</li>
        <li>Из тех файлов, которые мы изменили, выбираем только те (или все), которые нужны нам (например, скомпилированные классы нам не нужны), и эти классы с изменениями попадают в состояние staged.</li>
        <li>Из заготовленных файлов из состояния staged создается коммит и переходит уже в гит репозиторий. После этого staged состояние — пустое. А вот modified еще может что-то содержать.</li>
    </ul>

    <p>Выглядит это так:</p>

<img data-max-width="800" data-id="ef35cd8e-590b-4cab-bbb7-77d6223948f1" src="https://cdn.javarush.com/images/article/ef35cd8e-590b-4cab-bbb7-77d6223948f1/original.png" alt="">

    <h3>Что такое коммит</h3>

    <p>Коммит — это основной объект в управлении контроля версий. Он содержит все изменения за время этого коммита. Коммиты связаны между собой как односвязный список. </p>

    <p>А именно: есть первый коммит. Когда создается второй коммит, то он (второй) знает, что идет после первого. И таким образом можно отследить информацию. </p>

    <p>Также у коммита есть еще своя информация, так называемые метаданные:</p>

    <ul>
        <li>уникальный идентификатор коммита, по которому можно его найти;</li>
        <li>имя автора коммита, который создал его;</li>
        <li>дата создания коммита;</li>
        <li>комментарий, который описывает, что было сделано во время этого коммита.</li>
    </ul>

    <p>Вот как это выглядит:</p>

<img data-max-width="512" data-id="d80d3a26-bd59-478c-85fa-9a988575352b" src="https://cdn.javarush.com/images/article/d80d3a26-bd59-478c-85fa-9a988575352b/original.png" alt="">

    <h3>Что такое ветка</h3>

<img data-max-width="512" data-id="80f5b58d-cb22-4fe4-9bb2-81f57d33cf9c" src="https://cdn.javarush.com/images/article/80f5b58d-cb22-4fe4-9bb2-81f57d33cf9c/512.jpeg" alt="">

    <p>Ветка — это указатель какого-то коммита. Так как коммит знает, какой коммит был до него, когда ветка указывает на какой-то коммит, к ней относятся и все те предыдущие. </p>

    <p>Исходя из этого можно сказать, что веток, указывающих на один и тот же коммит, может быть сколько угодно много.</p>

    <p>Работа происходит в ветках, поэтому когда создается новый коммит, ветка переносит свой указатель на более новый коммит.</p>

    <h2>Начало работы с Git</h2>

    <p>Можно работать и только с локальным репозиторием, и с удаленным.</p>

    <p>Для отработки нужных команд можно воспользоваться только локальным репозиторием. Он хранит всю информацию только локально в проекте в папке .git.</p>

    <p>Если говорить об удаленном, то вся информация хранится где-то на удаленном сервере: локально хранится только копия проекта, изменения которой можно запушить (git push) в удаленный репозиторий.</p>

    <p>Здесь и далее будем обсуждать работу с гитом в консоли. Конечно, можно пользоваться какими-то графическими решениями (например, в Intellij IDEA), но сперва нужно разобраться, какие команды происходят и что они значат.</p>

    <h3>Работа с гитом в локальном репозитории</h3>

    <p>Чтобы создать локальный репозиторий, нужно написать:</p>

<div class="terminal">git init</div>

<img data-max-width="800" data-id="218e78b6-d26c-44f8-a655-44e590317a6c" src="https://cdn.javarush.com/images/article/218e78b6-d26c-44f8-a655-44e590317a6c/original.png" alt="">

    <p>После этого будет создана скрытая папка .git в том месте, где находится консоль.</p>

    <p>.git — это папка, которая хранит всю информацию о гит репозитории. Ее удалять не нужно ;)</p>

    <p>Далее, добавляются файлы в этот проект, и их состояние становится Untracked. Чтобы посмотреть, какой статус работы на данный момент, пишем:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="fde62d18-a75d-4342-9f83-0acd4e1d1f1b" src="https://cdn.javarush.com/images/article/fde62d18-a75d-4342-9f83-0acd4e1d1f1b/original.png" alt="">

    <p>Мы находимся в master ветке, и пока мы не перейдем в другую, так все и останется.</p>

    <p>Таким образом видно, какие файлы изменены, но еще не добавлены в состояние staged. Чтобы добавить их в состояние staged, нужно написать git add. Здесь может быть несколько вариантов, например:</p>

    <ul>
        <li>git add -A — добавить все файлы из состояния в staged;</li>
        <li>git add . — добавить все файлы из этой папки и всех внутренних. По сути то же самое, что и предыдущее;</li>
        <li>git add <имя файла> — добавляет только конкретный файл. Здесь можно пользоваться регулярными выражениями, чтобы добавлять по какому-то шаблону. Например, git add *.java: это значит, что нужно добавить только файлы с расширением java.</li>
    </ul>

    <p>Ясно, что первые два варианта простые, а вот с добавлением будет интереснее, поэтому пишем:</p>

<div class="terminal">git add *.txt</div>

    <p>Чтобы проверить статус, используем уже известную нам команду:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="0c82c10c-f970-449c-b1ce-20efab908c0c" src="https://cdn.javarush.com/images/article/0c82c10c-f970-449c-b1ce-20efab908c0c/original.png" alt="">

    <p>Отсюда видно, что регулярное выражение отработало верно, и теперь test_resource.txt находится в staged состоянии.</p>

    <p>И, наконец, последний этап (при локальном репозитории, с удаленным будет еще один ;)) — закоммитить и создать новый коммит:</p>

<div class="terminal">git commit -m “all txt files were added to the project”</div>

<img data-max-width="800" data-id="4d91e463-8948-476a-8c19-366571d09ae6" src="https://cdn.javarush.com/images/article/4d91e463-8948-476a-8c19-366571d09ae6/original.png" alt="">

    <p>Далее есть отличная команда, чтобы посмотреть на историю коммитов в ветке. Воспользуемся ею:</p>

<div class="terminal">git log</div>

<img data-max-width="800" data-id="2233dc68-5cc1-433d-8c23-2f0214e9ad7c" src="https://cdn.javarush.com/images/article/2233dc68-5cc1-433d-8c23-2f0214e9ad7c/original.png" alt="">

    <p>Здесь уже видно, что появился наш первый коммит с текстом, который мы передали. Очень важно понять, что текст, который мы передаем, должен максимально точно определять то, что было проделано за этот коммит. Это в будущем будет помогать множество раз.</p>

    <p>Пытливый читатель, который еще не уснул, может сказать: а что случилось с файлом GitTest.java? Сейчас узнаем, используем для этого:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="2ee337ec-e4ef-4353-90fb-eb637e350112" src="https://cdn.javarush.com/images/article/2ee337ec-e4ef-4353-90fb-eb637e350112/original.png" alt="">

    <p>Как видим, он так и остался в состоянии untracked и ждет своего часа. А может мы вовсе не хотим его добавлять в проект? Бывает и такое. </p>

    <p>Далее, чтобы стало интереснее, попробуем изменить наш текстовый файл test_resource.txt. Добавим туда какой-то текст и проверим состояние:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="62ccd4b1-447d-422d-a28f-47ad5d39c9dd" src="https://cdn.javarush.com/images/article/62ccd4b1-447d-422d-a28f-47ad5d39c9dd/original.png" alt="">

    <p>Здесь хорошо видна разница между двумя состояниями — untracked и modified. </p>

    <p>GitTest.java находится в состоянии untracked, а test_resource.txt находится в modified.</p>

    <p>Теперь, когда уже есть файлы в состоянии modified, мы можем посмотреть на изменения, которые были произведены над ними. Сделать это можно при помощи команды: </p>

<div class="terminal">git diff</div>

<img data-max-width="800" data-id="be25b293-9720-4332-99fe-921a7a285297" src="https://cdn.javarush.com/images/article/be25b293-9720-4332-99fe-921a7a285297/original.png" alt="">

    <p>То есть здесь хорошо видно, что я добавил в наш текстовый файл hello world!</p>

    <p>Добавляем изменения в текстовом файле и коммитим:

<div class="terminal">git add test_resource.txt</div>
<div class="terminal">git commit -m “added hello word! to test_resource.txt”</div>

    <p>Чтобы посмотреть на все коммиты, пишем:</p>

<div class="terminal">git log</div>

<img data-max-width="800" data-id="0e748579-2e48-4be2-bf91-ecfb88150956" src="https://cdn.javarush.com/images/article/0e748579-2e48-4be2-bf91-ecfb88150956/original.png" alt="">

    <p>Как видим, уже есть два коммита.</p>

    <p>Таким же образом добавляем и GitTest.java. Теперь без комментариев, просто команды:</p>

<div class="terminal">git add GitTest.java</div>
<div class="terminal">git commit -m “added GitTest.java”</div>
<div class="terminal">git status</div>

<img data-max-width="800" data-id="e73028fb-3b33-42ef-befe-235a038b692b" src="https://cdn.javarush.com/images/article/e73028fb-3b33-42ef-befe-235a038b692b/original.png" alt="">

    <h3>Работа с .gitignore</h3>

    <p>Ясно, что мы хотим хранить только исходный код и ничего другого в репозитории. А что может быть еще? Как минимум, скомпилированные классы и/или файлы, которые создают среды разработки. </p>

    <p>Чтобы гит их игнорировал, есть специальный файл, который нужно создать. Делаем это: создаем файл в корне проекта с названием .gitignore, и в этом файле каждая строка будет шаблоном для игнорирования.</p>

    <p>В этом примере гит игнор будет выглядеть так:</p>

<div class="terminal">
*.class<br/>
target/<br/>
*.iml<br/>
.idea/<br/>
</div>

    <p>Смотрим теперь:</p>

    <ul>
        <li>первая строка — это игнорирование всех файлов с расширением .class;</li>
        <li>вторая строка — это игнорирование папки target и всего, что она содержит;</li>
        <li>третья строка — это игнорирование всех файлов с расширением .iml;</li>
        <li>четвертая строка — это игнорирование папки .idea.</li>
    </ul>

    <p>Попробуем на примере. Чтобы посмотреть как это работает, добавим скомпилированный класс GitTest.class в проект и посмотрим статус проекта:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="9f5cff1c-f541-4bb9-8cd9-2c5195f71529" src="https://cdn.javarush.com/images/article/9f5cff1c-f541-4bb9-8cd9-2c5195f71529/original.png" alt="">

    <p>Ясно, что мы не хотим как-то случайно (если использовать git add -A) добавить скомпилированный класс в проект. Для этого создаем .gitignore файл и добавляем все, что описывалось ранее:</p>

<img data-max-width="800" data-id="5a78638d-0e90-4ab6-a9f2-1b985902f2a6" src="https://cdn.javarush.com/images/article/5a78638d-0e90-4ab6-a9f2-1b985902f2a6/original.png" alt="">

    <p>Теперь добавим новым коммитом гит игнор в проект:</p>

<div class="terminal">git add .gitignore</div>
<div class="terminal">git commit -m “added .gitignore file”</div>

    <p>И теперь момент истины: у нас есть в untracked состоянии скомпилированный класс GitTest.class, который мы не хотели добавлять в гит репозиторий. </p>

    <p>Вот здесь-то и должен заработать гит игнор:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="b0cf652f-0ac6-4b47-b6de-caaa2d35249d" src="https://cdn.javarush.com/images/article/b0cf652f-0ac6-4b47-b6de-caaa2d35249d/original.png" alt="">

    <p>Все чисто) Гит игнору +1).</p>

    <h3>Работа с ветками</h3>

    <p>Разумеется, работать в одной ветке неудобно одному и невозможно, когда в команде больше одного человека. Для этого существует ветвление.</p>

    <p>Ветка — это просто подвижный указатель на коммиты.</p>

    <p>В этой части рассмотрим работу в разных ветках: как смерджить изменения одной ветки в другую, какие могут возникнуть конфликты и многое другое.</p>

    <p>Чтобы посмотреть список всех веток в репозитории и понять, на какой находишься, нужно написать:</p>

<div class="terminal">git branch -a</div>

<img data-max-width="800" data-id="645fec04-03b2-4a92-b179-47d925cc9307" src="https://cdn.javarush.com/images/article/645fec04-03b2-4a92-b179-47d925cc9307/original.png" alt="">

    <p>Видно, что у нас только одна ветка master, и звездочка перед ней говорит, что мы находимся на ней. К слову, чтобы узнать, на какой ветке мы находимся, можно воспользоваться и проверкой статуса (git status).</p>

    <p>Далее есть несколько вариантов создания веток (может их и больше, я использую эти):</p>

    <ul>
        <li>создать новую ветку на основе той, на которой находимся (99% случаев);</li>
        <li>создать ветку на основе конкретного коммита (1%).</li>
    </ul>

    <h4>Создаем ветку на основе конкретного коммита</h4>

    <p>Опираться будем на уникальный идентификатор коммита. Чтобы найти его, напишем:</p>

<div class="terminal">git log</div>

<img data-max-width="800" data-id="a0633270-4f07-40ad-95bd-9075a74e4c6a" src="https://cdn.javarush.com/images/article/a0633270-4f07-40ad-95bd-9075a74e4c6a/original.png" alt="">

    <p>Выделим коммит с комментарием “added hello world…”. У него уникальный идентификатор — “6c44e53d06228f888f2f454d3cb8c1c976dd73f8”. Мы хотим создать ветку development начиная с этого коммита. Для этого напишем:</p>

<div class="terminal">git checkout -b development 6c44e53d06228f888f2f454d3cb8c1c976dd73f8</div>

    <p>Создается ветка, в которой будут только первые два коммита из ветки master. Чтобы проверить это, мы сперва убедимся, что перешли в другую ветку и посмотрим на количество коммитов ней:</p>

<div class="terminal">git status</div>
<div class="terminal">git log</div>

<img data-max-width="800" data-id="a7d8a049-7854-45ac-b18e-c8c43b881dff" src="https://cdn.javarush.com/images/article/a7d8a049-7854-45ac-b18e-c8c43b881dff/original.png" alt="">

    <p>И правда: получилось, что у нас два коммита. Кстати, интересный момент: в этой ветке еще нет файла .gitignore, поэтому наш скомпилированный файл (GitTest.class) теперь подсвечивается в untracked состоянии.</p>

    <p>Теперь можем провести еще раз ревизию наших веток, написав:</p>

<div class="terminal">git branch -a</div>

<img data-max-width="800" data-id="1ac27563-c3b7-4180-b2a8-8671859fe6c9" src="https://cdn.javarush.com/images/article/1ac27563-c3b7-4180-b2a8-8671859fe6c9/original.png" alt="">

    <p>Видно, что есть две ветки — master и development  — и сейчас стоим на development.</p>

    <h4>Создаем ветку на основе текущей</h4>

    <p>Второй способ создания ветки — создание на основе другой. Создадим ветку на основе master ветки: для этого нужно сперва перейти на нее, а уже следующим шагом — создать новую. Смотрим:</p>

    <ul>
        <li>git checkout master — переходим на ветку master;</li>
        <li>git status — проверяем, точно ли на мастере.</li>
    </ul>

<img data-max-width="800" data-id="968f1ec0-ce0a-4e48-907e-9e90917dc75d" src="https://cdn.javarush.com/images/article/968f1ec0-ce0a-4e48-907e-9e90917dc75d/original.png" alt="">

    <p>Вот здесь видно, что мы перешли на master ветку, здесь уже работает гит игнор, и скомпилированный класс уже не светится как untracked.</p>

    <p>Теперь создаем новую ветку на основе master ветки:</p>

<div class="terminal">git checkout -b feature/update-txt-files</div>

<img data-max-width="800" data-id="c1e06a9a-bccf-49e1-852e-41690dd823c3" src="https://cdn.javarush.com/images/article/c1e06a9a-bccf-49e1-852e-41690dd823c3/original.png" alt="">

    <p>Если есть сомнения, что эта ветка будет не такой же, как и master, можно это легко проверить, написав git log и посмотреть на все коммиты. Там их должно быть четыре.</p>

    <h3>Резолвим конфликты</h3>

    <p>Прежде чем разобраться с тем, что такое конфликт, нужно поговорить о слиянии (смердживании) одной ветки в другую.</p> 

    <p>Вот такой картинкой можно показать процесс, когда одну ветку мерджат в другую:</p>

<img data-max-width="512" data-id="c417cc45-2cfb-40d8-a6bf-6b8bf3ed9563" src="https://cdn.javarush.com/images/article/c417cc45-2cfb-40d8-a6bf-6b8bf3ed9563/original.png" alt="">

    <p>То есть, есть главная ветка. От нее в какой-то момент создают второстепенную, в которой происходят изменения. Как только работа сделана, нужно слить одну ветку в другую.</p>

    <p>На нашем примере, мы создали ветку feature/update-txt-files. Как написано в имени ветки — обновим текст.</p>

<img data-max-width="800" data-id="dee60445-8d14-4a27-b588-5340924819cc" src="https://cdn.javarush.com/images/article/dee60445-8d14-4a27-b588-5340924819cc/original.png" alt="">

    <p>Теперь нужно создать под это дело новый коммит:</p>

<div class="terminal">git add *.txt</div>
<div class="terminal">git commit -m “updated txt files”</div>
<div class="terminal">git log</div>

<img data-max-width="800" data-id="7c3cd527-3183-4ece-9e6b-ed0ee2aa4d16" src="https://cdn.javarush.com/images/article/7c3cd527-3183-4ece-9e6b-ed0ee2aa4d16/original.png" alt="">

    <p>Теперь, если мы хотим смерджить feature/update-txt-files ветку в master, нужно перейти в master и написать git merge feature/update-txt-files:</p>

<div class="terminal">git checkout master</div>
<div class="terminal">git merge feature/update-txt-files</div>
<div class="terminal">git log</div>

<img data-max-width="800" data-id="fc3b02c2-01ed-4ac2-843a-3448ed916e1c" src="https://cdn.javarush.com/images/article/fc3b02c2-01ed-4ac2-843a-3448ed916e1c/original.png" alt="">

    <p>Как результат — теперь и в мастер ветке есть коммит, который был добавлен в feature/update-txt-files.</p>

    <p>Эта функциональность добавлена, поэтому можно удалить фиче (feature) ветку. Для этого напишем:</p>

<div class="terminal">git branch -D feature/update-txt-files</div>

    <p>Усложняем ситуацию: теперь допустим, что опять нужно изменить txt файл. Но теперь еще и в мастере этот файл будет изменен также. То есть он будет параллельно изменяться, и гит не сможет понять что нужно делать в ситуации, когда мы захотим смерджить в master ветку новый код.</p>

    <p>Создаем новую ветку на основе master, делаем изменения в text_resource.txt и создаем коммит под это дело:</p>

<div class="terminal">git checkout -b feature/add-header</div>
<p>... делаем изменения в файле</p>

<img data-max-width="800" data-id="84ef38d3-8851-4f71-ba88-9ab69d3400bc" src="https://cdn.javarush.com/images/article/84ef38d3-8851-4f71-ba88-9ab69d3400bc/original.png" alt="">

<div class="terminal">git add *.txt</div>
<div class="terminal">git commit -m “added header to txt”</div>

<img data-max-width="800" data-id="d7b1f440-c876-43d2-9af0-4768dd0a293d" src="https://cdn.javarush.com/images/article/d7b1f440-c876-43d2-9af0-4768dd0a293d/original.png" alt="">

    <p>Переходим на master ветку и также обновляем этот текстовый файл в той же строке, что и фиче ветка:</p>

<div class="terminal">git checkout master</div>
<p>… обновили test_resource.txt</p>

<img data-max-width="800" data-id="4ef49b9b-3cde-4cd3-b894-b3c475bb1277" src="https://cdn.javarush.com/images/article/4ef49b9b-3cde-4cd3-b894-b3c475bb1277/original.png" alt="">

<div class="terminal">git add test_resource.txt</div>
<div class="terminal">git commit -m “added master header to txt”</div>

    <p>И теперь самый интересный момент: нужно смерджить изменения из feature/add-header ветки в master. Мы находимся в мастер ветке, поэтому нужно только написать:</p>

<div class="terminal">git merge feature/add-header</div>

    <p>Но мы получим результат с конфликтом в файле test_resource.txt:</p>

<img data-max-width="800" data-id="50a26f73-9286-4d33-9a7b-faabd35fa32b" src="https://cdn.javarush.com/images/article/50a26f73-9286-4d33-9a7b-faabd35fa32b/original.png" alt="">

    <p>И здесь мы можем видеть, что гит не смог самостоятельно решить, как смерджить этот код и говорит, что нужно вначале разрезолвить конфликт, а уже потом сделать коммит.</p>

    <p>Ок, открываем в текстовом редакторе файл, в котором конфликт, и видим:</p>

<img data-max-width="800" data-id="9b5a2b9f-3ce7-42fd-8fa1-a29f429460c8" src="https://cdn.javarush.com/images/article/9b5a2b9f-3ce7-42fd-8fa1-a29f429460c8/original.png" alt="">

    <p>Чтобы понять, что здесь сделал гит, нужно вспомнить, что мы где писали, и сравнить:</p>

    <ol>
        <li>Между “<<<<<<< HEAD” и “=======” находятся изменения мастер, которые были в этой строке в мастер ветке.</li>
        <li>Между “=======” и “>>>>>>> feature/add-header” находятся изменения, которые были в feature/add-header ветке.</li>
    </ol>

    <p>Таким образом гит показывает, что в этом месте он не смог понять, как слить воедино этот файл, разделил этот участок на две части из разных веток и предложил решить нам самим.</p>

    <p>Хорошо, твердою волей решаю убрать все, оставить только слово header:</p>

<img data-max-width="800" data-id="e4e6acfb-1b7f-4f48-a445-5235340944ae" src="https://cdn.javarush.com/images/article/e4e6acfb-1b7f-4f48-a445-5235340944ae/original.png" alt="">

    <p>Посмотрим на статус изменений, описание будет несколько другим. Будет не modified состояние, а Unmerged. Так что смело можно было добавить пятое состояние… Но я думаю, что это излишне, посмотрим:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="c13fa252-9322-4aaf-abcb-ce0c6198d3cf" src="https://cdn.javarush.com/images/article/c13fa252-9322-4aaf-abcb-ce0c6198d3cf/original.png" alt="">

    <p>Убедились, что это другой случай, необычный. Продолжаем:</p>

<div class="terminal">git add *.txt</div>

<img data-max-width="800" data-id="e0674e1a-9d45-4deb-bc3d-f381b7dea5cf" src="https://cdn.javarush.com/images/article/e0674e1a-9d45-4deb-bc3d-f381b7dea5cf/original.png" alt="">

    <p>В описании можно заметить, что предлагают написать только git commit. Слушаем и пишем:</p>

<div class="terminal">git commit</div>

<img data-max-width="800" data-id="337a32e7-777e-47e2-84c0-c87ff43ee142" src="https://cdn.javarush.com/images/article/337a32e7-777e-47e2-84c0-c87ff43ee142/original.png" alt="">

    <p>И все: таким образом мы сделали это — разрезолвили конфликт в консоли.</p>

    <p>Конечно, в средах разработки можно это сделать немного проще, например, в Intellij IDEA все настроено так хорошо, что можно выполнять все необходимые действия в ней. Но среда разработки делает много чего “под капотом”, и мы зачастую не понимаем, что именно там произошло. А когда нет понимания, тогда могут возникнуть и проблемы.</p>

    <h2>Работа с удаленными репозиториями</h2>

    <p>Последний шаг — разобраться еще с несколькими командами, которые нужны для работы с удаленным репозиторием. </p>

    <p>Как я уже говорил, удаленный репозиторий — это какое-то место, где хранится репозиторий и откуда можно его клонировать.</p>

    <p>Какие бывают удаленные репозитории? Примеров тьма:</p>

    <ul>
        <li>GitHub — это крупнейшее хранилище для репозиториев и совместной разработки.</li>
        <li>GitLab — веб-инструмент жизненного цикла DevOps с открытым исходным кодом, представляющий систему управления репозиториями кода для Git с собственной вики, системой отслеживания ошибок, CI/CD пайплайн и другими функциями.</li>
        <li>BitBucket — веб-сервис для хостинга проектов и их совместной разработки, основанный на системе контроля версий Mercurial и Git. Одно время имел большое преимущество перед GitHub в том, что у него были бесплатные приватные репозитории. В прошлом году GitHub также открыл эту возможность для всех бесплатно.</li>
        <li>И так далее…</li>
    </ul>

    <p>Первое, что нужно сделать в работе с удаленным репозиторием — клонировать проект себе в локальный. </p>

    <p>Для этого экспортируем проект, который мы делали локально. Теперь каждый его может себе клонировать, написав:</p>

<div class="terminal">git clone https://github.com/romankh3/git-demo</div>

    <p>Теперь локально есть полная копия проекта. Чтобы быть уверенным, что локально находится последняя копия проекта, нужно, как говорится, спулить данные, написав:</p>

<div class="terminal">git pull</div>

<img data-max-width="800" data-id="085baafe-99f0-45b9-8eb4-39c78e7a6f7e" src="https://cdn.javarush.com/images/article/085baafe-99f0-45b9-8eb4-39c78e7a6f7e/original.png" alt="">

    <p>В нашем случае сейчас ничего не изменилось удаленно, поэтому и ответ: Already up to date.</p>

    <p>Но если мы внесем какие-то изменения в удаленном репозитории, локальный обновится после того, как мы их спулим.</p>

    <p>И, наконец, последняя команда — запушить данные на удаленный репозиторий. Когда мы локально что-то сделали и хотим это передать на удаленный репозиторий, нужно сперва создать новый коммит локально. Для этого добавим в наш текстовый файл еще что-нибудь:</p>

<img data-max-width="800" data-id="94a8c820-aee8-4e79-94b8-2a9a54391d42" src="https://cdn.javarush.com/images/article/94a8c820-aee8-4e79-94b8-2a9a54391d42/original.png" alt="">

    <p>Теперь уже обыденная для нас вещь — создаем коммит под это дело:</p>

<div class="terminal">git add test_resource.txt</div>
<div class="terminal">git commit -m “prepated txt for pushing”</div>

    <p>И теперь команда, чтобы отправить это на удаленный репозиторий:</p>

<div class="terminal">git push</div>

    <p>Вот и все! </p>

    <table>
        <tbody>
            <tr>
                <th>Полезные ссылки</th>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li>Официальная <a href="https://bit.ly/3eUqoaa" target="_blank">документация на Git, есть на русском</a>. Рекомендуем как справочное пособие.</li>
                        <li><a href="https://tproger.ru/translations/difference-between-git-and-github/" target="_blank">Git и GitHub: что это такое и в чем разница</a></li>
                        <li>Хабр: <a href="https://habr.com/ru/post/342116/" target="_blank">Git на практике</a></li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <h1>2. Как работать с Git в IntelliJ IDEA</h1>

    <p>В этой части ты узнаешь, как работать с Git в Intellij IDEA.</p>

    <h2>Необходимые вводные:</h2>

    <ol>
        <li>Прочесть, повторить и понять предыдущую часть. Это поможет быть уверенным, что все уже настроено и готово к работе.</li>
        <li>Установить Intellij IDEA. С этим все должно быть в порядке :)</li>
        <li>Выделить час времени для полного усвоения.</li>
    </ol>

    <p>Для работы возьмем <a href="https://github.com/romankh3/git-demo" target="_blank">демо-проект</a>, который использовался в лекции про Git.</p>

    <h2>Клонируем проект локально</h2>

    <p>Здесь есть два варианта.</p>

    <ol>
        <li>Если есть уже гитхаб аккаунт и хочется что-то потом запушить, лучше сделать форк проекта к себе и клонировать свою копию. Как сделать форк — можешь почитать в этой статье, в главе <a href="https://javarush.com/groups/posts/2693-komandnaja-rabota-bez-putanicih-razbiraem-strategii-vetvlenija-v-gite" target="_blank">пример the forking workflow</a>.</li>
        <li>Клонировать с репозитория и проделать все локально без возможности все это запушить на сервер. </li>
    </ol>

    <p>Чтобы клонировать проект с гитхаба, нужно скопировать ссылку на проект и передать ее в IntelliJ IDEA:</p>

    <ol>
        <li><p>Копируем адрес проекта:</p>
<img data-max-width="1024" data-id="19b7469c-f5c5-461f-8332-7e9659259de3" src="https://cdn.javarush.com/images/article/19b7469c-f5c5-461f-8332-7e9659259de3/original.png" alt=""></li>
        <li><p>Открываем Intellij IDEA и выбираем Get from Version Control:</p>
<img data-max-width="800" data-id="8cfb51b2-9087-4882-a736-4d3a347822fe" src="https://cdn.javarush.com/images/article/8cfb51b2-9087-4882-a736-4d3a347822fe/original.png" alt=""></li>
        <li><p>Копируем вставляем адрес на проект:</p>
<img data-max-width="800" data-id="9ba60369-5c93-4600-9538-e7e238241d80" src="https://cdn.javarush.com/images/article/9ba60369-5c93-4600-9538-e7e238241d80/original.png" alt=""></li>
        <li><p>Вам предложат создать Intellij IDEA проект. Принимаем предложение:</p>
<img data-max-width="800" data-id="9808f1ed-b67a-4254-b53c-467defa28a05" src="https://cdn.javarush.com/images/article/9808f1ed-b67a-4254-b53c-467defa28a05/original.png" alt=""></li>
        <li><p>Так как нет системы сборки, выбираем Create project from existing sources:</p>
<img data-max-width="800" data-id="8bca15d7-aa1c-4f79-b2ab-4a8460604e11" src="https://cdn.javarush.com/images/article/8bca15d7-aa1c-4f79-b2ab-4a8460604e11/original.png" alt=""></li>
        <li><p>Далее будет такая картина маслом:</p>
<img data-max-width="1024" data-id="79fbb8fb-653f-4741-8e45-517137bda74a" src="https://cdn.javarush.com/images/article/79fbb8fb-653f-4741-8e45-517137bda74a/original.jpeg" alt=""></li>
    </ol>

    <p>С клонированием разобрались, теперь-то можно и оглянуться по сторонам.</p>

    <h2>Первый взгляд на Intellij IDEA как на гит UI</h2>

    <p>Присмотрись еще раз внимательно к клонированному проекту: там можно получить много информации о системе контроля версий.</p>

    <p>Первое — это Version Control панель в нижнем левом углу. В ней можно найти все локальные изменения и получить список коммитов (аналог git log). </p>

    <p>Перейдем в лекцию Log. Присутствует некая визуальная составляющая, которая помогает понять, как именно шел процесс разработки. Например, видно, что создавалась новая ветка с коммитом added header to txt, который после влился в мастер-ветку. Если нажать на коммит, в правом углу можно увидеть всю информацию о коммите: всех изменениях и его метаданных.</p>

<img data-max-width="1024" data-id="79c6c4f7-dc94-4857-a494-b07fcad66ae1" src="https://cdn.javarush.com/images/article/79c6c4f7-dc94-4857-a494-b07fcad66ae1/original.png" alt="">

    <p>Более того, можно посмотреть, какие были сделаны изменения. Тем более что там же был разрезолвлен конфликт. Это IDEA тоже отлично показывает. </p>

    <p>Если нажать два раза на файл, который был изменен за этот коммит, увидим, как резолвили кофликт:</p>

<img data-max-width="1024" data-id="f75644b6-260c-471c-9435-9536ac860998" src="https://cdn.javarush.com/images/article/f75644b6-260c-471c-9435-9536ac860998/original.png" alt="">

    <p>Заметно, что справа и слева были два варианта одного файла, который нужно было смержить в один. А посредине — результат, который в итоге получился. </p>

    <p>Когда в проекте множество веток, коммитов и пользователей, которые работают в проекте, необходимо поискать отдельно по ветке (branch), пользователю (user) и дате (date):</p>

<img data-max-width="1024" data-id="432c834b-1cb9-4abd-be7a-2bf16a954f84" src="https://cdn.javarush.com/images/article/432c834b-1cb9-4abd-be7a-2bf16a954f84/original.png" alt="">

    <p>Также перед началом работы стоит объяснить, как понять, в какой ветке мы находимся. </p>

    <p>В правом нижнем углу есть кнопка Git: master, где после Git: показано, на какой ветке находится сейчас проект. Если нажать на кнопку, можно проделать множество полезных вещей: перейти на другую ветку, создать новую, переименовать существующую, и так далее.</p>

<img data-max-width="1024" data-id="ec71d9e1-9094-4575-918b-f9c033c5b742" src="https://cdn.javarush.com/images/article/ec71d9e1-9094-4575-918b-f9c033c5b742/original.png" alt="">

    <h2>Работа с репозиторием</h2>

    <h3>Полезные горячие клавиши</h3>

    <p>Чтобы дальше работать, нужно запомнить несколько очень полезных горячих клавиш:</p>

    <ol>
        <li><span class="text-bold">ctrl + t</span> — получить последние изменения с удаленного репозитория (git pull).</li>
        <li><span class="text-bold">ctrl + k</span> — сделать коммит/посмотреть все изменения, которые есть на данный момент. Сюда входят и untracked, и modified файлы (git commit).</li>
        <li><span class="text-bold">ctrl + shift + k</span> — это команда для создания пуша изменений на удаленный репозиторий. Все коммиты, которые были созданы локально и еще не находятся на удаленном, будут предложены для пуша (git push).</li>
        <li><span class="text-bold">alt + ctrl + z</span> — откатить в конкретном файле изменения до состояния последнего созданного коммита в локальном репозитории. Если в левом верхнем углу выделить весь проект, то можно будет откатить изменения всех файлов.</li>
    </ol>

    <h2>Что мы хотим?</h2>

    <p>Нам для работы нужно освоить базовый сценарий, который используется везде.</p>

    <p>Стоит задача реализовать новую функциональность в отдельной ветке и запушить ее на удаленный репозиторий (дальше нужно создать еще пул-реквест на главную ветку, но это выходит за рамки нашей лекции).</p>

    <p>Что для этого нужно сделать?</p>

    <ol>
        <li><p>Получить все изменения на текущий момент в основной ветке (master, например).</p></li>
        <li><p>На базе этой основной создать отдельную для своей работы.</p></li>
        <li><p>Реализовать новую функциональность.</p></li>
        <li><p>Перейти на основную ветку и проверить, не было ли новых изменений за время, пока работали. Если не было, то все хорошо, а если было, то делаем следующее: переходим на работающую ветку и делаем <a href="https://habr.com/ru/post/161009/" target="_blank">ребейз</a> изменений из основной ветки в нашу. Если все прошло успешно, то отлично. Но вполне могут быть и конфликты. И их как раз можно будет заранее решить, не тратя время на удаленном репозитории.</p>
    <p><em>Казалось бы, зачем это делать? Это правило хорошего тона, которое предотвращает возникновение конфликтов уже после пуша своей ветки на локальный репозиторий (есть, конечно, вероятность,что все равно они будут, но она становится <span class="text-bold">значительно</span> меньше)</em>.</p></li>
        <li><p>Запушить свои изменения на удаленный репозиторий.</p></li>
    </ol>

    <h3>Как получить изменения с удаленного сервера</h3>
    <p>Мы добавили описание в README новым коммитом и хотим эти изменения получить. Предлагается выбор между мерджем и ребейзом в случае, если были сделаны изменения и в локальном репозитории и на удаленном. Выбираем мерж.</p>

    <p>Вводим <span class="text-bold">ctrl + t</span>:</p>

<img data-max-width="1024" data-id="5c72afca-c605-40be-baec-b044d9555833" src="https://cdn.javarush.com/images/article/5c72afca-c605-40be-baec-b044d9555833/original.png" alt="">

    <p>В результате, видно как изменился README, т.е. изменения из удаленного репозитория подтянулись, и в правом нижнем углу можно посмотреть все детали тех изменений, которые пришли с сервера.</p>

<img data-max-width="1024" data-id="192f52f3-7d69-4d38-acfc-4e51b8959327" src="https://cdn.javarush.com/images/article/192f52f3-7d69-4d38-acfc-4e51b8959327/original.png" alt="">

    <h3>Создать новую ветку на основе master</h3>

    <p>Здесь все просто. </p>

    <p>Переходим в правый нижний угол и нажимаем на <span class="text-bold">Git: master</span>, выбираем <span class="text-bold">+ New Branch</span>.</p>

<img data-max-width="512" data-id="43cbb574-d986-4835-a553-4bf11e789b03" src="https://cdn.javarush.com/images/article/43cbb574-d986-4835-a553-4bf11e789b03/original.png" alt="">

Оставляем галочку <span class="text-bold">Checkout branch</span> и пишем имя новой ветки. В нашем случае это будет <span class="text-bold">readme-improver</span>.

<img data-max-width="512" data-id="52260cdd-fd57-41b5-b570-3fce47c90bd8" src="https://cdn.javarush.com/images/article/52260cdd-fd57-41b5-b570-3fce47c90bd8/original.png" alt="">

    <p>После этого <span class="text-bold">Git: master</span> сменится на <span class="text-bold">Git: readme-improver</span>.</p>

    <h3>Имитируем параллельную работу</h3>

    <p>Чтобы конфликты появились, их кто-то должен создать.</p>

    <p>Отредактируем через браузер README новым коммитом и таким образом сымитируем параллельную работу. Мол, кто-то во время работы сделал изменения в том же файле, что и мы, что приведет к конфликту. Удалим слово “полностью” из 10 строки.</p>

    <h2>Реализовать свою функциональность</h2>

    <p>Задача стоит в том, чтобы поменять README и добавить описание к новой статье, то есть то, что работа в гите идет через Intellij IDEA. Добавляем это:</p>

<img data-max-width="1024" data-id="666f0816-af10-4d33-8f46-43eea4cdae82" src="https://cdn.javarush.com/images/article/666f0816-af10-4d33-8f46-43eea4cdae82/original.png" alt="">

    <p>Изменения выполнены, теперь можно создать коммит. Нажимаем горячую клавишу <span class="text-bold">ctrl + k</span>, получим:</p>

<img data-max-width="800" data-id="e74703dc-9dcb-4329-9da4-7019de72d7d3" src="https://cdn.javarush.com/images/article/e74703dc-9dcb-4329-9da4-7019de72d7d3/original.png" alt="">

    <p>Прежде чем создать коммит, нужно внимательно посмотреть на то, что предлагается в этом окне. </p>

    <p>В секции <span class="text-bold">Commit Message</span> пишем текст коммита, и чтобы он создался, нужно нажать кнопку <span class="text-bold">Commit</span>. </p>

    <p>Пишем, что README изменился и создаем коммит. В результате в левом нижнем углу всплывает оповещение, в котором будет имя коммита:</p>

<img data-max-width="512" data-id="22b731d0-d034-4389-9402-dc56c0c7589d" src="https://cdn.javarush.com/images/article/22b731d0-d034-4389-9402-dc56c0c7589d/original.png" alt="">

    <h3>Проверить, не изменилась ли основная ветка</h3>

    <p>Выполнили задачу, она работает, тесты написали, все хорошо. Но прежде чем пушить на сервер, нужно таки проверить, не было ли изменений в основной ветке за это время. Как это могло произойти? Очень просто: кому-то дали задачу после вас, и этот кто-то сделал ее быстрее вас.</p>

   <p>Поэтому переходим на master ветку. Для этого нужно в правом нижнем углу сделать то, что показано ниже на рисунке:</p>

<img data-max-width="512" data-id="7e3b5947-e12a-48e0-a976-295568cd7a42" src="https://cdn.javarush.com/images/article/7e3b5947-e12a-48e0-a976-295568cd7a42/original.png" alt="">

    <p>В master ветке нажимаем <span class="text-bold">ctrl + t</span>, чтобы получить ее последние изменения с удаленного сервера. Если посмотреть, какие были изменения, легко можно заметить, что произошло:</p>

<img data-max-width="1024" data-id="9f366692-f62c-4a48-8fe6-553d8c7f5d61" src="https://cdn.javarush.com/images/article/9f366692-f62c-4a48-8fe6-553d8c7f5d61/original.png" alt="">

    <p>Как видим, было удалено слово “полностью”. Быть может, это был кто-то из маркетинга и решил, что так нельзя писать и дал разработчикам задачу обновить это.</p>

    <p>Теперь у нас локально последняя версия master ветки. Переходим обратно на <span class="text-bold">readme-improver</span>.</p>

    <p>Теперь нужно заребейзить изменения из мастер ветки в нашу. Делаем:

<img data-max-width="512" data-id="50aa8901-8646-471e-86ca-a0db9959cbcf" src="https://cdn.javarush.com/images/article/50aa8901-8646-471e-86ca-a0db9959cbcf/original.png" alt="">

    <p>Если вы все правильно выполняли со мной, в результате должен показаться конфликт в README файле:</p>

<img data-max-width="800" data-id="f4478512-2490-4d36-aef8-118117ac0ee1" src="https://cdn.javarush.com/images/article/f4478512-2490-4d36-aef8-118117ac0ee1/original.png" alt="">

    <p>Здесь также много информации, которую нужно бы понять и впитать. Здесь показан список (в нашем случае из одного элемента) файлов, в которых есть конфликты. Мы можем выбрать три опции:</p>

    <ol>
        <li>accept yours — принять только изменения из readme-improver.</li>
        <li>accept theirs — принять только изменения из master.</li>
        <li>merge — самому выбрать, что нужно оставить, а что убрать.</li>
    </ol>

<p>Непонятно, что там изменилось, и если уж изменения находятся в мастере, значит они нужны там, и просто принять наши изменения нельзя, поэтому выбираем <span class="text-bold">merge</span>:

<img data-max-width="1080" data-id="2b109118-e031-4fe9-ac0a-137ce9f81251" src="https://cdn.javarush.com/images/article/2b109118-e031-4fe9-ac0a-137ce9f81251/original.png" alt="">

    <p>Здесь видно, что есть три части:</p>

    <ol>
        <li>Это изменения из readme-improver.</li>
        <li>Результат. Пока что там так, как было до изменений.</li>
        <li>Изменения из master ветки.</li>
    </ol>

    <p>Нам нужно таким образом собрать результат, чтобы он всех удовлетворил. Поэтому изучили, что сделали ДО нас, поняли, что просто убрали слово “полностью”. Ну окей, без проблем. Значит и мы его уберем в результате и добавим наши изменения. Как только поправим результат, можно нажать <span class="text-bold">Apply</span>. </p>

    <p>После этого всплывет оповещение, что ребейз прошел успешно:</p>

<img data-max-width="512" data-id="b1d89a4f-b0c9-4124-934e-c99b6b9b8bfb" src="https://cdn.javarush.com/images/article/b1d89a4f-b0c9-4124-934e-c99b6b9b8bfb/original.png" alt="">

    <p>Вот так мы зарезолвили свой первый конфликт через Intellij IDEA.</p>

    <h3>Запушить изменения на удаленный сервер</h3>

    <p>Следующий шаг — запушить изменения на удаленный сервер и создавать пул-реквест. Для этого просто нажимаем <span class="text-bold">ctrl + shift + k</span>, после чего получим:</p>

<img data-max-width="800" data-id="a50a5ffe-b7e9-4185-ab97-c72792f29a0d" src="https://cdn.javarush.com/images/article/a50a5ffe-b7e9-4185-ab97-c72792f29a0d/original.png" alt="">

    <p>Слева будет список коммитов, которые не запушены на удаленный репозиторий, а справа будут все файлы, которые изменены. И все: нажимаем <span class="text-bold">Push</span>, и будет вам счастье :)</p>

    <p>При успешном пуше будет вот такое уведомление в нижнем правом углу:</p>

<img data-max-width="512" data-id="b0845cd5-3492-4d72-bf67-6b76e074e9ac" src="https://cdn.javarush.com/images/article/b0845cd5-3492-4d72-bf67-6b76e074e9ac/original.png" alt="">

    <h2>Бонус: создание пулл-реквеста</h2>

    <p>Переходим на гитхаб репозиторий и видим, что гитхаб уже знает, что нам предложить:</p>

<img data-max-width="1024" data-id="a5000a13-d403-4cb9-8ebf-d0d480ee5a73" src="https://cdn.javarush.com/images/article/a5000a13-d403-4cb9-8ebf-d0d480ee5a73/original.jpeg" alt="">

    <p>Нажимаем на <span class="text-bold">Compare & pull request</span>, после чего нажимаем <span class="text-bold">Create pull request</span>. Из-за того, что мы заблаговременно порешали конфликты, теперь при создании пул-реквеста, его сразу можно мержить:

<img data-max-width="1024" data-id="f21b12a2-3415-4b8f-afcc-ab584e70116a" src="https://cdn.javarush.com/images/article/f21b12a2-3415-4b8f-afcc-ab584e70116a/original.jpeg" alt="">

    <p>Вот и все!</p>
