Типы-обертки детально
<p>----------------------------------------</p>
Класс Integer Integer хорош еще и тем – что это класс, а значит у него могут быть поля и методы. И, конечно, они у него есть. Даже много – несколько десятков. Поэтому мы рассмотрим самые основные из них. У класса Integer есть два поля, которые содержат максимальное и минимальное значение типа in
<p>----------------------------------------</p>
<div class="lesson-carousel lesson-carousel--comics lesson-carousel--desktop">
    <div class="lesson-carousel__list">
        <div class="lesson-carousel__item">
            <img data-id="3271132f-5752-4a05-88d5-17677be5c9bf" src="https://cdn.javarush.com/images/article/3271132f-5752-4a05-88d5-17677be5c9bf/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="9a95af90-eab2-4c24-ae3b-813fa6edd257" src="https://cdn.javarush.com/images/article/9a95af90-eab2-4c24-ae3b-813fa6edd257/original.png" alt="">
        </div>
    </div>
</div>
<div class="lesson-carousel lesson-carousel--comics lesson-carousel--mobile">
    <div class="lesson-carousel__list">
        <div class="lesson-carousel__item">
            <img data-id="1e569f52-11cc-4e0e-aab5-941d6223b928" src="https://cdn.javarush.com/images/article/1e569f52-11cc-4e0e-aab5-941d6223b928/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="3a15c0e2-c5d8-4205-ab91-6c17ca658ae8" src="https://cdn.javarush.com/images/article/3a15c0e2-c5d8-4205-ab91-6c17ca658ae8/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="35cb7637-a499-4dcd-9562-7ff497079e5f" src="https://cdn.javarush.com/images/article/35cb7637-a499-4dcd-9562-7ff497079e5f/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="f73d4ac6-ef44-491b-9ea1-65a0d65055d7" src="https://cdn.javarush.com/images/article/f73d4ac6-ef44-491b-9ea1-65a0d65055d7/original.png" alt="">
        </div>
    </div>
</div>
<hr>
<h2>1. Класс <code>Integer</code></h2>
<p><code>Integer</code> хорош еще и тем, что это класс, а значит, у него могут быть поля и методы. И, конечно, они у него есть. Даже много — несколько десятков. Поэтому мы рассмотрим самые основные из них.</p>
<p>У класса <code>Integer</code> есть два поля, которые содержат максимальное и минимальное значение типа <code>int</code>:</p>
<table>
    <tbody>
    <tr>
        <th>Поле</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
            <pre><code>Integer.MAX_VALUE</code></pre>
        </td>
        <td>Максимальное значение типа <code>int</code></td>
    </tr>
    <tr>
        <td>
            <pre><code>Integer.MIN_VALUE</code></pre>
        </td>
        <td>Минимальное значение типа <code>int</code></td>
    </tr>
    </tbody>
</table>
<p>Иногда хочется присвоить переменной самое маленькое или самое большое значение типа <code>int</code>. Чтобы не загромождать код непонятными константами, можно очень красиво написать:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>int <span class="text-user">min</span> = <span class="text-neon">Integer</span>.<span class="text-orange">MIN_VALUE</span>;</code></pre>
        </td>
        <td>
            <pre><code>min будет равняться 0x80000000</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p>Также у класса <code>Integer</code> есть несколько интересных методов, вот они:</p>
<table>
    <tbody>
    <tr>
        <th>Методы</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>String <span class="text-neon">Integer</span>.<span class="text-red">toHexString</span>(int)</code></pre>
        </td>
        <td>Возвращает строку — шестнадцатеричное представление числа</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>String <span class="text-neon">Integer</span>.<span class="text-red">toBinaryString</span>(int)</code></pre>
        </td>
        <td>Возвращает строку — двоичное представление числа</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>String <span class="text-neon">Integer</span>.<span class="text-red">toOctalString</span>(int)</code></pre>
        </td>
        <td>Возвращает строку — восьмеричное представление числа</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Integer <span class="text-neon">Integer</span>.<span class="text-red">valueOf</span>(int i)</code></pre>
        </td>
        <td>Оборачивает переданный <code>int</code> в <code>Integer</code></td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Integer <span class="text-neon">Integer</span>.<span class="text-red">parseInt</span>(String)</code></pre>
        </td>
        <td>Возвращает число, полученное из строки</td>
    </tr>
    </tbody>
</table>
<p>Раньше вы уже сталкивались со статическим методом <code>Integer.parseInt()</code>. Напомним, как он работает:</p>
<div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>int <span class="text-user">имя</span> = <span class="text-neon">Integer</span>.<span class="text-red">parseInt</span>(<span class="text-green">строка</span>);</code></pre>
</div>
<p>Если в метод <code>parseInt()</code> передать строку, содержащую число (только цифры), он распарсит эту строку и вернет число, которое в ней содержится.</p>
<p>Остальные методы тоже полезны. Например, некоторые из них могут преобразовывать переданное число в строку в двоичном, восьмеричном или шестнадцатеричном виде.</p>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task12.task1204"></div>
<hr>
<h2>2. Класс <code>Double</code></h2>
<p>Класс <code>Double</code>, в общем-то, аналогичен классу <code>Integer</code>, только является оберткой не для типа <code>int</code>, а для типа <code>double</code>. У него тоже есть интересные нам поля и методы, рассмотрим некоторые из них:</p>
<p>Интересных полей у класса <code>Double</code> шесть:</p>
<table>
    <tbody>
    <tr>
        <th>Поле</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>double <span class="text-neon">Double</span>.NEGATIVE_INFINITY</code></pre>
        </td>
        <td>Минус бесконечность</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>double <span class="text-neon">Double</span>.POSITIVE_INFINITY</code></pre>
        </td>
        <td>Плюс бесконечность</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>int <span class="text-neon">Double</span>.MIN_EXPONENT</code></pre>
        </td>
        <td>Минимальное значение экспоненты (2<sup>x</sup>)</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>int <span class="text-neon">Double</span>.MAX_EXPONENT</code></pre>
        </td>
        <td>Максимальное значение экспоненты (2<sup>x</sup>)</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>double <span class="text-neon">Double</span>.MIN_VALUE</code></pre>
        </td>
        <td>Минимальное значение типа <code>double</code></td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>double <span class="text-neon">Double</span>.MAX_VALUE</code></pre>
        </td>
        <td>Максимальное значение типа <code>double</code></td>
    </tr>
    </tbody>
</table>
<p><strong>Бесконечность</strong></p>
<p>Если вы разделите <code>-1.0</code> на <code>0.0</code>, получите отрицательную бесконечность, если <code>1.0</code> на <code>0.0</code> — положительную бесконечность. Тип <code>double</code> может не только делить на ноль, но и хранить такие значения.</p>
<p><strong>Экспонента числа <code>double</code></strong></p>
<p>С экспонентой тоже все просто. Число double внутри состоит из мантисы и экспоненты. Только вот значение экспоненты — это не <code>10<sup>х</sup></code>, а <code>2<sup>х</sup></code>. Если экспонента вырастет на <code>1</code>, итоговое значение числа станет больше в два раза.</p>
<p><code>MIN_EXPONENT == -1024</code>, в итоге получаем <code>2<sup>-1024</sup></code> примерно равно <code>10<sup>-308</sup></code></p>
<p>Также у класса <code>Double</code> есть интересные методы:</p>
<table>
    <tbody>
    <tr>
        <th>Методы</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>String <span class="text-neon">Double</span>.<span class="text-red">toHexString</span>(double)</code></pre>
        </td>
        <td>Возвращает строку — шестнадцатеричное представление числа</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>boolean <span class="text-neon">Double</span>.<span class="text-red">isInfinite</span>(double)</code></pre>
        </td>
        <td>Проверяет, является ли переданное число бесконечностью.</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>boolean <span class="text-neon">Double</span>.<span class="text-red">isNaN</span>(double)</code></pre>
        </td>
        <td>Проверяет, является ли переданное число <code><span class="text-red">NaN</span></code></td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Double <span class="text-neon">Double</span>.<span class="text-red">valueOf</span>(double)</code></pre>
        </td>
        <td>Оборачивает переданный <code>double</code> в <code><span class="text-neon">Double</span></code></td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Double <span class="text-neon">Double</span>.<span class="text-red">parseDouble</span>(String)</code></pre>
        </td>
        <td>Возвращает число, полученное из строки</td>
    </tr>
    </tbody>
</table>
<p>Из интересного можно отметить наличие метода <code>isInfinite()</code>, который возвращает <code>true</code>, если переданное в него число было плюс или минус бесконечность.</p>
<p>Аналогично работает и метод <code><span class="text-red">isNaN()</span></code> — проверяет, является ли переданное в него число <code><span class="text-red">NaN</span></code>: специальная константа, обозначающая неопределенность (<span class="term">Not a Number</span>, <span class="term">Не число</span>).</p>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task12.task1205"></div>
<hr>
<h2>3. Класс <code>Character</code></h2>
<p>Класс <code>Character</code> в первую очередь интересен большим количеством утилитных статических методов, которые позволяют проверять символы на принадлежность разным категориям.</p>
<p>Примеры</p>
<table>
    <tbody>
    <tr>
        <th>Методы</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">isAlphabetic</span>(int)</code></pre>
        </td>
        <td>Проверяет, является ли символ символом алфавита</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">isLetter</span>(char)</code></pre>
        </td>
        <td>Является ли символ буквой</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">isDigit</span>(char)</code></pre>
        </td>
        <td>Является ли символ цифрой</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">isSpaceChar</span>(char)</code></pre>
        </td>
        <td>Является ли символ пробелом, символом переноса строки или смены параграфа (коды: 12, 13, 14)</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">isWhitespace</span>(char)</code></pre>
        </td>
        <td>Является ли символ разделителем: пробел, tab, и т.д.</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">isLowerCase</span>(char)</code></pre>
        </td>
        <td>Символ в нижнем регистре — строчные буквы?</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">isUpperCase</span>(char)</code></pre>
        </td>
        <td>Символ в верхнем регистре — заглавные буквы?</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">toLowerCase</span>(char)</code></pre>
        </td>
        <td>Преобразует символ в нижний регистр</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Character.<span class="text-red">toUpperCase</span>(char)</code></pre>
        </td>
        <td>Преобразует символ в верхний регистр</td>
    </tr>
    </tbody>
</table>
<p>Особенностью данных методов является то, что они работают со всеми известными алфавитами: символы арабских цифр будут определяться как цифры и т.п.</p>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task12.task1206"></div>
<hr>
<h2>4. Класс <code>Boolean</code></h2>
<p>Тип <code>Boolean</code> практически такой же, как тип <code>boolean</code>. Отличия минимальны.</p>
<p>Ниже мы покажем упрощенный вариант класса <code>Boolean</code>:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>class <span class="text-neon">Boolean</span>
{
   public <span class="text-orange">static</span> final <span class="text-neon">Boolean</span> <span class="text-viola">TRUE</span> = new <span class="text-neon">Boolean</span>(true);
   public <span class="text-orange">static</span> final <span class="text-neon">Boolean</span> <span class="text-viola">FALSE</span> = new <span class="text-neon">Boolean</span>(false);

   private final boolean <span class="text-user">value</span>;

   public <span class="text-neon">Boolean</span>(boolean <span class="text-green">value</span>)
   {
      this.<span class="text-user">value</span> = <span class="text-green">value</span>;
   }

   public boolean <span class="text-red">booleanValue</span>()
   {
      return <span class="text-user">value</span>;
   }

   public <span class="text-orange">static</span> <span class="text-neon">Boolean</span> valueOf(boolean <span class="text-green">value</span>)
   {
      return (<span class="text-green">value</span> ? <span class="text-viola">TRUE</span> : <span class="text-viola">FALSE</span>);
   }
}</code></pre>
        </td>
        <td style="width:320px"><br><br>Константы: <code><span class="text-viola">TRUE</span></code> и <code><span class="text-viola">FALSE</span></code>
            <br><br><br>Переменная-значение
            <br><br>Конструктор класса <code><span class="text-neon">Boolean</span></code>
            <br><br><br><br><br>Метод возвращает значение внутренней переменной-значения
            <br><br><br><br>Этот статический метод умеет преобразовывать <code>true</code> в <code><span class="text-viola">TRUE</span></code> и <code>false</code> в <code><span class="text-viola">FALSE</span></code>.
        </td>
    </tr>
    </tbody>
</table>
<p>В типе <code>Boolean</code> есть две константы (два поля):</p>
<table>
    <tbody>
    <tr>
        <th>Константы класса</th>
        <th>Аналог типа boolean</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Boolean.TRUE</code></pre>
        </td>
        <td>
            <pre><code>true</code></pre>
        </td>
        <td>истина</td>
    </tr>
    <tr>
        <td>
            <pre class="language-java"><code>Boolean.FALSE</code></pre>
        </td>
        <td>
            <pre><code>false</code></pre>
        </td>
        <td>ложь</td>
    </tr>
    </tbody>
</table>
<p>Работать с ними можно так же, как и с типом <code>boolean</code>:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Примечание</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>if (Boolean.TRUE)
{
}</code></pre>
        </td>
        <td><code>Boolean</code> — единственный класс, который можно писать внутри условия</td>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>Boolean a = Boolean.TRUE;
boolean b = Boolean.TRUE;
boolean с = true;</code></pre>
        </td>
        <td>Все три переменные равны <code>true</code>/<code>TRUE</code></td>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>Boolean a = Boolean.TRUE;
Boolean b = Boolean.TRUE;
if (a == b)</code></pre>
        </td>
        <td>Константы можно сравнивать и через <code>equals</code> и через <code>==</code>
            <br><br>Так тоже будет работать.
        </td>
    </tr>
    </tbody>
</table>
<p>Autoboxing тут работает отлично, поэтому можете пользоваться этим типом так же, как типом <code>boolean</code>: никаких подводных камней тут нет.</p>
<table>
    <tbody>
    <tr>
        <th>Как записано</th>
        <th>Как это работает</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code><span class="text-neon">Boolean</span> a = true;
<span class="text-neon">Boolean</span> b = true;
<span class="text-neon">Boolean</span> c = false;
<span class="text-viola">boolean</span> d = a;</code></pre>
        </td>
        <td>
<pre class="language-java"><code><span class="text-neon">Boolean</span> a = <span class="text-neon">Boolean</span>.<span class="text-red">valueOf</span>(true);
<span class="text-neon">Boolean</span> b = <span class="text-neon">Boolean</span>.<span class="text-red">valueOf</span>(true);
<span class="text-neon">Boolean</span> c = <span class="text-neon">Boolean</span>.<span class="text-red">valueOf</span>(false);
<span class="text-viola">boolean</span> d = a.<span class="text-red">booleanValue</span>();</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p>А вот как происходят сравнения между типами <code>boolean</code> и <code>Boolean</code>:</p>
<pre class="lecture-code language-java"><code>boolean <span class="text-red">a </span>= true;
Boolean <span class="text-green">b</span> = true; // будет равен Boolean.TRUE
Boolean <span class="text-user">c</span> = true; // будет равен Boolean.TRUE

<span class="text-red">a</span> == <span class="text-green">b</span>; // true (сравниваются как примитивы по значению)
<span class="text-red">a</span> == <span class="text-user">c</span>; // true (сравниваются как примитивы по значению)
<span class="text-green">b</span> == <span class="text-user">c</span>; // <span class="code text-green">true</span> (сравниваются по ссылке, но указывают на один и тот же объект)</code></pre>
<p>Если очень нужно создать независимый объект <code>Boolean</code>, то надо создать его явно:</p>
<pre class="language-java"><code>boolean a = <span class="text-user">true</span>;
Boolean b = <span class="text-red">new</span> <span class="text-neon">Boolean</span>(<span class="text-user">true</span>); // новый объект Boolean
Boolean c = <span class="text-user">true</span>; // будет равен Boolean.TRUE

a == b; // true (сравниваются как примитивы по значению)
a == c; // true (сравниваются как примитивы по значению)
b == c; // <span class="code text-red">false</span> (сравниваются по ссылке, указывают на различные объекты)</code></pre>
<p>И еще один пример: использование <code>Boolean</code> внутри <code>if</code>:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Примечание</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>Boolean <span class="text-user">less</span> = (2 &lt; 3);
if (<span class="text-user">less</span>)
{
   ...
}</code></pre>
        </td>
        <td>Скомпилируется и будет работать</td>
    </tr>
    </tbody>
</table>
<p>Скомпилируется, но работать не будет:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Примечание</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>Boolean <span class="text-user">less</span> = <span class="text-red">null</span>;
if (<span class="text-user">less</span>)
{
   ...
}</code></pre>
        </td>
        <td><br><span class="text-red">Ошибка</span>. В этой строке кинется исключение</td>
    </tr>
    </tbody>
</table>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task12.task1207"></div>
<hr>
<h2>5. Кэширование значений при autoboxing</h2>
<p>А вот с целочисленными типами-обертками подводные камни есть.</p>
<p>Как вы уже знаете, если вы сравниваете <code>int</code> и <code>Integer</code>, <code>Integer</code> преобразовывается в <code>int</code>:</p>
<table>
    <tbody>
    <tr>
        <th>Как записано</th>
        <th>Как это работает</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>int <span class="code text-green">a</span> = 5;
Integer <span class="code text-user">b</span> = 5;
if (<span class="code text-green">a</span> == <span class="code text-user">b</span>)
{
   ...
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>int <span class="code text-green">a</span> = 5;
Integer <span class="code text-user">b</span> = <span class="text-viola">Integer</span>.valueOf(5);
if (<span class="code text-green">a</span> == <span class="code text-user">b</span>.<span class="text-red">intValue</span>())
{
   ...
}</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p>Если сравнить между собой два объекта типа <code>Integer</code>, преобразовываться к типу <code>int</code> они не будут:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Вывод на экран</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>Integer <span class="code text-green">a</span> = 500;
Integer <span class="code text-user">b</span> = 500;
int <span class="code text-orange">c</span> = 500;

System.out.println(<span class="code text-green">a</span> == <span class="code text-user">b</span>); // сравнение ссылок
System.out.println(<span class="code text-green">a</span> == <span class="code text-orange">c</span>);
System.out.println(<span class="code text-user">b</span> == <span class="code text-orange">c</span>);</code></pre>
        </td>
        <td><pre><code>



<span class="text-red">false</span>
true
true</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p>Хоть <code><span class="text-green">a</span> == <span class="text-orange">c</span></code> и <code><span class="text-user">b</span> == <span class="text-orange">c</span></code>, но <code><span class="text-green">a</span> != <span class="text-user">b</span></code>, т.к. при сравнении <code><span class="text-green">a</span></code> и <code><span class="text-user">b</span></code> сравниваются ссылки. Что, в принципе, ожидаемо.</p>
<p><strong>Сюрприз</strong></p>
<p>Но, вот если мы заменим <code>500</code> на <code>100</code>, получим совсем другой результат:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Вывод на экран</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>Integer <span class="code text-green">a</span> = 100;
Integer <span class="code text-user">b</span> = 100;
int <span class="code text-orange">c</span> = 100;

System.out.println(<span class="code text-green">a</span> == <span class="code text-user">b</span>); // сравнение ссылок
System.out.println(<span class="code text-green">a</span> == <span class="code text-orange">c</span>);
System.out.println(<span class="code text-user">b</span> == <span class="code text-orange">c</span>);</code></pre>
        </td>
        <td><pre><code>



<span class="text-green">true</span>
true
true</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p>Все дело в том, что <strong>при autoboxing <span class="text-red">не всегда</span> создается действительно новый объект</strong> <code>Integer</code>. Для значений от <code>-128</code> до <code>127</code> включительно объекты кэшируются.</p>
<p>В классе <code>Integer</code> есть скрытый массив, который хранит объекты: <code>Integer(-128)</code>, <code>Integer(-127)</code>, ... <code>Integer(126)</code>, <code>Integer(127)</code></p>
<p>Если вы напишете <code>Integer x = 128</code>, autoboxing создаст новый объект, а если <code>Integer x = 127</code>, autoboxing возьмет готовый объект из кэша (из массива).</p>
<p>Если вы не хотите, чтобы объект <code>Integer</code> брался из кэша, вам придется создать его явно, написав: <code>Integer x = new Integer(127);</code></p>
<p>Такой кэш есть у всех типов-оберток: <code>Integer</code>, <code>Long</code>, <code>Byte</code>, <code>Short</code>, <code>Boolean</code>. У типа <code>Boolean</code> оба его значения <code><span class="text-viola">TRUE</span></code> и <code><span class="text-viola">FALSE</span></code> являются константами: по сути тоже кэшируются.</p>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task12.task1208"></div>