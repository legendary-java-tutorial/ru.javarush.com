Наследование
<p>----------------------------------------</p>
Пегас Давайте поглубже разберем третий принцип ООП – наследование. Это очень интересная тема, которой вы будете пользоваться очень часто. Программирование, для несведущих, неотличимо от магии. Поэтому начнем с такой интересной аналогии… Предположим, что вы – волшебник и хотите создать летающую л
<p>----------------------------------------</p>
<h2>1. Пегас</h2>
<p>Давайте поглубже разберем третий принцип <span class="term">ООП</span> — <span class="term text-red">наследование</span>. Это очень интересная тема, которой вы будете пользоваться часто. <span class="text-green">Программирование, для несведущих, неотличимо от магии. Поэтому начнем с такой интересной аналогии...;</span></p>
<p>Предположим, что вы &#8211; волшебник и хотите создать летающую лошадь. С одной стороны, вы бы могли попробовать наколдовать пегаса. Но т.к. пегасов в природе не существует, это будет очень непросто. Придется очень многое делать самому. <span class="text-orange">Куда проще взять лошадь и приколдовать ей крылья.</span></p>
<p><img data-id="0bebe8d6-01b1-4bd5-9183-03d6702cae17" src="https://cdn.javarush.com/images/article/0bebe8d6-01b1-4bd5-9183-03d6702cae17/original.png" alt="Наследование. ООП"></p>
<p><span class="text-green">В программировании такой процесс называется «наследование». </span>Предположим, вам нужно написать очень сложный класс. Писать с нуля долго, потом еще долго все тестировать и искать ошибки. Зачем идти самым сложным путем? Лучше поискать, а нет ли уже такого класса?</p>
<p>Предположим, вы нашли класс, который своими методами реализует 80% нужной вам функциональности. Что делать с ним дальше? Вы можете просто скопировать его код в свой класс. Но у такого решения есть несколько минусов:</p>
<ol>
    <li><span class="text-orange">Найденный класс уже может быть скомпилирован в байт-код, а доступа к его исходному коду у вас нет.</span></li>
    <li><span class="text-red">Исходный код класса есть, но вы работаете в компании, которую могут засудить на пару миллиардов за использование даже 6 строчек чужого кода. А потом она засудит вас.</span></li>
    <li><span class="text-user">Ненужное дублирование большого объема кода. Кроме того, если автор чужого класса найдет в нем ошибку и исправит ее, у вас эта ошибка останется.</span></li>
</ol>
<p>Есть решение потоньше, и без необходимости получать легальный доступ к коду оригинального класса. <span class="text-green">В Java вы можете просто объявить тот класс родителем вашего класса. </span>Это будет эквивалентно тому, что вы добавили код того класса в код своего. В <span class="text-orange">вашем классе появятся все данные и все методы класса-родителя.</span> Например, можно делать так: наследуемся от «лошади», добавляем «крылья» &#8211; получаем «пегаса»</p>
<p><img data-id="6b147d69-0757-4778-af37-469393c38ae1" src="https://cdn.javarush.com/images/article/6b147d69-0757-4778-af37-469393c38ae1/original.png" alt="Наследование. ООП"></p>
<hr>
<h2>2. Общий базовый класс</h2>
<p>Наследование можно использовать и для других целей. Допустим, у вас есть десять классов, которые очень похожи, имеют совпадающие данные и методы. Вы можете создать специальный базовый класс, вынести эти данные (и работающие с ними методы) в этот базовый класс и объявить те десять классов его наследниками. Т.е. указать в каждом классе, что у него есть класс-родитель — данный базовый класс.</p>
<p>Также как <span class="text-red">преимущества абстракции раскрываются только рядом с инкапсуляцией, так и преимущества наследования гораздо сильнее при использовании полиморфизма.</span> Но о нем вы узнаете немного позже. Сегодня же мы рассмотрим несколько примеров использования наследования.</p>
<p>Шахматные фигуры</p>
<p>Предположим, мы пишем программу, которая играет в шахматы с пользователем, а значит, нам понадобятся классы для фигур. Что бы это были за классы?</p>
<p>Очевидный ответ, если вы когда-нибудь играли в шахматы — <span class="text-user">Король, Ферзь, Слон, Конь, Ладья и Пешка.</span></p>
<p>Но в самих классах еще нужно было бы хранить информацию по каждой фигуре. Например, координаты x и y, а также ценность фигуры. Ведь некоторые фигуры ценнее других.</p>
<p>Кроме того, фигуры ходят по-разному, а значит и поведение классов будет отличаться. Вот как можно было бы описать их в виде классов:</p>
<table>
    <tbody>
    <tr>
        <td>
<pre class="language-java"><code>class King
{
   int x;
<strong>   </strong>int y;
   int worth;

   void kingMove()
   {
     // код, решающий,
     // как пойдет
     // король
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Queen
{
   int x;
   int y;
   int worth;

   void queenMove()
   {
     // код, решающий,
     // как пойдет
     // ферзь
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Rook
{
   int x;
   int y;
   int worth;

   void rookMove()
   {
     // код, решающий,
     // как пойдет
     // ладья
   }
}</code></pre>
        </td>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>class Knight
{
   int x;
   int y;
   int worth;

   void knightMove()
   {
     // код, решающий,
     // как пойдет
     // конь
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Bishop
{
   int x;
<span>   int y;
</span>   int worth;

   void bishopMove()
   {
     // код, решающий,
     // как пойдет
     // слон
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Pawn
{
   int x;
   int y;
   int worth;

   void pawnMove()
   {
     // код, решающий,
     // как пойдет
     // пешка
   }
}</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p>Это очень примитивное описание шахматных фигур.</p>
<p><strong>Общий базовый класс</strong></p>
<p>А вот как можно было бы сократить код с помощью наследования. Мы могли бы вынести одинаковые методы и данные в общий класс. Назовем его <code>ChessItem</code>. <span class="text-orange">Объекты класса <code><span class="text-orange">ChessItem</span></code> не имеет смысла создавать, так как ему не соответствует ни одна шахматная фигура</span>, но от него было бы много пользы:</p>
<table>
    <tbody>
    <tr>
        <td>
<pre class="language-java"><code>class King extends ChessItem
{
   void kingMove()
   {
     // код, решающий,
     // как пойдет король
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Queen extends ChessItem
{
   void queenMove()
   {
     // код, решающий,
     // как пойдет ферзь
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Rook extends ChessItem
{
   void rookMove()
   {
     // код, решающий,
     // как пойдет ладья
   }
}</code></pre>
        </td>
    </tr>
    <tr>
        <td></td>
        <td>
<pre class="language-java"><code>class ChessItem
{
   int x;
   int y;
   int worth;
}</code></pre>
        </td>
        <td></td>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>class Knight extends ChessItem
{
   void knightMove()
   {
     // код, решающий,
     // как пойдет конь
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Bishop extends ChessItem
{
   void bishopMove()
   {
     // код, решающий,
     // как пойдет слон
   }
}</code></pre>
        </td>
        <td>
<pre class="language-java"><code>class Pawn extends ChessItem
{
   void pawnMove()
   {
     // код, решающий,
     // как пойдет пешка
   }
}</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p><span class="text-user">Это отличный способ упростить код похожих объектов.</span> <span class="text-orange">Особенно много преимуществ мы получаем, когда в проекте тысячи различных объектов и сотни классов.</span> Тогда правильно подобранными родительскими (базовыми) классами можно не только существенно упростить логику, но и сократить код в десятки раз.</p>
<hr>
<h2>3. Наследование класса — <code>extends</code></h2>
<p><span class="text-user">Так что же нужно, чтобы унаследовать какой-то класс?</span> Чтобы унаследовать один класс от другого, нужно после объявления нашего класса указать ключевое слово <code><span class="text-red">extends</span></code> и написать имя родительского класса. Выглядит это обычно примерно так:</p>
<div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>class <span class="text-green">Потомок</span> <span class="text-red">extends</span> <span class="text-user">Родитель</span></code></pre>
</div>
<p>Именно такую конструкцию нужно написать при объявлении класса Потомок. <span class="text-red">Наследоваться, кстати, можно только от одного класса.</span></p>
<p><img data-id="74977ca1-0dbc-4891-b538-6ad8ba6a3104" src="https://cdn.javarush.com/images/article/74977ca1-0dbc-4891-b538-6ad8ba6a3104/original.jpg" alt="Наследование класса – extends"></p>
<p>На картинке мы видим «корову», унаследованную от «свиньи». «Свинья» унаследована от «курицы», «курица» от «яйца». <span class="text-red">Только один родитель!</span> Такое наследование не всегда логично. Но если есть только свинья, а очень нужна корова, программист зачастую не может устоять перед желанием сделать «корову» из «свиньи».</p>
<p>В Java нет множественного наследования: нельзя унаследовать класс от двух классов. У каждого класса может быть только один класс-родитель. <span class="text-green">Если класс-родитель не указан, таковым считается класс <code><span class="text-green">Object</span></code>.</span></p>
<p>Хотя в Java есть множественное наследование интерфейсов. Это немного снижает остроту проблемы. Про интерфейсы мы поговорим немного позже, а пока давайте продолжим разбираться с наследованием.</p>
<p>P.S.</p>
<p>Вот вам несколько историй, о том, как часто приходится делать из мухи свинью. И что за это бывает:</p>
<ul>
    <li><a href="https://habr.com/ru/post/328552/">https://habr.com/ru/post/328552/</a></li>
    <li><a href="https://voron-vp.livejournal.com/42033.html">https://voron-vp.livejournal.com/42033.html</a></li>
</ul>
<hr>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task07.task0713"></div>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task07.task0714"></div>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.pro.task07.task0715"></div>
<hr>
<div class="lesson-carousel lesson-carousel--comics lesson-carousel--desktop">
    <div class="lesson-carousel__list">
        <div class="lesson-carousel__item">
            <img data-id="7a257b58-bb13-4e41-8cbe-541fcd4ad9eb" src="https://cdn.javarush.com/images/article/7a257b58-bb13-4e41-8cbe-541fcd4ad9eb/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="101b84d3-6284-45f3-b892-eb29ec327f6e" src="https://cdn.javarush.com/images/article/101b84d3-6284-45f3-b892-eb29ec327f6e/original.png" alt="">
        </div>
    </div>
</div>
<div class="lesson-carousel lesson-carousel--comics lesson-carousel--mobile">
    <div class="lesson-carousel__list">
        <div class="lesson-carousel__item">
            <img data-id="26ce485b-aed1-412a-9c04-1f042c895ea2" src="https://cdn.javarush.com/images/article/26ce485b-aed1-412a-9c04-1f042c895ea2/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="0b90f671-71b6-44c5-960e-c4452cf9060e" src="https://cdn.javarush.com/images/article/0b90f671-71b6-44c5-960e-c4452cf9060e/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="eb6c5904-f9a2-4364-a0e4-ca19f7cc2a00" src="https://cdn.javarush.com/images/article/eb6c5904-f9a2-4364-a0e4-ca19f7cc2a00/original.png" alt="">
        </div>
        <div class="lesson-carousel__item">
            <img data-id="962e279f-605e-40ad-aba5-af852c30fc7a" src="https://cdn.javarush.com/images/article/962e279f-605e-40ad-aba5-af852c30fc7a/original.png" alt="">
        </div>
    </div>
</div>