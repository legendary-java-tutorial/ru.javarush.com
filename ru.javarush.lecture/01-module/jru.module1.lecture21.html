Советы по использованию коллекций
<p>----------------------------------------</p>
Как ты можешь помнить, в Java есть удобный инструмент для хранения объектов одинаковых типов – коллекции. Попробуем вспомнить основные интерфейсы коллекций...
<p>----------------------------------------</p>
    <h2>1. Список коллекций</h2>

    <p>Как ты можешь помнить, в Java есть удобный инструмент для хранения объектов одинаковых типов – коллекции.</p>

    <p>Попробуем вспомнить основные интерфейсы коллекций:</p>

    <p><span class="text-neon"><span class="text-bold">List</span></span>, <span class="text-neon"><span class="text-bold">Set</span></span>, <span class="text-neon"><span class="text-bold">Map</span></span> и <span class="text-neon"><span class="text-bold">Queue</span></span>.</p>

    <p>Как водится, нет правильных или неправильных инструментов, если использовать их по назначению. А для этого мы с тобой должны хорошенько разобраться в их особенностях, чтобы знать, когда и какую коллекцию использовать.</p>

    <h3>1. List</h3>

    <p>Давай начнем с самой часто используемой коллекции.</p>

    <p><span class="text-neon"><span class="text-bold">List</span></span> максимально схож с самым обычным массивом. Название же нам говорит о том, что это список (list).</p>

    <p>Эта коллекция дает нам возможность удобно хранить в себе список объектов одного типа, не заботясь о размере самой коллекции, как мы это делали, используя массивы. Обращение к элементам коллекции происходит по индексу. Если мы точно знаем, на каком месте находится объект и нам необходимо часто к нему обращаться, при этом нам не нужно часто добавлять или удалять элементы, <span class="text-neon"><span class="text-bold">List</span></span> — это идеальный вариант.</p>

    <h3>2. Set</h3>

    <p><span class="text-neon"><span class="text-bold">Set</span></span> (множество) имеет совсем другую структуру.</p>

    <p>В первую очередь, <span class="text-neon"><span class="text-bold">Set</span></span> стоит использовать, когда нам нужно хранить уникальные объекты. Допустим, это набор авторов в библиотеке, где каждый автор уникален. Но мы не можем просто так обратиться к нашему набору авторов и достать из него конкретного автора. Функционал <span class="text-neon"><span class="text-bold">Set</span></span>-а дает нам возможность быстро проверить, представлен ли конкретный автор в нашей библиотеке, например проверить его наличие в коллекции <span class="text-neon"><span class="text-bold">Set</span></span>. Также есть возможность пройтись по всей коллекции, по каждому элементу, но это не оптимально.</p>

    <p>То есть, в нашей библиотеке <span class="text-neon"><span class="text-bold">Set</span></span> может служить чем-то вроде набора всех авторов, для быстрой проверки, представлен ли этот автор в библиотеке. </p>

    <h3>3. Map</h3>

    <p><span class="text-neon"><span class="text-bold">Map</span></span> (словарь) больше похожа на картотеку, где каждая ячейка подписана, и в ней мы можем хранить как отдельные объекты, так и целые структуры. <span class="text-neon"><span class="text-bold">Map</span></span> стоит использовать в случаях, когда необходимо сохранить соответствие одного значения к другому.</p>

    <p>В <span class="text-neon"><span class="text-bold">Map</span></span> это называется соответствие ключ – значение.</p>

    <p>С такой структурой в нашей библиотеке мы сможем использовать объект автора как ключ, а список (<span class="text-neon"><span class="text-bold">List</span></span>) книг как значение. Таким образом, проверив в <span class="text-neon"><span class="text-bold">Set</span></span> наличие автора в библиотеке, мы сможем по этому же объекту автора достать <span class="text-neon"><span class="text-bold">List</span></span> с его книгами из <span class="text-neon"><span class="text-bold">Map</span></span>. </p>

    <h3>4. Queue</h3>

    <p><span class="text-neon"><span class="text-bold">Queue</span></span> (очередь) – представляет собой коллекцию, которая построена как очередь. Причем эта очередь может быть не только <span class="text-bold">LIFO</span> (Last In First Out – последний зашел, первый вышел), но и <span class="text-bold">FIFO</span> (First In First Out – первый зашей, первый вышел). А еще очередь может быть двунаправленная, с выходами с обоих сторон.</p>

    <p>Этот инструмент удобен в случаях, когда объекты, поступающие в наш класс, метод, необходимо использовать в порядке их поступления. Например, в нашей библиотеке.</p>

    <p>Мы можем добавлять вновь прибывших посетителей в <span class="text-neon"><span class="text-bold">Queue</span></span> и по очереди их обслуживать, выдавая книги, за которыми они к нам приходят.</p>

    <p>Как мы с тобой можем видеть, все структуры хороши, если использовать их по назначению. И в пределах одного примера, библиотеки, мы использовали все четыре типа коллекций.</p>

    <h2>2. Сложность</h2>

    <p>Как уже было отмечено, коллекции, которые мы рассматривали выше, это интерфейсы, а значит у них должны быть реализации, которые мы и будем использовать.</p>

    <p>Поскольку забивать гвозди микроскопом — не самая лучшая идея, нам стоит знать, какую именно реализацию коллекции лучше использовать в той или иной ситуации. </p>

    <p>Чаще всего, выбирая тот или иной инструмент, мы смотрим на 2 показателя:</p>

    <ul>
        <li>насколько этот инструмент подходит под задачу</li>
        <li>насколько быстро будет происходить работа с ним</li>
    </ul>

    <p>Если с выбором подходящего под задачу инструмента мы кое-как разобрались, то скорость его работы – это что-то новенькое.</p>

    <p>Показатель скорости работы часто выражают через временную сложность и обозначают большой буквой О.</p>

    <p>Что вообще такое эта временная сложность?</p>

    <p>Простыми словами, эта сложность указывает на время отработки алгоритма, который заложен в коллекцию для того или иного действия (добавление, удаление элемента, поиск).</p>

    <h3>ArrayList vs LinkedList</h3>

    <p>Давай рассмотрим это на примере двух реализаций интерфейса <span class="text-neon"><span class="text-bold">List</span></span> — <span class="text-bold"><span class="text-red">ArrayList</span></span> и <span class="text-bold"><span class="text-red">LinkedList</span></span>.</p>

    <p>Частично про различие этих двух реализаций упоминается <a href="https://habr.com/ru/post/162017/" target="_blank">в этой статье</a>.</p>

    <p>Внешне, работа с этими коллекциями похожа:</p>

    <pre class='language-java line-numbers'><code>
List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
arrayList.add(String);
arrayList.get(index);
arrayList.remove(index);
arrayList.remove(String);
 
List&lt;String&gt; linkedList = new LinkedList&lt;&gt;();
 
linkedList.add(String);
 
linkedList.get(index);
linkedList.remove(index);
linkedList.remove(String);
    </code></pre>
 
    <p>Как ты мог заметить, в обоих случаях мы одинаково добавляем, берем и удаляем элемент из списка. Это из-за того, что мы создаем реализации на основе одно интерфейса. Но на этом сходство у них заканчивается.</p>

    <p>Благодаря разной реализации интерфейса <span class="text-neon"><span class="text-bold">List</span></span> эти две структуры имеют разную эффективность при разном использовании.</p>

    <p>Рассмотрим пример операции удаления и добавления элемента.</p>

    <p>Если нам нужно будет удалить элемент из середины списка <span class="text-bold"><span class="text-red">ArrayList</span></span>, каждый раз мы будем переписывать остальную часть списка, следующую за элементом, который мы удаляем.</p>

    <p>Допустим, у нас есть список из 5-ти элементов и нам нужно удалить 3-й.</p>

    <pre class='language-java line-numbers'><code>
List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
list.remove(2);
    </code></pre>

    <p>В таком случае после удаления у нас освободится одна ячейка, и мы будем вынуждены перезаписать 4-й элемент на место 3-го, а 5-й на место 4-го.</p>
 
    <img data-max-width="256" data-id="636d21b1-d9dc-417f-bd92-519c1fcf40e7" src="https://cdn.javarush.com/images/article/636d21b1-d9dc-417f-bd92-519c1fcf40e7/original.png" alt="">

    <p>Это максимально неэффективно.</p>

    <p>То же самое будет происходить и при добавлении элемента в середину списка.</p>

    <img data-max-width="256" data-id="c9d8dd16-9fe9-4e07-9b8e-95f20d8b112e" src="https://cdn.javarush.com/images/article/c9d8dd16-9fe9-4e07-9b8e-95f20d8b112e/original.png" alt="">

    <p>LinkedList же устроен по-другому. Добавление или удаление элементов из него происходит быстро, так как нам всего лишь нужно изменить ссылки в предыдущем и следующем элементе, исключив из цепочки элементов объект, который мы удаляем.</p>

    <p>На примере того же списка из 5-ти элементов, удалив из него 3-й, мы должны просто поменять ссылку на следующий элемент во 2-м и ссылку на предыдущий в 4-м элементе.</p>
 
    <img data-max-width="512" data-id="9d6f648d-9b2f-4bdd-a9cb-bf277a2f9f29" src="https://cdn.javarush.com/images/article/9d6f648d-9b2f-4bdd-a9cb-bf277a2f9f29/original.png" alt="">

    <p>То же самое, только наоборот, происходит при добавлении элемента в список.</p>

    <p>Обратите внимание, насколько меньше действий нам необходимо произвести в <span class="text-bold"><span class="text-red">LinkedList</span></span> в сравнении с <span class="text-bold"><span class="text-red">ArrayList</span></span>. А это всего лишь 5 элементов. Будь в списке 100 и больше элементов, превосходство <span class="text-bold"><span class="text-red">LinkedList</span></span> было бы более ощутимо. </p>

    <p>Но как поменяется ситуация, если мы будем обращаться к элементу по индексу?</p>

    <p>Тут все будет ровно наоборот.</p>

    <p>Так как ArrayList</span></span> устроен как обычный массив, нам будет очень просто взять любой элемент по его индексу. Мы просто переместим указатель на определенное место и возьмем из ячейки элемент.</p>

    <p>Но в <span class="text-bold"><span class="text-red">LinkedList</span></span> так просто не получится. Нам придется пройтись по всем элементам массива, чтобы найти элементы с определенным индексом. Только в данном случае имеет смысл называть это не индекс, а порядковый номер.</p>

    <p>Давай попробуем выразить это все через большую О?</p>

    <p>Начнем с обращения к элементу по индексу.</p>

    <p>В <span class="text-bold"><span class="text-red">ArrayList</span></span> это происходит в одно действие, вне зависимости от местоположения элемента в списке. В начале он или в конце.</p>

    <p>Временная сложность в данном случае будет <span class="text-bold">О(1)</span>.</p>

    <p>В <span class="text-bold"><span class="text-red">LinkedList</span></span> нам придется перебрать то количество элементов, индекс которого нам нужен.</p>

    <p>Временная сложность для такого действия будет <span class="text-bold">О(n)</span> – где n – это индекс элемента, который нам нужен.</p>

    <p>Получается, под скобки большого О мы помещаем число, которое соответствует количеству производимых действий.</p>

    <p>Вернемся к удалению и добавлению?</p>

    <p><span class="text-bold">Начнем с LinkedList.</span></p>

    <p>Так как нам не нужно делать большое количество действий для добавления или удаления элемента, и скорость этой операции никак не зависит от того, где находится элемент, сложно будет выглядеть так – <span class="text-bold">О(1)</span> и называется константной.</p>

    <p>Сложность этой же операции для <span class="text-bold"><span class="text-red">ArrayList</span></span> будет уже <span class="text-bold">О(n)</span> и называется линейной.</p>

    <p>В алгоритмах с линейной сложностью время работы напрямую зависит от количества элементов, которые предстоит обработать. Также это может зависеть и от положения элемента, в начале списка или ближе к концу.</p>

    <p>Сложность еще бывает логарифмической. Выглядит она вот так — <span class="text-bold">O(log n)</span>.</p>

    <p>В качестве примера можем рассмотреть отсортированный <span class="text-bold"><span class="text-red">TreeSet</span></span> список из 10-ти чисел, в котором нам нужно найти число 2.</p>

    <p>Так как список отсортирован и в нем нет дубликатов, мы можем разделить его пополам и проверить, в какой части списка осталось искомое число, откинуть одну из частей и повторить действия снова, пока не дойдем до искомого элемента. В итоге мы найдем число, обработав log(n) количество элементов.</p>

    <p>Давай взглянем на таблицу, в которой описаны сложности остальных коллекций.</p>
 
    <table>
        <tbody>
            <tr>
                <th></th>
                <th>По индексу</th>
                <th>По ключу</th>
                <th>Поиск</th>
                <th>Вставка в конец</th>
                <th>Вставка в середину</th>
                <th>Удаление</th>
            </tr>

            <tr>
                <th>ArrayList</th>
                <td>O(1)</td>
                <td>N/A</td>
                <td>О(n)</td>
                <td>O(1)</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>

            <tr>
                <th>LinkedList</th>
                <td>O(n)</td>
                <td>N/A</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>HashSet</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>TreeSet</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(log n)</td>
                <td>N/A</td>
                <td>O(log n)</td>
                <td>O(log n)</td>
            </tr>

            <tr>
                <th>HashMap</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>TreeMap</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(log n)</td>
                <td>N/A</td>
                <td>O(log n)</td>
                <td>O(log n)</td>
            </tr>

            <tr>
                <th>ArrayDeque</th>
                <td>N/A</td>
                <td>N/A</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
        <tbody>
    </table>

    <p>Теперь, когда у нас с тобой есть таблица, в которой указана временная сложность для популярных коллекций, мы можем ответить на вопрос, почему из такого количества коллекций мы чаще всего используем <span class="text-bold"><span class="text-red">ArrayList</span></span>, <span class="text-neon"><span class="text-bold">HashSet</span></span> и <span class="text-neon"><span class="text-bold">HashMap</span></span>.</p>

    <p>Они просто максимально эффективны для большинства задач :)</p>