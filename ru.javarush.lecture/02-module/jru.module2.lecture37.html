Декларативный и императивный подход написания кода
<p>----------------------------------------</p>
Сегодня мы коснемся темы функционального программирования, а именно различия между декларативным и императивным программированием. Сначала давай быстро пробежимся по терминам, а потом сравним эти стили программирования и посмотрим...
<p>----------------------------------------</p>
    <p>Сегодня мы коснемся темы функционального программирования, а именно различия между декларативным и императивным программированием.</p>

    <p>Сначала давай быстро пробежимся по терминам, а потом сравним эти стили программирования и посмотрим, как они отражаются в Java и могут ли сосуществовать в данном языке.</p>

    <p><span class="text-bold">Функциональное программирование</span> — это парадигма, в которой процесс вычисления определяется вычислением значений функций в математическом их понимании, а не в понимании подпрограмм, как в <span class="text-bold">процедурном программировании</span>. То есть в этих двух парадигмах значение слова “функция” трактуется по-разному. Это нужно запомнить и не путать. В Java ты с этим не запутаешься: функции в значении подпрограмм — это “методы”, а функции как математические функции — это просто “функции” (также: лямбда-функции или method reference).</p>

    <p>На практике в процедурном программировании функции зависят не только от входных переменных, но и от внешних факторов (например, других переменных вне функции или состояния системы). Таким образом при вызове одной и той же функции с одинаковыми аргументами в различном контексте могут получаться разные результаты. В функциональном же программировании при вызове функции с одинаковыми аргументами мы всегда получаем одинаковый результат, так как функции зависят только от входных данных.</p>

    <h4>Положительные стороны функционального программирования</h4>

    <ul>
        <li>Повышение надежности кода</li>
        <li>Удобство организации модульного тестирования</li>
        <li>Возможности оптимизации кода при компиляции</li>
        <li>Возможности параллелизма</li>
    </ul>

    <h4>Отрицательные стороны функционального программирования</h4>

    <p>Недостатки функционального программирования вытекают из все тех же его особенностей:</p>

    <ul>
        <li><p>Отсутствие присваиваний и замена их на порождение новых данных приводят к необходимости постоянного выделения и автоматического освобождения памяти. Поэтому в системе исполнения функциональной программы обязательным компонентом становится высокоэффективный сборщик мусора.</p></li>
        <li><p>Нестрогая модель вычислений приводит к непредсказуемому порядку вызова функций, что создает проблемы при вводе-выводе, где порядок выполнения операций важен.</p></li>
    </ul>

    <p>Краткая справка по функциональному программированию завершена, теперь перейдем непосредственно к стилям программирования.</p>

    <p><span class="text-bold">Императивное программирование</span> — это парадигма программирования, для которой характерны следующие черты:</p>

    <ul>
        <li><p>В исходном коде программы записываются инструкции (команды).</p></li>
        <li><p>Инструкции должны выполняться последовательно.</p></li>
        <li><p>Данные, получаемые при выполнении предыдущих инструкций, могут читаться из памяти последующими инструкциями.</p></li>
        <li><p>Данные, полученные при выполнении инструкции, могут записываться в память.</p></li>
    </ul>

    <p>Основные черты императивных языков:</p>

    <ul>
        <li>Использование именованных переменных.</li>
        <li>Использование оператора присваивания.</li>
        <li>Использование составных выражений.</li>
        <li>Использование подпрограмм.</li>
    </ul>

    <p>Императивная программа похожа на приказы, выражаемые повелительным наклонении в естественных языках, то есть представляют собой последовательность команд.</p>

    <p>К императивным языкам программирования относятся C, C++.</p>

    <p><span class="text-bold">Декларативное программирование</span> — парадигма программирования, в которой задается спецификация решения задачи, то есть описывается конечный результат, а не способ его достижения. В качестве примеров декларативных языков можно привести язык разметки HTML. При написании тегов в этом языке мы не задумываемся о том, как элементы будут отрисовываться на странице, мы просто описываем, как эта страница должна выглядеть.</p>

    <p>Другой язык декларативного программирования — SQL.</p>

    <p><span class="text-bold">Чтобы сравнить два стиля программирования</span>, рассмотрим пример из реальной жизни: как объяснить человек, как добраться до какого-то места?</p>

    <p>Представим ситуацию: к нам подошел человек на улице и спросил: “Как пройти к музею N?”</p>

    <p>При императивном подходе мы бы объясняли ему алгоритм того, как добраться туда пешком:</p>

    <ul>
        <li>сейчас развернуться</li>
        <li>идти 2 квартала по прямой</li>
        <li>повернуть направо</li>
        <li>…</li>
    </ul>

    <p>При декларативном же подходе мы просто называем адрес, а дальше человек сам, своими силами (инструментами) добирается до нужного места.</p>

    <p><span class="text-bold">Java</span> же на данный момент является <span class="text-bold">мультипарадигмальным языком программирования</span>. Мультипарадигменность заключается в том, что язык поддерживает несколько парадигм.</p>

    <p>Во время своего долгого развития язык расширял свою объектно-ориентированную модель для того, чтобы его пользователи получали различные инструменты и могли выбрать лучший для решения каждой конкретной задачи.</p>

    <p>Поэтому на данный момент Java поддерживает как и императивный (например, написание кода вызовов методов), так и декларативный подход (например, аннотации, доступные в Runtime).</p>

    <h4>Подведем итог:</h4>

    <ul>
        <li><p>Существуют различные парадигмы программирования.</p></li>
        <li><p>Есть декларативный и императивный подходы.</p></li>
        <li><p>Выбирать стоит тот, который лучше будет справляться с решением поставленных задач.</p></li>
        <li><p>Java — мультипарадигменный язык, поддерживающий оба подхода.</p></li>
    </ul>