Знакомство с методами wait, notify, notifyAll
<p>----------------------------------------</p>
&#8212; Привет, Амиго! &#8212; Привет, Риша! &#8212; Я познакомлю тебя с методами wait, notify, notifyAll класса Object. Сегодня мы просто ознакомимся с ними, но потом еще раз вернемся и уже выделим на это больше времени. &#8212; Хорошо. &#8212; Эти методы были придуманы как часть механизма синхронизации нитей. Напомню, что в Java есть встроенный механизм управления ...
<p>----------------------------------------</p>
<p>&#8212; Привет, Амиго!</p>
<p><span class="text-user">&#8212; Привет, Риша!</span></p>
<p>&#8212; Я познакомлю тебя с методами <strong>wait</strong>, <strong>notify</strong>, <strong>notifyAll</strong> класса Object.</p>
<p>Сегодня мы просто ознакомимся с ними, но потом еще раз вернемся и уже выделим на это больше времени.</p>
<p><span class="text-user">&#8212; Хорошо.</span></p>
<p>&#8212; Эти методы были придуманы как часть механизма синхронизации нитей.</p>
<p>Напомню, что в Java есть встроенный механизм управления доступом к общим ресурсам (объектам) из разных нитей. Нить может объявить какой-нибудь объект занятым, и другие нити будут вынуждены ждать, пока занятый объект не освободится.</p>
<p><span class="text-user">&#8212; Я помню, это делается с помощью ключевого слова <strong>synchronized</strong>.</span></p>
<p>&#8212; Правильно. Обычно такой код выглядит примерно так:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>public void print()
{
 Object monitor = getMonitor();
 synchronized(monitor)
 {
  System.out.println("text");
 }
}</code></pre>
<p>Помнишь, как это работает?</p>
<p><span class="text-user">&#8212; Ага. Если две нити одновременно вызовут метод print(), то одна из них войдет в блок, помеченный synchronized, и заблокирует monitor, поэтому вторая нить будет ждать, пока монитор не освободится.</span></p>
<p>&#8212; Правильно. Как только нить входит в блок, помеченный synchronized, то объект-монитор помечается как занятый, и другие нити будут вынуждены ждать освобождения объекта-монитора. Один и тот же объект-монитор может использоваться в различных частях программы.</p>
<p><span class="text-user">&#8212; Кстати, почему – монитор?</span></p>
<p>&#8212; Монитором принято называть объект, который хранит состояние занят/свободен.</p>
<p>Вот тут и вступают в дело методы <strong>wait</strong> и <strong>notify</strong>.</p>
<p>Собственно, методов как таковых всего два. Остальные – это лишь модификации этих методов.</p>
<p>Теперь разберемся, <strong>что же такое метод wait и зачем он нужен.</strong></p>
<p>Иногда в программе может оказаться такая ситуация, что нить вошла в блок кода synchronized, заблокировала монитор и не может работать дальше, т.к. каких-то данных еще не хватает: например, файл который она должна обработать еще не загрузился или что-нибудь в таком духе.</p>
<p>Мы же можем просто подождать, когда файл скачается. Можно просто в цикле проверять – если файл еще не скачался – спать, например, секунду и опять проверять и т.д.</p>
<p>Примерно так:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>while(!file.isDownloaded())
{
 Thread.sleep(1000);
}
processFile(file);</code></pre>
<p>Но в нашем случае такое ожидание слишком дорого. Т.к. наша нить заблокировала монитор, то другие нити вынуждены тоже ждать, хотя их данные для работы могут быть уже готовы.</p>
<p>Для решения этой проблемы и был придуман метод <strong>wait</strong>(). Вызов этого метода приводит к тому, что нить освобождает монитор и «становится на паузу».</p>
<p>Метод wait можно вызвать у объекта-монитора и только тогда, когда это монитор занят – т.е. внутри блока <strong>synchronized</strong>. При этом нить временно прекращает работу, а монитор освобождается, чтобы им могли воспользоваться другие нити.</p>
<p>Часто встречаются ситуации, когда в блок <strong>synchronized</strong> зашла нить, вызвала там wait, освободила монитор.</p>
<p>Затем туда вошла вторая нить и тоже стала на паузу, затем третья и так далее.</p>
<p><span class="text-user">&#8212; А как же нить снимется с паузы?</span></p>
<p>&#8212; Для этого есть второй метод – notify.</p>
<p>Методы <strong>notify</strong>/<strong>notifyAll</strong> можно вызвать у объекта-монитора и только, когда этот монитор занят – т.е. внутри блока <strong>synchronized</strong>. Метод <strong>notifyAll</strong> снимает с паузы все нити, которые стали на паузу с помощью данного объекта-монитора.</p>
<p>Метод <strong>notify</strong> «размораживает» одну случайную нить, метод <strong>notifyAll</strong> – все «замороженные» нити данного монитора.</p>
<p><span class="text-user">&#8212; Очень интересно, спасибо Риша.</span></p>
<p>&#8212; Рад, что тебе нравится, Амиго!</p>
<p>Есть еще модификации метода <strong>wait</strong>():</p>
<table>
<tbody>
<tr>
<th>Метод wait()</th>
<th>Пояснение</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java" data-line="" data-start=""><code>void wait(long timeout)</code></pre>
</td>
<td>Нить «замерзает», но через переданное количество миллисекунд автоматически «размораживается».</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java" data-line="" data-start=""><code>void wait(long timeout, int nanos)</code></pre>
</td>
<td>Нить «замерзает», но через переданное количество миллисекунд и наносекунд автоматически «размораживается».</td>
</tr>
</tbody>
</table>
<p>Это, как еще говорят, wait с таймаутом. Метод работает как обычный wait, но если указанное время прошло, а нить никто не снял с паузы – она активируется сама.</p>
