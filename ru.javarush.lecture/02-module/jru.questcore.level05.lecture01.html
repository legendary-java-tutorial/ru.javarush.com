Модификаторы доступа, переопределение методов, реализация абстрактных методов
<p>----------------------------------------</p>
Давайте углубимся в тему «модификаторы доступа» и узнаем, как они связаны с реализацией абстрактных методов и интерфейсов, а также с переопределением методов. Модификаторы, словно своеобразные вахтёры, отвечают на вопрос «Кто может обращаться к данному методу/переменной?». Подробности — в этой лекции.
<p>----------------------------------------</p>
<p>&#8212; Я расскажу тебе про «<span class="text-red">модификаторы доступа</span>». Когда-то я уже рассказывал про них, но повторение – мать учения.</p>
<p>Ты можешь управлять доступом (видимостью) методов и переменных твоего класса из других классов. Модификатор доступа отвечает на вопрос «Кто может обращаться к данному методу/переменной?». Каждому методу или переменной можно указывать только один модификатор.</p>
<p><strong>1)</strong> Модификатор «<strong><span class="text-red">public</span></strong>».</p>
<p>К переменной, методу или классу, помеченному модификатором <strong><span class="text-red">public</span></strong>, можно обращаться из любого места программы. Это самая высокая степень открытости – никаких ограничений нет.</p>
<p><strong>2)</strong> Модификатор «<strong><span class="text-red">private</span></strong>».</p>
<p>К переменной, методу или классу, помеченному модификатором <span class="text-red"><strong>private</strong></span>, можно обращаться только из того же класса, где он объявлен. Для всех остальных классов помеченный метод или переменная – невидимы. Это самая высокая степень закрытости – только свой класс. Такие методы не наследуются и не переопределяются. Доступ к ним из класса-наследника также невозможен.</p>
<p><strong>3) «Модификатор</strong> <strong>«<span class="text-red">по умолчанию</span>».</strong></p>
<p>Если переменная или метод не помечены никаким модификатором, то считается, что они помечены «модификатором по умолчанию». Переменные и методы с таким модификатором видны всем классам пакета, в котором они объявлены, и только им. Этот модификатор еще называют «<span class="text-red"><strong>package</strong></span>» или «<span class="text-red"><strong>package private</strong></span>», намекая, что доступ к переменным и методам открыт для всего пакета, в котором находится их класс</p>
<p><strong>4)</strong> Модификатор «<span class="text-red"><strong>protected</strong></span>».</p>
<p>Этот уровень доступа чуть шире, чем <span class="text-red"><strong>package</strong></span>. К переменной, методу или классу, помеченному модификатором <span class="text-red"><strong>protected</strong></span>, можно обращаться из его же пакета (как package), но еще из всех классов, унаследованных от текущего.</p>
<p>Таблица с пояснением:</p>
<table>
<tbody>
<tr>
<th style=text-align: center;" rowspan="2">Тип видимости</th>
<th style="text-align: center;" rowspan="2">Ключевое слово</th>
<th style="text-align: center;" colspan="4">Доступ</th>
</tr>
<tr>
<th style="text-align: center;">Свой класс</th>
<th style="text-align: center;">Свой пакет</th>
<th style="text-align: center;">Класс &#8212; наследник</th>
<th style="text-align: center;">Все классы</th>
</tr>
<tr>
<td><b>Закрытый</b></td>
<td><b>private</b></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-red">Нет</span></td>
<td style="text-align: center;"><span class="text-red">Нет</span></td>
<td style="text-align: center;"><span class="text-red">Нет</span></td>
</tr>
<tr>
<td><b>Пакет</b></td>
<td>(нет модификатора)</td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-red">Нет</span></td>
<td style="text-align: center;"><span class="text-red">Нет</span></td>
</tr>
<tr>
<td><b>Защищенный</b></td>
<td><b>protected</b></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-red">Нет</span></td>
</tr>
<tr>
<td><b>Открытый</b></td>
<td><b>public</b></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
<td style="text-align: center;"><span class="text-green">Есть</span></td>
</tr>
</tbody>
</table>
<p>Есть способ, чтобы легко запомнить эту таблицу. Представь себе, что ты составляешь завещание и делишь все вещи на четыре категории. Кто может пользоваться твоими вещами?</p>
<table>
<tbody>
<tr>
<th>Кто имеет доступ</th>
<th>Модификатор</th>
<th>Пример</th>
</tr>
<tr>
<td>Только <span class="red_text text-red"><b>я сам</b></span></td>
<td><b>private</b></td>
<td>Личный дневник</td>
</tr>
<tr>
<td><span class="text-red">Семья</span></td>
<td>(нет модификатора)</td>
<td>Семейные фотографии</td>
</tr>
<tr>
<td><span class="text-red">Семья и наследники</span></td>
<td><b>protected</b></td>
<td>Фамильное поместье</td>
</tr>
<tr>
<td><span class="text-red">Все</span></td>
<td><b>public</b></td>
<td>Мемуары</td>
</tr>
</tbody>
</table>
<p class="amigo"><span class="text-user">&#8212; Если представить, что классы, лежащие в одном пакете, – это одна семья, то очень даже похоже.</span></p>
<p>&#8212; Хочу также рассказать тебе несколько интересных нюансов насчет переопределения методов.</p>
<p><b>1) Неявная реализация абстрактного метода.</b></p>
<p>Допустим, у тебя есть код:</p>
<div class="code-heading">Код</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code>class Cat
{
 public String <span class="text-red">getName</span>()
 {
  return "Васька";
 }
}</code></pre>
<p>И ты решил унаследовать от него класс тигр и добавить новому классу интерфейс</p>
<div class="code-heading">Код</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code>class Cat
{
 public String <span class="text-user">getName</span>()
 {
   return "Васька";
 }
}</code></pre>
<pre class="line-numbers language-java" data-line="" data-start=""><code>interface <span class="text-red">HasName</span>
{
 String <span class="text-red">getName</span>();
 int <span class="text-red">getWeight</span>();
}</code></pre>
<pre class="line-numbers language-java" data-line="" data-start=""><code>class Tiger <span class="text-user">extends Cat</span> <span class="text-red">implements HasName</span>
{
 public int <span class="text-red">getWeight</span>()
 {
  return 115;
 }

}</code></pre>
<p>Если ты просто реализуешь все недостающие методы, которые тебе подскажет Intellij IDEA, то можешь потом долго искать ошибку.</p>
<p>Оказывается, что в классе Tiger есть унаследованный от Cat метод getName, который и будет считаться реализацией метода getName для интерфейса HasName.</p>
<p><span class="text-user">&#8212; Не вижу в этом ничего страшного.</span></p>
<p>&#8212; Это не очень плохо, это скорее потенциальное место для ошибок.</p>
<p>Но может быть еще хуже:</p>
<div class="code-heading">Код</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code>interface <span class="text-red">HasWeight</span>
{
 <span class="text-red">int getValue();</span>
}</code></pre>
<pre class="line-numbers language-java" data-line="" data-start=""><code>interface <span class="text-user">HasSize</span>
{
 <span class="text-user">int getValue();</span>
}</code></pre>
<pre class="line-numbers language-java" data-line="" data-start=""><code>class Tiger extends Cat implements <span class="text-red">HasWeight</span>, <span class="text-user">HasSize</span>
{
 <span class="text-user">public int</span> <span class="text-red">getValue</span>()
 {
  return 115;
 }
}</code></pre>
<p>Оказывается, ты не всегда можешь унаследоваться от нескольких интерфейсов. Вернее унаследоваться можешь, а вот корректно их реализовать – нет. Посмотри на пример, оба интерфейса требуют, чтобы ты реализовал метод getValue(), и не ясно, что он должен возвращать: вес(weight) или размер(size). Это довольно-таки неприятная вещь, если тебе придется с ней столкнуться.</p>
<p><span class="text-user">&#8212; Да, согласен. Хочешь реализовать метод, а не можешь. Вдруг ты уже унаследовал метод с таким же именем от базового класса. Обломись.</span></p>
<p>&#8212; Но есть и приятные новости.</p>
<p><strong>2) <span class="text-red">Расширение видимости.</span></strong> При переопределении типа разрешается расширить видимость метода. Вот как это выглядит:</p>
<table>
<tbody>
<tr>
<th>Код на Java</th>
<th>Описание</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>class Cat
{
 <span class="text-red">protected</span> String getName()
 {
  return "Васька";
 }
}</code></pre>
</td>
<td></td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>class Tiger extends Cat
{
 <span class="text-red">public</span> String getName()
 {
  return "Василий Тигранович";
 }
}</code></pre>
</td>
<td>Мы расширили видимость метода с <code><span class="text-red">protected</span></code> до <code><span class="text-red">public</span></code>.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<th>Использование</th>
<th>Почему это «законно»</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>public static void main(String[] args)
{
 Cat cat = new Cat();
 cat.getName();
}</code></pre>
</td>
<td>Все отлично. Тут мы даже не знаем, что в классе-наследнике видимость метода была расширена.</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>public static void main(String[] args)
{
 Tiger tiger = new Tiger();
 tiger.getName();
}</code></pre>
</td>
<td>Тут вызывается метод, у которого расширили область видимости.</p>
<p>Если бы этого сделать было нельзя, всегда можно было бы объявить метод в Tiger:<br />
<strong>public</strong> String getPublicName()<br />
{<br />
super.getName(); //вызов protected метода<br />
}</p>
<p>Т.е. ни о каком нарушении безопасности и речи нет.</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>public static void main(String[] args)
{
 Cat catTiger = new Tiger();
 catTiger.getName();
}</code></pre>
</td>
<td>Если все условия подходят для вызова метода базового типа (<strong>Cat</strong>), то они уж точно подойдут для вызова типа наследника (<strong>Tiger</strong>) . Т.к. ограничения на вызов метода были ослаблены, а не усилены.</td>
</tr>
</tbody>
</table>
<p><span class="text-user">&#8212; Не уверен, что понял полностью, но то, что так можно делать, запомню.</span></p>
<p><strong>3)</strong> <span class="text-red"><strong>Сужение типа результата.</strong></span></p>
<p>В переопределенном методе мы можем <span class="text-red"><strong>поменять тип результата</strong></span>, <strong>сузив</strong> его.</p>
<table>
<tbody>
<tr>
<th>Код на Java</th>
<th>Описание</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>class <span class="text-red">Cat</span>
{
 public Cat parent;
 public <span class="text-red">Cat</span> <span class="text-user">getMyParent</span>()
 {
  return this.parent;
 }
 public void <span class="text-user">setMyParent</span>(Cat cat)
 {
  this.parent = cat;
 }
}</code></pre>
</td>
<td></td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>class <span class="text-red">Tiger</span> extends Cat
{
 public <span class="text-red">Tiger</span> <span class="text-user">getMyParent</span>()
 {
  return (<span class="text-red">Tiger</span>) this.parent;
 }
}</code></pre>
</td>
<td>Мы переопределили метод <code><span class="text-red">getMyParent</span></code>, теперь он возвращает объект типа <code><span class="text-red">Tiger</span></code>.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<th>Использование</th>
<th>Почему это «законно»</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>public static void main(String[] args)
{
 Cat parent = new Cat();

 Cat me = new Cat();
 me.setMyParent(parent);
 Cat myParent = me.getMyParent();
}</code></pre>
</td>
<td>Все отлично. Тут мы даже не знаем, что в классе наследнике тип результата метода getMyParent был сужен.</p>
<p>«Старый код» как работал так и работает.</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>public static void main(String[] args)
{
 Tiger parent = new Tiger();

 Tiger me = new Tiger();
 me.setMyParent(parent);
 Tiger myParent = me.getMyParent();
}</code></pre>
</td>
<td>Тут вызывается метод, у которого сузили тип результата.</p>
<p>Если бы этого сделать было нельзя, всегда можно было бы объявить метод в Tiger:<br />
<strong>public Tiger</strong> getMyTigerParent()<br />
{<br />
return (Tiger) this.parent;<br />
}</p>
<p>Т.е. ни о каком нарушении безопасности и/или контроля приведения типов нет речи.</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>public static void main(String[] args)
{
 Tiger parent = new Tiger();

<span class="text-red"> Cat me = new Tiger();</span>
 me.setMyParent(parent);
<span class="text-red"> Cat myParent = me.getMyParent();</span>
}</code></pre>
</td>
<td>И тут все отлично работает, хотя мы расширили тип переменных до базового класса (Cat).</p>
<p>Нет ничего страшного <span class="text-red">при вызове метода getMyParent</span>, т.к. <span class="text-red">его результат</span>, хоть и класса Tiger, все равно <span class="text-red">сможет</span> отлично <span class="text-red">присвоиться в переменную</span> myParent <span class="text-red">базового класса (Cat).</span></p>
<p>Объекты Tiger можно смело хранить как в переменных класса Tiger, так и в переменных класса Cat.</td>
</tr>
</tbody>
</table>
<p><span class="text-user">&#8212; Ага. Я понял. Надо <strong>при переопределении методов беспокоиться о том, как все это будет работать, если мы передадим наши объекты в код, который умеет обращаться только с базовым классом, и ничего о нашем классе не знает.</strong></span></p>
<p>&#8212; Именно! Тогда вопрос на засыпку, почему нельзя расширить тип результата при переопределении метода?</p>
<p><span class="text-user">&#8212; Это же очевидно, тогда перестанет работать код в базовом классе:</span></p>
<table>
<tbody>
<tr>
<th>Код на Java</th>
<th>Пояснение проблемы</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>class Cat
{
 public Cat parent;
 public Cat <span class="text-user">getMyParent</span>()
 {
  return this.parent;
 }
 public void <span class="text-user">setMyParent</span>(Cat cat)
 {
  this.parent = cat;
 }
}</code></pre>
</td>
<td></td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>class Tiger extends Cat
{
 public <span class="text-red">Object</span> <span class="text-user">getMyParent</span>()
 {
  if (this.parent != null)
   return this.parent;
  else
   <span class="text-red">return "я - сирота";</span>
 }
}</code></pre>
</td>
<td>Мы переопределили метод getMyParent и расширили тип его результата.</p>
<p>Тут все отлично.</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>public static void main(String[] args)
{
 Tiger parent = new Tiger();

 Cat me = new Tiger();
 <span class="text-red">Cat myParent = me.getMyParent();</span>
}</code></pre>
</td>
<td>Тогда у нас <span class="text-red">перестанет работать этот код.</span></p>
<p>Метод <span class="text-red">getMyParent может вернуть любой объект типа Object, т.к. на самом деле он вызывается у объекта типа Tiger.</span></p>
<p>А у нас <span class="text-red">нет проверки перед присваиванием.</span> Тогда вполне возможно, что <span class="text-red">переменная myParent типа Cat будет хранить ссылку на строку.</span></td>
</tr>
</tbody>
</table>
<p>&#8212; Отличный пример, Амиго!</p>
<p>В Java <strong>перед вызовом метода не проверяется, есть ли такой метод у объекта или нет. Все проверки происходят во время выполнения.</strong> И [гипотетический] вызов отсутствующего метода, скорее всего, приведет к тому, что программа начнет выполнять байт-код там, где его нет. Это, в конце концов, приведет к фатальной ошибке, и операционная система принудительно закроет программу.</p>
<p><span class="text-user">&#8212; Ничего себе. Буду знать.</span></p>
