Многопоточность или многонитевость
<p>----------------------------------------</p>
Представьте игру «Космические гонки»: вы летите, уворачиваясь от метеоритов и патрульных крейсеров, а рядом  — такие же звездолёты. Приложение игры должно отслеживать команды управления, перемещать звездолеты, рассчитывать их траектории и последствия столкновения, отрисовывать все это на экране пользователя…  Как это сделать? Ответ: многопоточность.
<p>----------------------------------------</p>
<p>&#8212; Привет, Амиго! У нас новая и очень трудная тема. Сочувствую. Часто она считается одной из самых сложных не только в Java, но и в программировании вообще. Это – <em><strong><span class="text-red">многонитевость (multithreading)</span></strong></em>.</p>
<p>Представь себе средненькую компьютерную игру, например, гонки на звездолетах. Ты летишь по просторам космоса, уворачиваясь от метеоритов и патрульных крейсеров, а с тобой еще два десятка таких же участников этих нелегальных гонок.</p>
<p>Допустим, ты решил написать такую же игру. Твоей программе придется отслеживать команды управления (ввод с клавиатуры), перемещать звездолеты, рассчитывать их траектории и последствия столкновения, а также отрисовывать все это на экране пользователя. Это очень сложная работа.</p>
<p>Вспомни, как мы решили «проблему большой сложности» в том примере про рост курьерской компании.</p>
<p><span class="text-user">&#8212; Мы разделили ее на независимые отделы и жестко задали (стандартизировали) способы их взаимодействия.</span></p>
<p><strong>&#8212; Но что делать, когда независимым частям нужно выполнить какой-то объем работы, параллельно с другими частями?! Ответ на этот вопрос – нити(трэды) (или как их неправильно называют – потоки).</strong></p>
<p><strong>Попробуй представить программу, как <span class="text-red">такого маленького робота</span>, который <span class="text-red">бегает по коду и выполняет команды</span>. Сначала выполнил команду, написанную в одной строке, затем перешел на следующую, и так далее.</strong></p>
<p><span class="text-user">&#8212; Представил. Ничего сложного!</span></p>
<p>&#8212; Отлично. А теперь представь, что таких роботов у тебя несколько. И пока один занимается вводом от пользователя, второй меняет объекты в соответствии с ним. Третий выполняет код, по отображению этих объектов на экран, а четвертый несколько раз в секунду проверяет – не столкнулись ли корабли и, в случае столкновения, просчитывает его результаты.</p>
<p>Таким образом, мы можем разделить программу не только на независимые части/объекты, но и добиться того, что эти части будут выполнять свою работу независимо друг от друга. А чем меньше взаимодействия между отдельными частями, тем меньше сложность программы.</p>
<p>Представь, что <strong>ты смог <span class="text-red">заменить менеджера – скриптом</span></strong>, <strong>рассылающим письма</strong>. А остальные отделы компании об этом даже не догадались. Такие примеры уже имели место в 26 веке и показали отличные результаты. <strong>Большинство менеджеров, и даже топ-менеджеров, может быть успешно заменено скриптом средней сложности.</strong> Только после вмешательства «профсоюза офисного планктона» удалось остановить массовые увольнения менеджеров. Но это так – отвлечение от темы.</p>
<p><span class="text-user">&#8212; Как интересно.</span></p>
<p>&#8212; Мало того, что в программе может быть несколько таких «маленьких роботов», исполняющих код, так эти роботы могут еще общаться друг с другом и порождать новых роботов.</p>
<p><span class="text-user">&#8212; Порождать новых роботов?</span></p>
<p>&#8212; Да, для выполнения новых задач. Иногда выгодно создать еще одного робота (еще одну нить), которая будет выполнять какое-то действие одновременно с текущей нитью (роботом).</p>
<p class="text-user">&#8212; Думаю, что это хорошая вещь, хоть пока не могу придумать, где бы я этим пользовался.</p>
<p class="text-user">А почему это называется «нити»?</p>
<p>&#8212; Представь, что все роботы разного цвета, и каждый робот помечает своим цветом все команды, которые он выполнил. Таким образом, за маленьким роботом, как за карандашом, будет тянуться след. Этот след тянется за роботом, как нитка за иголкой.</p>
<p>У каждого такого «маленького робота» есть задание, для исполнения которого его создали. И нить – это набор команд, выполненных в процессе исполнения этого задания.</p>
<p>Допустим, ты летишь на звездолете, чтобы доставить груз. Тогда «доставить груз» &#8212; это твое задание, ты в процессе его исполнения. А путь, который ты пролетел – это твоя нить. Можно сказать, что каждому новому заданию, каждой еще не решенной задаче соответствует своя нить – путь, который еще предстоит пройти.</p>
<p><span class="text-user">&#8212; Другими словами, есть задание и «маленький робот», который его исполняет, а нить – это всего лишь взгляд на текущее положение дел со стороны?</span></p>
<p>&#8212; Именно так.</p>
<p>А вот как все это работает глубоко внутри. Т.к. процессор у компьютера один, то он может выполнять только одну команду одновременно. Поэтому происходит вот что: процессор постоянно переключается между нитями. Переключился на новую нить, выполнил несколько ее команд, затем переключился на следующую нить, выполнил несколько ее команд и так далее. <span class="text-red">Но т.к. переключение между нитями происходит сотни раз в секунду, со стороны кажется, что все нити работают одновременно.</span></p>

<a href='https://cdn.javarush.com/images/article/821343b2-82b0-4b58-9aef-840d7565d6b1/original.jpeg' target='_blank'><img data-id="821343b2-82b0-4b58-9aef-840d7565d6b1" data-max-width="850" alt="Многопоточность или многонитевость - 1" src="https://cdn.javarush.com/images/article/821343b2-82b0-4b58-9aef-840d7565d6b1/original.jpeg"></a>

