Причины существования интерфейсов — поддержка заявленного поведения
<p>----------------------------------------</p>
Интерфейс — это механизм взаимодействия чего-то с чем-то. Вот человек говорит псу «сидеть», то есть, отдает команду в соответствии с «голосовым интерфейсом управления псом». Если пёс команду выполняет, значит он поддерживает этот интерфейс. В программировании — то же самое. Можно объединить методы, действия над объектом и его данными, в интерфейс. Зачем? Узнаете из лекции.
<p>----------------------------------------</p>
<p>&#8212; Привет, Амиго! Хочу сегодня тебе рассказать о причинах существования интерфейсов. Тебе очень часто придется слышать, что такой-то класс, объект или сущность поддерживает определенный интерфейс. Что же это значит – <strong>поддерживать интерфейс</strong>?</p>

<a href='https://cdn.javarush.com/images/article/6c1c13b8-2a0d-457d-be06-09dbc5e92910/original.jpeg' target='_blank'><img data-id="6c1c13b8-2a0d-457d-be06-09dbc5e92910" data-max-width="850" alt="Причины существования интерфейсов &#8212; поддержка заявленного поведения - 1" src="https://cdn.javarush.com/images/article/6c1c13b8-2a0d-457d-be06-09dbc5e92910/original.jpeg"></a>

<p>В более широком смысле интерфейс какой-нибудь вещи – это механизм взаимодействия этой вещи с другими предметами. Например, пульт от телевизора – это дистанционный интерфейс. Собака понимает и исполняет команды &#8212; это значит, что собака поддерживает голосовой интерфейс (управления). Если все это подытожить, то можно сказать, что интерфейс – это стандартизированный способ взаимодействия двух вещей, и этот стандарт известен двум сторонам. Когда человек говорит собаке «сидеть», он отдает команду в соответствии с «голосовым интерфейсом управления собакой», и если собака выполняет эту команду, то мы говорим, что собака поддерживает этот интерфейс.</p>
<p>Так же и в программировании. Методы – это действия над объектом, над его данными. И если класс реализует определенные методы, то он «поддерживает исполнение» определенных команд. Какие же преимущества дает объединение методов в интерфейс?</p>
<p><strong>1)</strong> Каждый <strong>interface</strong>, как и <strong>class</strong>, имеет уникальное имя. Обе стороны могут быть на 100% уверены, что вторая сторона поддерживает именно нужный (известный им) интерфейс, а не похожий.</p>
<p><strong>2)</strong> Каждый интерфейс налагает определенные ограничения на тот класс, который собирается поддерживать его. Класс сам решает (его разработчик), что он будет делать в случае вызова его методов, которые он унаследовал от интерфейса, но результат должен находиться в пределах ожиданий. Если мы скомандовали собаке «сидеть», и она покрутилась 5 минут на месте и села, то это – поддержка интерфейса. А если она вместо этого вцепилась вам в ногу, то ни о какой поддержке тут не может быть и речи. Выполнение команды не привело к ожидаемым результатам.</p>
<p>Допустим, ты с друзьями участвуешь в написании компьютерной игры. И тебе досталась работа запрограммировать поведение одного персонажа. Один ваш коллега уже написал код по отображению всех персонажей на экран. Второй, отвечающий за сохранение игры на диск, написал код по сохранению всех объектов игры в файл. Каждый из них написал много кода и сделал интерфейс для взаимодействия с ним. Например, это может выглядеть так:</p>
<table>
<tbody>
<tr>
<th>Код на Java</th>
<th>Описание</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>interface <span class="text-red">Saveable</span>
{
 void saveToMap(Map&lt;String, Object&gt; map);
 void loadFromMap(Map&lt;String, Object&gt; map);
}</code></pre>
</td>
<td>&#8212; интерфейс по сохранению/загрузке объекта из map’а.</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>interface <span class="text-red">Drawable</span>
{
 void draw(Screen screen);
}</code></pre>
</td>
<td>&#8212; интерфейс по отрисовке объекта внутри переданного объекта screen.</td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>class PacMan <span class="text-red">implements Saveable, Drawable</span>
{
…
}</code></pre>
</td>
<td>&#8212; твой класс, реализующий поддержку двух интерфейсов.</td>
</tr>
</tbody>
</table>
<p>Другими словами, чтобы поддержать реализацию какого-то интерфейса (группы интерфейсов) в своем классе нужно:</p>
<p><strong>1)</strong> Унаследоваться от них</p>
<p><strong>2)</strong> Реализовать объявленные в них методы</p>
<p><strong>3)</strong> Методы должны делать то, для чего они предназначены.</p>
<p>Тогда остальной код программы, который ничего не знает о твоем классе и его объектах, сможет успешно работать с ним.</p>
<p><span class="text-user">&#8212; А почему код может ничего не знать о моем классе?</span></p>
<p>&#8212; Допустим, ты взял код программы, который кто-то написал год назад. Или твои друзья купили/лицензировали движок игры у кого-то еще. Есть рабочий код игры. Тысячи объектов, которые взаимодействуют друг с другом. И они могут с легкостью <strong>правильно взаимодействовать с твоими объектами</strong>, если взаимодействие организовано через интерфейсы, и ты правильно реализовал эти интерфейсы в своих классах.</p>
<p><span class="text-user">&#8212; Круто! Не знал что так можно.</span></p>
<p>&#8212; На этом принципе основаны все большие проекты. Уже давно никто ничего не пишет с нуля.</p>
<p>Люди тоже не изобретают математику и алфавит каждый раз заново, а изучают все то, что было придумано до них.</p>
