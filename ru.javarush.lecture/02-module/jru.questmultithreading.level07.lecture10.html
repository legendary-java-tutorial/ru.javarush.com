Другие детали синхронизации и многонитиевости
<p>----------------------------------------</p>
&#8212; Привет, Амиго! Есть такая здоровенная тема, называется Java Memory Model. В принципе знать ее тебе пока не обязательно, но услышать про это – будет полезно. С целью устранить все возможные проблемы, в Java изменили механизм работы памяти. Теперь память не просто делится на локальный кэш нити и глобальную, а механизм стал еще лучше. &#8212; ...
<p>----------------------------------------</p>
<p>&#8212; Привет, Амиго!</p>
<p>Есть такая здоровенная тема, называется Java Memory Model. В принципе знать ее тебе пока не обязательно, но услышать про это – будет полезно.</p>
<p>С целью устранить все возможные проблемы, в Java изменили механизм работы памяти. Теперь не просто память  делится на локальный кэш нити и глобальную, но и механизм стал еще лучше.</p>
<p><span class="text-user">&#8212; И сложнее!</span></p>
<p>&#8212; Да, лучше и сложнее. Это как самолет. Летать на самолете лучше, чем идти пешком, но сложнее. Попробую объяснить тебе новую ситуацию очень упрощенно.</p>
<p>Вот что было придумано. <span class="text-red"><strong>В код был добавлен механизм синхронизации локальной памяти нитей, названный «happens before» (дословно «случилось перед»). Был придуман ряд правил/условий, при наступлении которых память синхронизируется – обновляется до актуального состояния.</strong></span></p>
<p>Пример:</p>
<table>
<tbody>
<tr>
<th>Порядок</th>
<th>Нить 1</th>
<th>Нить 2</th>
</tr>
<tr>
<td><strong>1</strong><br />
<strong> 2</strong><br />
<strong> …</strong><br />
<strong> 101</strong><br />
<strong> 102</strong><br />
<strong> 103</strong><br />
<strong> 104</strong><br />
<strong> 105</strong><br />
<strong> …</strong><br />
<strong> 201</strong><br />
<strong> 202</strong><br />
<strong> 203</strong><br />
<strong> 204</strong><br />
<strong> 205</strong></td>
<td>
<pre class="line-numbers language-java" data-line="" data-start=""><code><strong>public</strong> int y = 1;
<strong>public</strong> int x = 1;

x=2;
synchronized(mutex)
{
 y = 2;
}</code></pre>
</td>
<td>нить ждет освобождения мютекса &#8212; mutex</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>synchronized(mutex)
{
<strong> if</strong> (y == x)
 System.out.println("YES");
}</code></pre>
</td>
</tr>
</tbody>
</table>
<p>Одно из таких условий – это захват освобожденного мютекса. Если мютекс был освобожден и снова захвачен, то перед захватом обязательно выполнится синхронизация памяти. Нить 2 увидит «самые новые» значения переменных x и y, даже если не объявлять их volatile.</p>
<p><span class="text-user">&#8212; Как интересно. И много таких условий?</span></p>
<p>&#8212; Достаточно, вот некоторые условия синхронизации памяти:</p>
<ul>
<li>В рамках одной нити любая команда <strong>happens-before</strong> (читается «случается перед») любой операцией, следующей за ней в исходном коде.</li>
<li>Освобождение лока (unlock) <strong>happens-before </strong>захватом того же лока (lock).</li>
<li>Выход из <strong>synchronized</strong> блока/метода <strong>happens-before</strong> вход в synchronized блок/метод на том же мониторе.</li>
<li>Запись volatile поля <strong>happens-before</strong> чтение того же самого volatile поля.</li>
<li>Завершение метода run экземпляра класса Thread <strong>happens-before</strong> выход из метода join() или возвращение false методом isAlive() экземпляром той же нити.</li>
<li>Вызов метода start() экземпляра класса Thread <strong>happens-before</strong> начало метода run() экземпляра той же нити.</li>
<li>Завершение конструктора <strong>happens-before</strong> начало метода finalize() этого класса</li>
<li>Вызов метода interrupt() на нити <strong>happens-before</strong>, когда нить обнаружила, что данный метод был вызван, либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted()</li>
</ul>
<p><span class="text-user">&#8212; Т.е. все немного сложнее, чем я думал?</span></p>
<p>&#8212; Да, немного сложнее…</p>
<p><span class="text-user">&#8212; Спасибо, Риша, буду думать.</span></p>
<p>&#8212; Не заморачивайся сильно на эту тему. Придет время, сам все поймешь. Пока тебе лучше разбираться в основах, чем лезть в дебри внутреннего устройства Java-машины.</p>
<p><span class="text-user">&#8212; О_о. М-да. Некоторые вещи лучше не знать.</span></p>
