Принципы инкапсуляции
<p>----------------------------------------</p>
Сегодняшнюю лекцию посвятим инкапсуляции и начнем ее сразу с примеров :) Перед тобой — привычный автомат с газировкой. У меня к тебе один вопрос: а как он работает? Попробуй ответить подробно: откуда вываливается стакан, как поддерживается температура внутри ...
<p>----------------------------------------</p>
Привет! Сегодняшнюю лекцию посвятим инкапсуляции и начнем ее сразу с примеров :)

<img data-id="cd065697-891d-46fe-9429-a3bf741cf71f" data-max-width="850" alt="Принципы инкапсуляции - 1" src="https://cdn.javarush.com/images/article/cd065697-891d-46fe-9429-a3bf741cf71f/1024.jpeg">Перед тобой — <em>привычный автомат с газировкой</em>. У меня к тебе один вопрос: а как он работает? Попробуй ответить подробно: откуда вываливается стакан, как поддерживается температура внутри, где хранится лед, как автомат понимает, какой сироп добавить и т.д.

Вероятнее всего, ответов на эти вопросы у тебя нет. Хорошо, возможно не все пользуются такими автоматами, в нынешнее время они не настолько популярны.

Попробуем привести другой пример. Что-нибудь, чем ты точно пользуешься много раз каждый день.

О, есть идея!
<img data-id="3a3c8ba1-d3e2-4818-8766-d840c278e19b" data-max-width="850" alt="Принципы инкапсуляции - 2" src="https://cdn.javarush.com/images/article/3a3c8ba1-d3e2-4818-8766-d840c278e19b/1024.jpeg">
Расскажи, как работает <em>поисковик Google</em>. Как именно он ищет информацию по тем словам, которые ты ввел? Почему наверху находятся эти результаты, а не другие? 

Хотя ты пользуешься гуглом каждый день, скорее всего, ты этого не знаешь. Но это не важно. <strong>Ведь тебе и не нужно этого знать.</strong>

Ты можешь вводить запросы в поисковик не задумываясь, как именно он работает. Ты можешь купить газировку в автомате, не зная как он устроен. Ты можешь водить машину, не вникая в работу двигателя внутреннего сгорания, и вообще не зная физику даже на школьном уровне.

Все это возможно благодаря одному из главных принципов объектно-ориентированного программирования — <strong>инкапсуляции</strong>.

Читая разные статьи на эту тему, наверняка ты сталкивался с тем, что в программировании есть два распространенных понятия — <strong>инкапсуляция</strong> и <strong>сокрытие</strong>. И под словом «инкапсуляция» авторы понимают то одно, то другое (так уж сложилось). Мы разберем оба термина, чтобы у тебя было полное понимание.

Изначальное значение слова «<em>инкапсуляция</em>» в программировании — <strong>объединение данных и методов работы с этими данными в одной упаковке</strong> («капсуле»).

В Java в роли упаковки-капсулы выступает <em>класс</em>. Класс содержит в себе и <em>данные</em> (поля класса), и <em>методы</em> для работы с этими данными. 
<img data-id="5fe85c7c-7d12-4195-aca8-111e1c0992d9" data-max-width="850" alt="Принципы инкапсуляции - 3" src="https://cdn.javarush.com/images/article/5fe85c7c-7d12-4195-aca8-111e1c0992d9/1024.jpeg">
Тебе это кажется очевидным, но в других концепциях программирования все устроено иначе. Например, в функциональном программировании данные строго отделены от операций над ними.

В ООП же (объектно-ориентированном программировании) программы состоят из классов-капсул, которые являются одновременно и данными, и функциями для работы с ними.

Теперь поговорим о <strong>сокрытии</strong>.

Как же так получается, что мы пользуемся всякими сложными механизмами без понимания, как они устроены и на чем основана их работа? Все просто: их создатели предоставили простой и удобный <strong>интерфейс</strong>.

На автомате с газировкой интерфейс — это кнопки на панели. Нажав одну кнопку, ты выбираешь объем стакана. Нажав вторую, выбираешь сироп. Третья отвечает за добавление льда. И это все, что тебе нужно сделать.

Неважно, как именно автомат устроен внутри. Главное — <strong>он устроен так, что для получения газировки пользователю нужно нажать три кнопки</strong>.

То же и с автомобилем. Неважно, что там происходит у него внутри. Главное —<strong> при нажатии правой педали автомобиль едет вперед, а при нажатии левой — тормозит</strong>.

Именно в этом заключается суть сокрытия. Все «внутренности» программы скрываются от пользователя. Для него эта информация является лишней, ненужной. Пользователю необходим конечный результат, а не внутренний процесс.

Давай для примера посмотрим на класс <code>Auto</code>:

<pre class="lang-java line-numbers"><code>
public class Auto {

   public void gas() {

       /*внутри автомобиля происходят какие-то сложные вещи
       в результате которых он едет вперед*/
   }

   public void brake() {

       /*внутри автомобиля происходят какие-то сложные вещи
       в результате которых он тормозит*/
   }

   public static void main(String[] args) {

       Auto auto = new Auto();

       //Как все выглядит для пользователя

       //нажал одну педаль - поехал
       auto.gas();
      
       //нажал другую педаль - затормозил
       auto.brake();
   }
}
</code></pre>
Вот как выглядит сокрытие реализации в Java-программе. Все как в реальной жизни: пользователю предоставлен интерфейс (методы). Если ему нужно, чтобы автомобиль в программе выполнил действие, достаточно вызвать нужный метод. А уж что там происходит внутри этих методов — информация лишняя, главное, чтобы все работало как надо.

Здесь мы говорили про <strong>сокрытие реализации</strong>. Кроме него в Java есть еще <strong>сокрытие данных</strong>. О нем мы писали в <a href="https://javarush.com/groups/posts/1928-getterih-i-setterih" target="_blank">лекции про геттеры и сеттеры</a>, но не будет лишним напомнить.

Например, у нас есть класс <code>Cat</code>:

<pre class="lang-java line-numbers"><code>
public class Cat {

   public String name;
   public int age;
   public int weight;

   public Cat(String name, int age, int weight) {
       this.name = name;
       this.age = age;
       this.weight = weight;
   }

   public Cat() {
   }

   public void sayMeow() {
       System.out.println("Мяу!");
   }

  
}
</code></pre>
Возможно, ты запомнил из прошлой лекции, в чем проблема этого класса? Если нет — давай вспомним.

Проблема в том, что его данные (поля) открыты для всех, и другой программист легко может создать в программе безымянного кота с весом 0 и возрастом -1000 лет:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   Cat cat = new Cat();
   cat.name = "";
   cat.age = -1000;
   cat.weight = 0;

}
</code></pre>
В такой ситуации можно пристально следить за тем, не создает ли кто-то из твоих коллег объектов с неправильным состоянием, но гораздо лучше было бы исключить саму возможность создавать такие «неправильные объекты».
<img data-id="70d6b15d-d3a7-4cee-b562-4a9537ab78d0" data-max-width="850" alt="Принципы инкапсуляции - 4" src="https://cdn.javarush.com/images/article/70d6b15d-d3a7-4cee-b562-4a9537ab78d0/1024.jpeg">
С сокрытием данных нам помогают:

<ol>
<li>модификаторы доступа (<em>private</em>, <em>protected</em>, <em>package default</em>);</li>
<li>геттеры и сеттеры.</li>
</ol>
Туда можем, например, заложить проверку, не пытается ли кто-то присвоить коту отрицательное число в качестве возраста.

Как мы говорили ранее, авторы разных статей об инкапсуляции имеют в виду либо инкапсуляцию (объединение данных и методов), либо сокрытие, либо и то, и другое. В Java присутствуют оба механизма (в других ООП-языках это не обязательно так), так что последний вариант будет наиболее правильным.

Использование инкапсуляции дает нам несколько важных преимуществ:

<ol>
<li><strong>Контроль за корректным состоянием объекта.</strong> Примеры этому были выше: благодаря сеттеру и модификатору private, мы обезопасили нашу программу от котов с весом 0.</li><br>
<li><strong>Удобство для пользователя за счет интерфейса.</strong> Мы оставляем «снаружи» для доступа пользователя только методы. Ему достаточно вызвать их, чтобы получить результат, и совсем не нужно вникать в детали их работы.</li><br>
<li><strong>Изменения в коде не отражаются на пользователях.</strong> Все изменения мы проводим внутри методов. На пользователя это не повлияет: он как писал auto.gas() для газа машины, так и будет писать. А то, что мы поменяли что-то в работе метода gas() для него останется незаметным: он, как и раньше, просто будет получать нужный результат.</li>
</ol>