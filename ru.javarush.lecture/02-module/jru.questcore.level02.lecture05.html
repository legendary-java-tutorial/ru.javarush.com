Абстрактные классы
<p>----------------------------------------</p>
Очень часто вам нужно описать в программе что-то неконкретное, базовое. Например, «автомобиль». У него будет двигатель и кузов. Это не машина, а  всего лишь абстракция — класс, который мы сделали для удобства. А уже на его базе можно «Феррари» или «Ладу» сварганить. В лекции — подробности. Интересные.
<p>----------------------------------------</p>
<p>&#8212; Привет, Амиго! Новая интересная тема.</p>
<p><span class="text-user">&#8212; Да сегодня просто день интересных тем!!</span></p>
<p>&#8212; Спасибо!</p>
<p><span class="text-user">&#8212; Да не за что.</span></p>
<p>&#8212; Помнишь ситуацию, когда <span class="text-corporate">мы ввели базовый класс ChessItem для упрощения всех классов шахматных фигур?</span></p>
<p><span class="text-user">&#8212; Да.</span></p>
<p>&#8212; Теперь представь, что у каждой фигуры есть метод, который занимается ее отрисовкой на экране. Вызываешь метод, и фигура сама себя рисует в своих текущих координатах. Удобно было бы вынести этот метод в базовый класс?</p>
<p><span class="text-user">&#8212; Да. После того, что я узнал о полиморфизме, можно было бы вызывать метод отрисовки для всех фигур, независимо от их типа. Примерно так:</span></p>
<div class="code-heading">Пример</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code>class ChessBoard
{
  public void drawAllChessItems()
  {
  //добавляем фигуры в список
  ArrayList&lt;ChessItem&gt; <mark>items</mark> = new ArrayList&lt;&gt;();
  <mark>items</mark>.add(new King());
  <mark>items</mark>.add(new Queen());
  <mark>items</mark>.add(new Bishop());

  //рисуем их независимо от их типа.
  for (ChessItem item: <mark>items</mark>)
  {
   item.draw(); 
  }
 }
}</code></pre>
<p>&#8212; Молодец. Именно так. А что бы отрисовал на экране метод draw самого класса ChessItem?</p>
<p><span class="text-user">&#8212; Не знаю. Такой фигуры ведь в шахматах нет. Значит, и изображения у нее нет.</span></p>
<p>&#8212; Именно. Более того, создавать объекты типа ChessItem – не имеет смысла. Это не фигура из шахмат, <span class="text-red">всего лишь <em>абстракция</em> &#8212; класс, который мы сделали для удобства.</span> Так работает абстракция из ООП: мы вынесли важные (общие для всех фигур) данные и методы в базовый класс, а их различия оставили в их классах.</p>

<a href='https://cdn.javarush.com/images/article/2129890f-7564-412c-b4b8-e0830036e767/original.jpeg' target='_blank'><img data-id="2129890f-7564-412c-b4b8-e0830036e767" data-max-width="850" alt="Абстрактные классы - 1" src="https://cdn.javarush.com/images/article/2129890f-7564-412c-b4b8-e0830036e767/original.jpeg"></a>

<p>Для такого случая в Java есть специальный тип классов – <strong>абстрактные классы</strong>. Вот четыре вещи, которые стоит помнить об абстрактных классах.</p>
<p><strong>1)</strong> <span class="text-green">Абстрактный класс может содержать объявление метода без его реализации.</span> Такой метод называется абстрактным.</p>
<div class="code-heading">Пример</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code> public <span class="text-red">abstract</span> class ChessItem
{
 public int x, y; //координаты
 private int value; // «ценность» фигуры

 public int getValue() //обычный метод, возвращает значение value
 {
   return value;
 }

 <span class="text-red">public abstract void draw();</span> //абстрактный метод. Реализация отсутствует.

}</code></pre>
<div class="task-widget-container" showCover="true" taskKey="com.javarush.task.task12.task1234"></div>
<p><strong>2)</strong> <span class="text-green">Абстрактный метод помечается специальным ключевым словом <strong>abstract</strong>.</span></p>
<p>Если в классе есть хоть один абстрактный метод, класс тоже помечается ключевым словом abstract.</p>
<p><strong>3)</strong> <span class="text-red">Создавать объекты абстрактного класса нельзя.</span> Такой код просто не скомпилируется.</p>
<table>
<tbody>
<tr>
<th>Код на Java</th>
<th>Описание</th>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>ChessItem item = <span class="text-red">new ChessItem</span>();
item.draw();</code></pre>
</td>
<td><span class="text-red">Этот код не скомпилируется</span></td>
</tr>
<tr>
<td>
<pre class="line-numbers language-java block-inline" data-line="" data-start=""><code>ChessItem item = <span class="text-green">new Queen</span>();
item.draw();</code></pre>
</td>
<td><span class="text-green">А так можно.</span></td>
</tr>
</tbody>
</table>
<p><strong>4)</strong> Если ты наследовал свой класс от абстрактного класса, то нужно переопределить все унаследованные абстрактные методы &#8212; написать для них реализацию. Иначе такой класс тоже придется объявить абстрактным. <span class="text-red">Если в классе есть хотя-бы один нереализованный метод, объявленный прямо в нем или унаследованный от класса-родителя, то класс считается абстрактным.</span></p>
<p><span class="text-user">&#8212; А зачем это все нужно? Зачем нужны абстрактные классы? Разве нельзя вместо них использовать обычные? А вместо абстрактных методов просто писать две скобочки в качестве тела метода &#8212; {} ?</span></p>
<p>&#8212; Можно. Но эти ограничения сродни модификатору <code>private</code>. Мы специально запрещали с помощью <code>private</code> прямой доступ к данным, чтобы другие программисты и их классы пользовались только написанными нами <code>public</code>-методами.</p>
<p>То же и с абстрактным классом. <span class="text-green">Тот, кто написал этот класс, не хочет, чтобы создавались его объекты.</span> Наоборот, он рассчитывает на то, чтобы от его абстрактного класса наследовались и переопределяли абстрактные методы.</p>
<p><span class="text-user">&#8212; Все равно не понятно, зачем усложнять себе жизнь?</span></p>
<p>&#8212; Преимущество этого проявляется в больших проектах. Чем больше классов, тем чётче приходится очерчивать их роли. Ты увидишь преимущество этого, и уже в ближайшем будущем. Все через это проходят.</p>
