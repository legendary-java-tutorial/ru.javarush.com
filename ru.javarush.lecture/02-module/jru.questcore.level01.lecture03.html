Еще одно объяснение ООП (слабая связность, четкие функции)
<p>----------------------------------------</p>
Внутреннюю структуру продукта нужно поддерживать в таком состоянии, которое позволит внести значительные (и не очень) изменения с минимальными переделками. Именно объектно-ориентированный подход позволяет компаниям работать над огромными проектами и не загибаться, переделывая суть.
<p>----------------------------------------</p>
<p>&#8212; Привет, Амиго! Хотела тебе рассказать еще об одном преимуществе использования ООП. Видишь ли – программы больше напоминают не строения, а животных. <span class="text-green"><strong>Их не строят, их выращивают. </strong>Разработка &#8212; это постоянные изменения.</span> В строительстве ты можешь иметь хороший план и четко ему следовать. В случае с разработкой программ – это не так.</p>
<p>Очень часто что-то нельзя сделать тем способом, который ты себе наметил, и приходится многое переделывать. Еще чаще меняются требования заказчика.</p>
<p><span class="text-user">&#8212; А если заказчик проекта дал очень точную его спецификацию?</span></p>
<p>&#8212; Тогда взгляни на ситуацию во времени. <span class="text-corporate">Успех продукта приведет к тому, что заказчик захочет выпустить его новую версию, а затем еще и еще.</span> И, конечно, нужно будет всего лишь добавить «<strong>небольшие изменения</strong>» в уже существующий продукт. <span class="text-green">Поэтому разработка продукта – это последовательность постоянных изменений. </span>Только масштаб времени разный. Каждая новая версия может выходить раз в неделю, раз в месяц или раз в полгода.</p>
<p><span class="text-user">&#8212; И какой вывод можно сделать из всего этого?</span></p>
<p><span class="text-red">&#8212; Внутреннюю структуру продукта нужно поддерживать в таком состоянии, которое позволит внести значительные (и не очень) изменения с минимальными переделками.</span></p>
<p><span class="text-user">&#8212; И как такое сделать?</span></p>
<p>&#8212; Мы уже говорили, что программа состоит из объектов, которые взаимодействуют между собой. Давай нанесем на доску все объекты нашей программы, обозначив их жирными точками. И проведем от каждого объекта (точки) стрелочки ко всем объектам (точкам), с которыми он взаимодействует.</p>
<p>Теперь мы будем объединять объекты (точки) в группы. Точки должны быть объединены в группу, если связи между ними гораздо интенсивнее, чем с остальными точками. Если большинство стрелочек от точки идет к точкам ее же группы, тогда разбиение на группы произошло правильно. Точки внутри одной группы мы будем называть сильно связанными, а точки из разных групп – слабо связанными.</p>
<p>Это называется «<strong>принцип слабой связности</strong>». Программа разбивается на несколько частей, часто слоев, логика которых сильно завязана на их внутреннее устройство и очень слабо на другие слои/части. <span class="text-corporate">Обычно взаимодействие слоев очень регламентировано. Один слой может обращаться ко второму и использовать только небольшую часть его классов.</span></p>
<p><span class="text-user">&#8212; Тот же принцип «разделения на отделы» только в большем масштабе?</span></p>
<p>&#8212; Именно. Это приводит к тому, что мы можем реорганизовать отдел, повысить его эффективность, нанять в него еще больше людей, но если мы не изменим протокол взаимодействия других отделов с нашим, то все сделанные изменения останутся локальными. Никому не придется переучиваться. Не придется переделывать всю систему. Каждый отдел может заниматься такой внутренней оптимизацией, если общие механизмы взаимодействия выбраны удачно.</p>
<p><span class="text-user">&#8212; Выбраны удачно. А что будет, если они выбраны неудачно?</span></p>
<p>&#8212; Тогда «<strong>запас изменений</strong>» быстро иссякнет и придется переделывать всю систему. Такое приходится делать время от времени. Нельзя предугадать, что будет в будущем, но можно свести количество таких переделок к минимуму.</p>
<p><span class="text-user">&#8212; Хорошо. Про пользу такого разделения я понял, а ООП тут причем?</span></p>
<p>&#8212; Выбор структуры отделов и способа их взаимодействия – это «принцип Абстракции». В программировании он используется для определения, на какие части лучше разбить программу, и как эти части должны взаимодействовать. Данный принцип также можно применять к разделению полученных частей, пока мы не разобьем программу на отдельные классы.</p>
<p><span class="text-user">&#8212; А сокрытие внутренней структуры этих частей, и жёсткие ограничения на взаимодействие с другими частями – это Инкапсуляция, да?</span></p>
<p>&#8212; Именно. Инкапсуляция + Абстракция – это краеугольные камни <a href='https://javarush.com/groups/posts/principy-oop' target='_blank'>ООП</a>. Хорошая программа обязана следовать этим двум принципам. В дальнейшем мы рассмотрим остальные принципы и поймем, какие преимущества они дают.</p>
<p><span class="text-user">&#8212; Очень интересно. Жду с нетерпением.</span></p>
