Метод finalize, интерфейс closeable, try-with-resources(java7)
<p>----------------------------------------</p>
&#8212; Привет, Амиго! Я тут решила с тобой еще раз обсудить метод finalize(). Если ты помнишь, то finalize() – это специальный метод, который вызывается у объекта перед тем, как сборщик мусора его уничтожит. Основная цель этого метода – освободить используемые внешние не-Java ресурсы: закрыть файлы, потоки ввода-вывода и т.п. К сожалению, этот метод не оправдывает ...
<p>----------------------------------------</p>

<a href='https://cdn.javarush.com/images/article/e6882b0c-4466-408c-920e-f8e6823aab5d/original.jpeg' target='_blank'><img data-id="e6882b0c-4466-408c-920e-f8e6823aab5d" data-max-width="850" alt="Метод finalize, интерфейс closeable, try-with-resources(java7) - 1" src="https://cdn.javarush.com/images/article/e6882b0c-4466-408c-920e-f8e6823aab5d/original.jpeg"></a>

<p>&#8212; Привет, Амиго!</p>
<p>Я тут решила с тобой еще раз обсудить метод <strong>finalize</strong>().</p>
<p>Если ты помнишь, то finalize() – это специальный метод, который вызывается у объекта перед тем, как<br />
сборщик мусора его уничтожит.</p>
<p>Основная цель этого метода – освободить используемые внешние не-Java ресурсы: закрыть файлы, потоки ввода-вывода и т.п.</p>
<p>К сожалению, этот метод не оправдывает возложенных на него надежд. Java-машина может отложить уничтожение объекта, как и вызов метода finalize на сколько угодно. Более того, она вообще не гарантирует, что этот метод будет вызван. В куче ситуаций ради «оптимизации» он не вызывается.</p>
<p>Приведу тебе две цитаты:</p>
<table>
<tbody>
<tr>
<td>У Джошуа Блоха хорошо написано об этом методе: <a href="http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=7">link</a><br />
Краткая выдержка:</p>
<ol>
<li>finalize() можно использовать только в двух случаях:
<ol start="1.2">
<li><span style="font-family: inherit; font-size: inherit; color: inherit;">Проверка/подчистка ресурсов с логированием.</span></li>
<li>При работе с нативным кодом, который не критичен к утечке ресурсов.</li>
</ol>
</li>
<li>finalize() замедляет работу GC по очистке объекта в 430 раз</li>
<li>finalize() может быть не вызван</li>
</ol>
</td>
</tr>
<tr>
<td>Если я на собеседовании скажу, что finalize &#8212; это вредный и опасный костыль, который своим существованием сбивает с толку, то буду прав?</td>
</tr>
</tbody>
</table>
<p><span class="text-user">&#8212; М-да, обрадовала ты меня, Элли.</span></p>
<p>&#8212; На замену метода <strong>finalize</strong> в Java 7 появилась новая конструкция. Называется она – <strong>try-with-resources</strong>. Это не совсем замена <strong>finalize</strong> – скорее альтернативный подход.</p>
<p><span class="text-user">&#8212; Как try-catch, только с ресурсами?</span></p>
<p>&#8212; Почти как <strong>try-catch</strong>. Дело в том, что в отличие от метода <strong>finalize</strong>(), блок <strong>finally</strong> из конструкции <strong>try-catch-finally</strong> вызывается всегда. Этим и пользовались программисты, когда нужно было гарантированно освободить ресурсы, закрыть потоки и т.д.<br />
Пример:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>InputStream is = null;
try
{
 is = new FileInputStream("c:/file.txt");
 is.read(…);
}
finally
{
 if (is != null)
 is.close();
}</code></pre>
<p>Независимо от того, нормально ли отработал блок <strong>try</strong>, или там возникло исключение, блок <strong>finally</strong> вызовется всегда, и там можно будет освободить занятые ресурсы.</p>
<p>Поэтому в Java 7 этот подход решили сделать официальным, и вот что из этого вышло:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>try(InputStream is = new FileInputStream("c:/file.txt"))
{
 is.read(…);
}</code></pre>
<p>Это специальная конструкция <strong>try</strong>, называемая <strong>try-with-resources</strong> (так же как и второй <strong>for</strong> для коллекций называется <strong>foreach</strong>).</p>
<p>Обрати внимание – после try следуют круглые скобки, где объявляются переменные и создаются объекты. Эти объекты можно использовать внутри блока try, обозначенного скобками {}. Когда выполнение команд блока try закончится, независимо от того – нормально оно закончилось или было исключение, для объекта, созданного внутри круглых скобок (), будет вызван метод close();</p>
<p><span class="text-user">&#8212; Как интересно. Такая запись гораздо компактнее, чем предыдущая. Понять бы ее еще.</span></p>
<p>&#8212; Все не так сложно, как ты думаешь.</p>
<p><span class="text-user">&#8212; А я могу указывать в круглых скобках объекты своих классов?</span></p>
<p>&#8212; Да, конечно, иначе от этих скобок было бы мало пользы.</p>
<p><span class="text-user">&#8212; А если мне нужно вызвать другой метод при выходе из блока try, где мне его указать?</span></p>
<p>&#8212; Тут все немного тоньше. В Java 7 появился такой интерфейс:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>public interface AutoCloseable
{
 void close() throws Exception;
}</code></pre>
<p>Ты можешь унаследовать свой класс от такого интерфейса. И тогда его объекты можно будет использовать внутри try-with-resources. Только объекты такого типа можно использовать внутри круглых скобок try-with-resources для «автоматического закрытия».</p>
<p><span class="text-user">&#8212; Т.е. мне нужно будет переопределить метод close и написать в нем код по «очистке» моего объекта, а указать другой метод нельзя?</span></p>
<p>&#8212; Ага. Зато можно указывать несколько объектов, разделив их точкой с запятой:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>try(
InputStream is = new FileInputStream("c:/file.txt");
OutputStream os = new FileOutputStream("c:/output.txt")
)
{
 is.read(…);
 os.write(…);
}</code></pre>
<p><span class="text-user">&#8212; Уже лучше, но не так круто, как я надеялся.</span></p>
<p>&#8212; Все не так плохо, ты привыкнешь. Со временем.</p>
