Стратегии избегания DeadLock
<p>----------------------------------------</p>
&#8212; Привет, Амиго! Хочу рассказать тебе про пару стратегий избегания дедлоков. Самая лучшая стратегия – это продуманная архитектура и набор правил, когда можно использовать блокировки (захват мютексов) и в каком порядке. Классический способ борьбы с проблемой — разработка иерархии блокировок, установление правила, что некоторые блокировки никогда не могут захватываться в состоянии, в котором уже захвачены ...
<p>----------------------------------------</p>

<a href='https://cdn.javarush.com/images/article/263ae66f-8073-43c1-b216-05e5b8d8e419/original.jpeg' target='_blank'><img data-id="263ae66f-8073-43c1-b216-05e5b8d8e419" data-max-width="850" alt="Стратегии избегания DeadLock - 1" src="https://cdn.javarush.com/images/article/263ae66f-8073-43c1-b216-05e5b8d8e419/original.jpeg"></a>

<p>&#8212; Привет, Амиго!</p>
<p>Хочу рассказать тебе про пару стратегий избегания дедлоков.</p>
<p>Самая лучшая стратегия – это продуманная архитектура и набор правил, когда можно использовать блокировки (захват мютексов) и в каком порядке. Классический способ борьбы с проблемой — разработка иерархии блокировок, установление правила, что некоторые блокировки никогда не могут захватываться в состоянии, в котором уже захвачены какие-то другие блокировки.</p>
<p>Иногда, например, блокировкам присваивают уровни, требуя при этом от нити захватывать блокировки в порядке от большего уровня к меньшему, но не в обратном. Так же нельзя захватывать несколько блокировок одного уровня.</p>
<p>Например, в предыдущем примере про рыцарей, каждому рыцарю можно добавить его уникальный номер (id) и потребовать, чтобы блокировки происходили от большего id к меньшему.</p>
<div class="code-heading">Пример</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code><strong>class</strong> KnightUtil
{
 <strong>public</strong> <strong>static</strong> void kill(Knight knight1, Knight knight2)
 {
  Knight knightMax = knight1.id &gt; knight2.id ? knight1: knight2;
  Knight knightMin = knight1.id &gt; knight2.id ? knight2: knight1;

  <strong>synchronized</strong>(knightMax)
  {
   <strong>synchronized</strong>(knightMin)
   {
    knight2.live = 0;
    knight1.experience +=100;
   } 
  }
 }
}</code></pre>
<p><span class="text-user">&#8212; Красивое решение.</span></p>
<p>&#8212; Это очень простое решение, но мне нравится. Надеюсь, оно тебе пригодится, когда ты будешь думать, как решать возможные проблемы с дедлоками.</p>
<p><span class="text-user">&#8212; Спасибо, Элли.</span></p>
