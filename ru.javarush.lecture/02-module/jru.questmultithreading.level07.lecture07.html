Стратегия &#171;wait-notify-notifyAll&#187;
<p>----------------------------------------</p>
&#8212; Привет, Амиго! Хочу основательно разобрать с тобой тему wait-notify. Методы wait-notify обеспечивают удобный механизм взаимодействия нитей. Также их можно использовать для построения сложных высокоуровневых механизмов взаимодействия нитей. Начну с небольшого примера. Пусть у нас есть программа для сервера, которая должна выполнять различные задания, которые пользователи добавляют через сайт. Пользователи добавляют различные задания в разное ...
<p>----------------------------------------</p>

<a href='https://cdn.javarush.com/images/article/dfcfe1de-b1b1-4965-bbb0-8763e1fe4c4c/original.jpeg' target='_blank'><img data-id="dfcfe1de-b1b1-4965-bbb0-8763e1fe4c4c" data-max-width="850" alt="Стратегия &#171;wait-notify-notifyAll&#187; - 1" src="https://cdn.javarush.com/images/article/dfcfe1de-b1b1-4965-bbb0-8763e1fe4c4c/original.jpeg"></a>

<p>&#8212; Привет, Амиго!</p>
<p>Хочу основательно разобрать с тобой тему wait-notify. Методы wait-notify обеспечивают удобный механизм взаимодействия нитей. Также их можно использовать для построения сложных высокоуровневых механизмов взаимодействия нитей.</p>
<p>Начну с небольшого примера. Пусть у нас есть программа для сервера, которая должна выполнять различные задания, которые пользователи добавляют через сайт. Пользователи добавляют различные задания в разное время. Задачи ресурсоемкие, но сервер у нас с восьмиядерным процессором &#8212; справится. Как исполнять задачи на сервере?</p>
<p>Во-первых, мы создадим группу нитей-исполнителей, столько же, сколько и количество ядер процессора. Каждая нить сможет работать на своем ядре: нити не будут друг другу мешать, а ядра процессора не будут простаивать.</p>
<p>Во-вторых, создадим объект-очередь, в который будут помещаться полученные от пользователей задания. Разным типам заданий будут соответствовать различные объекты, но все они будут реализовать интерфейс Runnable, чтобы их можно было выполнить.</p>
<p><span class="text-user">&#8212; А можно пример такого объекта-задания?</span></p>
<p>&#8212; Вот смотри:</p>
<div class="code-heading">Класс вычисляет факториал числа n при вызове метода run()</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code><strong>class</strong> Factorial <strong>implements Runnable</strong>
{
 <strong>public</strong> int n = 0;
 <strong>public</strong> long result = 1;

 <strong>public</strong> Factorial (int n)
 {
  this.n = n;
 }

 <strong>public void run</strong>()
 {
  <strong>for</strong> (int i=2;i&lt;=n;i++)
   result*=i;
 }
}</code></pre>
<p><span class="text-user">&#8212; Пока ясно.</span></p>
<p>&#8212; Отлично. Тогда разберем, как должен выглядеть объект-очередь. Что ты можешь сказать про него?</p>
<p><span class="text-user">&#8212; Он должен быть thread-safe. В него кладутся объекты-задания (таски) нитью, которая принимает их от пользователей, а забираются задания нитями-исполнителями.</span></p>
<p>&#8212; Ага. А если задания временно закончились?</p>
<p><span class="text-user">&#8212; Тогда нити-исполнители должны ждать, пока они появятся.</span></p>
<p>&#8212; Верно. Тогда представь, что все это можно встроить в одну очередь. Вот смотри:</p>
<div class="code-heading">Очередь заданий, если задания нет, то нить засыпает и ждет его появления:</div>
<pre class="line-numbers language-java" data-line="" data-start=""><code><strong>public</strong> <strong>class</strong> JobQueue
{
 ArrayList jobs = new ArrayList();

 <strong>public synchronized</strong> void <strong>put</strong>(Runnable job)
 {
  jobs.add(job);
  this.<strong><span class="text-red">notifyAll</span></strong>();
 }

 public synchronized Runnable getJob()
 {
  while (jobs.size()==0)
   this.<strong><span class="text-red">wait</span></strong>();

  return jobs.remove(0);
 }
}</code></pre>
<p>У нас есть метод <strong>getJob</strong>, который смотрит, если список работы (jobs) пуст, то нить засыпает (wait), пока в списке что-то не появится.</p>
<p>А есть еще метод <strong>put</strong>, который позволяет добавить в список jobs новое задание (job). Как только новое задание добавлено, вызывается метод <strong>notifyAll</strong>. Вызов этого метода пробудит все нити-исполнители, которые заснули внутри метода getJob.</p>
<p><span class="text-user">&#8212; А можешь напомнить еще раз, как работают методы wait и notify?</span></p>
<p>&#8212; Метод wait вызывается только внутри блока synchronized, у объекта-мютекса. В нашем случае – это this. При этом происходит две вещи:</p>
<p><strong>1)</strong> Нить засыпает.</p>
<p><strong>2)</strong> Нить временно освобождает мютекс (пока не проснется).</p>
<p>После этого другие нити могут входить в блок synchronized и занимать этот же мютекс.</p>
<p>Метод <strong>notifyAll</strong> тоже можно вызвать только внутри блока synchronized у объекта-мютекса. В нашем случае – это this. При этом происходит две вещи:</p>
<p><strong>1)</strong> Просыпаются все нити, которые заснули на этом же объекте-мютексе.</p>
<p><strong>2) Как только текущая нить выйдет из блока synchronized, одна из проснувшихся нитей захватит мютекс и продолжит свою работу. Когда она освободит мютекс, другая проснувшаяся нить захватит мютекс и т.д.</strong></p>
<p>Очень похоже на автобус. Вы заходите внутрь, хотите передать за проезд, а водителя нет. И вы «засыпаете». Со временем вас набивается целый автобус, но за проезд пока никто не передает – некому. Затем заходит водитель, вы слышите « – Передаем за проезд». И тут начинается&#8230;</p>
<p><span class="text-user">&#8212; Интересное сравнение. А что такое автобус?</span></p>
<p>&#8212; А это Хулио рассказывал. Были такие странные штуки в 21 веке.</p>
