Метод clone, интерфейс Cloneable
<p>----------------------------------------</p>
&#8212; Привет, Амиго! &#8212; Привет, Ким. &#8212; Я тебе расскажу про метод clone(). Цель этого метода – клонировать объект – т.е. создать его клон/копию/дубликат. Если его вызвать, то Java-машина создаст и вернет дубликат объекта, у которого вызвали этот метод. Клонирование объекта в классе Object реализовано очень примитивно – при клонировании создается всего один новый объект: ...
<p>----------------------------------------</p>

<a href='https://cdn.javarush.com/images/article/6e110da5-fb61-4a99-9331-c9cacd9a1d50/original.jpeg' target='_blank'><img data-id="6e110da5-fb61-4a99-9331-c9cacd9a1d50" data-max-width="850" alt="Метод clone, интерфейс Cloneable - 1" src="https://cdn.javarush.com/images/article/6e110da5-fb61-4a99-9331-c9cacd9a1d50/original.jpeg"></a>

<p>&#8212; Привет, Амиго!</p>
<p><span class="text-user">&#8212; Привет, Ким.</span></p>
<p>&#8212; Я тебе расскажу про метод clone().</p>
<p>Цель этого метода – клонировать объект – т.е. создать его клон/копию/дубликат.</p>
<p>Если его вызвать, то Java-машина создаст и вернет дубликат объекта, у которого вызвали этот метод.</p>
<p>Клонирование объекта в классе Object реализовано очень примитивно – при клонировании создается всего один новый объект: просто создается еще один объект и его полям присваиваются значения полей объекта-образца.</p>
<p>Если копируемый объект содержит ссылки на другие объекты, то ссылки будут скопированы, дубликаты тех объектов не создаются.</p>
<p><span class="text-user">&#8212; Гм. Не густо.</span></p>
<p>&#8212; Дело в том, что Java-машина не знает, какие объекты можно клонировать, а какие нет. Файлы, например, клонировать нельзя. Как и поток System.in.</p>
<p>Поэтому вопрос о полноценном клонировании был отдан на откуп разработчикам классов. Тут все было сделано по аналогии с методом equals. Даже есть свой аналог hashCode – это интерфейс Cloneable.</p>
<p>Интерфейс <strong>Cloneable</strong> – это так называемый интерфейс-маркер, который не содержит никаких методов. Он используется, чтобы маркировать (помечать) некоторые классы.</p>
<p>Если разработчик класса считает, что объекты класса можно клонировать, он помечает класс этим интерфейсом (наследует класс от Cloneable).</p>
<p>Если разработчика не устраивает стандартная реализация метода clone, он должен написать свою, которая будет создавать дубликат объекта правильным образом.</p>
<p>При вызове метода <strong>clone</strong>(), Java проверяет, был ли у объекта интерфейс Cloneable. Если да &#8212; клонирует объект методом <strong>clone</strong>(), если нет &#8212; выкидывает исключение CloneNotSupportedException.</p>
<p><span class="text-user">&#8212; Т.е. мы должны или переопределить метод clone и написать его новую реализацию или унаследовать класс от Cloneable?</span></p>
<p>&#8212; Да, но переопределять метод все же придется. Метод clone() объявлен как protected, так что он доступен для вызова только классам из его пакета (java.lang.*) или классам-наследникам.</p>
<p><span class="text-user">&#8212; Я немного запутался, так что же надо сделать, чтобы клонировать объект?</span></p>
<p>&#8212; Смотри, если ты хочешь воспользоваться «клонированием по умолчанию», которое реализовано в классе Object, тебе нужно:</p>
<p><strong>а)</strong> Добавить интерфейс Cloneable своему классу</p>
<p><strong>б)</strong> Переопределить метод clone и вызвать в нем базовую реализацию:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>class Point implements Cloneable
{
 int x;
 int y;

 public Object clone()
 {
  return super.clone();
 }</span>
}</code></pre>
<p>Или ты можешь написать реализацию метода clone полностью сам:</p>
<pre class="line-numbers language-java" data-line="" data-start=""><code>class Point 
{
 int x;
 int y;

 public Object clone()
 {
  Point point = new Point();
  point.x = this.x;
  point.y = this.y;
  return point;
 }
}</code></pre>
<p><span class="text-user">&#8212; Интересный метод, буду пользоваться. Иногда…</span></p>
