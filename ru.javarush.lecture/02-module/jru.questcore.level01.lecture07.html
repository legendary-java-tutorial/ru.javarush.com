Инкапсуляция
<p>----------------------------------------</p>
Валидное внутреннее состояние, контроль передаваемых аргументов, минимизация ошибок при изменении кода классов, определение способа взаимодействия объекта с другими объектами… Что это было? Это — основные преимущества инкапсуляции, одного из четырёх китов ООП. Вот о чём вам расскажет Риша Гейтсман.
<p>----------------------------------------</p>
<p>&#8212; Привет, Амиго! Хочу посвятить сегодняшнюю лекцию <span class="red_text"><span class="text-red">инкапсуляции</span>.</span> Ты уже знаешь в общих чертах, что это такое.</p>

<a href='https://cdn.javarush.com/images/article/3643bfbf-3555-4a07-a18f-abd3db9abd5e/original.jpeg' target='_blank'><img data-id="3643bfbf-3555-4a07-a18f-abd3db9abd5e" data-max-width="1024" alt="Инкапсуляция - 1" src="https://cdn.javarush.com/images/article/3643bfbf-3555-4a07-a18f-abd3db9abd5e/original.jpeg"></a>

<p>В чем же преимущества инкапсуляции? Их достаточно много, но я могу выделить четыре, на мой взгляд, основных:</p>
<h3>1) Валидное внутреннее состояние.</h3>
<p>В программах часто возникают ситуации, когда несколько классов, взаимодействуют с одним и тем же объектом. В результате их совместной работы нарушается целостность данных внутри объекта &#8212; объект уже не может продолжить нормально работать.</p>
<p><span class="text-green">Поэтому объект должен следить за изменениями своих внутренних данных, а еще лучше – проводить их сам.</span></p>
<p>Если мы не хотим, чтобы какая-то переменная класса менялась другими классами, мы объявляем ее <strong>private</strong>, и тогда только методы её же класса смогут получить к ней доступ. Если мы хотим, чтобы значения переменных можно было только читать, но не изменять, тогда нужно добавить<strong> public getter</strong> для нужных переменных.</p>
<p>Например, мы хотим, чтобы все могли узнать количество элементов в нашей коллекции, но никто не мог его поменять без нашего разрешения. Тогда мы объявляем переменную <strong>private int count</strong> и метод <strong>public getCount()</strong>.</p>
<p>Правильное использование инкапсуляции гарантирует, что <span class="text-red">ни один класс не может получить прямой доступ к внутренним данным нашего класса и, следовательно, изменить их без контроля с нашей стороны.</span> Только через вызов методов того же класса, что и изменяемые переменные.</p>
<p><span class="text-green">Лучше исходить из того, что другие программисты всегда будут использовать твои классы самым удобным для них образом, а не самым безопасным для тебя (для твоего класса).</span> Отсюда и ошибки, и попытки заранее избавиться от них.</p>
<h3>2) Контроль передаваемых аргументов.</h3>
<p>Иногда нужно контролировать аргументы, передаваемые в методы нашего класса. Например, наш класс описывает объект &#171;человек&#187; и позволяет задать дату его рождения. <span class="text-corporate">Мы должны проверять все передаваемые данные на их соответствие логике программы и логике нашего класса.</span> Например, не допускать 13-й месяц, дату рождения 30 февраля и так далее.</p>
<p><span class="text-user">&#8212; А зачем кому-то указывать в дате рождения 30 февраля?</span></p>
<p>&#8212; Во-первых – это может быть ошибка ввода данных от пользователя.</p>
<p>Во-вторых, прежде чем программа будет работать как часы, в ней будет много ошибок. Например, возможна такая ситуация.</p>
<p>Программист пишет программу для определения людей, у которых день рождения послезавтра. Например, сегодня 3 марта. Программа добавляет к текущему дню месяца число 2 и ищет всех, кто родился 5 марта. Вроде бы все верно.</p>
<p>Вот только, когда наступит 30 марта программа не найдет никого, т.к. в календаре нет 32 марта. В программе становится гораздо меньше ошибок, когда в методы добавляют проверку переданных данных.</p>
<p><span class="text-user">&#8212; Помню, когда мы изучали ArrayList, я смотрел его код, и там была проверка индекса в методах get и set: index больше или равен нулю и меньше длины массива. Там еще кидалось исключение, если в массиве нет элемента с таким индексом.</span></p>
<p>&#8212; Да, <span class="text-green">это классический пример проверки входных данных.</span></p>
<h3>3) Минимизация ошибок при изменении кода классов.</h3>
<p>Представим, что мы написали один очень полезный класс, когда участвовали в большом проекте. Он так всем понравился, что другие программисты начали использовать его в сотнях мест в своем коде.</p>
<p>Класс оказался настолько полезен, что ты решил его улучшить. <span class="text-red">Но если ты удалишь какие-то методы этого класса, то код десятков людей перестанет компилироваться.</span> Им придется срочно все переделывать. И чем больше переделок, тем больше ошибок. Ты поломаешь кучу сборок, и тебя будут ненавидеть.</p>
<p>А когда мы меняем методы, объявленные как private, мы знаем, что нигде нет ни одного класса, который вызывал бы эти методы. Мы можем их переделать, поменять количество параметров и их типы, и зависимый код будет работать дальше. Ну, или как минимум, компилироваться.</p>
<h3>4) Задаем способ взаимодействия нашего объекта со сторонними объектами.</h3>
<p>Мы можем ограничить некоторые действия, допустимые с нашим объектом. Например, мы хотим, чтобы объект можно было создать только в одном экземпляре. Даже если его создание происходит в нескольких местах проекта одновременно. И мы можем сделать это благодаря инкапсуляции.</p>

<a href='https://cdn.javarush.com/images/article/85b1f2fa-09fe-4777-890e-05d3a824a2bf/original.jpeg' target='_blank'><img data-id="85b1f2fa-09fe-4777-890e-05d3a824a2bf" data-max-width="850" alt="Инкапсуляция - 2" src="https://cdn.javarush.com/images/article/85b1f2fa-09fe-4777-890e-05d3a824a2bf/original.jpeg"></a>

<p>Инкапсуляция позволяет добавлять <span class="text-red">дополнительные ограничения</span>, которые можно превратить в <span class="text-red">дополнительные преимущества</span>. Например, класс String реализован как immutable (неизменяемый) объект. Объект класса String неизменяем с момента создания и до момента смерти. Все методы класса String (remove, substring, &#8230;), <span class="text-green">возвращают новую строку, абсолютно не изменяя объект, у которого они были вызваны.</span></p>
<p><span class="text-user">&#8212; Ничего себе. Вот оно как, оказывается.</span></p>
<p>&#8212; Инкапсуляция очень интересная штука.</p>
<p><span class="text-user">&#8212; Ага.</span></p>
