Переопределение (override) методов
<p>----------------------------------------</p>
Ты уже используешь методы в Java и знаешь о них многое. Наверняка ты сталкивался с ситуацией, когда в одном классе было много методов с одинаковым названием, но разными аргументами. Если помнишь, в тех случаях мы использовали механизм перегрузки методов. Сегодня поговорим о переопределении (override) методов
<p>----------------------------------------</p>
Привет! Ты уже используешь методы в Java и знаешь о них многое. 

<img data-id="1074a8ae-9e09-4e3a-834d-d8bb800c85d3" data-max-width="850" alt="Как устроен механизм переопределения методов  - 1" src="https://cdn.javarush.com/images/article/1074a8ae-9e09-4e3a-834d-d8bb800c85d3/1024.jpeg">Наверняка ты сталкивался с ситуацией, когда в одном классе было много методов с одинаковым названием, но разными аргументами. Если помнишь, в тех случаях мы использовали механизм перегрузки методов.

Сегодня рассмотрим другую ситуацию. Представь, что у нас есть один общий метод, но он должен делать разные вещи в зависимости от того, в каком классе он был вызван.

Как реализовать такое поведение?

Чтобы разобраться, возьмем родительский класс <code>Animal</code>, обозначающий животных, и создадим в нем метод <code>voice</code> — «<em>голос</em>»:

<pre class="lang-java line-numbers"><code>
public class Animal {
  
   public void voice() {

       System.out.println("Голос!");
   }
}
</code></pre>
Хотя мы только начали писать программу, потенциальная проблема тебе, скорее всего, видна: животных в мире очень много, и все «говорят» по-разному: кошки мяукают, утки крякают, змеи шипят.
<img data-id="2a03e80c-4070-473b-ad97-fe6165eb937c" data-max-width="850" alt="Как устроен механизм переопределения методов  - 2" src="https://cdn.javarush.com/images/article/2a03e80c-4070-473b-ad97-fe6165eb937c/1024.jpeg">
Наша цель проста: избежать создания кучи методов для подачи голоса. Вместо того, чтобы создавать методы <code>voiceCat()</code> для мяуканья, <code>voiceSnake()</code> для шипения и т.д., мы хотим, чтобы при вызове метода <code>voice()</code> змея шипела, кошка мяукала, а собака лаяла.

Мы легко добьемся этого с помощью механизма <strong>переопределения методов (Override в Java)</strong>.

Википедия дает такое пояснение термина «переопределение»:

<strong>Переопределение метода</strong> (англ. <em>Method overriding</em>) в объектно-ориентированном программировании — одна из возможностей языка программирования, позволяющая подклассу или дочернему классу обеспечивать специфическую реализацию метода, уже реализованного в одном из суперклассов или родительских классов.

Оно, в общем-то, правильное. Переопределение позволяет взять какой-то метод родительского класса и написать в каждом классе-наследнике свою реализацию этого метода. Новая реализация «заменит» родительскую в дочернем классе.

Рассмотрим, как это выглядит на примере. Создадим 4 класса-наследника для нашего класса <code>Animal</code>:

<pre class="lang-java line-numbers"><code>
public class Bear extends Animal {
   @Override
   public void voice() {
       System.out.println("Р-р-р!");
   }
}
public class Cat extends Animal {

   @Override
   public void voice() {
       System.out.println("Мяу!");
   }
}

public class Dog extends Animal {

   @Override
   public void voice() {
       System.out.println("Гав!");
   }
}


public class Snake extends Animal {

   @Override
   public void voice() {
       System.out.println("Ш-ш-ш!");
   }
}
</code></pre>
Небольшой лайфхак на будущее: чтобы переопределить методы родительского класса, перейди в код класса-наследника в <em>Intellij IDE</em>a, нажми <em>Ctrl+O</em> и выбери в меню «<em>Override methods...</em>». Привыкай пользоваться горячими клавишами с начала, это ускоряет написание программ!

Чтобы задать нужное нам поведение, мы сделали несколько вещей:

<ol>
<li>Создали в каждом классе-наследнике метод с таким же названием, как и у метода в родительском классе.</li>
<li><p>Сообщили компилятору, что мы не просто так назвали метод так же, как в классе-родителе: хотим переопределить его поведение. Для этого «сообщения» компилятору мы поставили над методом <strong>аннотацию @Override</strong> («переопределен»).<br>
Проставленная над методом аннотация @Override сообщает компилятору (да и читающим твой код программистам тоже): «Все ок, это не ошибка и не моя забывчивость. Я помню, что такой метод уже есть, и хочу переопределить его».</p></li>
<li>Написали нужную нам реализацию для каждого класса-потомка. Змея при вызове <code>voice()</code> должна шипеть, медведь — рычать и т.д.</li>
</ol>
Давай посмотрим, как это будет работать в программе:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       Animal animal1 = new Dog();
       Animal animal2 = new Cat();
       Animal animal3 = new Bear();
       Animal animal4 = new Snake();
      
       animal1.voice();
       animal2.voice();
       animal3.voice();
       animal4.voice();
   }<em></em>
}
</code></pre>
Вывод в консоль:

<em>Гав!
Мяу!
Р-р-р!
Ш-ш-ш!</em>

Отлично, все работает как надо! Мы создали 4 переменных-ссылки родительского класса <code>Animal</code>, и присвоили им 4 разных объекта классов-наследников.

В результате каждый объект ведет себя по-своему. Для каждого из классов-наследников переопределенный метод <code>voice()</code> заменил «родной» метод <code>voice()</code> из класса <code>Animal</code> (который выводит в консоль просто «Голос!»).
<img data-id="d32b37ce-2c77-4862-ae43-363a54200e44" data-max-width="850" alt="Как устроен механизм переопределения методов  - 3" src="https://cdn.javarush.com/images/article/d32b37ce-2c77-4862-ae43-363a54200e44/1024.jpeg">
У переопределения есть ряд ограничений:

<ol>
<li><p><strong>У переопределенного метода должны быть те же аргументы, что и у метода родителя.</strong></p>
<p>Если метод <code>voice</code> родительского класса принимает на вход <code>String</code>, переопределенный метод в классе-потомке тоже должен принимать на вход <code>String</code>, иначе компилятор выдаст ошибку:</p>
<pre class="lang-java line-numbers"><code>
public class Animal {

   public void voice(String s) {

       System.out.println("Голос! " + s);
   }
}

public class Cat extends Animal {

   @Override//ошибка!
   public void voice() {
       System.out.println("Мяу!");
   }
}
</code></pre></li><br>
<li><p><strong>У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.</strong></p>
<p>В ином случае мы получим ошибку компиляции:</p>

<pre class="lang-java line-numbers"><code>
public class Animal {

   public void voice() {

       System.out.println("Голос!");
   }
}


public class Cat extends Animal {

   @Override
   public String voice() {         //ошибка!
       System.out.println("Мяу!");
       return "Мяу!";
   }
}
</code></pre></li><br>
<li><p><strong>Модификатор доступа у переопределенного метода также не может отличаться от «оригинального»:</strong></p>
<pre class="lang-java line-numbers"><code>
public class Animal {

   public void voice() {

       System.out.println("Голос!");
   }
}

public class Cat extends Animal {

   @Override
   private void voice() {      //ошибка!
       System.out.println("Мяу!");
   }
}
</code></pre></li></ol><strong>Переопределение методов в Java</strong> — один из инструментов для реализации идеи полиморфизма.

Поэтому главным преимуществом его использования будет та же гибкость, о которой мы говорили ранее. Мы можем выстроить простую и логичную систему классов, каждый из которых будет обладать специфическим поведением (собаки лают, кошки мяукают), но единым интерфейсом — один метод <code>voice()</code> на всех вместо кучи методов <code>voiceDog()</code>, <code>voiceCat()</code> и т.д.