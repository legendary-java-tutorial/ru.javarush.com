Методы equals &amp; hashCode: зачем, где используются, как работают
<p>----------------------------------------</p>
&#8212; Теперь я расскажу о не менее полезных методах equals(Object o) &amp; hashCode(). Как ты уже, наверное, успел запомнить, в Java при сравнении ссылочных переменных сравниваются не сами объекты, а ссылки на объекты. Код Пояснение Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i==j); i не равно j Переменные указывают на различные объекты. Хотя ...
<p>----------------------------------------</p>
<p>&#8212; Теперь я расскажу о не менее полезных методах <strong>equals(Object o) &amp; hashCode()</strong>.</p>
<p>Как ты уже, наверное, успел запомнить, в Java при сравнении ссылочных переменных сравниваются не сами объекты, а ссылки на объекты.</p>
<table>
<tbody>
<tr>
<th  >Код</th>
<th  >Пояснение</th>
</tr>
<tr>
<td>
<pre data-line="" data-start="" class="line-numbers language-java"><code>Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i==j);</code></pre>
</td>
<td>i не равно j<br />
Переменные указывают на различные объекты.<br />
Хотя объекты содержат одинаковые данные;</td>
</tr>
<tr>
<td>
<pre data-line="" data-start="" class="line-numbers language-java"><code>Integer i = new Integer(1);
Integer j = i;
System.out.println(i==j);</td>
<td>i равно j
Переменные содержат ссылку на один и тот же объект.</td>
</tr>
</tbody>
</table>
<p><span class="text-user"> &#8212; Да, я это помню.</span></p>
<p> &#8212; Есть также стандартное решение этой ситуации – метод <strong>equals</strong>.</p>
<p>Цель метода <strong>equals</strong> – определить идентичны ли объекты внутри, сравнив внутреннее содержание объектов.</p>
<p><span class="text-user"> &#8212; И как он это делает?</span></p>
<p> &#8212; Тут все аналогично методу toString().</p>
<p>У класса Object есть своя реализация метода equals, которая просто сравнивает ссылки:</p>
<pre data-line="" data-start="" class="line-numbers language-java"><code>public boolean equals(Object obj)
{
return (this == obj);
}</code></pre>
<p><span class="text-user"> &#8212; М-да. С чем боролись, на то и напоролись.</span></p>
<p> &#8212; Не вешай нос. Тут все тоже очень хитро.</p>
<p>Этот метод создавался, чтобы разработчики переопределяли его в своих классах. Ведь только разработчик класса знает, какие данные важны, что учитывать при сравнении, а что – нет.</p>
<p><span class="text-user"> &#8212; А можно пример такого метода?</span></p>
<p> &#8212; Конечно. Допустим, у нас есть класс, описывающий математические дроби, тогда он выглядел бы так (для ясности, я переведу английские названия на русский язык):</p>
<div class="code-heading">Пример</div>
<pre data-line="" data-start="" class="line-numbers language-java"><code>class Дробь
{
private int числитель;
private int знаменатель;
Дробь(int числитель, int знаменатель)
{
this.числитель = числитель;
this.знаменатель = знаменатель;
}public boolean equals(Object obj)
{
if (obj==null)
return false;

if (obj.getClass() != this.getClass() )
return false;

Дробь other = (Дробь) obj;
return this.числитель* other.знаменатель == this.знаменатель * other.числитель;
}
}</code></pre>
<table>
<tbody>
<tr>
<th width="100%">Пример вызова:</th>
</tr>
<tr>
<td><code>Дробь <strong>one</strong> = <strong>new</strong> Дробь(2,3);</code><br />
<code> Дробь <strong>two</strong> = <strong>new</strong> Дробь(4,6);</code><br />
<strong><code> System.out.println(one.equals(two));</code></strong></td>
</tr>
<tr>
<td><strong>Результат вызова будет true.</strong><br />
<strong> дробь 2/3 равна дроби 4/6</strong></td>
</tr>
</tbody>
</table>
<p> &#8212; Для большей ясности я использовала русские названия. Так можно делать только в обучающих целях.</p>
<p>Теперь разберем пример.</p>
<p>Мы переопределили метод <strong>equals</strong>, и теперь для объектов класса <strong>Дробь</strong> у него будет своя реализация.</p>
<p>В этом методе есть несколько проверок:</p>
<p><strong>1)</strong> Если переданный для сравнения объект – <strong>null</strong>, то объекты не равны. Объект, у которого вызвали метод <strong>equals</strong> ведь точно не <strong>null</strong>.</p>
<p><strong>2)</strong> Проверка на сравнение классов. Если объекты разных классов, то мы не будем пробовать их сравнить, а сразу скажем, что это различные объекты – <strong>return false</strong>.</p>
<p><strong>3)</strong> Со второго класса школы все помнят, что дробь 2/3 равна дроби 4/6. А как это проверить?</p>
<table>
<tbody>
<tr>
<th width="100%">2/3 == 4/6</th>
</tr>
<tr>
<td><strong>Умножим обе части на оба делителя (6 и 3), получим:</strong></td>
</tr>
<tr>
<td><strong>6 * 2 == 4 * 3</strong></td>
</tr>
<tr>
<td><strong>12 == 12</strong></td>
</tr>
<tr>
<td><strong>Общее правило:</strong></td>
</tr>
<tr>
<td><strong>Если</strong><br />
<strong> a / b == c / d</strong><br />
<strong> То</strong><br />
<strong> a * d == c * b</strong></td>
</tr>
</tbody>
</table>
<p> &#8212; Поэтому в третьей части метода <strong>equals</strong> мы преобразуем переданный объект к типу Дробь и сравниваем дроби.</p>
<p><span class="text-user"> &#8212; Понятно. Если бы мы просто сравнивали числитель с числителем и знаменатель со знаменателем, то дробь 2/3 не была бы равной 4/6.</span></p>
<p><span class="text-user">Теперь понятно, что ты имела ввиду, когда говорила, что только разработчик класса знает, как правильно его сравнивать.</span></p>
<p> &#8212; Да, но это только половина дела. <strong>Есть еще второй метод – hashCode()</strong></p>
<p><span class="text-user"> &#8212; С методом equals все понятно, а зачем нужен <strong>hashCode</strong>()?</span></p>
<p> &#8212; Метод <strong>hashCode</strong> нужен для быстрого сравнения.</p>
<p>У метода <strong>equals</strong> есть большой минус – он слишком медленно работает. Допустим, у тебя есть множество(Set) из миллиона элементов, и нам нужно проверить, содержит ли оно определенный объект или нет. Как это сделать?</p>
<p><span class="text-user"> &#8212; Можно в цикле пройтись по всем элементам и сравнить нужный объект с каждым объектом множества. Пока не найдем нужный.</span></p>
<p> &#8212; А если его там нет? Мы выполним миллион сравнений, чтобы узнать, что там нет этого объекта? Не многовато ли?</p>
<p> <span class="text-user">&#8212; Да, даже мне понятно, что слишком много сравнений. А что, есть другой способ?</span></p>
<p> &#8212; Да, для этого и используется <strong>hashCode</strong>().</p>
<p>Метод <strong>hashCode</strong>() для каждого объекта возвращает определенное число. Какое именно – это тоже решает разработчик класса, как и в случае с методом equals.</p>
<p>Давай рассмотрим ситуацию на примере:</p>
<p>Представь, что у тебя есть миллион 10-тизначных чисел. Тогда в качестве hashCode для каждого числа можно выбрать остаток от его деления на 100.</p>
<p>Пример:</p>
<table>
<tbody>
<tr>
<th width="50%">Число</th>
<th width="50%">Наш hashCode</th>
</tr>
<tr>
<td>1234567890</td>
<td>90</td>
</tr>
<tr>
<td>9876554321</td>
<td>21</td>
</tr>
<tr>
<td>9876554221</td>
<td>21</td>
</tr>
<tr>
<td>9886554121</td>
<td>21</td>
</tr>
</tbody>
</table>
<p><span class="text-user"> &#8212; Да, с этим понятно. И что нам делать с этим hashCode-числом?</span></p>
<p> &#8212; Вместо того чтобы сравнивать числа, мы будем сравнивать их <strong>hashCode</strong>. Так быстрее.</p>
<p>И только если <strong>hashCode</strong>-ы равны, сравнивать уже посредством <strong>equals</strong>.</p>
<p><span class="text-user"> &#8212; Да, так быстрее. Но нам все равно придется сделать миллион сравнений, только уже более коротких чисел, а для тех чисел, чьи hashCode совпадают, опять вызвать equals.</span></p>
<p> &#8212; Нет, можно обойтись гораздо меньшим числом.</p>
<p>Представь, что наше множество хранит числа, сгруппированные по hashCode или отсортированные по <strong>hashCode </strong>(что равносильно их группировке, т.к. числа с одинаковым hashCode находятся рядом). Тогда можно очень быстро и легко отбросить ненужные группы, достаточно один раз для каждой группы проверить совпадает ли ее hashCode с hashCode заданного объекта.</p>
<p>Представь, что ты студент, и ищешь своего друга, которого знаешь в лицо и про которого известно, что он живет в 17 общаге. Тогда ты просто проходишься по всем общежитиям универа и в каждом общежитии спрашиваешь «это 17 общага?». Если нет, то ты отбрасываешь всех из этой общаги и переходишь к следующей. Если «да», то начинаешь ходить по всем комнатам и искать друга.</p>
<p>В данном примере номер общаги – 17 – это и есть hashCode.</p>
<p>Разработчик, который реализует функцию hashCode, должен знать следующие вещи:</p>
<p><strong>А)</strong> <strong><span class="text-green">у двух разных объектов может быть одинаковый hashCode</span></strong> (разные люди могут жить в одной общаге)</p>
<p><strong>Б)</strong> <span class="text-green"><strong>у одинаковых объектов</strong></span> (<strong>с точки зрения equals</strong>) <strong><span class="text-green">должен быть одинаковый hashCode</span></strong>.</p>
<p><strong>В)</strong> <span class="text-red"><strong>хеш-коды должны быть выбраны таким образом, чтобы не было большого количества различных объектов с одинаковыми hashCode.</strong></span> Это сведет все их преимущество на нет (Ты пришел в 17 общагу, а там живет пол универа. Облом-с).</p>
<p>И теперь самое важное. Если ты переопределяешь метод <strong>equals</strong>, обязательно нужно переопределить метод <strong>hashCode</strong>(), с учетом трех вышеописанных правил.</p>
<p>Все дело в том, что <strong>коллекции в Java перед тем как сравнить объекты с помощью equals всегда ищут/сравнивают их с помощью метода hashCode()</strong>. И если у одинаковых объектов будут разные hashCode, то объекты будут считаться разными - до сравнения с помощью equals просто не дойдет.</p>
<p>В нашем примере с Дробью, если бы мы взяли hashCode равный числителю, то дроби 2/3 и 4/6 имели бы разные hashCode. Дроби – одинаковые, equals говорит, что они одинаковые, но hashCode говорит, что они разные. И если перед сравнением с помощью equals сравнивать по hashCode, то получим что объекты разные и до equals просто не дойдём.</p>
<p>Пример:</p>
<table>
<tbody>
<tr>
<th width="100%"></th>
</tr>
<tr>
<td><code><span class="text-green">HashSet&lt;Дробь&gt;set = new HashSet&lt;Дробь&gt;();</span></code><br />
<code><span class="text-green"> set.add(new Дробь(2,3));</span></code><code><span class="text-green">System.out.println( set.contains(new Дробь(4,6)) );</span></code></td>
</tr>
<tr>
<td>Если метод <span class="text-green"><strong>hashCode()</strong></span> будет возвращать числитель дроби, то результат будет <span class="text-green"><strong>false</strong></span>.<br />
Объект new <span class="text-green"><strong>Дробь(4,6) </strong></span>не будет найден в коллекции.</td>
</tr>
</tbody>
</table>
<p><span class="text-user"> &#8212; А как правильно реализовать hashCode для дроби?</span></p>
<p> &#8212; Тут надо помнить, что одинаковым дробям обязательно должен соответствовать одинаковый hashCode.</p>
<p><strong>Вариант 1</strong>: hashCode равен целой части от деления.</p>
<p>Для дроби 7/5 и 6/5 это будет 1.</p>
<p>Для дроби 4/5 и 3/5 это будет 0.</p>
<p>Но этот вариант плохо годится для сравнения дробей, которые заведомо меньше 1. Целая часть (hashCode) всегда будет 0.</p>
<p><strong>Вариант 2</strong>: hashCode равен целой части от деления знаменателя на числитель.</p>
<p>Этот вариант подойдет для случая, когда значение дроби меньше 1. Если дробь меньше 1, значит перевернутая дробь больше 1. А если мы переворачиваем все дроби – это никак не скажется на их сравнении.</p>
<p>Итоговый вариант будет совмещать в себе оба решения:</p>
<pre data-line="" data-start="" class="line-numbers language-java"><code>public int hashCode()
{
return числитель/знаменатель + знаменатель/числитель;
}</code></pre>
</table>
<p>Проверяем для дробей 2/3 и 4/6. У них должны быть равные hashCode:</p>
<table>
<tbody>
<tr>
<th width="33%"></th>
<th width="33%">Дробь 2/3</th>
<th width="33%">Дробь 4/6</th>
</tr>
<tr>
<td><strong>числитель / знаменатель</strong></td>
<td>2 / 3 == 0</td>
<td>4 / 6 == 0</td>
</tr>
<tr>
<td><strong>знаменатель / числитель</strong></td>
<td>3 / 2 == 1</td>
<td>6 / 4 == 1</td>
</tr>
<tr>
<td><strong>числитель / знаменатель</strong><br />
<strong> +</strong><br />
<strong> знаменатель / числитель</strong></td>
<td>0 + 1 == 1</td>
<td>0 + 1 == 1</td>
</tr>
</tbody>
</table>
<p>На этом – все.</p>
<p><span class="text-user"> &#8212; Спасибо, Элли, было действительно интересно.</span></p>
