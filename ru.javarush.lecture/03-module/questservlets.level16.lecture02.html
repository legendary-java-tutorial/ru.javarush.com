Порождающие паттерны
<p>----------------------------------------</p>
Singleton
Factory [Method]
Abstract Factory
Prototype
<p>----------------------------------------</p>
<h2>3.1 Singleton</h2>
<p><strong>Одиночка (Singleton)</strong> — порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.</p>
<img data-max-width="800" data-id="89e3023d-4033-48a2-8ca9-8752bf2a92dc" src="https://cdn.javarush.com/images/article/89e3023d-4033-48a2-8ca9-8752bf2a92dc/800.jpeg" alt="Одиночка (Singleton)">
<p>Очень часто начинающие программисты любят собрать утилитные методы в некоторый статический класс – класс, содержащий только статические методы. У такого подхода есть ряд минусов – например, нельзя передать ссылку на объект такого класса, такие методы тяжело тестировать и тому подобное.</p>
<p>В качестве альтернативы предложили решение класс-синглетон: класс, у которого может быть только один объект. При попытке создания этого объекта он создается только в том случае, если еще не существует, в противном случае возвращается ссылка на уже существующий экземпляр.</p>
<p>Существенно то, что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной более широкая функциональность. Например, этот класс может реализовывать некоторые интерфейсы и его объект можно передать в другие методы, как имплементацию интерфейса. Что нельзя сделать с набором статических методов.</p>
<p><strong>Плюсы:</strong></p>
<ul>
    <li>Методы привязаны к объекту, а не к статическому классу – можно передавать объект по ссылке.</li>
    <li>Методы объекта значительно легче тестировать и мокировать.</li>
    <li>Объект создается только по необходимости: отложенная инициализация объекта.</li>
    <li>Ускорение начального запуска программы, если есть множество одиночек, которые не нужны для запуска.</li>
    <li>Одиночку можно в дальнейшем превратить в шаблон-стратегию или несколько таких объектов.</li>
</ul>
<p><strong>Минусы:</strong></p>
<ul>
    <li>Усложняется контроль над межпоточными гонками и задержками.</li>
    <li>Многопоточного “одиночку” сложно писать “из головы”: доступ к давно построенному одиночке в идеале не должен открывать мьютекс. Лучше проверенные решения.</li>
    <li>Конфликт двух потоков за недостроенного одиночку приведет к задержке.</li>
    <li>Если объект создается долго, задержка может мешать пользователю или нарушать реальное время. В таком случае его создание лучше перенести в стадию инициализации программы.</li>
    <li>Требуются особые функции для модульного тестирования — например, чтобы перевести библиотеку в “не-одинокий” режим и полностью изолировать тесты друг от друга. </li>
    <li>Требуется особая тактика тестирования готовой программы, ведь пропадает даже понятие “простейшая запускаемость”, ведь запускаемость зависит от конфигурации.</li>
</ul>
<h2>3.2 Factory [Method]</h2>
<p><strong>Фабричный метод (Factory Method)</strong> — порождающий шаблон проектирования, предоставляющий подклассам (классам-наследникам) интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать.</p>
<p>Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не конкретные классы, а манипулировать абстрактными объектами на более высоком уровне.</p>
<img data-max-width="800" data-id="db65aca4-64e8-4622-8d7e-f71d93695269" src="https://cdn.javarush.com/images/article/db65aca4-64e8-4622-8d7e-f71d93695269/800.jpeg" alt="Фабричный метод (Factory Method)">
<p>Этот паттерн определяет интерфейс для создания объекта, но оставляет подклассам решение о том, на основании какого класса создавать объект. Фабричный метод позволяет классу делегировать создание подклассов. Используется, когда:</p>
<ul>
    <li>классу заранее неизвестно, объекты каких подклассов ему нужно создавать.</li>
    <li>класс спроектирован так, чтобы объекты, которые он создает, специфицировались подклассами.</li>
    <li>класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется определить, какой класс принимает эти обязанности на себя.</li>
</ul>
<h2>3.3 Abstract Factory</h2>
<p><strong>Абстрактная фабрика (Abstract factory)</strong> — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.</p>
<p>Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.</p>
<img data-max-width="800" data-id="0d872d57-68cb-4d8f-b8ef-951740561f2e" src="https://cdn.javarush.com/images/article/0d872d57-68cb-4d8f-b8ef-951740561f2e/800.jpeg" alt="Абстрактная фабрика (Abstract factory">
<p>Применяется в случаях, когда программа должна быть независимой от процесса и типов создаваемых новых объектов. Когда необходимо создать семейства или группы взаимосвязанных объектов, исключая возможность одновременного использования объектов из разных этих наборов в одном контексте.</p>
<p>Сильные стороны:</p>
<ul>
    <li>изолирует конкретные классы;</li>
    <li>упрощает замену семейств продуктов;</li>
    <li>гарантирует сочетаемость продуктов.</li>
</ul>
<p>Допустим, твоя программа работает с файловой системой. Тогда для работы в Linux тебе нужны объекты LinuxFile, LinuxDirectory, LinuxFileSystem. А для работы в Windwos тебе нужны классы WindowsFile, WindowsDirectory, WindowsFileSystem.</p>
<p>Класс Path, который создается через Path.of(), — это как раз тот случай. Path — это на самом деле не класс, а интерфейс и у него есть реализации WindowsPath и LinuxPath. А какой именно объект будет создан, скрыто от твоего кода и будет решаться во время работы программы.</p>
<h2>3.4 Prototype</h2>
<p><strong>Прототип (Prototype)</strong> — порождающий шаблон проектирования.</p>
<p>Этот паттерн задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа. Он позволяет уйти от реализации и следовать принципу “программирование через интерфейсы”.</p>
<p>В качестве возвращающего типа указывается интерфейс/абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип. Проще говоря, это паттерн создания объекта через клонирование другого объекта вместо создания через конструктор.</p>
<img data-max-width="800" data-id="58cb0797-b692-45a1-9bb3-ea72e0dfe0e4" src="https://cdn.javarush.com/images/article/58cb0797-b692-45a1-9bb3-ea72e0dfe0e4/800.jpeg" alt="Прототип (Prototype)">
<p>Паттерн используется чтобы:</p>
<ul>
    <li>избежать дополнительных усилий по созданию объекта стандартным путем (имеется в виду использование конструктора, так как в этом случае также будут вызваны конструкторы всей иерархии предков объекта), когда это непозволительно дорого для приложения.</li>
    <li>избежать наследования создателя объекта (object creator) в клиентском приложении, как это делает паттерн abstract factory.</li>
</ul>
<p>Используй этот шаблон проектирования, когда твоей программе безразлично, как именно в ней создаются, компонуются и представляются продукты:</p>
<ul>
    <li>инстанцируемые классы определяются во время выполнения, например, с помощью динамической загрузки;</li>
    <li>ты хочешь избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;</li>
    <li>экземпляры класса могут находиться в одном из нескольких различных состояний. Может оказаться удобнее установить соответствующее число прототипов и клонировать их, а не инстанцировать каждый раз класс вручную в подходящем состоянии.</li>
</ul>
