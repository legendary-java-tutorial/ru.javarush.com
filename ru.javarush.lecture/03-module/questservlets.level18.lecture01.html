Память в JVM, часть 2
<p>----------------------------------------</p>
Аппаратная архитектура памяти. 
Совмещение Java-модели памяти и аппаратной архитектуры памяти. 
Видимость общих объектов. 
Состояние гонки.
<p>----------------------------------------</p>
<h2>Аппаратная архитектура памяти</h2>

<p>Современная аппаратная архитектура памяти отличается от внутренней Java-модели памяти. Поэтому нужно  аппаратную архитектуру понимать, чтобы знать, как Java-модель работает с ней. В этом разделе описывается общая аппаратная архитектура памяти, а в следующем разделе описывается, как с ней работает Java.</p>

<p>Вот упрощенная схема аппаратной архитектуры современного компьютера:</p>
<img data-max-width="512" data-id="0a28b119-0299-42d8-aab3-fba135d16288" src="https://cdn.javarush.com/images/article/0a28b119-0299-42d8-aab3-fba135d16288/512.jpeg" alt="Аппаратная архитектура памяти">

<p>В современном мире у компьютера 2 или более процессора и это уже норма. Некоторые из этих процессоров также могут иметь несколько ядер. На таких компьютерах возможно одновременное выполнение нескольких потоков. Каждое ядро процессора способно выполнять один поток в любой момент времени. Это значит, что любое Java-приложение является априори многопоточным и внутри вашей программы может быть запущено по одному потоку на ядро процессора одновременно.</p>

<p>Ядро процессора содержит набор регистров, которые находятся в его памяти (внутри ядра). Оно выполняет операции над данными регистра намного быстрее, чем над данными, которые находятся в основной памяти компьютера (ОЗУ). Это связано с тем, что процессор может получить доступ к этим регистрам гораздо быстрее.</p>

<p>Каждый ЦП тоже может иметь свой слой кэш-памяти. Большинство современных процессоров его имеют. К своей кэш-памяти процессор может получить доступ намного быстрее, чем к основной памяти, но не так быстро, как к своим внутренним регистрам. Значение скорости доступа к кэш-памяти примерно между скоростями доступа к основной памяти и к внутренним регистрам.</p>

<p>Более того, у процессоров имеет место быть многоуровневый кэш. Но это не так важно знать, чтобы понять, как Java-модель памяти взаимодействует с аппаратной памятью. Важно знать, что процессоры могут иметь некоторый уровень кэш-памяти.</p>

<p>Любой компьютер точно также содержит ОЗУ (область основной памяти). Все ядра могут получить доступ к основной памяти. Основная область памяти обычно намного больше, чем кэш-память ядер процессоров.</p>

<p>В момент, когда процессору нужен доступ к основной памяти, он считывает ее часть в свою кэш-память. Он может также считывать часть данных из кэша в свои внутренние регистры и затем выполнять операции над ними. Когда ЦПУ необходимо будет записать результат опять в основную память, он сбросит данные из своего внутреннего регистра в кэш-память, и в какой-то момент, в основную память.</p>

<p>Данные, хранящиеся в кэш-памяти, в обычном случае сбрасываются обратно в основную память, когда процессору необходимо сохранить в кэш-памяти что-то еще. Кэш имеет возможность очищать свою память и записывать данные одновременно. У процессора нет необходимости читать или записывать полный кэш каждый раз во время обновления. Обычно кэш обновляется небольшими блоками памяти, они называются “строка кэша”. Одна или несколько “строк кэша” могут быть считаны в кэш-память, и одна или более строк кэша могут быть сброшены назад в основную память.</p>

<h2>Совмещение Java-модели памяти и аппаратной архитектуры памяти</h2>

<p>Как уже упоминалось, Java-модель памяти и аппаратная архитектура памяти различны. Аппаратная архитектура не различает стеки потоков и кучу. На оборудовании стек потоков и HEAP (куча) находятся в основной памяти. </p>

<p>Части стеков и кучи потоков могут иногда присутствовать в кэшах и внутренних регистрах ЦП. Это показано на диаграмме:</p>

<img data-max-width="1024" data-id="7b653255-07de-4c9b-b6c0-9c47c7e6cd44" src="https://cdn.javarush.com/images/article/7b653255-07de-4c9b-b6c0-9c47c7e6cd44/1024.jpeg" alt=" стек потоков и HEAP">

<p>Когда объекты и переменные могут храниться в различных областях памяти компьютера, могут возникнуть определенные проблемы. Вот две основные:</p>

<ul>
<li>Видимость изменений, которые произвел поток над общими переменными.</li>
<li>Состояние гонки при чтении, проверке и записи общих переменных.</li>
</ul>

<p>Обе эти проблемы я объясню далее.</p>

<h2>Видимость общих объектов</h2>

<p>Если два или более потока делят между собой объект без надлежащего использования volatile-объявления или синхронизации, то изменения общего объекта, сделанные одним потоком, могут быть невидимы для других потоков.</p>

<p>Представь, что общий объект изначально хранится в основной памяти. Поток, выполняющийся на ЦП, считывает общий объект в кэш этого же ЦП. Там он вносит изменения в объект. Пока кэш ЦП не был сброшен в основную память, измененная версия общего объекта не видна потокам, работающим на других ЦП. Таким образом, каждый поток может получить свою собственную копию общего объекта, каждая копия будет находиться в отдельном кэше ЦП.</p>

<p>Следующая диаграмма иллюстрирует набросок этой ситуации. Один поток, работающий на левом ЦП, копирует в его кэш общий объект и изменяет значение переменной count на 2. Это изменение невидимо для других потоков, работающих на правом ЦП, поскольку обновление для count еще не было сброшено обратно в основную память.</p>
<img data-max-width="800" data-id="c4ba107f-a25e-496d-af1a-4e7128d00d0e" src="https://cdn.javarush.com/images/article/c4ba107f-a25e-496d-af1a-4e7128d00d0e/800.jpeg" alt="">

<p>Для того, чтобы решить эту проблему, вы можете использовать ключевое слово volatile при объявлении переменной. Оно может гарантировать, что данная переменная считывается непосредственно из основной памяти и всегда записывается обратно в основную память, когда обновляется.</p>

<h2>Состояние гонки (race condition)</h2>

<p>Если два или более потоков совместно используют один объект и более одного потока обновляют переменные в этом общем объекте, то может возникнуть состояние гонки.</p>

<p>Представьте, что поток A считывает переменную count общего объекта в кэш своего процессора. Представьте также, что поток B делает то же самое, но в кэш другого процессора. Теперь поток A прибавляет 1 к значению переменной count, и поток B делает то же самое. Теперь переменная была увеличена дважды — отдельно по +1 в кэше каждого процессора.</p>

<p>Если бы эти приращения были выполнены последовательно, переменная count была бы увеличена в два раза и обратно в основную память было бы записано (исходное значение + 2).</p>

<p>Тем не менее, два приращения были выполнены одновременно без надлежащей синхронизации. Независимо от того, какой из потоков (A или B), записывает свою обновленную версию count в основную память, новое значение будет только на 1 больше исходного значения, несмотря на два приращения.</p>

<p>Эта диаграмма иллюстрирует возникновение проблемы с состоянием гонки, которое описано выше:</p>

<img data-max-width="800" data-id="37347ace-af3d-4648-a218-18f8c1576289" src="https://cdn.javarush.com/images/article/37347ace-af3d-4648-a218-18f8c1576289/800.jpeg" alt="">

<p>Для решения этой проблемы вы можете использовать синхронизированный блок Java. Синхронизированный блок гарантирует, что только один поток может войти в данный критический раздел кода в любой момент времени. </p>

<p><span class="text-green">Синхронизированные блоки также гарантируют, что все переменные, к которым обращаются внутри синхронизированного блока, будут считаны из основной памяти, и когда поток выйдет из синхронизированного блока, все обновленные переменные будут снова сброшены в основную память, независимо от того, объявлена ли переменная как volatile или нет.</span></p>