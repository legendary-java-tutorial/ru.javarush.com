Альтернативные виды связывания модулей ПО
<p>----------------------------------------</p>
Замена прямых зависимостей на обмен сообщениями. 
Закон Деметры (law of Demeter). 
Композиция вместо наследования.
<p>----------------------------------------</p>
    <h2>Замена прямых зависимостей на обмен сообщениями</h2>

    <p>Иногда модулю нужно всего лишь известить других о том, что в нем произошли какие-то события/изменения и ему не важно, что с этой информацией будет происходить потом.</p>

    <p>В этом случае модулям вовсе нет необходимости “знать друг о друге”, то есть содержать прямые ссылки и взаимодействовать непосредственно, а достаточно всего лишь обмениваться сообщениями (messages) или событиями (events).</p>

    <p>Иногда кажется, что связь модулей через обмен сообщениями является гораздо более слабой, чем прямая зависимость. Действительно, ведь методы не вызываются, информации о классах нет. Но это не более чем иллюзия.</p>

    <p>Вместо имен методов логика начинает привязываться к типам сообщений, их параметрам и передаваемым данным. <span class="text-red">Связность таких модулей размазывается.</span></p>

    <p>Раньше было как: вызываем методы — есть связность, не вызываем методы — нет связности. А теперь представь, что модуль A стал посылать немного другие данные в своих сообщениях. И при этом все зависимые от этих сообщений модули будут работать неправильно.</p>

    <p>Допустим, раньше, при добавлении нового пользователя модуль авторизации слал сообщение <span class="text-bold">USER_ADDED, а после апдейта он стал слать это сообщение при попытке регистрации и дополнительно в параметрах указывать успешная регистрация или нет.</p>

    <p>Поэтому очень важно реализовывать механизм сообщений очень грамотно. Для этого есть различные шаблоны.</p>

    <p><span class="text-bold">Наблюдатель (Observer).</span> Применяется в случае зависимости «один-ко-многим», когда множество модулей зависят от состояния одного — основного. Использует механизм рассылки, который заключается в том, что основной модуль просто осуществляет рассылку одинаковых сообщений всем своим подписчикам, а модули, заинтересованные в этой информации, реализуют интерфейс “подписчика” и подписываются на рассылку.</p>

    <p>Этот подход находит широкое применение в системах с пользовательским интерфейсом, позволяя ядру приложения (модели) оставаться независимым и при этом информировать связанные с ним интерфейсы о том, что произошли какие-то изменения и нужно обновиться.</p>

    <p>Тут формат сообщений стандартизируется на уровне операционной системы, разработчики которой должны позаботиться об обратной совместимости и хорошей документации.</p>

    <p>Организация взаимодействия посредством рассылки сообщений имеет дополнительный “бонус” — необязательность существования “подписчиков” на “опубликованные” (то есть рассылаемые) сообщения. Качественно спроектированная подобная система допускает добавление/удаление модулей в любое время.</p>

    <h2>Шина обмена сообщениями</h2>

    <p>Можно организовать обмен сообщениями и по-другому использовать для этого паттерн <span class="text-bold">Посредник (Mediator)</span>.</p>

    <p>Он применяется, когда между модулями имеется зависимость “многие ко многим”. Медиатор выступает в качестве посредника в общении между модулями, действуя как центр связи и избавляет модули от необходимости явно ссылаться друг на друга.</p>

    <p>В результате взаимодействие модулей друг с другом (“все со всеми”) заменяется взаимодействием модулей лишь с посредником (“один со всеми”). Говорят, что посредник инкапсулирует взаимодействие между множеством модулей.</p>
<img data-max-width="1024" data-id="68cdf298-e0c1-40cf-8e0e-afb3508ae104" src="https://cdn.javarush.com/images/article/68cdf298-e0c1-40cf-8e0e-afb3508ae104/1024.jpeg" alt="Шина обмена сообщениями">

    <p>Это так называемый <span class="text-bold">умный посредник</span>. Именно там чаще всего разработчики начинают добавлять свои костыли, чем влияют на поведение отдельных модулей через включение/выключение получения определенных сообщений.</p>

    <p>Типичный пример из жизни — контроль трафика в аэропорту. Все сообщения, исходящие от самолетов, поступают в башню управления диспетчеру вместо того, чтобы пересылаться между самолетами напрямую. А диспетчер уже принимает решения о том, какие самолеты могут взлетать или садиться, и, в свою очередь, отправляет самолетам соответствующие сообщения.</p>

    <p><span class="text-bold"><span class="text-red">Важно!</span></span> Модули могут пересылать друг другу не только простые сообщения, но и объекты-команды. Такое взаимодействие описывается шаблоном Команда (<span class="text-bold">Command</span>). Суть заключается в инкапсулировании запроса на выполнение определенного действия в виде отдельного объекта.</p>

    <p>Фактически этот объект содержит один единственный метод <span class="code text-orange">execute()</span>, что позволяет затем передавать это действие другим модулям на выполнение в качестве параметра и вообще производить с объектом-командой любые операции, какие могут быть произведены над обычными объектами. </p>

    <h2>Закон Деметры (law of Demeter)</h2>

    <p><a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B" target="_blank">Закон Деметры</a> запрещает использование неявных зависимостей: "Объект A не должен иметь возможность получить непосредственный доступ к объекту C, если у объекта A есть доступ к объекту B и у объекта B есть доступ к объекту C".</p>

    <p>Это означает, что все зависимости в коде должны быть “явными” — классы/модули могут использовать в работе только “свои зависимости” и не должны лезть через них к другим. Хороший пример – это трехуровневая архитектура. Уровень интерфейса должен работать с уровнем логики, но не должен напрямую взаимодействовать с уровнем базы данных.</p>

    <p>Кратко этот принцип формулируют еще таким образом: "Взаимодействуй только с непосредственными друзьями, а не с друзьями друзей". Тем самым достигается меньшая связанность кода, а также большая наглядность и прозрачность его дизайна.</p>

    <p>Закон Деметры реализует уже упоминавшийся “принцип минимального знания”, являющийся основой слабой связанности и заключающийся в том, что объект/модуль должен знать как можно меньше деталей о структуре и свойствах других объектов/модулей и вообще чего угодно, <span class="text-bold">включая собственные компоненты</span>.</p>

    <p>Аналогия из жизни: если ты хочешь, чтобы собака побежала, глупо командовать ее лапами, лучше отдать команду собаке, а она уже разберется со своими лапами сама.</p>
 
    <h2>Композиция вместо наследования</h2>

    <p>Это очень большая и интересная тема и она достойна как минимум отдельной лекции. На эту тему в интернете было сломано немало копий пока не был достигнут консенсус — наследование используем по минимуму, композицию — по максимуму.</p>

    <p>Все дело в том, что наследование дает фактически самую сильную связь между классами, поэтому его следует избегать. Эта тема хорошо раскрыта в статье Герба Саттера — “<a href="http://programming-lang.com/ru/comp_programming/satter/0/j84.html" target="_blank">Предпочитайте композицию наследованию</a>”.</p>

    <p>Когда ты начнешь изучать паттерны проектирования, то столкнешься с целой кучей паттернов, которые управляют созданием объекта или его внутренним устройством. Кстати, могу посоветовать в данном контексте обратить внимание на шаблон <span class="text-bold">Делегат (Delegation/Delegate)</span> и, пришедший из игр, шаблон <span class="text-bold">Компонент (Component)</span>.  </p>

    <p>Детальнее о паттернах мы поговорим немного позднее.</p>