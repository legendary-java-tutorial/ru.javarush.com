Многопоточные паттерны
<p>----------------------------------------</p>
Active object
Lock
Monitor
Double check locking
Scheduler
<p>----------------------------------------</p>
<h2>3.1 Active object</h2>
<p><strong>Активный объект (Active object)</strong> — это шаблон проектирования, который отделяет поток выполнения метода от потока, в котором он был вызван. Цель этого шаблона — предоставлять параллельность выполнения, используя асинхронные вызовы методов и планировщик обработки запросов.</p>
<p>Упрощённый вариант:</p>
<img data-max-width="800" data-id="19841270-318f-4d3e-ad78-23c7e8acf225" src="https://cdn.javarush.com/images/article/19841270-318f-4d3e-ad78-23c7e8acf225/800.jpeg" alt="Active object">
<p>Классический вариант:</p>
<img data-max-width="800" data-id="db9858eb-5021-40ae-a561-9989b344f1fd" src="https://cdn.javarush.com/images/article/db9858eb-5021-40ae-a561-9989b344f1fd/800.jpeg" alt="Active object 2">
<p>Этот шаблон состоит из шести элементов:</p>
<ul>
    <li>Объект-заместитель (proxy), который предоставляет интерфейс к публично-доступным методам клиента.</li>
    <li>Интерфейс, который определяет методы доступа к активному объекту.</li>
    <li>Список поступающих запросов от клиентов.</li>
    <li>Планировщик (scheduler), который определяет порядок выполнения запросов.</li>
    <li>Реализация методов активного объекта.</li>
    <li>Процедура обратного вызова (callback) или переменная (variable) для получения клиентом результата.</li>
</ul>
<h2>3.2 Lock</h2>
<p><strong>Паттерн Блокировка (Lock)</strong> — механизм синхронизации, позволяющий обеспечить исключительный доступ к разделяемому ресурсу между несколькими потоками. Блокировки — это один из способов обеспечить политику управления распараллеливанием.</p>
<img data-max-width="800" data-id="c1de466a-7e83-4372-a79e-7344cbe094f8" src="https://cdn.javarush.com/images/article/c1de466a-7e83-4372-a79e-7344cbe094f8/800.jpeg" alt="">
<p>В основном, используется мягкая блокировка, при этом предполагается что каждый поток пытается “захватить блокировку” перед доступом к соответствующему разделяемому ресурсу.</p>
<p>Однако в некоторых системах предоставляется механизм обязательной блокировки, при его использовании попытка несанкционированного доступа к заблокированному ресурсу будет прервана через создание исключения в потоке, который пытался получить доступ.</p>
<p><strong>Семафор</strong> — самый простой тип блокировки. С точки зрения доступа к данным не делается никаких различий между режимами доступа: общим (только чтение) или эксклюзивным (чтение и запись). В режиме общего доступа несколько потоков могут запросить блокировку для доступа к данным в режиме “только чтение”. Также используется эксклюзивный режим доступа в алгоритмах обновления и удаления.</p>
<img data-max-width="800" data-id="14da5562-e2ce-49f4-b330-3312f977f4b4" src="https://cdn.javarush.com/images/article/14da5562-e2ce-49f4-b330-3312f977f4b4/800.jpeg" alt="Lock pattern">
<p>Типы блокировок различают по стратегии блокировки продолжения исполнения потока. В большинстве реализаций запрос блокировки препятствует дальнейшему исполнению потока, пока не появится доступ к заблокированному ресурсу.</p>
<p><strong>Спинлок</strong> — это блокировка, которая ожидает в цикле, пока не появится доступ. Такая блокировка очень эффективна, если поток ожидает блокировку незначительный интервал времени, это позволяет избежать избыточной перепланировки потоков. Затраты на ожидание доступа будут значительными при длительном удержании блокировки одним из потоков.</p>
<img data-max-width="800" data-id="8c7fe29c-5d7b-4888-9745-b45fbe9a0424" src="https://cdn.javarush.com/images/article/8c7fe29c-5d7b-4888-9745-b45fbe9a0424/800.jpeg" alt="Lock pattern 2">
<p>Для эффективной реализации механизма блокировки требуется поддержка на аппаратном уровне. Аппаратная поддержка может быть реализована в виде одной или нескольких атомарных операций, таких как “test-and-set”, “fetch-and-add” или “compare-and-swap”. Такие инструкции позволяют без прерываний проверить, что блокировка свободна, и если это так, то занять блокировку.</p>
<h2>3.3 Monitor</h2>
<p><strong>Паттерн Монитор</strong> — высокоуровневый механизм взаимодействия и синхронизации процессов, обеспечивающий доступ к разделяемым ресурсам. Подход к синхронизации двух или более компьютерных задач, использующих общий ресурс, обычно аппаратуру или набор переменных.</p>
<p>При многозадачности, основанной на мониторах, компилятор или интерпретатор прозрачно для программиста вставляет код блокировки-разблокировки в оформленные соответствующим образом процедуры, избавляя программиста от явного обращения к примитивам синхронизации.</p>
<img data-max-width="800" data-id="3b7a2de5-610e-43da-9752-9ae8fa604eb8" src="https://cdn.javarush.com/images/article/3b7a2de5-610e-43da-9752-9ae8fa604eb8/800.jpeg" alt="">
<p>Монитор состоит из:</p>
<ul>
    <li>набора процедур, взаимодействующих с общим ресурсом</li>
    <li>мьютекса</li>
    <li>переменных, связанных с этим ресурсом</li>
    <li>инварианта, который определяет условия, позволяющие избежать состояние гонки</li>
</ul>
<p>Процедура монитора захватывает мьютекс перед началом работы и держит его или до выхода из процедуры, или до момента ожидания определенного условия. Если каждая процедура гарантирует, что перед освобождением мьютекса инвариант истинен, то никакая задача не может получить ресурс в состоянии, ведущем к гонке.</p>
<p>Именно так в Java работает оператор <strong>synchronized</strong> в паре с методами <code>wait()</code> и <code>notify()</code>.</p>
<h2>3.4 Double check locking</h2>
<p><strong>Блокировка с двойной проверкой (Double checked locking)</strong> — параллельный шаблон проектирования, предназначающийся для уменьшения накладных расходов, связанных с получением блокировки.</p>
<p>Сначала проверяется условие блокировки без какой-либо синхронизации. Поток пытается получить блокировку, только если результат проверки говорит о том, что получение блокировки необходимо.</p>

<pre class='language-java line-numbers'><code>
//Double-Checked Locking
public final class Singleton {
private static Singleton instance; //Don't forget volatile modifier

public static Singleton getInstance() {
     if (instance == null) {                //Read

         synchronized (Singleton.class) {    //
             if (instance == null) {         //Read Write
                 instance = new Singleton(); //
             }
         }
     }
 }
</code></pre>
<p>Как создать объект-синглетон в потокобезопасной среде?</p>
<pre class='language-java line-numbers'><code>
public static Singleton getInstance() {
   if (instance == null)
    instance = new Singleton();
}

</code></pre>
<p>Если ты создаешь объект Singleton из разных потоков, то может возникнуть ситуация, когда создастся несколько объектов одновременно, а это неприемлемо. Поэтому разумно обернуть создание объекта в оператор synchronized.</p>
<pre class='language-java line-numbers'><code>
public static Singleton getInstance() {
    synchronized (Singleton.class) {
        if (instance == null)
        instance = new Singleton();
    }
}

</code></pre>
<p>Такой подход будет работать, однако у него есть небольшой минус. После того, как объект создан, каждый раз при попытке его получить в будущем будет выполняться проверка в блоке synchronized, а значит будет лочиться текущий поток и все, что с этим связано. Так что этот код можно немного оптимизировать:</p>
<pre class='language-java line-numbers'><code>
public static Singleton getInstance() {
     if (instance != null)
        return instance;
 
    synchronized (Singleton.class) {
        if (instance == null)
        instance = new Singleton();
    }
}

</code></pre>
<p>На некоторых языках и/или на некоторых машинах невозможно безопасно реализовать этот шаблон. Поэтому иногда его называют анти-паттерном. Такие особенности привели к появлению отношения строгого порядка “happens before” в Java Memory Model и C++ Memory Model.</p>
<p>Обычно он используется для уменьшения накладных расходов при реализации ленивой инициализации в многопоточных программах, например, в составе шаблона проектирования Одиночка. При ленивой инициализации переменной инициализация откладывается до тех пор, пока значение переменной не понадобится при вычислениях.</p>
<h2>3.5 Scheduler</h2>
<p><strong>Планировщик (Scheduler)</strong> — параллельный шаблон проектирования, обеспечивающий механизм реализации политики планирования, но при этом не зависящий ни от одной конкретной политики. Управляет порядком, в соответствии с которым потокам предстоит выполнить последовательный код, используя для этого объект, который явным образом задаёт последовательность ожидающих потоков.</p>
<img data-max-width="800" data-id="6cf63a65-1fe5-44f8-a43c-6f5219728c9a" src="https://cdn.javarush.com/images/article/6cf63a65-1fe5-44f8-a43c-6f5219728c9a/800.jpeg" alt="">
<p>Более детально с этим шаблоном вы можете ознакомиться в официальной документации. Также есть отличная <a href="https://habr.com/ru/company/vk/blog/317440/" target="_blank">статья на русском</a>.</p>