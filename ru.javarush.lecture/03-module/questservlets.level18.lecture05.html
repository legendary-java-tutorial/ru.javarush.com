Виды сборщиков мусора в Java
<p>----------------------------------------</p>
Serial GC. 
Parallel GC. 
CMS GC. 
G1 (Garbage first) GC. 
Shenandoah (Шандара). 
ZGC.
<p>----------------------------------------</p>
<h2>Serial GC</h2>

<p>Сборка мусора повышает эффективность работы с памятью в Java, так как объекты, не имеющие ссылок удаляются из кучи и освобождается место для новосозданных объектов.</p>

<p>У Java виртуальной машины есть восемь типов сборщиков мусора. Рассмотрим каждый из них в деталях.</p>

<p><strong>Серийный GC</strong> — это самая простая реализация GC. Она предназначена для небольших приложений, работающих в однопоточных средах. Все события сборки мусора выполняются последовательно в одном потоке. Уплотнение выполняется после каждой сборки мусора.</p>

<img data-max-width="1024" data-id="3cbe67b6-3553-40cf-90a8-6df5080f300f" src="https://cdn.javarush.com/images/article/3cbe67b6-3553-40cf-90a8-6df5080f300f/1024.jpeg" alt="Serial GC">

<p>Запуск сборщика приводит к событию “остановки мира”, когда все приложение приостанавливает работу. Поскольку на время сборки мусора все приложение замораживается, не следует прибегать к такому в реальной жизни, если требуется, чтобы задержки были минимальными.</p>

<p>Аргумент JVM для использования последовательного сборщика мусора <strong>-XX:+UseSerialGC</strong>.</p>

<h2>Parallel GC</h2>

<p><strong>Параллельный сборщик мусора</strong> предназначен для приложений со средними и большими наборами данных, которые выполняются на многопоточном или многопроцессорном оборудовании. Это реализация GC по умолчанию и она также известна как сборщик пропускной способности.</p>

<p>Несколько потоков предназначаются для малой сборки мусора в молодом поколении. Единственный поток занят основной сборкой мусора в старшем поколении.</p>

<img data-max-width="1024" data-id="9253feb3-a0e1-4ef0-9696-25926c18df42" src="https://cdn.javarush.com/images/article/9253feb3-a0e1-4ef0-9696-25926c18df42/1024.jpeg" alt="Parallel GC">

<p>Запуск параллельного GC также вызывает “остановку мира” и приложение зависает. Такое поведение больше подходит для многопоточной среды, когда требуется завершить много задач и допустимы длительные паузы, например при выполнении пакетного задания.</p>

<p>Аргумент JVM для использования параллельного сборщика мусора: <strong>-XX:+UseParallelGC</strong>.</p>

<h2>CMS GC </h2>

<p>Также известен нам как <strong>параллельный сборщик низких пауз</strong>.</p>

<p>Тут для малой сборки мусора задействуются несколько потоков, происходит это через такой же алгоритм, как и в параллельном сборщике. Основная сборка мусора многопоточна, как и в старом параллельном GC, но CMS работает одновременно с процессами приложений, чтобы свести к минимуму события “остановки мира”.</p>

<img data-max-width="1024" data-id="ba41fb23-bd47-4051-8264-a95a9c9849ad" src="https://cdn.javarush.com/images/article/ba41fb23-bd47-4051-8264-a95a9c9849ad/1024.jpeg" alt="CMS GC">

<p>Из-за этого сборщик CMS потребляет больше ресурсов процессора, чем другие сборщики. Если у вас есть возможность выделить больше ЦП для повышения производительности, то CMS предпочтительнее, чем простой параллельный сборщик. В CMS GC не выполняется уплотнение.</p>

<p>Аргумент JVM для использования параллельного сборщика мусора с разверткой меток: <strong>-XX:+UseConcMarkSweepGC</strong>.</p>

<h2>G1 (Garbage first) GC</h2>

<p><strong>G1GC</strong> был задуман как замена CMS и разрабатывался для многопоточных приложений, которые характеризуются крупным размером кучи (более 4 ГБ). Он параллелен и конкурентен, как CMS, но “под капотом” работает совершенно иначе, чем старые сборщики мусора.</p>

<p>Хотя G1 также действует по принципу поколений, в нем нет отдельных пространств для молодого и старшего поколений. Вместо этого каждое поколение представляет собой набор областей, что позволяет гибко изменять размер молодого поколения.</p>

<p>G1 разбивает кучу на набор областей одинакового размера (в зависимости от размера кучи) и сканирует их в несколько потоков. Область во время выполнения программы может неоднократно становиться как старой, так и молодой.</p>

<p>После завершения этапа разметки G1 знает, в каких областях содержится больше всего мусора. Если пользователь заинтересован в минимизации пауз, G1 может выбрать только несколько областей. Если время паузы неважно для пользователя или предел этого времени установлен высокий, G1 пройдет по большему числу областей.</p>

<p>Поскольку G1 GC идентифицирует регионы с наибольшим количеством мусора и сначала выполняет сбор мусора в них, он и называется: “Мусор — первым”.</p>

<img data-max-width="800" data-id="a2c26fd4-2e6b-4d2c-a646-473db59d44a6" src="https://cdn.javarush.com/images/article/a2c26fd4-2e6b-4d2c-a646-473db59d44a6/800.jpeg" alt="">

<p>Помимо областей Эдема, Выживших и Старой памяти, в G1GC присутствуют еще два типа.</p>

<ul>
<li><strong>Humongous</strong> (Огромная) — для объектов большого размера (более 50% размера кучи).</li>
<li><strong>Available</strong> (Доступная) — неиспользуемое или не выделенное пространство.</li>
</ul>

<p>Аргумент JVM для использования сборщика мусора G1: <strong>-XX:+UseG1GC</strong>.</p>

<h2>Shenandoah (Шандара) </h2>

<p><strong>Shenandoah</strong> — новый GC, выпущенный как часть JDK 12. Ключевое преимущество Shenandoah перед G1 состоит в том, что большая часть цикла сборки мусора выполняется одновременно с потоками приложений. G1 может эвакуировать области кучи только тогда, когда приложение приостановлено, а Shenandoah перемещает объекты одновременно с приложением.</p>

<p>Shenandoah может компактировать живые объекты, очищать мусор и освобождать оперативную память почти сразу после обнаружения свободной памяти. Поскольку все это происходит одновременно, без приостановки работы приложения, то Shenandoah более интенсивно нагружает процессор.</p>

<o>Аргумент JVM для сборщика мусора Шенандоа: <strong>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</strong>.</p>

<h2>ZGC</h2>

<p><strong>ZGC</strong> — еще один GC, выпущенный как часть JDK 11 и улучшенный в JDK 12.</p>

<p>Он предназначен для приложений, которые требуют быстродействия и низкой задержки (паузы в менее чем 10 мс) и/или задействуют очень большую кучу (несколько терабайт).</p>

<p>Основные цели ZGC — низкая задержка, масштабируемость и простота в применении.
Для этого он позволяет Java-приложению продолжать работу, несмотря на то, что выполняются операции по сбору мусора. По умолчанию ZGC освобождает неиспользуемую память и возвращает ее в операционную систему.</p>

<p>Таким образом, ZGC привносит значительное улучшение по сравнению с другими традиционными GC, обеспечивая чрезвычайно низкое время паузы (обычно в пределах 2 мс).</p>

<img data-max-width="512" data-id="3ca77686-5b92-46ad-ab67-f8623caa9c71" src="https://cdn.javarush.com/images/article/3ca77686-5b92-46ad-ab67-f8623caa9c71/512.jpeg" alt="Основные цели ZGC ">

<p>Аргумент JVM для использования сборщика мусора ZGC: <strong>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</strong>.</p>