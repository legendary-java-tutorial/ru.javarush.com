Атомарные операции в Java
<p>----------------------------------------</p>
Предпосылки появления атомарных операций. 
Атомарные операции. 
Знакомство с атомарными типами. 
AtomicInteger.
<p>----------------------------------------</p>
<h2>Предпосылки появления атомарных операций</h2>

<p>Давай разберем данный пример, который поможет понять работу атомарных операций:</p>

<pre class='language-java line-numbers'><code>
public class Counter {
    int count; 
 
    public void increment() {
        count++;
    }
}
</code></pre>

<p>Когда у нас один поток, все работает классно, но если мы добавляем многопоточку, то получаем неправильные результаты, а все из-за того, что операция инкремента составляет не одну операцию, а три: запрос на получение текущего значения <mark class="user">count</mark>, потом увелечение ее на 1 и запись снова в <mark class="user">count</mark>.</p>

<p>И когда два потока захотят увеличить переменную, скорее всего, ты потеряешь данные. То есть оба потока получают 100, в результате оба запишут 101 вместо ожидаемого значения 102.</p>

<p>И как же это решить? Нужно использовать блокировки. Ключевое слово <span class="text-user"><span class="text-bold">synchronized</span></span> помогает решить данную проблему, использование этого слова дает вам гарантию, что один поток будет обращаться к методу единовременно.</p>

<pre class='language-java line-numbers'><code>
public class SynchronizedCounterWithLock {
    private volatile int count;
 
    public synchronized void increment() {
        count++;
    }
}
</code></pre>

<p>Плюс надо добавлять ключевое слово <span class="text-user"><span class="text-bold">volatile</span></span>, которое обеспечивает корректную видимость ссылок среди потоков. Мы разбирали его работу выше.</p>

<p>Но все же есть минусы. Самый большой — это производительность, в тот момент времени, когда много потоков пытаются получить блокировку и один получает возможность для записи, остальные потоки будут или заблокированы, или приостановлены до момента освобождения потока.</p>

<p>Все эти процессы, блокировка, переход в другой статус ​​— очень дороги для производительности системы.</p>

<h2>Атомарные операции</h2>

<p>Алгоритм использует низкоуровневые машинные инструкции, такие как сравнение и замена (CAS, compare-and-swap, что обеспечивает целостность данных  и по ним уже существует большое количество исследований).</p>

<p>Типичная операция CAS работает с тремя операндами:</p>

<ul>
<li>Место в памяти для работы (M)</li>
<li>Существующее ожидаемое значение (A) переменной</li>
<li>Новое значение (B), которое необходимо установить</li>
</ul>

<p>CAS атомарно обновляет M до B, но только если значение M совпадает с A, в противном случае никаких действий предприниматься не будет.</p>

<p>В первом и втором случае вернут значение М. Это позволяет объединить три шага, а именно — получение значения, сравнение значения и его обновление. И это все превращается в одну операцию на машинном уровне.</p>

<p>В тот момент времени, когда многопоточное приложение обращается к переменной и пытается обновить его и применяется CAS, то один из потоков получит его и сможет обновить его. Но в отличии от блокировок, другие потоки просто получат ошибки о том, что им не удалось обновить значение. Потом они перейдут к дальнейшей работе, а переключение полностью исключено при таком типе работе.</p>

<p>При этом логика становится труднее из-за того, что мы должны обработать ситуацию, когда операция CAS не отработала успешно. Мы просто смоделируем код таким образом, чтобы он не двигался дальше, пока операция не произойдет успешно.</p>

<h2>Знакомство с атомарными типами</h2>

<p>Ты столкнулся с ситуацией, когда тебе нужно настроить синхронизацию для самой простой переменной типа <span class="text-orange">int</span>?</p>

<p>Первый способ, который мы уже разобрали – это использование <span class="text-user"><span class="text-bold">volatile</span></span> + <span class="text-user"><span class="text-bold">synchronized</span></span>. Но есть еще специальные классы Atomic*.</p>

<img data-max-width="1024" data-id="bd36155b-5ec3-43e3-b496-5a6161332457" src="https://cdn.javarush.com/images/article/bd36155b-5ec3-43e3-b496-5a6161332457/1024.jpeg" alt="">

<p>Если у нас используется CAS, то операции работают быстрее по сравнению с первым способом. И в дополнение у нас есть специальные и очень удобные методы для добавления значения и операции инкремента и декремента.</p>

<p><span class="code"><span class="text-green">AtomicBoolean</span></span>, <span class="code"><span class="text-green">AtomicInteger</span></span>, <span class="code"><span class="text-green">AtomicLong</span></span>, <span class="code"><span class="text-green">AtomicIntegerArray</span></span>, <span class="code"><span class="text-green">AtomicLongArray</span></span> —классы в которых операции атомарны. Ниже мы разберем работу с ними.</p>

<h2>AtomicInteger</h2>

<p>Класс <span class="code"><span class="text-green">AtomicInteger</span></span> предоставляет операции с значением <span class="text-orange">int</span>, которые могут быть прочитаны и записаны атомарно, в дополнение содержит расширенные атомарные операции. </p>

<p>У него есть методы <span class="code text-orange">get</span> и <span class="code text-orange">set</span>, которые работают, как чтение и запись по переменным. </p>

<p>То есть “происходит до (happens-before)” с любым последующим получением той же переменной, о которой мы говорили ранее. У атомарного метода <span class="code text-orange">compareAndSet</span> также есть эти особенности согласованности памяти.</p>

<p>Все операции, которые возвращают новое значение, выполняются атомарно:</p>

<table>
<tbody>
<tr>
<td>int addAndGet (int delta)</td>
<td>Добавляет определенное значение к текущему значению.</td>
</tr>
<tr>
<td>boolean compareAndSet 
(ожидаемое int, обновление int)</td>
<td>Устанавливает значение для данного обновленного значения, если текущее значение совпадает с ожидаемым значением.</td>
</tr>
<tr>
<td>int decrementAndGet ()</td>
<td>Уменьшает на единицу текущее значение.</td>
</tr>
<tr>
<td>int getAndAdd (int delta)</td>
<td>Добавляет данное значение к текущему значению.</td>
</tr>
<tr>
<td>int getAndDecrement ()</td>
<td>Уменьшает на единицу текущее значение.</td>
</tr>
<tr>
<td>int getAndIncrement ()</td>
<td>Увеличивает на единицу текущее значение.</td>
</tr>
<tr>
<td>int getAndSet (int newValue)</td>
<td>Устанавливает заданное значение и возвращает старое значение.</td>
</tr>
<tr>
<td>int incrementAndGet ()</td>
<td>Увеличивает на единицу текущее значение.</td>
</tr>
<tr>
<td>lazySet (int newValue)</td>
<td>В конце-концов устанавливается на заданное значение.</td>
</tr>
<tr>
<td>boolean weakCompareAndSet (ожидаемое, обновление int)</td>
<td>Устанавливает значение для данного обновленного значения, если текущее значение совпадает с ожидаемым значением.</td>
</tr>
</tbody>
</table>

<p>Пример:</p>

<pre class='language-java line-numbers'><code>
ExecutorService executor = Executors.newFixedThreadPool(5);
IntStream.range(0, 50).forEach(i -> executor.submit(atomicInteger::incrementAndGet));
executor.shutdown();
executor.awaitTermination(Long.MAX_VALUE, TimeUnit.HOURS);

System.out.println(atomicInteger.get()); // выведет 50
</code></pre>