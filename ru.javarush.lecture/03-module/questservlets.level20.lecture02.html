Класс StringUtils из Apache Commons
<p>----------------------------------------</p>
Знакомство со StringUtils
StringUtils.isEmpty() и StringUtils.isBlank()
StringUtils.equals()
StringUtils.compare()
Проверяем, содержит ли строка другую подстроку
Работа с подстроками
<p>----------------------------------------</p>
<h2>Знакомство со StringUtils</h2>

<p><strong>StringUtils</strong> — наиболее используемый класс Apache Commons. Он содержит различные утилиты и методы, которые помогают разработчикам избегать написания шаблонного или просто громоздкого кода для базовых операций.</p>

<p>Многие методы в классе <span class="code"><span class="text-green">StringUtils</span></span> имеют свои эквиваленты в <strong>java.lang.String</strong>, но, в отличие от методов <strong>java.lang.String</strong>, являются безопасными для работы с null. Это означает, что исключение <span class="text-red"><span class="text-bold">NullPointerException</span></span> не выбрасывается в самый неожиданный момент.</p>

<p>Apache Commons содержит ряд методов, и мы рассмотрим некоторые из наиболее часто используемых.</p>

<p>Список методов StringUtils:</p>

<table>
<tbody>
<tr>
<td><span class="code text-orange">isEmpty()</span></td>
<td>Проверяет, пустая ли строка</td>
</tr>
<tr>
<td><span class="code text-orange">equals()</span></td>
<td>Сравнивает строки</td>
</tr>
<tr>
<td><span class="code text-orange">compare()</span></td>
<td>Сравнивает строки</td>
</tr>
<tr>
<td><span class="code text-orange">indexOf()</span></td>
<td>Поиск подстроки в строке</td>
</tr>
<tr>
<td><span class="code text-orange">lastIndexOf()</span></td>
<td>Поиск подстроки в строке</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="code text-orange">contains()</span></td>
<td>Проверяет вхождение подстроки в строку</td>
</tr>
<tr>
<td><span class="code text-orange">containsIgnoreCase()</span></td>
<td>Проверяет вхождение подстроки в строку, игнорируя регистр</td>
</tr>
<tr>
<td><span class="code text-orange">containsAny()</span></td>
<td>Проверяет вхождение подстроки в любом месте строки</td>
</tr>
<tr>
<td><span class="code text-orange">containsNone()</span></td>
<td>Проверяет, нет ли вхождения подстроки в любом месте строки</td>
</tr>
<tr>
<td><span class="code text-orange">containsOnly()</span></td>
<td>Проверяет вхождение подстроки в строку</td>
</tr>
<tr>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="code text-orange">substring()</span></td>
<td>Получение подстроки</td>
</tr>
<tr>
<td><span class="code text-orange">split()</span></td>
<td>Разбиваем строку на подстроки</td>
</tr>
<tr>
<td><span class="code text-orange">join()</span></td>
<td>Объединяем подстроки</td>
</tr>
<tr>
<td><span class="code text-orange">remove()</span></td>
<td>Удаляем подстроку</td>
</tr>
<tr>
<td><span class="code text-orange">replace()</span></td>
<td>Заменить подстроку</td>
</tr>
<tr>
<td><span class="code text-orange">countMatches()</span></td>
<td>Считаем количество совпадений</td>
</tr>
</tbody>
</table>

<h2>StringUtils.isEmpty() и StringUtils.isBlank()</h2>

<p>Оба метода используются для проверки того, содержит ли строка какой-либо текст. Они возвращают true, если строка действительно пуста. Кроме того, <span class="code text-orange">isBlank()</span> также вернет <span class="text-green"><em>true</em></span>, если строка содержит только пробелы.</p>

<p>У них также есть свои обратные методы: <span class="code text-orange">isNotEmpty()</span> и <span class="code text-orange">isNotBlank()</span>.</p>

<p>Давай посмотрим, как ты можешь использовать <span class="code text-orange">isEmpty()</span> вместе с его аналогом <span class="code text-orange">java.lang.String.isEmpty()</span>, а также <span class="code text-orange">isBlank()</span>:</p>

<pre class='language-java line-numbers'><code>
String nullValue = null;
String emptyValue = "";
String blankValue = "\n \t   \n";

if(StringUtils.isEmpty(emptyValue)) {
   System.out.println("emptyValue is emptyValue");
}

if(StringUtils.isBlank(blankValue)) {
   System.out.println("blankValue is blankValue");
}

if(!nullValue.isEmpty()) {
   System.out.println("nullString isn't null");
}
</code></pre>

<p>Здесь три переменных типа <span class="text-orange">String</span>. Одна указывает на <em><strong>null</strong></em>, вторая не является <em><strong>null</strong></em>, но не имеет содержимого (пустая строка), а третья не пустая, но при печати выдаст пустой результат.</p>

<p>Выполнение этого кода приводит к:</p>

<pre><code>emptyValue is emptyValue
blankValue is blankValue
Exception in thread "main" java.lang.NullPointerException
</code></pre>

<p>Метод <span class="code text-orange">isEmpty()</span>, встроенный в <strong>java.lang.String</strong>, небезопасный для <em><strong>null</strong></em>. Ты легко получишь <span class="text-red"><span class="text-bold">NullPointerException</span></span>, если попытаешся проверить, пуста ли она, так как вызовешь метод по ссылке <em><strong>null</strong></em>. Нужно будет заранее проверить, является ли ссылка нулевой:</p>

<pre class='language-java line-numbers'><code>
String nullValue = null;
String emptyValue = "";
String blankValue = "\n \t   \n";

if(StringUtils.isEmpty(emptyValue)) {
   System.out.println("emptyValue is emptyValue");
}

if(StringUtils.isBlank(blankValue)) {
   System.out.println("blankValue is blankValue");
}

if(nullValue != null && !nullValue.isEmpty()) {
   System.out.println("nullString isn't null");
}
</code></pre>

<p>Теперь это приводит к:</p>

<pre><code>emptyValue is emptyValue
blankValue is blankValue
</code></pre>

<p>И если мы протестируем эти методы на <mark class="user">nullString</mark>:</p>

<pre class='language-java line-numbers'><code>
String nullValue = null;

if(StringUtils.isEmpty(nullValue)) {
   System.out.println("nullValue is emptyValue");
}

if(StringUtils.isBlank(nullValue)) {
   System.out.println("nullValue is blankValue");
}
</code></pre>

<p>То получим:</p>

<pre><code>nullValue is emptyValue
nullValue is blankValue
</code></pre>

<p>Методы <span class="code"><span class="text-green">StringUtils</span></span> безопасны для <em><strong>null</strong></em> и дают ожидаемый результат, даже если в них передали <em><strong>null</strong></em>.</p>

<h2>StringUtils.equals()</h2>

<p>Этот метод сравнивает две строки и возвращает <span class="text-green"><em>true</em></span>, если они идентичны или обе ссылки указывают на <em><strong>null</strong></em>, но имей ввиду, что этот метод чувствителен к регистру.</p>

<p>Давай посмотрим, как он работает:</p>

<pre class='language-java line-numbers'><code>
System.out.println(StringUtils.equals(null, null));
System.out.println(StringUtils.equals(null, "какая-то информация"));
System.out.println(StringUtils.equals("какая-то информация", null));
System.out.println(StringUtils.equals("какая-то информация",  "какая-то информация"));
System.out.println(StringUtils.equals("какая-то дополнительная информация", "какая-то информация"));
</code></pre>

<p>Результат:</p>

<pre><code>true
false
false
true
false
</code></pre>

<p>​Для сравнения метода <span class="code text-orange">equals()</span> из <span class="code"><span class="text-green">StringUtils</span></span> с <span class="code text-orange">java.lang.String.equals()</span>:</p>

<pre class='language-java line-numbers'><code>
String nullValue = null;

System.out.println(StringUtils.equals(nullValue, null));
System.out.println(StringUtils.equals(nullValue, "какая-то информация"));

System.out.println(nullValue.equals(null));
System.out.println(nullValue.equals("какая-то информация"));
</code></pre>

<p>Это опять привело тебя к:</p>

<pre><code>true
false
Exception in thread "main" java.lang.NullPointerException
</code></pre>

<p>Опять же, вызов метода для ссылки <em><strong>null</strong></em> приводит к исключению <span class="text-red"><span class="text-bold">NullPointerException</span></span>, и нужно будет заранее проверить, является ли ссылочная переменная <em><strong>null</strong></em>, перед ее использованием.</p>

<h2>StringUtils.compare()</h2>

<p>Объявление этого метода выглядит следующим образом:</p>

<pre class='language-java line-numbers'><code>
public static int compare(final String str1, final String str2)
</code></pre>

<p>Этот метод сравнивает две строки лексикографически, как это делает метод <span class="code text-orange">java.lang.String.compareTo()</span>, возвращая:</p>

<ul>
<li>0, если str1 равно str2 (или оба равны null)</li>
<li>Значение меньше, чем 0, если str1 меньше, чем str2</li>
<li>Значение, большее, чем 0, если str1 больше, чем str2</li>
</ul>

<p>Лексикографический порядок – это порядок по словарю. Давай посмотрим, как мы можем использовать это в нашей программе:</p>

<pre class='language-java line-numbers'><code>
System.out.println(StringUtils.compare(null, null));
System.out.println(StringUtils.compare(null , "javaRush"));
System.out.println(StringUtils.compare("javaRush", null));
System.out.println(StringUtils.compare("javaRush", "JAVARUSH"));
System.out.println(StringUtils.compare("javaRush", "javaRush"));
</code></pre>

<p>Получаем:</p>

<pre><code>0
-1
1
32
0
</code></pre>

<p>Примечание: значение <em><strong>null</strong></em> считается меньшим, чем значение, отличное от <em><strong>null</strong></em>. Два значения <em><strong>null</strong></em> считаются равными.</p>

<h2>Проверяем, содержит ли строка другую подстроку</h2>

<p>Для этого в <span class="code"><span class="text-green">StringUtils</span></span> есть 5 методов:</p>

<ul>
<li><span class="code text-orange">contains()</span></li>
<li><span class="code text-orange">containsIgnoreCase()</span></li>
<li><span class="code text-orange">containsAny()</span></li>
<li><span class="code text-orange">containsNone()</span></li>
<li><span class="code text-orange">containsOnly()</span></li>
</ul>

<p>Метод <span class="code text-orange">contains()</span> возвращает <span class="text-green"><em>true</em></span> или <span class="text-red"><em>false</em></span> в зависимости от того, содержится ли последовательность поиска в другой последовательности или нет.</p>

<p>Если в такой метод передать <em><strong>null</strong></em>, то он вернет <span class="text-red"><em>false</em></span>. Если передать не <em><strong>null</strong></em>, то метод просто вызовет <span class="code text-orange">java.lang.String.indexOf(String str)</span> у передаваемого объекта.</p>

<p>Примеры:</p>

<pre class='language-java line-numbers'><code>
String value = "JavaRush is cool";

System.out.println(StringUtils.contains(null, "a"));
System.out.println(StringUtils.contains(value, "JavaRush"));
System.out.println(StringUtils.contains(value, "C++"));
System.out.println(StringUtils.contains(value, "javarush"));
</code></pre>

<p>Метод чувствителен к регистру, поэтому последний вызов также вернет <span class="text-red"><em>false</em></span>:</p>

<pre><code>false
true
false
false
</code></pre>

<p>Метод <span class="code text-orange">containsAny()</span> возвращает <span class="text-green"><em>true</em></span>, если строка, переданная первым аргументом, содержит хотя бы одну из подстрок, переданную 2-N аргументами.</p>

<p>Пример:</p>

<pre class='language-java line-numbers'><code>
String value = "JavaRush is cool";
System.out.println(StringUtils.containsAny(value, "cool", "c00l", "bro", "hello"));
</code></pre>

<p>Выведет на экран:</p>

<pre><code>true
</code></pre>

<p>Этот метод также чувствителен к регистру.</p>

<h4>Метод containsNone() </h4>

<p>Когда нужно проверить, что определенная строка не содержит ничего из списка, можно воспользоваться методом <span class="code text-orange">containsNone()</span>. Первым параметром в него передается строка, а следующие параметры – это строки, которых не должно быть в целевой стоке.</p>

<p>Пример:</p>

<pre class='language-java line-numbers'><code>
String s = "JavaRush is cool";
System.out.println(StringUtils.containsNone(s, 'g', 'a'));
</code></pre>

<p>Вывод в консоль: </p>

<pre><code>false
</code></pre>

<h2>Работа с подстроками</h2>

<p>Работа с подстроками похожа на работу методов класса <span class="code"><span class="text-green">String</span></span>:</p>

<pre class='language-java line-numbers'><code>
substring(String str, int start)
substring (String str, int start, int end)
</code></pre>

<p>Эти методы возвращают подстроку из строки <span class="code">str</span>. Строка задается двумя индексами: <strong>start</strong> и <strong>end</strong>. И как принято в Java, последний символ диапазона – <strong>end-1</strong>. В чем же преимущество этих методов?</p>

<p>Если передать в такой метод <em><strong>null</strong></em>, он просто вернет <em><strong>null</strong></em>, а не кинет исключение. Эти методы поддерживают отрицательные значение индексов. При этом строка рассматривается как замкнутая петля. После последнего символа идет первый и т.д.</p>

<p>Давай посмотрим, как мы можем его использовать:</p>

<pre class='language-java line-numbers'><code>
System.out.println(StringUtils.substring("lets java", 2, 6));
System.out.println(StringUtils.substring("lets java", -8));
System.out.println(StringUtils.substring(null, 3));
</code></pre>

<p>Выполнение приведенного выше кода дает нам:</p>

<pre><code>ts j
ets java
null
</code></pre>

<h3>StringUtils.split()</h3>

<p>Метод, который позволяет разбить строку на подстроки, используя специальный символ-разделитель. Если такой есть в целевой строке, то метод вернет массив подстрок. Если символа нет – вернется пустой массив. Ну а если в метод передать <em><strong>null</strong></em>, он вернет <em><strong>null</strong></em>. Давай рассмотрим  этот код и работу метода:</p>

<pre class='language-java line-numbers'><code>
String myData = "Address, City, State, Zip, Phone, Email, Password";

System.out.println(Arrays.toString(StringUtils.split(myData, ',')));
System.out.println(Arrays.toString(StringUtils.split(null, '.')));
System.out.println(Arrays.toString(StringUtils.split("", '.')));
</code></pre>

<p>Результат:</p>

<pre><code>[Address,  City,  State,  Zip,  Phone,  Email,  Password]
null
[]
</code></pre>

<h3>StringUtils.join()</h3>

<p>Метод <span class="code text-orange">join()</span> позволяет склеить массив строк в одну строку. При этом в него можно передать специальный символ-разделитель, которые будет добавлен между подстроками в результирующей строке. А если в метод передать <em><strong>null</strong></em>, то он вернет <em><strong>null</strong></em>.</p>

<p>Этот метод представляет собой прямую противоположность методу <span class="code text-orange">split()</span>. Давай рассмотрим этот простой пример:</p>

<pre class='language-java line-numbers'><code>
String myData = "Address, City, State, Zip, Phone, Email, Password";

String[] myString =  StringUtils.split(myData, ',');
System.out.println(StringUtils.join(myString, '-'));
</code></pre>

<p>Выполнение приведенного выше кода дает нам:</p>

<pre><code>Address- City- State- Zip- Phone- Email- Password
</code></pre>

<h4>StringUtils.replace()</h4>

<p>Ищет строку внутри строки, находит ее, если она существует, и заменяет все ее вхождения новой строкой.</p>

<p>Объявление этого метода выглядит следующим образом:</p>

<pre><code>public static String replace(final String text, final String searchString, final String replacement)
</code></pre>

<p>Если строка поиска не найдена в тексте, то ничего не произойдет и текст останется прежним. Следуя той же логике, если текст равен <em><strong>null</strong></em>, этот метод возвращает <em><strong>null</strong></em>. Если ты ищешь <em><strong>null</strong></em>-строку или заменяешь подстроку на <em><strong>null</strong></em>, то метод вернет оригинальную строку.</p>

<p>Давай попробуем этот метод:</p>

<pre class='language-java line-numbers'><code>
String value = "JavaRush is the best";
System.out.println(StringUtils.replace(value, "best", "cool"));
</code></pre>

<p>Результат:</p>

<pre><code>JavaRush is the cool
</code></pre>

<ul>
<li><a href="https://stackabuse.com/guide-to-apache-commons-stringutils-class-in-java/" target="_blank">Guide to Apache Commons' StringUtils Class in Java</a></li>
<li><a href="https://rukovodstvo.net/posts/id_649/" target="_blank">Руководство по классу StringUtils Apache Commons в Java</a></li>
</ul>