Структурные паттерны
<p>----------------------------------------</p>
Adapter
Decorator
Proxy
Bridge
Facade
<p>----------------------------------------</p>
<h2>2.1 Adapter</h2>
<p><strong>Адаптер (Adapter)</strong> — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.</p>
<p>Официальное определение немного сложновато воспринимается, но если описать его своими словами, то адаптер — это паттерн проектирования, который <span class="text-red">позволяет объектам с несовместимыми интерфейсами работать вместе</span>.</p>
<img data-max-width="800" data-id="16b33563-4c66-4b1c-bb21-cebc6331e598" src="https://cdn.javarush.com/images/article/16b33563-4c66-4b1c-bb21-cebc6331e598/800.jpeg" alt="Adapter pattern">
<p><strong>Используется</strong> для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс. Создается дополнительный класс, у которого есть нужный интерфейс, а этот класс уже в свою очередь вызывает методы нужного объекта (у которого нет требуемого интерфейса).</p>
<p><strong>Важно!</strong> Если в коде ты встречаешь у класса суффикс Adapter, то имеешь полное право считать, что этот класс выполняет роль адаптера и связан с группой классов, которые работают по описанной выше схеме.</p>
<p><strong>Применяется в случаях</strong>, когда система поддерживает требуемые данные и поведение, но имеет неподходящий интерфейс. Чаще всего шаблон Адаптер применяется, если необходимо создать класс, унаследованный от нового или уже существующего абстрактного класса.</p>
<p><strong>Сильные стороны:  </strong></p>
<ul>
    <li>Переход на использование других внешних классов не требует переделки самой системы, достаточно реализовать еще один класс Adapter.</li>
    <li>Независимость от реализации внешних классов (классов из библиотек, чей код мы не можем поменять). Твоя программа становится независимой от интерфейса внешних классов.</li>
</ul>
<h2>2.2 Decorator</h2>
<p><strong>Декоратор (Decorator)</strong> — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет хорошую и гибкую альтернативу практике создания подклассов с целью расширения функциональности.</p>
<img data-max-width="800" data-id="a4f5f64a-fb28-494b-8c21-f8086ac55ce4" src="https://cdn.javarush.com/images/article/a4f5f64a-fb28-494b-8c21-f8086ac55ce4/800.jpeg" alt="Декоратор (Decorator) pattern">
<p><strong>Используется для</strong> динамического подключения к объекту дополнительных обязательств.</p>
<p>Многие из вас спросят: как можно динамически (во время работы программы) добавить объекту новое поведение? Объект можно собрать из кусочков, то есть маленьких объектов. Помнишь цепочки фильтров в сервлетах? Или Stream API, когда ты писал запрос с использованием filter(), map(), list()?</p>
<pre class='language-java line-numbers'><code>
IntStream.of(50, 60, 70, 80, 90).filter(x -> x < 90).map(x -> x + 10).limit(3).forEach(System.out::print);
</code></pre>
<p><strong>Сильные стороны паттерна Decorator:</strong></p>
<ul>
    <li>Нет необходимости создавать подклассы для расширения функциональности объекта.</li>
    <li>Возможность динамически подключать новую функциональность в любом месте: до или после основной функциональности объекта ConcreteComponent.</li>
</ul>
<h2>2.3 Proxy</h2>
<p><strong>Заместитель (Proxy)</strong> — структурный шаблон проектирования, предоставляющий объект, который контролирует доступ к другому объекту, перехватывая и пропуская через себя все его вызовы.</p>
<img data-max-width="800" data-id="3e687962-786e-4b54-8f30-5b4b2d5fad1c" src="https://cdn.javarush.com/images/article/3e687962-786e-4b54-8f30-5b4b2d5fad1c/800.jpeg" alt="Заместитель (Proxy)">
<p>Паттерн Proxy предоставляет объект-заменитель вместо настоящего объекта. Этот объект контролирует доступ к оригинальному объекту. Используется очень часто.</p>
<p>Помнишь, как мы использовали фреймворк Mockito и перехватывали обращение к реальному объекту с помощью метода Mockito.spy() или аннотации @Spy? Именно тогда и создавался специальный Proxy-объект, через который проходили все вызовы к оригинальному объекту.</p>
<p>И мы тогда с помощью добавления объекту правил могли этими вызовами управлять. Именно так – оригинальный объект не меняется, а работа с ним становится значительно гибче. Особенно полезно бывает, когда не мы из нашего кода вызываем proxy-объект, а передаем его куда-то. Контролируя таким образом общение двух независимых от нас объектов.</p>
<p><strong>Виды прокси</strong> по назначению:</p>
<ul>
    <li><strong>Протоколирующий прокси</strong>: сохраняет в лог все вызовы “Субъекта” с их параметрами.</li>
    <li><strong>Удаленный заместитель</strong> (remote proxies): обеспечивает связь с “Субъектом”, который находится в другом адресном пространстве или на удаленной машине. Также может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному “Субъекту”.</li>
    <li><strong>Виртуальный заместитель</strong> (virtual proxies): обеспечивает создание реального “Субъекта” только тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном “Субъекте”, чтобы отложить его создание.</li>
    <li><strong>Копировать-при-записи</strong>: обеспечивает копирование “субъекта” при выполнении клиентом определенных действий (частный случай “виртуального прокси”).</li>
    <li><strong>Защищающий заместитель</strong> (protection proxies): может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права.</li>
    <li><strong>Кэширующий прокси</strong>: обеспечивает временное хранение результатов расчета до отдачи их множественным клиентам, которые могут разделить эти результаты.</li>
    <li>Экранирующий прокси: защищает “Субъект” от опасных клиентов (или наоборот).</li>
    <li><strong>Синхронизирующий прокси</strong>: производит синхронизированный контроль доступа к “Субъекту” в асинхронной многопоточной среде.</li>
    <li><strong>“Умная” ссылка</strong> (smart reference proxy): производит дополнительные действия, когда на “Субъект” создается ссылка, например, рассчитывает количество активных ссылок на “Субъект”.</li>
</ul>
<h2>2.4 Bridge</h2>
<p><strong>Шаблон Мост (Bridge)</strong> — структурный шаблон проектирования, используемый чтобы “разделять абстракцию и реализацию так, чтобы они могли изменяться независимо”.</p>
<p>Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.</p>
<img data-max-width="800" data-id="679b0f01-4e75-4a06-be9d-21baf2a51f94" src="https://cdn.javarush.com/images/article/679b0f01-4e75-4a06-be9d-21baf2a51f94/800.jpeg" alt="Мост (Bridge)">
<p>Когда абстракция и реализация разделены, они могут изменяться независимо. Другими словами, при реализации через шаблон мост, изменение структуры интерфейса не мешает изменению структуры реализации.</p>
<p>Рассмотрим такую абстракцию как фигура. Существует множество типов фигур, каждая со своими свойствами и методами. Однако есть что-то, что объединяет все фигуры. Например, каждая фигура должна уметь рисовать себя, масштабироваться и так далее.</p>
<p>В то же время рисование графики может отличаться в зависимости от типа ОС или графической библиотеки. Фигуры должны иметь возможность рисовать себя в различных графических средах. Но реализовывать в каждой фигуре все способы рисования или модифицировать фигуру каждый раз при изменении способа рисования непрактично.</p>
<p>В этом случае помогает шаблон мост, позволяя создавать новые классы, которые будут реализовывать рисование в различных графических средах. При использовании такого подхода очень легко можно добавлять как новые фигуры, так и способы их рисования.</p>
<p>Связь, изображаемая стрелкой на диаграммах, может иметь 2 смысла: а) “разновидность”, в соответствии с принципом подстановки Лисков и б) одна из возможных реализаций абстракции. Обычно в языках используется наследование для реализации как а), так и б), что приводит к разбуханию иерархий классов.</p>
<p>Мост служит именно для решения этой проблемы: <strong>объекты создаются парами</strong> из объекта класса иерархии А и иерархии B, наследование внутри иерархии А имеет смысл “разновидность” по Лисков, а для понятия “реализация абстракции” используется ссылка из объекта A в парный ему объект B.</p>
<h2>2.5 Facade</h2>
<p><strong>Шаблон Фасад (Facade)</strong> — структурный шаблон проектирования, позволяющий скрыть сложность системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.</p>
<img data-max-width="800" data-id="55d9994f-3185-49a2-94e2-6686e342e528" src="https://cdn.javarush.com/images/article/55d9994f-3185-49a2-94e2-6686e342e528/800.jpeg" alt="Шаблон Фасад (Facade)">
<p>Как обеспечить унифицированный интерфейс с набором разрозненных реализаций или интерфейсов, например, с подсистемой, если нежелательно сильное связывание с этой подсистемой или реализация подсистемы может измениться?</p>
<p>Определить одну точку взаимодействия с подсистемой — фасадный объект, обеспечивающий общий интерфейс с подсистемой, и возложить на него обязанность по взаимодействию с ее компонентами. Фасад — это внешний объект, обеспечивающий единственную точку входа для служб подсистемы.</p>
<p>Реализация других компонентов подсистемы закрыта и не видна внешним компонентам. Фасадный объект обеспечивает реализацию GRASP паттерна Устойчивый к изменениям с точки зрения защиты от изменений в реализации подсистемы.</p>
<p><strong>Важно!</strong> Этот шаблон применяется, когда мы хотим полностью скрыть какую-то группу объектов и всю коммуникацию с ними пропустить через наш объект. Если же вы просто хотите обеспечить некоторый контроль процесса коммуникации объектов и скрывать их не обязательно, то лучше воспользоваться паттерном Proxy.</p>