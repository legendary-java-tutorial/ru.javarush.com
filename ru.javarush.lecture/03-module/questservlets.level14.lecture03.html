Критерии хорошей архитектуры ПО
<p>----------------------------------------</p>
Эффективность. 
Гибкость. 
Масштабируемость. 
Расширяемость.  
Тестируемость. 
Сопровождаемость кода.
<p>----------------------------------------</p>
    <h2>Эффективность</h2>

    <p>Опытные программисты легко могут отличить хорошую архитектуру от плохой, но если их попросить описать ее несколькими словами, то они вряд ли смогут это сделать. Нет единого критерия хорошей архитектуры и нет единого определения.</p>

    <p>Однако, если подумать, то можно написать ряд критериев, которым должна удовлетворять хорошая архитектура. <span class="text-bold">Хорошая архитектура</span> — это, прежде всего, логичная архитектура, делающая процесс разработки и сопровождения программы более простым и эффективным.</p>

    <p>Когда у программы хорошая архитектура, то всегда достаточно легко понять, как она устроена и где писать код. Программу с хорошей архитектурой легче изменять, тестировать, отлаживать и развивать. Умные люди сформулировали такие критерии хорошей архитектуры:</p>

    <ul>
        <li>Эффективность;</li>
        <li>Гибкость;</li>
        <li>Расширяемость;</li>
        <li>Масштабируемость;</li>
        <li>Тестируемость;</li>
        <li>Сопровождаемость кода.</li>
    </ul>

    <p><span class="text-bold">Эффективность системы.</span> Программа, конечно же, должна решать поставленные задачи и хорошо выполнять свои функции, причем в различных условиях. Кажется, что любая программа делает, то что должна делать, (если она написана), но зачастую это совсем не так.</p>

    <p>Ты будешь постоянно встречать программы, которые не делают, то, что заявлено.</p>

    <ul>
        <li>Libre Office полноценная замена Microsoft Office (на самом деле нет);</li>
        <li>Браузер Edge поддерживает все web-стандарты (на самом деле нет);</li>
        <li>Банк заботится о безопасности личных данных своих пользователей (на самом деле нет).</li>
    </ul>

    <p>И это мы еще не коснулись производительности, надежности, своевременного исправления багов или публикации информации об известных уязвимостях.</p>

    <p>Понятно, что никто не идеален, но программа должна решать поставленные перед ней первоочередные задачи. Поэтому без эффективности никуда.</p>

    <h2>Гибкость</h2>

    <p>Единственная вещь, которая по моему мнению еще более важна чем эффективность, — это гибкость. Любое приложение приходится менять со временем, так как изменяются требования, добавляются новые. Чем быстрее и удобнее можно внести изменения в существующий функционал, чем меньше проблем и ошибок это вызовет, тем <span class="text-bold">гибче</span> архитектура системы.</p>

    <p>Очень часто начинающие программисты/архитекторы думают, что им нужна идеальная архитектура под текущие задачи. Нет. <span class="text-green">Тебе нужна идеальная архитектура под задачи, которые тебе озвучат через год.</span> Ты, уже сейчас не зная будущих задач, должен знать, что они будут.</p>

    <p>Нет смысла пытаться их предсказать, ведь всегда будет что-то неожиданное. Но ты должен учитывать, что такие задачи появятся. Поэтому в процессе разработки старайся оценивать то, что получается на предмет того, как это надо будет менять.</p>

    <p>Спроси у себя: "А что будет, если текущее архитектурное решение окажется неверным?", "Какое количество кода подвергнется при этом изменениям?". Изменение одного фрагмента системы не должно влиять на ее другие фрагменты.</p>

    <p>По возможности архитектурные решения не должны «вырубаться в камне», и последствия архитектурных ошибок должны быть в разумной степени ограничены. "Хорошая архитектура позволяет ОТКЛАДЫВАТЬ принятие ключевых решений" (Боб Мартин) и минимизирует “цену” ошибок.</p>

    <p>Один из таких подходов — разбиение приложения на микросервисы: легко разбить уже существующую логику на отдельные части. Но самая большая проблема — это внесение будущих изменений сразу в десяток сервисов для реализации одной маленькой фичи.</p>
 
    <h3>Масштабируемость</h3>

    <p>Масштабируемость — это возможность сократить срок разработки за счет добавления к проекту новых людей. Архитектура должна позволять распараллелить процесс разработки, так чтобы множество людей могли работать над программой одновременно.</p>

    <p>Кажется, что это правило само собой выполняется, но на практике все с точностью да наоборот. Есть даже суперпопулярная книга “<span class="text-bold">Мифический человеко-месяц</span>”, где объясняется, почему при добавлении в проект новых людей время его разработки увеличивается.</p>

    <h2>Расширяемость</h2>

    <p><span class="text-bold">Расширяемость</span> — это возможность добавлять в систему новые функции и сущности, не нарушая ее основной структуры. На начальном этапе в систему имеет смысл закладывать лишь основной и самый необходимый функционал.</p>

    <p>Это так называемый принцип <span class="text-bold">YAGNI — you ain’t gonna need it</span>, “тебе это не понадобится”. При этом архитектура должна позволять легко наращивать дополнительный функционал по мере необходимости. Причем так, чтобы внесение наиболее вероятных изменений требовало наименьших усилий.</p>

    <p>Требование, чтобы архитектура системы обладала гибкостью и расширяемостью (то есть была способна к изменениям и эволюции), является настолько важным, что оно даже сформулировано в виде отдельного принципа — “<span class="text-bold">Принципа открытости/закрытости</span>”. <span class="text-bold">Open-Closed Principle</span> — второй из пяти принципов SOLID: <span class="text-green">программные сущности (классы, модули, функции) должны быть открытыми для расширения, но закрытыми для модификации</span>.</p>

    <p>Иными словами: <span class="text-bold">должна быть возможность изменить и расширять поведение системы <span class="text-red">без переписывания</span> уже существующих частей системы</span>.</p>

    <p>Это означает, что приложение следует проектировать так, чтобы изменение его поведения и добавление новой функциональности достигалось бы за счет написания нового кода (расширения), и при этом не приходилось бы менять уже существующий код.</p>

    <p>В таком случае появление новых требований не повлечет за собой модификацию существующей логики, а сможет быть реализовано прежде всего за счет ее расширения. Именно этот принцип является основой "плагинной архитектуры" (Plugin Architecture). О том, за счет каких техник это может быть достигнуто, будет рассказано дальше.</p>

    <p>Помнишь сервлеты и фильтры? Зачем нужны были фильтры, да еще с отдельными интерфейсами, если, по сути всю ту же логику можно было реализовать с помощью сервлетов?</p>

    <p>Именно изобретение концепции фильтров (служебных сервлетов) позволило вынести различные служебные функции в отдельный слой. И в будущем при изменении поведения фильтров не нужно было менять сервлеты.</p>

    <p>До изобретения фильтров вся служебная логика, которая отвечала за перенаправление запросов, размещалась в самих сервлетах. И часто одно маленькое изменение в логике приводило к тому, что нужно было пройтись по всем сервлетам и во все внести различные изменения.</p>

    <h2>Тестируемость</h2>

    <p>Если ты Java Backend Developer, то твои серверные приложения часто отдают наружу набор методов в виде REST API. И чтобы проверить, что все твои методы работают как задумано, их нужно покрыть тестами.</p>

    <p>Вообще покрытие тестами API — это хороший стиль. Он позволяет убедиться, что твое API действительно делает то, что было задумано. А также, что еще более важно, <span class="text-green">ты можешь вносить изменения в серверную логику и легко проверить, что ты случайно ничего не сломал</span>.</p>

    <p>Как только ты начнешь писать тесты, то поймешь, что большинство кода вообще невозможно тестировать: private методы, сильная связность, статические классы и переменные.</p>

    <p>“Зачем нужны тесты, если код работает?”, — спросит новичок.</p>

    <p>“Зачем нужен рабочий код, если его невозможно тестировать?”, — спросит профессионал.</p>

    <p>Код, который легко тестировать, будет содержать меньше ошибок и надежнее работать. Но тесты не просто улучшают качество кода. Почти все разработчики со временем приходят к выводу, что требование “хорошей тестируемости” является также направляющей силой, автоматически ведущей к хорошему дизайну.</p>

    <p>Приведу цитату из книги “Идеальная Архитектура”: "Используйте принцип “тестируемости” класса в качестве “лакмусовой бумажки” хорошего дизайна класса. Даже если вы не напишите ни строчки тестового кода, ответ на этот вопрос в 90% случаев поможет понять, насколько все “хорошо” или “плохо” с его дизайном".</p>

    <p>Существует целая методология разработки программ на основе тестов, которая так и называется — разработка через тестирование (Test-Driven Development, TDD). Это уже конечно другая крайность: напиши код, прежде чем писать код.</p>

    <h2>Сопровождаемость кода</h2>

    <p>Над программой, как правило, работает множество людей — одни уходят, приходят новые. Среднее время работы программиста в IT-компании — полтора года. Так что если ты пришел на проект, которому 5 лет, то только 20% твоих коллег работали над ним с самого начала.</p>

    <p>Поддерживать и развивать программу, которую писали другие, очень тяжело. Даже если программа уже написана, зачастую нужно продолжить ее сопровождать: фиксить ошибки и вносить мелкие исправления. И зачастую это приходится делать людям, которые не принимали участия в ее написании.</p>

    <p>Поэтому хорошая архитектура должна давать возможность относительно <span class="text-green">легко и быстро разобраться в системе новым людям</span>. Проект должен быть:</p>

    <ul>
        <li>Хорошо структурирован.</li>
        <li>Не содержать дублирования.</li>
        <li>Иметь хорошо оформленный код.</li>
        <li>Желательно содержать документацию.</li>
        <li>Нужно применять стандартные и привычные решения для программистов.</li>
    </ul>

    <p>Ты можешь легко оценить проект, над которым работаешь, <span class="text-bold">по 5-бальной системе</span>. Просто насчитай за каждое из этих требований по <span class="text-bold">два бала</span>. И если получишь 5 и больше, то ты — счастливчик.</p>

    <p>У программистов есть даже <span class="text-bold">принцип наименьшего удивления</span>: чем экзотичнее система, тем сложнее ее понять другим. Обычно, он используется в отношении пользовательского интерфейса, но применим и к написанию кода.</p>