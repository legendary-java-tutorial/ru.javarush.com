Продвинутое тестирование с помощью Mockito
<p>----------------------------------------</p>
Библиотека Mockito
Mock-объекты
Аннотация @RunWith
<p>----------------------------------------</p>
<h2>1.1 Библиотека Mockito</h2>
<p>Сегодня мы познакомимся с продвинутым тестированием. А точнее с библиотекой <strong>Mockito</strong>. Даже и не думайте увильнуть от этого дела.</p>
<p>Во-первых, эта библиотека – это стандарт в тестирование <strong>Spring’а</strong>. Который фактически является стандартом в отрасли Java-backend разработки.</p>
<p>Во-вторых, <span class="text-red">тебе придется писать тесты для своего Spring-кода</span>. <span class="text-green">Единственный способ понять, что написанный тобой бекенд работает как нужно – это вызывать методы его API</span>. И сделать это с помощью тестов в 10 раз легче, чем без них. Ты сам в этом убедишься.</p>
<p>Добавить библиотеку Mockito в ваш <code>pom.xml</code> можно с помощью кода:</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mockito&lt;/groupId&gt;
    &lt;artifactId&gt;mockito-junit-jupiter&lt;/artifactId&gt;
    &lt;version&gt;4.2.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>Весь исходный код проекта Mockito можно найти на <a href="https://github.com/mockito/mockito" target="_blank">GitHub</a>.</p>
<h2>1.2 Mock-объекты</h2>
<p>Так что же такое эта Mockito и чем она так хороша?</p>
<p>В процессе развития и становления тестирования очень часто возникала необходимость вместо реального объекта подсунуть коду какую-нибудь «заглушку».</p>
<p>Например, тестируется код, который работает с базой данных и что-то там меняет. Хорошо чтобы перед каждым тестом состояние этой базы было одним и тем же (иначе тесты будут разные). И базу хотелось бы попроще, чтобы быстро эти состояния откатывать.</p>
<p>Или, например, ты тестируешь код, который рассылает полезные SMS. А для непосредственно рассылок он использует какой-нибудь платный SMS Gateway. Хорошо бы для тестирования кода подсунуть ему некий виртуальный Gateway, чтобы не рассылать сотни SMS непонятно кому.</p>
<p>Или твой код запрашивает данные у других веб-серверов, которые банально недоступны на тестовом сервере. Или ты пишешь код для интернет-платежей, который нужно 50 раз протестировать, и только потом допускать к реальным финансовым каналам.</p>
<p>Думаю, вы поняли… Виртуальные объекты или как их еще называют объекты-заглушки очень полезная штука.</p>
<p>И тут возникает сложность – в Java-то статическая типизация. Значит, чтобы вместо объекта типа <code>ReadDatabase</code> присвоить переменной ссылку на объект <code>VirtualDatabase</code>, нужно унаследовать класс <code>VirtualDatabase</code> от <code>RealDatabase</code>.</p>
<p>Затем оказывается, что у класса <code>RealDatabase</code> куча приватных методов и переменных, которые хранят ссылки на другие реальные объекты, и нормальную заглушку таким образом не напишешь. В теории хороший, но на практике тупиковый вариант.</p>
<p>И тут нам на помощь приходит <code>DynamicProxy</code> (более подробно <a href="https://www.baeldung.com/java-dynamic-proxies" target="_blank">можно почитать</a>), которые появились еще в Java 5. Она позволяет создавать виртуальные объекты, к которым у компилятора нет претензий.</p>
<p>Такие виртуальные объекты называют <strong>mock’ами </strong>(от слова mock – макет). Библиотека Mockito смогла вознести работу с этими моками на небывалую высоту. Отсюда, кстати, и название библиотеки.</p>
<h2>1.3 Аннотация @ExtendWith</h2>
<p>Библиотека Mockito отлично работает вместе с JUnit, ее можно даже рассматривать как его расширение.</p>
<p>Есть два способа активировать работу библиотеки Mockito в ваших unit-тестах. Первый способ – это добавить специальную аннотацию:</p>
<pre class='language-java line-numbers'><code>
<span class="text-green">@ExtendWith(MockitoExtension.class)</span>
public class MockitoAnnotationTest {
    ...
}
</code></pre>
<p>Второй способ – включить ее работу вызвав метод <code>openMocks()</code>:</p>
<pre class='language-java line-numbers'><code>
public class MockitoAnnotationTest {
<span class="text-green">    @BeforeEach</span>
    public void init() {
<span class="text-red">        MockitoAnnotations.openMocks(this);</span>
   }
}
</code></pre>
<p>Чаще всего ты будешь видеть первый вариант, но иногда полезно знать, что есть и второй.</p>
