Мусорные ссылки в Java
<p>----------------------------------------</p>
Слабые ссылки в Java
WeakReference и SoftReference в Java
Ссылка PhantomReference в Java
<p>----------------------------------------</p>
<h2>8.1 Слабые ссылки в Java</h2>
<p>В Java есть несколько видов ссылок. </p>
<p>Есть <strong>StrongReference</strong> — это самые обычные ссылки, которые мы создаем каждый день.</p>
<pre class='language-java line-numbers'><code>
Object object = new Object();//создал обьект
object = null;//теперь может быть собран сборщиком мусора
</code></pre>
<p>И есть три “особых” типа ссылок — SoftReference, WeakReference, PhantomReference. По сути, различие между всеми типами ссылок только одно — поведение GC с объектами, на которые они ссылаются. Мы более детально обсудим особенности каждого типа ссылок позже, а пока достаточно будет следующих знаний:</p>
<ul>
    <li><strong>SoftReference</strong> — мягкая ссылка, если GC видит, что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти. Наверное.</li>
    <li><strong>WeakReference</strong>  – слабая ссылка , если GC видит, что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.</li>
    <li><strong>PhantomReference</strong> — фантомная ссылка, если GC видит, что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.</li>
</ul>
<p>Также можно сказать, что у типов ссылок есть некая степень мягкости:</p>
<ul>
    <li><strong>Обычная жесткая ссылка</strong> – любая переменная ссылочного типа. Очистится сборщиком мусора не раньше, чем станет неиспользуемой.</li>
    <li><strong>SoftReference</strong>. Объект не станет причиной израсходования всей памяти – гарантированно будет удален до возникновения OutOfMemoryError. Может быть раньше, зависит от реализации сборщика мусора.</li>
    <li><strong>WeakReference</strong>. Слабее мягкой. Не препятствует утилизации объекта, сборщик мусора игнорирует такие ссылки.</li>
    <li><strong>PhantomReference</strong>. Используется для “предсмертной” обработки объекта: объект доступен после финализации, пока не очищен сборщиком мусора.</li>
</ul>
<p>Если пока не понятно, в чем же разница, то не переживайте, скоро все станет на свои места. Мелочи в деталях, а детали будут дальше.</p>
<h2>8.2 WeakReference и SoftReference в Java</h2>
<p>Для начала давайте рассмотрим разницу между <strong>WeakReference</strong> и <strong>SoftReference</strong> в Java.</p>
<p>Если вкратце, то сборщик мусора освободит память объекта, если на него указывают только слабые ссылки. Если на объект указывают ссылки SoftReferences, то освобождение памяти происходит, когда JVM сильно нуждается в памяти.</p>
<p>Это дает определенное преимущество <strong>SoftReference</strong> перед Strong ссылкой в определенных случаях. Например, SoftReference используют для реализации кэша приложений, поэтому JVM первым делом удалит объекты, на которые указывают только SoftReferences.</p>
<p><strong>WeakReference</strong> отлично подходит для хранения метаданных, например, для хранения ссылки на ClassLoader. Если ни один класс не загружен, то не стоит ссылаться на ClassLoader. Именно поэтому WeakReference делает возможность сборщику мусора выполнить свою работу с ClassLoader, как только на него удалится последняя сильная ссылка.</p>
<p>Пример WeakReference в Java:</p>
<pre class='language-java line-numbers'><code>
// какой-то объект
Student student = new Student();
 
// слабая ссылка на него
WeakReference<Student> weakStudent = new WeakReference<Student>(student);
 
// теперь объект Student может быть собран сборщиком мусора
student = null;
</code></pre>
<p><strong>Пример SoftReference в Java:</strong></p>
<pre class='language-java line-numbers'><code>
// какой-то объект
Student student = new Student();
 
// слабая ссылка на него
SoftReference<Student> softStudent = new SoftReference<Student>(student)
 
// теперь объект Student может быть собран сборщиком мусора
// но это случится только в случае сильной необходимости JVM в памяти
student = null;
</code></pre>
<h2>8.3 Ссылка PhantomReference в Java</h2>
<p>Экземпляр PhantomReference создается точно также, как и на примерах WeakReference и SoftReference, но используется он довольно редко.</p>
<p>PhantomReference может быть собрана сборщиком мусора, если на объект нет сильных (Strong), слабых ссылок (WeakReference) или мягких (SoftReference).</p>
<p>Вы можете создать объект Phantom Reference следующим образом:</p>
<pre class='language-java line-numbers'><code>
PhantomReference myObjectRef = new PhantomReference(MyObject);
</code></pre>
<p><strong>PhantomReference</strong> может использоваться в ситуациях, когда использование finalize() не имеет смысла. Этот ссылочный тип отличается от других типов, поскольку он не предназначен для доступа к объекту. Он является сигналом о том, что объект уже финализирован и сборщик мусора готов вернуть свою память.</p>
<p>Для этого сборщик мусора помещает его в специальный <strong>ReferenceQueue</strong> для последующей обработки. ReferenceQueue — это место, куда помещаются ссылки на объекты для освобождение памяти.</p>
<p>Фантомные ссылки — это безопасный способ узнать, что объект удален из памяти. Например, рассмотрим приложение, которое имеет дело с большими изображениями. Предположим, что мы хотим загрузить изображение в память, когда оно уже находится в памяти, которая готова для сборки мусора. В этом случае мы хотим подождать пока сборщик мусора убьет старое изображение и только потом загружать в память новое.</p>
<p>Здесь PhantomReference является гибким и безопасным выбором. Ссылка на старое изображение будет передана в ReferenceQueue после уничтожения старого объекта изображения. Получив эту ссылку, мы можем загрузить новое изображение в память. </p>
