Порождающие паттерны, часть 2
<p>----------------------------------------</p>
Builder
Lazy Initialization
Object pool
<p>----------------------------------------</p>
<h2>4.1 Builder</h2>
<p><strong>Строитель (Builder)</strong> — порождающий шаблон проектирования, который предоставляет способ создания составного объекта.</p>
<p>Отделяет конструирование сложного объекта от его представления так, что в результате одного и того же процесса конструирования могут получаться разные представления.</p>
<img data-max-width="800" data-id="99aeba59-79ef-4340-b9e3-ebdb2ae3a6b8" src="https://cdn.javarush.com/images/article/99aeba59-79ef-4340-b9e3-ebdb2ae3a6b8/800.jpeg" alt="Строитель (Builder)">
<p><strong>Сильные стороны:</strong></p>
<ul>
    <li>позволяет изменять внутреннее представление продукта;</li>
    <li>изолирует код, реализующий конструирование и представление;</li>
    <li>дает более тонкий контроль над процессом конструирования.</li>
</ul>
<p><strong>Слабые стороны:</strong></p>
<ul>
    <li>алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;</li>
    <li>процесс конструирования должен обеспечивать различные представления конструируемого объекта.</li>
</ul>
<p>Хороший пример – это класс HttpRequest, у него есть подкласс HttpRequest.Builder, с помощью которого можно создавать экземпляры класса HttpRequest и гарантировать их валидность.</p>
<h2>4.2 Lazy Initialization</h2>
<p><strong>Отложенная (ленивая) инициализация (Lazy initialization)</strong> — приём в программировании, когда некоторая ресурсоёмкая операция (создание объекта, вычисление значения) выполняется непосредственно перед тем, как будет использован её результат.</p>
<p>Таким образом инициализация выполняется “по требованию”, а не заблаговременно. Аналогичная идея находит применение в самых разных областях: например, компиляция “на лету” и логистическая концепция “Точно в срок”.</p>
<img data-max-width="800" data-id="fa045df5-58b9-4433-bc35-45548f452406" src="https://cdn.javarush.com/images/article/fa045df5-58b9-4433-bc35-45548f452406/800.jpeg" alt="Lazy Initialization">
<p>Частный случай ленивой инициализации — создание объекта в момент обращения к нему — является одним из порождающих шаблонов проектирования. Как правило он используется в сочетании с такими шаблонами, как Фабричный метод, Одиночка и Заместитель.</p>
<p><strong>Сильные стороны:</strong></p>
<ul>
    <li>Инициализация выполняется только в тех случаях, когда она действительно необходима;</li>
    <li>Ускоряется начальная инициализация приложения: все, что можно отложить, откладываем.</li>
</ul>
<p><strong>Слабые стороны:</strong></p>
<ul>
    <li>Невозможно явным образом задать порядок инициализации объектов;</li>
    <li>Возникает задержка при первом обращении к объекту, что может оказаться критичным при параллельном выполнении другой ресурсоёмкой операции. Из-за этого требуется тщательно просчитывать целесообразность использования “ленивой” инициализации в многопоточных программных системах.</li>
</ul>
<p>Помнишь, как при написании web.xml там можно было указать порядок старта сервлетов? Это как раз и есть следствие ленивой загрузки. Tomcat создаст объекты сервлетов при первом к ним обращении. </p>
<h2>4.3 Object pool</h2>
<p><strong>Объектный пул (object pool)</strong> — порождающий шаблон проектирования, набор инициализированных и готовых к использованию объектов. Когда системе требуется объект, он не создаётся, а берётся из пула. Когда объект больше не нужен, он не уничтожается, а возвращается в пул.</p>
<img data-max-width="512" data-id="780f7d14-5ad3-42e2-bbfe-409cef49851e" src="https://cdn.javarush.com/images/article/780f7d14-5ad3-42e2-bbfe-409cef49851e/512.jpeg" alt="Object pool">
<p>Объектный пул применяется для повышения производительности, когда создание объекта в начале работы и уничтожение его в конце приводит к большим затратам. Особенно заметно повышение производительности, когда объекты часто создаются-уничтожаются, но одновременно существует лишь небольшое их число.</p>
<p>Объектный пул удобен, если объект владеет другими ресурсами, кроме памяти — например, сетевыми сокетами. Либо если коллекция объектов отнимает значительную часть памяти компьютера и “мусора” создаётся действительно много.</p>
<p>Как ты помнишь, Tomcat выполняет каждый запрос в отдельном потоке. Но потоки не создаются каждый раз заново, а хранятся в пуле потоков. Это позволяет быстрее выполнять запросы: когда поток нужен, он просто берется из пула. Кстати, вопрос: а как бы ты поместил запущенные поток в пул и взял его из пула?</p>