Критерии плохой архитектуры ПО
<p>----------------------------------------</p>
Критерии плохого дизайна. 
Определение "плохого дизайна". 
Причины "плохого дизайна". 
Актуальность.
<p>----------------------------------------</p>
    <h2>Критерии плохого дизайна</h2>

    <p>Жизнь устроена достаточно просто: зачастую, чтобы быть умным, нужно просто не делать глупые вещи. Разработки ПО это тоже касается: в большинстве случаев, чтобы что-то сделать хорошо, нужно просто не делать плохо.</p>

    <p>У большинства программистов был опыт работы с фрагментами системы, у которых был плохой дизайн. Но что еще более печально, у большей части из вас будет печальный опыт осознания того, что именно вы были авторами такой системы. Хотели как лучше, а получилось как всегда.</p>

    <p>Большинство разработчиков не стремятся к плохой архитектуре, при этом для многих систем наступает момент, когда начинают говорить, что ее архитектура ужасна. Почему так происходит? Был ли дизайн архитектуры плохим с самого начала или стал таким с течением времени?</p>

    <p>Корнем этой проблемы является отсутствие определения “плохого” дизайна.</p>

    <p>Мне кажется, что именно понимание качества дизайна и причин его “загнивания” являются самыми важными качествами для любого программиста. Как и в большинстве других случаев, главное — идентифицировать проблему, а уж решить ее будет делом техники.</p>
<img data-max-width="512" data-id="66399989-15b7-441d-bd24-a1670a49976a" src="https://cdn.javarush.com/images/article/66399989-15b7-441d-bd24-a1670a49976a/512.jpeg" alt="">
    <h2>Определение “плохого дизайна”</h2>

    <p>Если ты решишь похвастаться своим кодом перед коллегой-программистом, то скорее всего получишь в ответ насмешки: “Кто ж так делает?”, ’А почему именно так?” и “Я бы сделал все по-другому”. Такое очень часто происходит.</p>

    <p>Все люди разные, но код ты пишешь все-таки для своих коллег-программистов, поэтому в процессе разработки каждой фичи всегда нужна фаза review, когда на твой код смотрят другие люди.</p>

    <p>Но даже если массу вещей можно сделать разными способами, есть набор критериев, с которым, согласились бы все разработчики. Любой кусок кода, который удовлетворяет своим требованиям, но все же, проявляет одну (или несколько) характеристик, обладает плохим дизайном.</p>

    <p>Плохой дизайн:</p>

    <ul>
        <li>Тяжело изменить, поскольку любое изменение влияет на слишком большое количество других частей системы. (<span class="text-bold">Жесткость</span>, Rigidity).</li>
        <li>При внесении изменений неожиданно ломаются другие части системы. (<span class="text-bold">Хрупкость</span>, Fragility).</li>
        <li>Код тяжело использовать повторно в другом приложении, поскольку его слишком тяжело “выпутать” из текущего приложения. (<span class="text-bold">Неподвижность</span>, Immobility).</li>
    </ul>

    <p>А самое смешное в том, что практически <span class="text-red">невозможно найти кусок системы</span>, который не содержит ни одной из этих характеристик (то есть является гибким, надежным и повторно используемым), отвечает требованием, и при этом дизайн его плохой.</p>

    <p>Таким образом, мы можем использовать эти три характеристики для однозначного определения, является ли дизайн “плохим” или “хорошим”.</p>

    <h2>Причины “плохого дизайна”</h2>

    <p>Что делает дизайн жестким, хрупким и неподвижным? <span class="text-bold">Жесткая взаимозависимость модулей.</span></p>

    <p><span class="text-bold">Дизайн является жестким (rigid)</span>, если его нельзя с легкостью изменить. Эта жесткость связана с тем, что единственное изменение куска кода в переплетенной системе приводит к каскадным изменениям в зависимых модулях. Это всегда происходит, когда над кодом работает один человек.</p>

    <p>Это сразу же усложняет весь процесс коммерческой разработки: когда количество каскадных изменений не может быть предсказано проектировщиком или разработчиком, то оценить влияние такого изменения невозможно. Поэтому такие изменения стараются откладывать в долгий ящик.</p>

    <p>И это в свою очередь делает стоимость изменений непредсказуемой. Менеджеры, столкнувшиеся с такой неопределенностью, неохотно соглашаются на внесение изменений, таким образом, дизайн официально становится жестким.</p>

    <p>В какой-то момент ваш проект проходит “горизонт событий” и обречен на сваливание в “черную дыру” жесткой архитектуры.</p>

    <p><span class="text-bold">Хрупкость (fragility)</span> — это склонность системы к поломкам во множестве мест после единственного изменения. Обычно новые проблемы происходят в местах, концептуально не связанных с местом изменений. Такая хрупкость серьезно подрывает веру в дизайн и сопровождение системы.</p>

    <p>Такое обычно было, когда не было приватных методов. Достаточно сделать все методы публичными, и ты будешь обречен на возникновение хрупкой архитектуры. Инкапсуляция помогает бороться с этим на микроуровне. Но на макроуровне тебе нужна модульная архитектура.</p>

    <p>Когда у проекта хрупкая архитектура, то разработчики не могут гарантировать качества продукта.</p>

    <p>Простые изменения в одной части приложения приводят к ошибкам в других несвязанных частях. Исправление этих ошибок приводит к еще большему количеству проблем, и процесс сопровождения превращается в известного пса, гоняющегося за собственным хвостом.</p>

    <p><span class="text-bold">Дизайн является неподвижным (immobile)</span>, когда нужные части системы сильно завязаны на другие нежелательные подробности. Слишком много своего кода, своих уникальных подходов и решений.</p>

    <p>Помнишь логер JUL, разработчики которого без веских на то оснований придумали свои уровни логирования? Это как раз тот случай.</p>

    <p>Чтобы представить проектировщику, насколько легко использовать существующий дизайн повторно, достаточно подумать о том, насколько просто его будет использовать в новом приложении.</p>

    <p>Если дизайн является сильносвязанным, то этот проектировщик ужаснется количеству работы, необходимой для отделения требуемых частей системы от ненужных подробностей. В большинстве случаев такой дизайн не является повторно используемым, поскольку стоимость его отделения превышает его разработку с нуля.</p>
 
    <h2>Актуальность</h2>

    <p><span class="text-bold">Всё меняется, но всё остается прежним.</span> (Китайская пословица)</p>

    <p>Выше были подняты очень хорошие вопросы. Чем опасны хрупкие и жесткие системы? Да тем, что процесс управления подобным проектом становится непредсказуемым и неуправляемым. А цена — заоблачной.</p>

    <p>Как менеджер может давать или не давать добро на добавление некоторой фичи, если он не знает, сколько на самом деле на это потребуется времени? Как приоритезировать задачи, если нельзя адекватно оценить время и сложность их выполнения?</p>

    <p><span class="text-green">А как разработчикам выплачивать тот самый технический долг, когда при его выплате мы огребем, причем понять, сколько именно огребем, мы не можем, пока не огребем?</span></p>

    <p>Проблемы с повторным использованием кода или тестированием тоже очень актуальны. Юнит-тесты служат не только для проверки некоторых предположений относительно тестируемого модуля, но и для определения степени его связанности и могут служить показателем повторного использования.</p>

    <p>Вот тебе цитата Боба Мартина на этот случай: <span class="text-neon">“Для того, чтобы использовать ваш код повторно, нужно чтобы трудозатраты на его повторное использование были меньшими, чем стоимость разработки с нуля”</span>. В противном случае никто с этим делом не будет даже заморачиваться.</p>

    <p>Использование принципов и паттернов проектирования служат одной цели – сделать дизайн хорошим. Если их использование не дает тебе никакой выгоды (или наоборот, нарушает принципы “хорошего дизайна”), значит что-то в твоей консерватории не то и, возможно, инструмент начали использоваться не по назначению.</p>