Правильная декомпозиция ПО
<p>----------------------------------------</p>
Иерархическая. 
Функциональная. 
Сильная и слабая связность. 
Композиция вместо наследования.
<p>----------------------------------------</p>
    <h2>Иерархическая декомпозиция</h2>

    <p>Никогда не стоит сразу начинать писать классы вашего приложения. Сначала его нужно спроектировать. Проектирование должно закончиться продуманной архитектурой. И чтобы получить эту архитектуру, тебе нужно последовательно выполнить декомпозицию системы.</p>

    <p>Декомпозицию надо проводить иерархически — сначала систему разбивают на крупные функциональные модули/подсистемы, описывающие ее работу в самом общем виде. Затем полученные модули анализируются более детально и делятся на подмодули либо на объекты.</p>

    <p>Перед тем как выделять объекты, разделите систему на основные смысловые блоки хотя бы мысленно. В небольших приложениях обычно сделать это очень просто: пару уровней иерархии бывает вполне достаточно, так как система вначале делится на подсистемы/пакеты, а пакеты делятся на классы.</p>
<img data-max-width="800" data-id="ab05085b-576e-4306-8d95-24ef33eb86c9" src="https://cdn.javarush.com/images/article/ab05085b-576e-4306-8d95-24ef33eb86c9/800.jpeg" alt="Иерархическая декомпозиция">

    <p>Эта мысль не так банальна, как кажется. Например, в чем заключается суть такого распространенного “архитектурного шаблона” как Модель-Вид-Контроллер (MVC)?</p>

    <p>Всего-навсего в <span class="text-bold">отделении представления от бизнес-логики</span>. Сначала любое пользовательское приложение делится на два модуля — один отвечает за реализацию самой бизнес логики (Модель), а второй — за взаимодействие с пользователем (Пользовательский Интерфейс или Представление).</p>

    <p>Затем выясняется, что модули должны как-то взаимодействовать, для этого в них добавляют Контроллер, задача которого управлять взаимодействием модулей. Также в мобильной (классический) версии MVC в него добавляют паттерн Наблюдатель, чтобы View мог получать события из модели и изменять отображаемые данные в реальном времени.</p>

    <p>Типичными модулями верхнего уровня, полученными в результате первого деления системы на наиболее крупные составные части, как раз и являются:</p>

    <ul>
        <li>Бизнес-логика;</li>
        <li>Пользовательский интерфейс;</li>
        <li>База данных;</li>
        <li>Система обмена сообщениями;</li>
        <li>Контейнер объектов.</li>
    </ul>

    <p>При первом разбиении обычно все приложение разбивается на 2-7 (максимум 10 частей). Если разбить на большее количество частей, то потом возникнет желание их сгруппировать, и мы получим опять-таки 2-7 модулей верхнего уровня.</p>

    <h2>Функциональная декомпозиция</h2>

    <p>Деление на модули/подсистемы лучше всего производить <span class="text-green">исходя из тех задач, которые решает система</span>. Основная задача разбивается на составляющие ее подзадачи, которые могут решаться/выполняться автономно, независимо друг от друга.</p>

    <p>Каждый модуль должен отвечать за решение какой-то подзадачи и выполнять соответствующую ей <span class="text-bold">функцию</span>. Помимо функционального назначения модуль характеризуется также набором данных, необходимых ему для выполнения его функции, то есть:</p>

    <p><span class="text-bold">Модуль = Функция + Данные</span>, необходимые для ее выполнения.</p>

    <p>Если декомпозиция на модули выполнена правильно, то взаимодействие с другими модулями (отвечающими за другие функции) будет минимальным. Оно может быть, но его отсутствие не должно быть критически важным для вашего модуля.</p>

    <p><span class="text-green">Модуль — это не произвольный кусок кода, а отдельная функционально осмысленная и законченная программная единица (подпрограмма), которая обеспечивает решение некоторой задачи и в идеале может работать самостоятельно или в другом окружении и быть переиспользуемой. Модуль должен быть некой "целостностью, способной к относительной самостоятельности в поведении и развитии".</span> (Кристофер Александер)</p>

    <p>Таким образом, грамотная декомпозиция основывается, прежде всего, на <span class="text-bold">анализе функций</span> системы и необходимых для выполнения этих функций данных. Функции в этом случае — это не функции класса и модули, ведь это не объекты. Если у тебя  в модуле всего пара классов, значит ты перестарался.</p>

    <h2>Сильная и слабая связность</h2>

    <p>Очень важно не перестараться с разбиением на модули. Если дать новичку монолитное Spring-приложение и попросить разбить его на модули, то он вынесет каждый Spring Bean в отдельный модуль и будет считать, что его работа закончена. Но это не так.</p>

    <p><span class="text-green">Главным критерием качества декомпозиции является то, насколько модули сфокусированы на решении своих задач и независимы.</span></p>

    <p><span class="text-neon">Обычно это формулируют следующим образом: "Модули, полученные в результате декомпозиции, должны быть максимально сопряжены внутри (high internal cohesion) и минимально связаны друг с другом (low external coupling)."</span></p>

    <p><span class="text-bold">High Cohesion, высокая сопряженность</span> или "сплоченность" внутри модуля, говорит о том, модуль сфокусирован на решении одной узкой проблемы, а не занимается выполнением разнородных функций или несвязанных между собой обязанностей.</p>

    <p>Сопряженность — cohesion, характеризует степень, в которой задачи, выполняемые модулем, связаны друг с другом. </p>

    <p>Следствием High Cohesion является <span class="text-bold">принцип единственной ответственности</span> (<span class="text-green">Single Responsibility Principle — первый из пяти принципов SOLID</span>), согласно которому любой объект/модуль должен иметь лишь одну обязанность и не должно быть больше одной причины для его изменения.</p>

    <p><span class="text-bold">Low Coupling</span>, слабая связанность, означает что модули, на которые разбивается система, должны быть, по возможности, <span class="text-bold">независимы</span> или слабо связаны друг с другом. Они должны иметь возможность взаимодействовать, но при этом как можно меньше знать друг о друге.</p>

    <p>Каждый модуль не должен знать, как устроен другой модуль, на каком языке он написан и как он работает. Часто для организации взаимодействия таких модулей используют некий контейнер, в который эти модули и загружаются.</p>

    <p>При правильном проектировании, при изменении одного модуля, не придется править другие или эти изменения будут минимальными. Чем слабее связанность, тем легче писать/понимать/расширять/чинить программу.</p>

    <p>Считается, что хорошо спроектированные модули должны обладать следующими свойствами:</p>

    <ul>
        <li><span class="text-bold">Функциональная целостность и завершенность</span> — каждый модуль реализует одну функцию, но реализует хорошо и полностью, модуль самостоятельно выполняет полный набор операций для реализации своей функции.</li>
        <li><span class="text-bold">Один вход и один выход</span> — на входе программный модуль получает определенный набор исходных данных, выполняет содержательную обработку и возвращает один набор результатных данных, то есть реализуется стандартный принцип IPO — вход–>процесс–>выход.</li>
        <li><span class="text-bold">Логическая независимость</span> — результат работы программного модуля зависит только от исходных данных, но не зависит от работы других модулей.</li>
        <li><span class="text-bold">Слабые информационные связи с другими модулями</span> — обмен информацией между модулями должен быть по возможности минимизирован.</li>
    </ul>

    <p>Новичку очень сложно понять, как снизить связность модулей еще сильнее. Частично это знание приходит с опытом, частично — после чтения умных книг. Но лучше всего помогает анализ архитектур уже существующих приложений.</p>

    <h2>Композиция вместо наследования</h2>

    <p>Грамотная декомпозиция — это своего рода искусство и сложная задача для большинства программистов. Простота тут обманчива, а ошибки обходятся дорого.</p>
<img data-max-width="512" data-id="eaa5a7c9-4bb0-4c8f-8e73-97a82484f23b" src="https://cdn.javarush.com/images/article/eaa5a7c9-4bb0-4c8f-8e73-97a82484f23b/512.jpeg" alt="">
    <p>Бывает, что выделенные модули оказываются сильно сцеплены друг с другом и их не удается разрабатывать независимо. Или не ясно за какую функцию каждый из них отвечает. Если ты столкнулся с похожей проблемой, то скорее всего разбиение на модули произвели неправильно.</p>

    <p>Всегда должно быть понятно, <span class="text-green">какую роль выполняет каждый модуль</span>. Самый надежный критерий того, что декомпозиция делается правильно, это если модули получаются самостоятельными и ценными подпрограммами, которые могут быть использованы в отрыве от всего остального приложения (а значит, могут быть переиспользуемы).</p>

    <p>Делая декомпозицию системы, желательно проверять ее качество, задавая себе вопросы: "Какую задачу выполняет каждый модуль?", “Насколько модули легко тестировать?”, “Возможно ли использовать модули самостоятельно или в другом окружении?”, “Как сильно изменения в одном модуле отразятся на остальных?”.</p>

    <p>Нужно стараться, чтобы модули были предельно <span class="text-bold">автономны</span>. Как было сказано раньше, это <span class="text-green">является ключевым параметром правильной декомпозиции</span>. Поэтому проводить ее нужно таким образом, чтобы модули изначально слабо зависели друг от друга. Если это у тебя получилось, то ты молодец.</p>

    <p>Если нет, то тут тоже не все потеряно. Имеется ряд специальных техник и шаблонов, позволяющих дополнительно минимизировать и ослабить связи между подсистемами. Например, в случае MVC для этой цели использовался шаблон “Наблюдатель”, но возможны и другие решения.</p>

    <p>Можно сказать, что техники для уменьшения связанности, как раз и составляют основной “инструментарий архитектора”. Только необходимо понимать, что речь идет обо всех подсистемах и <span class="text-bold">ослаблять связанность нужно на всех уровнях иерархии</span>, то есть не только между классами, но также и между модулями на каждом иерархическом уровне.</p>