Знакомство с REST
<p>----------------------------------------</p>
Подход Remote API
Подход REST
Отсутствие состояния
Единообразие интерфейса
Кэширование
<p>----------------------------------------</p>
<h2>8.1 Подход Remote API</h2>
<p>Все программисты делают одну и ту же ошибку при построении архитектуры клиент-сервер. <span class="text-viola">Они начинают воспринимать запросы к серверу, как вызов методов</span>.</p>
<p>Ты хочешь запустить процесс генерации отчета на сервере, почему бы не отправить ему запрос вида:</p>
 <div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>
        http://server.com/<span class="text-red">startDocumentGeneration</span>?params
        </code></pre>
</div>
<p>А как загрузить отчет после того, как он завершится? Для этого напишем еще один метод: </p>
 <div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>
        http://server.com/<span class="text-red">getDocument</span>
        </code></pre>
</div>
<p>Сервер в <code>HttpSession</code> хранит информацию по нашему документу, и как только документ будет сгенерирован, сервер его отдаст.</p>
<p>Отличный подход. Или нет?</p>
<p>Подход на самом деле ужасный. Все дело в том, что сервер должен запомнить номер документа. Другими словами, чтобы правильно обрабатывать новые вызовы методов, сервер должен запомнить результаты вызова предыдущих методов.</p>
<p>В вебе это большая проблема. Интернет может пропасть, браузер закрыться. Страницу можно перегрузить или случайно кликнуть по ссылке и так далее. А сервер будет продолжать хранить мегабайты данных из предыдущих запросов пользователя…</p>
<p>Для комфортной работы с сервером вы не можете рассчитывать, что у вас всегда под рукой будут данные предыдущих запросов к серверу.</p>
<p>Как же тогда вызывать методы сервера? Правильный ответ будет ужасен: а никак!</p>
<h2>8.2 Подход REST</h2>
<p>Программисты вернулись к истокам и вспомнили, что изначально запрос содержал путь к файлу на сервере: </p>
 <div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>
        http://server.com/<span class="text-red">path</span>?params
        </code></pre>
</div>
<p>И решили использовать этот подход по максимуму.</p>
<p>Теперь <span class="text-green">сервер рассматривается как хранилище данных</span>, которые <span class="text-viola">видны наружу в виде некоторого дерева</span>.</p>
<p>Хотите получить список всех пользователей, вызывайте запрос: </p>
 <div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>
          http://server.com/<span class="text-red">users</span>
        </code></pre>
</div>
<p>Хотите получить данные по пользователю 113, выполняете запрос:</p>
 <div class="lesson-example lesson-example--center">
    <pre class="lecture-code lecture-code--present language-java"><code>
          http://server.com/<span class="text-red">users/113</span>
        </code></pre>
</div>
<p>И так далее, все в том же ключе.</p>
<p>Еще раз, сервер рассматривается как хранилище данных, которые видны наружу в виде некоторого дерева.</p>
<p>Данные можно получать – запросы <strong>GET</strong>, изменять – запрос <strong>POST</strong> и удалять – запрос <strong>DELETE</strong>.</p>
<h2>8.3 Отсутствие состояния</h2>
<p>REST-протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами от клиента никакая информация о состоянии клиента на сервере не хранится.</p>
<p>Все запросы от клиента должны быть составлены так, чтобы сервер каждый раз получил <strong>всю необходимую информацию для выполнения запроса</strong>. Состояние сессии при этом сохраняется на стороне клиента.</p>
<p>Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента.</p>

<h2>8.4 Единообразие интерфейса</h2>
<p>Все пути, по которым отдаются объекты с сервера, стандартизируются. Это очень удобно, особенно если ты получаешь данные из чужих REST-серверов.</p>
<p>Все интерфейсы объектов должны соблюдать три условия:</p>
<p><strong>Идентификация ресурсов</strong></p>
<p>Все ресурсы идентифицируются в запросах с использованием URI. Ресурсы внутри сервера отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера.</p>
<p><strong>Манипуляция ресурсами через представление</strong></p>
<p>Если клиент хранит представление ресурса, включая метаданные, то он обладает достаточной информацией для модификации или удаления ресурса на сервере.</p>
<p><strong>"Самоописываемые" сообщения</strong></p>
<p>Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать. Например, если вам нужна информация о пользователе, то сервер вернет вам JSON объект, где будут поля имя, адрес.</p>
<p>Не должно быть ситуации, когда клиент должен знать, что первое число в ответе — это возраст, а второе – это дата рождения. </p>
<h2>8.5 Кэширование</h2>
<p>Подход REST предполагает, что запросы к данным идет посредством HTTP протокола. Поэтому объекты получаются посредством вызова GET-запроса. А значит на них, как и на все ресурсы, полученные посредством GET-запроса, распространяются все правила кэширования HTTP-ресурсов.</p>
<p>То есть данные, полученные через REST API, кэшируются так же, как и любые статические ресурсы на веб-серверах. Красота :)</p>