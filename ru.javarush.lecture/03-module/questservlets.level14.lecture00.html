Клиент-серверная архитектура
<p>----------------------------------------</p>
Архитектура приложения
Концепция взаимодействия клиент-сервер
Важный нюанс
Архитектура «клиент-сервер»
<p>----------------------------------------</p>
<h2>1.1 Архитектура приложения</h2>
<p>Этот курс рассчитан на новичков, потому что проектировать архитектуру серьезного приложения ты не будешь еще долго. Но не надо расстраиваться, хорошая архитектура – это скорее исключение, чем правило. Очень сложно выбрать правильную архитектуру приложения <strong>до</strong> создания приложения.</p>
<p>Примеры популярных архитектур больших серверных приложений:</p>
<ul>
    <li>Многослойная архитектура (Layered Architecture).</li>
    <li>Многоуровневая архитектура (Tiered Architecture).</li>
    <li>Сервис-ориентированная архитектура (Service Oriented Architecture – SOA).</li>
    <li>Микросервисная архитектура (Microservice Architecture).</li>
</ul>
<p>Каждая из них имеет свои плюсы и свои минусы. Но изучение их тебе ничего не даст. Архитектура – это ответ на вопрос <strong>«как организовать взаимодействие тысяч объектов внутри системы»</strong>. И пока ты на своем опыте не почувствуешь всю сложность проблемы, ты не сможешь понять и всю многогранность решения.</p>
<p>Все приложения используют какую-нибудь архитектуру или или хотя бы делают вид. Поэтому знание популярных подходов к проектированию приложений позволит тебе быстрее и лучше понимать, как приложение устроено. А значит вносить изменения именно в те места, куда нужно.</p>
<p>А что значит «вносить изменения куда нужно?». Есть места, куда не нужно вносить изменения? Именно.</p>
<p>Чтобы добавить конкретики, давай предположим, что ты работаешь над <strong>средним backend-проектом</strong>. Он пишется вот уже 5 лет командой из 20 человек. На проект потрачено 100 человеко-лет, в нем около 100 тысяч строк кода. Суммарно он состоит из двух тысяч классов, которые разбиты на 10 модулей разного размера.</p>
<p>И добавим суровой реальности. Логика некоторых задач размазана по нескольким модулям. Также бизнес-логика может быть во фронтенде (написанном на JavaScript) и/или записана в виде stored procedure прямо в базе данных. Ты все еще уверен, что сразу сможешь определить место, <strong>куда именно вносить изменения</strong>?</p>
<p>Это не какой-то кошмар, который я придумал, чтобы вас напугать. Это типичнейший проект. Бывает еще и похуже. Почему же так происходит? Причин может быть сколько угодно, но почти всегда присутствуют такие:</p>
<ul>
    <li>На проекте работает куча людей – каждый из них видит его немного по-своему.</li>
    <li>За 5 лет в проекте сменилось 10 человек, новички не стали сильно в нем разбираться.</li>
    <li>Создание софта – это постоянное внесение изменений, которые постоянно все меняют.</li>
    <li>Пять лет назад, когда определялись с архитектурой, задумка проекта была несколько иной.</li>
</ul>
<img data-max-width="512" data-id="bb4dc295-bea7-4d16-b33e-a81e7f3993a8" src="https://cdn.javarush.com/images/article/bb4dc295-bea7-4d16-b33e-a81e7f3993a8/512.jpeg" alt="">
<p>Но главное, что независимо от архитектуры проекта, все работающие над ним программисты, придерживались одного и того же понимания, как этот проект устроен. Начнем с самого простого понятия – клиент-серверной архитектуры. </p>
<h2>1.2 Концепция взаимодействия клиент-сервер</h2>
<p>Сейчас мы разберемся с концепцией, которая лежит в основе архитектуры <strong>клиент-сервер</strong> и позволит вам лучше понять как организовано взаимодействие миллионов программ в сети интернет.</p>
<p>Как понятно из названия, в данной концепции участвуют две стороны: <strong>клиент</strong> и <strong>сервер</strong>. Здесь все как в жизни: клиент – это заказчик той или иной услуги, а сервер – поставщик услуг. Клиент и сервер физически представляют собой <strong>программы</strong>, например, <span class="text-green">типичным клиентом является браузер</span>.</p>
<p>В качестве сервера можно привести следующие примеры:</p>
<ul>
    <li>Веб-сервера, например Tomcat.</li>
    <li>Сервера баз данных, например, MySQL.</li>
    <li>Платежные шлюзы, например Stripe.</li>
</ul>
<p>Клиент с сервером обычно общаются через интернет (хотя могут работать и в одной локальной сети и вообще в любых других типах сетей). Общение происходит по стандартным протоколам, таким как HTTP, FTP или более низкоуровневым, таким как TCP или UDP.</p>
<p>Протокол обычно выбирается под тип услуги, которую оказывают сервера. Например, если это видеосвязь, то обычно используется UDP.</p>
<p>Помните, как работает Tomcat и его сервлеты? Сервер получает HTTP-сообщение, распаковывает его, достает оттуда всю нужную информацию и передает сервлету на обработку. Затем результат обработки упаковывает обратно в HTTP-response и отсылает клиенту.</p>
<p>Это и есть типичное взаимодействие клиент-сервер. Браузер – это веб-клиент, а Tomcat – это веб-сервер. Tomcat даже так и называется – веб-сервер.</p>
<p>Но если подумать, то важно не название, а суть – распределение ролей между программами. Твой JS-скрипт, работающий в HTML-странице, вполне можно назвать <strong>клиентом</strong>, а твой сервлет – <strong>сервером</strong>. Ведь они работают в паре в рамках <strong>концепции клиент-сервер</strong>.</p>
<h2>1.3 Важный нюанс</h2>
<p>Еще стоит отметить, что в <strong>основе взаимодействия клиент-сервер лежит принцип того, что такое взаимодействие начинает клиент</strong>: сервер лишь отвечает клиенту и сообщает о том может ли он предоставить услугу клиенту и если может, то на каких условиях.</p>
<p>Не имеет значения, где физически находится клиент и где сервер. Клиентское программное обеспечение и серверное программное обеспечение обычно установлено на разных машинах, но также они могут работать и на одном компьютере.</p>
<p>Данную концепцию разработали как первый шаг в сторону упрощения сложной системы. У нее есть такие сильные стороны:</p>
<ul>
    <li><strong>Упрощение логики</strong>: сервер ничего не знает о клиенте и как он будет использовать его данные в дальнейшем.</li>
    <li>Могут быть <strong>слабые клиенты</strong>: все ресурсоемкие задачи можно перенести на сервер.</li>
    <li>Независимое развитие кода клиентов и кода сервера.</li>
    <li>Множество различных клиентов, пример – Tomcat и разные браузеры.</li>
</ul>
<p>Самый базовый вариант взаимодействия клиента и сервера представлен на картинке:</p>
<img data-max-width="512" data-id="20aca3ae-a74c-4cbc-9caa-e5ab1447c1a5" src="https://cdn.javarush.com/images/article/20aca3ae-a74c-4cbc-9caa-e5ab1447c1a5/512.jpeg" alt="клиент-сервер">
<p>Тут важно отметить две детали. Во-первых, из картинки видно, что к одному серверу могут обращаться множество клиентов. Во-вторых, они могут к нему обращаться одновременно. Это тоже важная часть работы сервера.</p>
<p>Один клиент обычно взаимодействует с одним пользователем, поэтому там часто даже авторизация не нужна. Однако сервер обрабатывает запросы тысяч клиентов и разрабатывая для него код нужно уметь отличать авторизацию от аутентификации.</p>
<p>Еще важно, что сервер обрабатывает тысячи запросов параллельно. А это значит, что, разрабатывая код бэкенда, тебе постоянно нужно будет думать над задачей одновременного доступа к ресурсам. Также у кода сервера очень высокая вероятность race condition (гонки потоков), deadlock (взаимная блокировка потоков).</p>
<p><strong>Жизненный цикл важных объектов нужно обязательно контролировать:</strong></p>
<p>Ты не можешь просто так запустить на сервере новый поток через <code>new Thread().start()</code>. Вместо этого тебе нужно иметь ThreadPool, который будет шариться между всеми сервисными потоками.</p>
<p>Также нельзя просто так запустить асинхронную задачу, они ведь тоже выполняются в отдельных потоках. Создавая такую задачу, ты всегда должен знать, какой пул-потоков ее выполняет и что произойдет, если такой пул переполнится.</p>
<p>Все работы с файлами и директориями нужно делать через try-with-resources. Если в обычном приложении ты забыл закрыть поток или файл – разве это проблема? Закроется сам при выходе из программы. А вот если ты где-то в коде забыл закрыть файл на сервере, и ваш сервер работает месяцами… Скоро таких незакрытых файлов накопятся тысячи и ОС перестанет открывать новые файлы на чтение (работу с файлами контролирует ОС). Тимлид вас по головке не погладит…</p>
<h2>1.4 Архитектура «клиент-сервер»</h2>
<p>еще один важный момент. <strong>Архитектура клиент-сервер определяет лишь общие принципы взаимодействия между компьютерами</strong>, детали взаимодействия определяют различные протоколы.</p>
<p>Данная концепция (клиент-сервер) говорит нам, что нужно разделять машины в сети на клиентские, которым всегда что-то надо и на серверные, которые дают то, что надо. При этом взаимодействие всегда начинает клиент, а правила, по которым происходит взаимодействие описывает протокол.</p>
<p>Существует два вида архитектуры взаимодействия клиент-сервер: первый получил название <strong>двухуровневая архитектура</strong> клиент-серверного взаимодействия, второй – многоуровневая архитектура клиент-сервер (иногда его называют <strong>трехуровневая архитектура</strong> или трехзвенная архитектура, но это частный случай).</p>
<p>Принцип работы двухуровневой архитектуры взаимодействия клиент-сервер заключается в том, что обработка запроса происходит на одном сервере без обращения к другим серверам в процессе этой обработки.</p>
<p>Двухуровневую модель взаимодействия клиент-сервер можно нарисовать в виде простой схемы.</p>
<img data-max-width="800" data-id="fc9e05b7-e396-4057-96ac-e8417be7b534" src="https://cdn.javarush.com/images/article/fc9e05b7-e396-4057-96ac-e8417be7b534/800.jpeg" alt="двухуровневой архитектуры взаимодействия клиент-сервер">
<p>Тут видно, что первый уровень – это все, что касается клиента, а второй уровень – это все, что касается сервера.</p>