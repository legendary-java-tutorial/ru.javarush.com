История логов в Java
<p>----------------------------------------</p>
Первый логгер - log4j
Первый официальный логгер - JUL: java.util.logging
Первый логгер-обертка – JCL: jakarta commons logging
Первый последний логгер - Logback
Последний универсальный логгер – SLF4J: Simple Logging Facade for Java
<p>----------------------------------------</p>
<h2>2.1 Первый логгер – log4j</h2>
<p>Как ты уже знаешь, история логов началась с <code>System.err.println()</code> – вывод записи в консоль. Его и сейчас активно используют при дебаге, например, Intellij IDEA с помощью него выводит сообщения об ошибках в консоль. Но никаких настроек у этого варианта нет, так что пойдем дальше.</p>
<p>Первый и самый популярный логгер назывался <code>Log4j</code>. Это было хорошее и гибко настраиваемое решение. В силу разных обстоятельств это решение так и не попало в JDK, чем очень расстроило все комьюнити.</p>
<p>Этот логгер не просто умел логировать, он был создан программистами для программистов и позволял им решать проблемы, которые постоянно возникали в связи с логированием.</p>
<p>Как вы уже знаете, логи пишутся в конечном итоге для того, чтобы какой-то человек их читал и пытался понять, что же произошло во время работы программы – что и когда пошло не так как ожидалось.</p>
<p>В <code>log4j</code> для этого были три вещи:</p>
<ul>
    <li><strong>логирование подпакетов;</strong></li>
    <li><strong>множество appender’ов (результатов);</strong></li>
    <li><strong>горячая перезагрузка настроек.</strong></li>
</ul>
<p>Во-первых, настройки <code>log4j</code> можно было прописать таким образом, чтобы включить логирование в одном пакете и выключить в другом. Например, можно было включить логирование в пакете <code>com.javarush.server</code>, но при этом выключить его в <code>com.javarush.server.payment</code>. Это позволяло быстро убрать из лога ненужную информацию.</p>
<p>Во-вторых, <code>log4j</code> позволял писать результаты логирования сразу в несколько лог-файлов. И вывод в каждый можно было настроить индивидуально. Например, в один файл можно было писать только информацию о серьезных ошибках, в другой – логи из определенного модуля, в а третий – логи за определенное время.</p>
<p>Каждый лог-файл, таким образом был настроен на определенный тип ожидаемых проблем. Это очень упрощало жизнь программистам, которым не доставляло удовольствия просматривать вручную гигабайтные файлы логов.</p>
<p>И наконец, в-третьих, <code>log4j</code> позволял изменить настройки лога прямо во время работы программы, не перезапуская ее. Это было очень удобно, когда нужно было подправить работу логов, чтобы найти дополнительную информацию по определенной ошибке.</p>
<p>Важно! Есть две версии лога <code>log4j</code>: <strong>1.2.x</strong> и <strong>2.x.x</strong>, которые <span class="text-red">несовместимы друг с другом</span>.</p>
<p>Подключить логгер в проект можно с помощью кода:</p>
<pre class='line-numbers'><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
    &lt;version&gt;2.17.2&lt;/version&gt;
  &lt;/dependency&gt;
 
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
    &lt;version&gt;2.17.2&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2>2.2 Первый официальный логгер – JUL: java.util.logging</h2>
<p>После того как в Java-сообществе появился зоопарк логгеров, разработчики <code>JDK</code> решили сделать один стандартный логгер, которым бы пользовались все. Так появился логгер <code>JUL</code>: пакет <code>java.util.logging</code>.</p>
<p>Однако, при его разработке создатели логгера взяли за основу не <code>log4j</code>, а вариант логгера от IBM, что повлияло на его развитие. Хорошая новость – логгер <code>JUL</code> входит в состав <code>JDK</code>, плохая – им мало кто пользуется.</p>
<img data-max-width="800" data-id="3b660d0c-a0bf-4afb-a496-e0ccb7e659fb" src="https://cdn.javarush.com/images/article/3b660d0c-a0bf-4afb-a496-e0ccb7e659fb/800.jpeg" alt="JUL">
<p>Мало того, что разработчики <code>JUL</code> сделали <strong>«еще один универсальный стандарт»</strong>, так они сделали для него свои собственные уровни логирования, которые отличались от принятых в то время у популярных логгеров.</p>
<p>И это было большой проблемой. Ведь продукты на <code>Java</code> зачастую собраны из большого количества библиотек и в каждой такой библиотеке был свой собственный логгер. Значит нужно было конфигурировать все логгеры которые есть в приложении.</p>
<p>Хотя сам по себе логгер довольно неплох. Создание логгера более-менее похожее. Для этого нужно сделать импорт:</p>
<pre><code>
<span class="text-red">java.util.logging.Logger</span> <span class="text-green">log</span> = <span class="text-red">java.util.logging.Logger</span>.<span class="text-orange">getLogger</span>(<span class="text-user">LoggingJul.class.getName()</span>);
</code></pre>
<p><span class="text-user">Имя класса</span> специально передается для того, чтобы знать, откуда идет логирование.</p>
<p>Только с выходом  разработчики решили важные проблемы, после чего <code>JUL</code> по-настоящему удобно использовать. До этого это был какой-то второразрядный логгер.</p>
<p>Также этот логгер поддерживает лямбда-выражения и ленивые вычисления. Начиная с <code>Java 8</code>, в него можно передавать <code>Supplier&lt;String&gt;</code>. Это помогает считать и создавать строку только в тот момент, когда это действительно нужно, а не каждый раз, как это было ранее.</p>
<p>Методы с аргументом <code>Supplier&lt;String&gt; msgSupplier</code> выглядят как показано ниже:</p>
<pre class='language-java line-numbers'><code>
public void info(Supplier<String> msgSupplier) {
   log(Level.INFO, msgSupplier);
}
</code></pre>
<h2>2.3 Первый логгер-обертка – JCL: jakarta commons logging</h2>
<p>Долгое время не было единого стандарта среди логгеров, <code>JUL</code> должен был стать таким, но он был хуже <code>log4j</code>, поэтому единого стандарта так и не появилось. Зато появился целый зоопарк логгеров, каждый из которых хотел стать тем самым.</p>
<img data-max-width="800" data-id="134a78f3-d92d-425d-a70d-6eaf950ecc6b" src="https://cdn.javarush.com/images/article/134a78f3-d92d-425d-a70d-6eaf950ecc6b/800.jpeg" alt="JCL">
<p>Однако обычным Java-разработчикам не нравилось, что почти у каждой библиотеки есть свой собственный логгер и его нужно как-то по-особенному конфигурировать. Поэтому сообщество решило создать специальную обертку над другими логгерами – так появился <code>JCL: jakarta commons logging</code></p>
<p>И опять-таки проект, который создавался, чтобы быть лидером, не стал им. Нельзя создать победителя, победителем можно только стать. Функциональность <code>JCL</code> была очень бедной и никто не хотел им пользоваться. Логгер, созданный, чтобы стать заменой всех логгеров, постигла такая же судьба, как и <code>JUL</code> – им не пользовались.</p>
<p>Хотя он был добавлен во многие библиотеки, выпускаемые сообществом Apache, но зоопарк логгеров только разрастался.</p>
<h2>2.4 Первый последний логгер – Logback</h2>
<p>Но и это еще не все. Разработчик <code>log4j</code> решил, что он самый умный (ну ведь его логгером пользовалось больше всего людей) и решил написать новый улучшенный логгер, который будет сочетать в себе плюсы <code>log4j</code> и других логгеров.</p>
<p>Новый логгер носил название <code>Logback</code>. Именно этот логгер должен был стать будущим единым логгером, которым бы пользовались все. В основе была та же идея, что и в <code>log4j</code>.</p>
<p>Подключить в проект этот логгер можно с помощью кода:</p>
<pre class='line-numbers'><code>
&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    &lt;version&gt;1.2.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Отличия были в том, что в <code>Logback</code>:</p>
<ul>
    <li>улучшена производительность;</li>
    <li>добавлена нативная поддержка <code>slf4j</code>;</li>
    <li>расширена опция фильтрации.</li>
</ul>
<p>Еще одним преимуществом этого логгера было то, что у него были очень хорошие настройки по умолчанию. И конфигурировать логгер нужно было, только если вы хотели что-то в них изменить. Также файл настроек был лучше адаптирован под корпоративный софт – все его конфигурации задавались в виде <code>xml/</code>.</p>
<p>По умолчанию <code>Logback</code> не требует каких-либо настроек и записывает все логи от уровня <code>DEBUG</code> и выше. Если вам нужно другое поведение, его можно настроить через <code>xml</code> конфигурацию:</p>
<pre class='line-numbers'><code>&lt;configuration&gt;
    &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
        &lt;file&gt;app.log&lt;/file&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss,SSS} %-5p [%c] - %m%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;logger name="org.hibernate.SQL" level="DEBUG" /&gt;
    &lt;logger name="org.hibernate.type.descriptor.sql" level="TRACE" /&gt;
    &lt;root level="info"&gt;
        &lt;appender-ref ref="FILE" /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h2>2.5 Последний универсальный логгер – SLF4J: Simple Logging Facade for Java</h2>
<p>Как же бывает долог путь поиска золотой середины…</p>
<p>В 2006 году один из создателей <code>log4j</code> вышел из проекта и решил еще раз попробовать создать универсальный логгер. Но на этот раз это был не новый логгер, а новый универсальный стандарт (обертка), который позволял взаимодействовать различным логгерам вместе.</p>
<p>Этот логгер назвали <code>slf4j — Simple Logging Facade for Java</code>, он был оберткой вокруг <code>log4j</code>, <code>JUL</code>, <code>common-loggins и logback</code>. Этот логгер решал реальную проблему – управление зоопарком логгеров, поэтому все стали сразу им пользоваться.</p>
<p>Мы героически решаем проблемы, которые сами себе и создаем. Как видим, прогресс дошел до того, что создали обертку над оберткой…</p>
<p>Сама обертка состоит из двух частей:</p>
<ul>
    <li><code>API</code>, который используется в приложениях;</li>
    <li>Реализации, которые добавляются в виде отдельных зависимостей для каждого логгера.</li>
</ul>
<p>Подключить логгер в проект можно с помощью кода:</p>
<pre class='line-numbers'><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
    &lt;version&gt;2.17.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
    &lt;version&gt;2.17.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
    &lt;version&gt;2.17.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Достаточно подключить правильную реализацию и все: весь проект будет работать с ней.</p>
<h2>2.6 Оптимизация в slf4j</h2>
<p><code>Slf4j</code> поддерживает все новые функции, такие как <span class="text-green">форматирование строк для логирования</span>. До этого была такая проблема. Допустим, ты хочешь вывести в лог сообщение:</p>
<pre class='language-java'><code>
log.debug("User " + user + " connected from " + request.getRemoteAddr());
</code></pre>
<p>С этим кодом есть проблема. Допустим, ваше приложение работает на <code>production</code> и не пишет в лог никакие <code>DEBUG-сообщения</code>, однако метод <code>log.debug()</code> все равно будет вызван, а при его вызове будут вызваны и такие методы:</p>
<ul>
    <li><code>user.toString();</code></li>
    <li><code>request.getRemoteAddr();</code></li>
</ul>
<p>Вызов этих методов замедляет приложение. Их вызов нужен только во время дебага, но они все равно вызываются.</p>
<p>С точки зрения логики, эту проблему нужно было решать в самой библиотеке логирования. И в первой версии log4j решение было придумано:</p>
<pre class='language-java line-numbers'><code>
if (log.isDebugEnabled()) {
    log.debug("User " + user + " connected from " + request.getRemoteAddr());
}
</code></pre>
<p>Вместо одной строки для лога теперь нужно было писать три. Что резко ухудшило читабельность кода, и понизило популярность <code>log4j</code>.</p>
<p>Логгер <code>slf4j</code> смог немного улучшить ситуацию, предложив умное логирование. Выглядело оно так:</p>
<pre class='language-java'><code>
log.debug("User {} connected from {}", user, request.getRemoteAddr());
</code></pre>
<p>где <code>{}</code> обозначают вставки аргументов, которые передаются в методе. То есть первая <code>{}</code> соответствует user, вторая <code>{}</code> — <code>request.getRemoteAddr()</code>.</p>
<p>Эти параметры будут конкатенировать в единое сообщение только в случае, если уровень логирования позволяет записывать в лог. Не идеально, но лучше, чем все остальные варианты.</p>
<p>После этого <code>SLF4J</code> стал быстро расти в популярности, на данный момент это лучшее решение.</p>
<p>Поэтому будем рассматривать логирование на примере связки <code>slf4j-log4j12</code>.</p>
