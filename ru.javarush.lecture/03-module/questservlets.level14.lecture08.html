Инвертирование зависимостей
<p>----------------------------------------</p>
Dependency Inversion
Инвертирование зависимостей на практике
<p>----------------------------------------</p>
<h2>9.1 Dependency Inversion</h2>
<p>Помнишь, мы когда-то говорили, что в серверном приложении нельзя просто так создавать потоки через <code>new Thread().start()</code>? Потоки должен создавать только контейнер. Теперь мы разовьем эту мысль еще сильнее.</p>
<p><span class="text-green">Все объекты тоже должен создавать только контейнер</span>. Конечно, речь не идет обо всех объектах, а скорее о так называемых бизнес-объектах. Их еще часто называют бинами. Ноги этого подхода растут из пятого принципа SOLID, который требует избавляться от классов и переходить на интерфейсы:</p>
<ul>
    <li> Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций.</li>
    <li>Абстракции не должны зависеть от деталей. Реализация должна зависеть от абстракции.</li>
</ul>
<p>Модули не должны содержать ссылки на конкретные реализации, а все зависимости и взаимодействие между ними должно строиться исключительно на основе абстракций (то есть интерфейсов). Саму суть этого правила можно записать одной фразой: <span class="text-red">все зависимости должны быть в виде интерфейсов</span>.</p>
<p>Несмотря на свою фундаментальность и кажущуюся простоту, это правило нарушается чаще всего. А именно, каждый раз, когда в коде программы/модуля мы используем оператор new и создаем новый объект конкретного типа, тем самым вместо зависимости от интерфейса образуется зависимость от реализации.</p>
<p>Понятно, что этого нельзя избежать и объекты где-то должны создаваться. Но, по крайней мере, нужно свести к минимуму количество мест, где это делается и в которых явно указываются классы, а также локализовать и изолировать такие места, чтобы они не были разбросаны по всему коду программы.</p>
<p>Очень хорошим решением является безумная идея о том, чтобы сконцентрировать создание новых объектов в рамках специализированных объектов и модулей — фабрик, сервис локаторов, IoC-контейнеров.</p>
<p>В каком-то смысле такое решение следует Принципу единственного выбора (Single Choice Principle), который говорит: <span class="text-red">"Всякий раз, когда система программного обеспечения должна поддерживать множество альтернатив, их полный список должен быть известен только одному модулю системы"</span>.</p>
<p>Поэтому, если в будущем придется добавить новые варианты (или новые реализации, как в рассматриваемом нами случае создания новых объектов), то достаточно будет произвести обновление только того модуля, в котором содержится эта информация, а все остальные модули останутся незатронутыми и смогут продолжать свою работу как обычно.</p>
<h3>Пример 1</h3>
<p>Было бы разумно вместо <code>new ArrayList </code>писать что-то типа <code>List.new()</code>, JDK подставила бы вам правильную реализацию листа: ArrayList, LinkedList или даже ConcurrentList. </p>
<p>Например, компилятор смотрит, что к объекту есть обращения из различных потоков и ставит туда потоко-безопасную реализацию. Или слишком много вставок в середину листа, тогда реализация будет основана на LinkedList.</p>
<h3>Пример 2</h3>
<p>Это уже произошло с сортировками, например. Когда последний раз ты писал алгоритм сортировки для сортировки коллекции? Вместо этого теперь все пользуются метод <code>Collections.sort()</code>, а элементы коллекции должны поддерживать интерфейс Comparable (сравниваемый).</p>
<p>Если в метод <code>sort()</code> передать коллекцию из меньше чем 10 элементов, ее вполне можно отсортировать сортировкой пузырьком (Bubble sort), а не Quicksort.</p>
<h3>Пример 3</h3>
<p>Компилятор уже следит за тем, как ты конкатенируешь строки и заменят ваш код на <code>StringBuilder.append()</code>.</p>
<h2>9.2 Инвертирование зависимостей на практике</h2>
<p>Теперь самое интересное: давай подумаем, как нам совместить теорию и практику. Каким образом модули могут корректно создавать и получать свои “зависимости” и не нарушать Dependency Inversion?</p>
<p>Для этого при проектировании модуля ты должен решить для себя:</p>
<ul>
    <li>что модуль делает, какую функцию выполняет;</li>
    <li>то модулю нужно от его окружения, то есть с какими объектами/модулями ему придется иметь дело;</li>
    <li>и как он это будет получать.</li>
</ul>
<p>Чтобы соблюсти принципы Dependency Inversion тебе обязательно нужно определиться с тем, какие внешние объекты использует ваш модуль и как он будет получить на них ссылки.</p>
<p>И тут возможны следующие варианты:</p>
<ul>
    <li>модуль сам создает объекты;</li>
    <li>модуль берет объекты из контейнера;</li>
    <li>модуль понятия не имеет откуда берутся объекты.</li>
</ul>
<p>Проблема в том, что для создания объекта необходимо вызвать конструктор конкретного типа, и в результате модуль будет зависеть не от интерфейса, а от конкретной реализации. Но если мы не хотим, чтобы в коде модуля объекты создавались явно, то можно использовать паттерн Фабричный Метод (<strong>Factory Method</strong>).</p>
<p><span class="text-user">"Суть заключается в том, что вместо непосредственного инстанцирования объекта через new, мы предоставляем классу-клиенту некоторый интерфейс для создания объектов. Поскольку такой интерфейс при правильном дизайне всегда может быть переопределен, мы получаем определенную гибкость при использовании низкоуровневых модулей в модулях высокого уровня"</span>.</p>
<p>В случаях, когда нужно создавать группы или семейства взаимосвязанных объектов, вместо Фабричного Метода используется Абстрактная Фабрика (<strong>Abstract factory</strong>).</p>
<h2>9.3 Использование Service Locator</h2>
<p>Модуль берет необходимые объекты у того, у кого они уже есть. Предполагается, что в системе есть некоторый репозиторий объектов, в который модули могут “класть” свои объекты и “брать” объекты из репозитория.</p>
<p>Этот подход реализуется шаблоном Локатор Сервисов (<strong>Service Locator</strong>), основная идея которого заключается в том, что в программе имеется объект, знающий, как получить все зависимости (сервисы), которые могут потребоваться.</p>
<p>Главное отличие от фабрик в том, что Service Locator не создает объекты, а фактически уже содержит в себе инстанцированные объекты (или знает где/как их получить, а если и создает, то только один раз при первом обращении). Фабрика при каждом обращении создает новый объект, который ты получаешь в полную собственность и можешь делать с ним что хочешь.</p>
<p><strong>Важно</strong>! <span class="text-green">Локатор сервисов выдает ссылки на одни и те же уже существующие объекты</span>. Поэтому с объектами, выданными Service Locator, нужно быть очень осторожным, так как одновременно с тобой ими может пользоваться кто-то еще.</p>
<p>Объекты в Service Locator могут быть добавлены напрямую через конфигурационный файл да и вообще любым удобным программисту способом. Сам Service Locator может быть статическим классом с набором статических методов, синглетоном или интерфейсом и передаваться требуемым классам через конструктор или метод.</p>
<p>Service Locator иногда называют антипаттерном и не рекомендуют использовать (потому что он создает неявные связности и дает лишь видимость хорошего дизайна). Подробно можно почитать у Марка Симана:
</p>
<ul>
    <li><a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorIsAnAntiPattern.aspx" target="_blank">Service Locator is an Anti-Pattern</a></li>
    <li><a href="http://blog.ploeh.dk/2010/11/01/PatternRecognitionAbstractFactoryOrServiceLocator.aspx" target="_blank">Abstract Factory or Service Locator?</a></li>
</ul>
<h2>9.4 Dependency Injection</h2>
<p>Модуль вообще не заботится о “добывании” зависимостей. Он лишь определяет, что ему нужно для работы, а все необходимые зависимости ему поставляются (внедряются) извне кем-то другим.</p>
<p>Это так и называется — <strong>Внедрение Зависимостей</strong> (Dependency Injection). Обычно требуемые зависимости передаются либо в качестве параметров конструктора (Constructor Injection), либо через методы класса (Setter injection).</p>
<p>Такой подход инвертирует процесс создания зависимости — вместо самого модуля создание зависимостей контролирует кто-то извне. Модуль из активного эмитента объектов становится пассивным — не он создает, а для него создают другие.</p>
<p>Такое изменение направления действия называется <strong>Инверсия Контроля (Inversion of Control)</strong>, или Принцип Голливуда — “Не звоните нам, мы сами вам позвоним”.</p>
<p> Это <span class="text-green">самое гибкое решение, дающее модулям наибольшую автономность</span>. Можно сказать, что только оно в полной мере реализует “Принцип единственной ответственности” — модуль должен быть полностью сфокусирован на том, чтобы хорошо выполнять свою функцию и не заботиться ни о чем другом.</p>
<p>Обеспечение модуля всем необходимым для работы — это отдельная задача, которой должен заниматься соответствующий “специалист” (обычно управлением зависимостями и их внедрениями занимается некий контейнер — IoC-контейнер).</p>
<p>По сути, здесь все как в жизни: в хорошо организованной компании программисты программируют, а столы, компьютеры и все необходимое им для работы покупает и обеспечивает офис-менеджер. Или, если использовать метафору программы как конструктора — модуль не должен думать о проводах, сборкой конструктора занимается кто-то другой, а не сами детали.</p>
<p>Не будет преувеличением сказать, что использование интерфейсов для описания зависимостей между модулями (Dependency Inversion) + корректное создание и внедрение этих зависимостей (прежде всего Dependency Injection) являются <strong>ключевыми техниками для снижения связанности</strong>.</p>
<p>Они служат тем фундаментом, на котором вообще держится слабая связанность кода, его гибкость, устойчивость к изменениям, переиспользование, и без которого все остальные техники имеют мало смысла. Это основа основ слабой связности и хорошей архитектуры.</p>
<p>Принцип Inversion of Control (вместе с Dependency Injection и Service Locator) детально разбирается Мартином Фаулером. Есть переводы обеих его статей: <a href="http://yugeon-dev.blogspot.com.es/2010/07/inversion-of-control-containers-and_21.html" target="_blank">"Inversion of Control Containers and the Dependency Injection pattern"</a> и <a href="http://habrahabr.ru/post/116232/" target="_blank">“Inversion of Control”</a>.</p>