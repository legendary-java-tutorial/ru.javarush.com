Память в JVM
<p>----------------------------------------</p>
Знакомство с памятью в JVM. 
Стек потока. 
Куча (heap). 
Взаимодействие с объектами. 
Пример взаимодействия с объектами.
<p>----------------------------------------</p>
<h2>Знакомство с памятью в JVM</h2>

<p>Как ты уже знаешь, JVM запускает Java-программы внутри себя. Как и любая виртуальная машина, она имеет собственную систему организации памяти. </p>

<p>Схема организации внутренней памяти указывает на принцип работы вашего Java-приложения. Таким образом можно определить узкие места в работе приложений и алгоритмов. Давай разберемся, как она устроена.</p>
<img data-max-width="800" data-id="1180008a-b863-4007-b14b-10c0a106ecb8" src="https://cdn.javarush.com/images/article/1180008a-b863-4007-b14b-10c0a106ecb8/800.jpeg" alt="Знакомство с памятью в JVM">

<p><strong>Важно!</strong> Модель Java в первоначальном виде была недостаточно хороша, поэтому она была пересмотрена в Java 1.5. Эта версия используется по сей день (Java 14+).</p>

<h2>Стек потока</h2>

<p>Модель памяти в Java, используемая внутри JVM, делит память на стеки потоков (thread stacks) и кучу (heap). Посмотрим на Java-модель памяти, логично разделенную на блоки:</p>

<img data-max-width="512" data-id="06c9cf70-8f47-463d-b6bd-e19ae1f5d72a" src="https://cdn.javarush.com/images/article/06c9cf70-8f47-463d-b6bd-e19ae1f5d72a/512.jpeg" alt="Стек потока">

<p><strong>Все потоки</strong>, работающие в JVM, имеют <strong>свой стек</strong>. Стек в свою очередь держит информацию о том, какие методы вызвал поток. Я буду называть это “стеком вызовов”. Стек вызовов возобновляется, как только поток выполняет свой код.</p>

<p>Стек потока содержит в себе <strong>все локальные переменные</strong>, требующиеся для выполнения методов из стека потока. Поток может получить доступ только к своему стеку. Локальные переменные не видны остальным потокам, только потоку, создавшему их. В ситуации, когда два потока выполняют один и тот же код, они оба создают свои локальные переменные. Таким образом, каждый поток имеет свою версию каждой локальной переменной.</p>

<p>Все локальные переменные примитивных типов (<span class="text-orange">boolean</span>, <span class="text-orange">byte</span>, <span class="text-orange">short</span>, <span class="text-orange">char</span>, <span class="text-orange">int</span>, <span class="text-orange">long</span>, <span class="text-orange">float</span>, <span class="text-orange">double</span>) полностью хранятся в стеке потоков и не видны другим потокам. Один поток может передать копию примитивной переменной другому потоку, но не может совместно использовать примитивную локальную переменную.</p>

<h2>Куча (heap)</h2>

<p>Куча содержит все объекты, созданные в вашем приложении, независимо от того, какой поток создал объект. К этому относятся и обертки примитивных типов (например, <span class="text-orange">Byte</span>, <span class="text-orange">Integer</span>, <span class="text-orange">Long</span> и так далее). Неважно, был ли объект создан и присвоен локальной переменной или создан как переменная-член другого объекта, он хранится в куче.</p>

<p>Ниже диаграмма, которая иллюстрирует стек вызовов и локальные переменные (они хранятся в стеках), а также объекты (они хранятся в куче):</p>

<img data-max-width="800" data-id="7b8ec0e5-49eb-4a16-b473-7462cbbc4065" src="https://cdn.javarush.com/images/article/7b8ec0e5-49eb-4a16-b473-7462cbbc4065/800.jpeg" alt="Куча (heap)">

<p>В случае, когда локальная переменная примитивного типа, она хранится в стеке потока.</p>

<p>Локальная переменная также может быть ссылкой на объект. В этом случае ссылка (локальная переменная) хранится в стеке потоков, но сам объект хранится в куче.</p>

<p>Объект содержит методы, эти методы содержат локальные переменные. Эти локальные переменные также хранятся в стеке потоков, даже если объект, которому принадлежит метод, хранится в куче.</p>

<p>Переменные-члены объекта хранятся в куче вместе с самим объектом. Это верно как в случае, когда переменная-член имеет примитивный тип, так и в том случае, если она является ссылкой на объект.</p>

<p>Статические переменные класса также хранятся в куче вместе с определением класса.</p>

<h2>Взаимодействие с объектами</h2>

<p>К объектам в куче могут обращаться все потоки, которые имеют ссылку на объект. Если поток имеет доступ к объекту, то он может получить доступ к переменным этого объекта. Если два потока вызывают метод для одного и того же объекта одновременно, они оба будут иметь доступ к переменным-членам объекта, но каждый поток будет иметь свою собственную копию локальных переменных.</p>


<img data-max-width="800" data-id="130d32a3-c025-4f2b-9a40-616ba1fd2080" src="https://cdn.javarush.com/images/article/130d32a3-c025-4f2b-9a40-616ba1fd2080/800.jpeg" alt="Взаимодействие с объектами (heap)">

<p>Два потока имеют набор локальных переменных. <mark class="user">Local Variable 2</mark> указывает на общий объект в куче (<mark class="green">Object 3</mark>). Каждый из потоков имеет свою копию локальной переменной со своей ссылкой. Их ссылки являются локальными переменными и поэтому хранятся в стеках потоков. Тем не менее, две разные ссылки указывают на один и тот же объект в куче.</p>

<p>Обрати внимание, что общий <mark class="green">Object 3</mark> имеет ссылки на <mark class="green">Object 2</mark> и <mark class="green">Object 4</mark> как переменные-члены (показано стрелками). Через эти ссылки два потока могут получить доступ к <mark class="green">Object 2</mark> и <mark class="green">Object</mark> 4.</p>

<p>На диаграмме также показана локальная переменная (<mark class="user">Local variable 1</mark> из <span class="code text-orange">methodTwo</span>). Каждая ее копия содержит разные ссылки, которые указывают на два разных объекта (<mark class="green">Object 1</mark> и <mark class="green">Object 5</mark>), а не на один и тот же. Теоретически оба потока могут обращаться как к <mark class="green">Object 1</mark>, так и к <mark class="green">Object 5</mark>, если они имеют ссылки на оба этих объекта. Но на диаграмме выше каждый поток имеет ссылку только на один из двух объектов.</p>

<h2>Пример взаимодействия с объектами</h2>

<p>Давай посмотрим, как мы можем продемонстрировать работу в коде:</p>

<pre class='language-java line-numbers'><code>
 public class MySomeRunnable implements Runnable() {

    public void run() {
        one();
    }

    public void one() {
        int localOne = 1;

        Shared localTwo = Shared.instance;

        //… делаем что-то с локальными переменными

        two();
    }

    public void two() {
        Integer localOne = 2;

        //… делаем что-то с локальными переменными
    }
}
</code></pre>

<pre class='language-java line-numbers'><code>
public class Shared {

    // храним инстанс на наш объект в переменной

    public static final Shared instance = new Shared();

    // переменные-члены, указывающие на два объекта в куче

    public Integer object2 = new Integer(22);
    public Integer object4 = new Integer(44);
}
</code></pre>

<p>Метод <span class="code text-orange">run()</span> вызывает метод <span class="code text-orange">one()</span>, а <span class="code text-orange">one()</span> в свою очередь вызывает <span class="code text-orange">two()</span>.</p>

<p>Метод <span class="code text-orange">one()</span> объявляет примитивную локальную переменную (<mark class="user">localOne</mark>) типа <span class="text-orange">int</span> и локальную переменную (<mark class="user">localTwo</mark>), которая является ссылкой на объект.</p>

<p>Каждый поток, выполняющий метод <span class="code text-orange">one()</span>, создаст свою собственную копию <mark class="user">localOne</mark> и <mark class="user">localTwo</mark> в своем стеке. Переменные <mark class="user">localOne</mark> будут полностью отделены друг от друга, находясь в стеке каждого потока. Один поток не может видеть, какие изменения вносит другой поток в свою копию <mark class="user">localOne</mark>.</p>

<p>Каждый поток, выполняющий метод <span class="code text-orange">one()</span>, также создает свою собственную копию <mark class="user">localTwo</mark>. Однако две разные копии <mark class="user">localTwo</mark> в конечном итоге указывают на один и тот же объект в куче. Дело в том, что <mark class="user">localTwo</mark> указывает на объект, на который ссылается статическая переменная <mark class="user">instance</mark>. Существует только одна копия статической переменной, и эта копия хранится в куче. </p>

<p>Таким образом, обе копии <mark class="user">localTwo</mark> в конечном итоге указывают на один и тот же экземпляр <span class="code"><span class="text-green">Shared</span></span>. Экземпляр <span class="code"><span class="text-green">Shared</span></span> также хранится в куче. Он соответствует <mark class="green">Object 3</mark> на диаграмме выше.</p>

<p>Обрати внимание, что класс <span class="code"><span class="text-green">Shared</span></span> также содержит две переменные-члены. Сами переменные-члены хранятся в куче вместе с объектом. Две переменные-члены указывают на два других объекта <mark class="green">Integer</mark>. Эти целочисленные объекты соответствуют <mark class="green">Object 2</mark> и <mark class="green">Object 4</mark> на диаграмме.</p>

<p>Также обрати внимание, что метод <span class="code text-orange">two()</span> создает локальную переменную с именем <mark class="user">localOne</mark>. Эта локальная переменная является ссылкой на объект типа <span class="text-orange">Integer</span>. Метод устанавливает ссылку <mark class="user">localOne</mark> для указания на новый экземпляр <span class="text-orange">Integer</span>. Ссылка будет храниться в своей копии <mark class="user">localOne</mark> для каждого потока. Два экземпляра <span class="text-orange">Integer</span> будут сохранены в куче и, поскольку метод создает новый объект <span class="text-orange">Integer</span> при каждом выполнении, два потока, выполняющие этот метод, будут создавать отдельные экземпляры <span class="text-orange">Integer</span>. Они соответствуют <mark class="green">Object 1</mark> и <mark class="green">Object 5</mark> на диаграмме выше.</p>

<p>Обрати также внимание на две переменные-члены в классе <span class="code"><span class="text-green">Shared</span></span> типа <span class="text-orange">Integer</span>, который является примитивным типом. Поскольку эти переменные являются переменными-членами, они все еще хранятся в куче вместе с объектом. В стеке потоков хранятся только локальные переменные.</p>