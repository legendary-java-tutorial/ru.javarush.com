Подход MVC
<p>----------------------------------------</p>
Знакомство с архитектурой MVC. 
Архитектура MVC в вебе. 
Пример MVC в вебе. 
Взаимодействие компонентов MVC.
<p>----------------------------------------</p>
    <h2>Знакомство с архитектурой MVC</h2>

    <p>Самая популярная архитектура приложений, о которой знает каждый программист, — это <span class="text-bold">MVC</span>. MVC расшифровывается как <span class="text-bold">Model-View-Controller</span>.</p>

    <p>Это не столько архитектура приложений, как архитектура компонентов приложения, но к этому нюансу вернемся попозже. Что же такое MVC?</p>

    <p>MVC — это схема разделения данных приложения и управляющей логики на три отдельных компонента: <span class="text-bold">модель, представление и контроллер</span> — таким образом, что модификация каждого компонента может осуществляться независимо.</p>

    <ul>
        <li><span class="text-bold">Модель (Model)</span> предоставляет данные и реагирует на команды контроллера, изменяя свое состояние.</li>
        <li><span class="text-bold">Представление (View)</span> отвечает за отображение данных модели пользователю, реагируя на изменения модели.</li>
        <li><span class="text-bold">Контроллер (Controller)</span> интерпретирует действия пользователя, оповещая модель о необходимости изменений.</li>
    </ul>

    <p>Эту модель придумали еще в 1978 (!) году. Да, проблемы с правильной архитектурой ПО были актуальны еще 50 лет назад. Вот как эта модель описывается диаграммой в оригинале:</p>

<img width="800" src="https://cdn.javarush.com/images/article/4bc8c5a2-d140-4b72-8fa8-74f1bcb802ed/original.jpeg" alt="Знакомство с архитектурой MVC">

    <p><span class="text-bold">Модель</span> предоставляет данные и методы работы с ними: запросы в базу данных, проверку на корректность. <span class="text-bold">Модель не зависит от представления</span> (не знает как данные визуализировать) и контроллера (не имеет точек взаимодействия с пользователем), предоставляя доступ к данным и управлению ими.</p>

    <p>Модель строится таким образом, чтобы отвечать на запросы, изменяя свое состояние, при этом может быть встроено уведомление “наблюдателей”. Модель, за счет независимости от визуального представления, <span class="text-bold">может иметь несколько различных представлений</span> для одной “модели”.</p>

    <p><span class="text-bold">Представление</span> отвечает за получение необходимых данных из модели и отправляет их пользователю. Представление не обрабатывает введенные данные пользователя.</p>

    <p><span class="text-bold">Контроллер</span> обеспечивает “связь” между пользователем и системой. Контролирует и направляет данные от пользователя к системе и наоборот. Использует модель и представление для реализации необходимого действия.</p>

    <p>Определенная сложность есть с тем, что данная модель за десятки лет немного эволюционировала. То есть название осталось тем же, а назначение частей начало меняться.</p>

    <h2>Архитектура MVC в вебе</h2>

    <p>Идея, которая лежит в основе конструкционного шаблона MVC, очень проста: нужно четко разделять ответственность за различное функционирование в наших приложениях:</p>

<p><mark class="green"> Model</mark> — обработка данных и логика приложения.</p>
<p><mark class="orange">View</mark> — предоставления данных пользователю в любом поддерживаемом формате.</p>
<p><mark class="viola">Controller</mark> — обработка запросов пользователя и вызов соответствующих ресурсов.</p>

    <p>Приложение разделяется на три основных компонента, каждый из которых отвечает за различные задачи. Давай подробно разберем компоненты клиент-серверного приложения на примере.</p>

    <h4>Контроллер (Controller)</h4>

    <p>Пользователь кликает на различные элементы на странице в браузере, в результате чего браузер отправляет различные HTTP запросы: GET, POST или другие. К контроллеру можно отнести браузер и JS-код, которые работают внутри страницы.</p>

    <p>Основная функция контроллера в данном случае — это вызывать методы у нужных объектов, управлять доступом к ресурсам для выполнения задач, заданных пользователем. Обычно контроллер вызывает соответствующую модель для задачи и выбирает подходящий вид.</p>

    <h4>Модель (Model)</h4>

    <p><span class="text-bold">Модель в широком смысле</span> — это данные и правила, которые используются для работы с данными — вместе они составляют бизнес-логику приложения. Проектирование приложения всегда начинается с построения моделей объектов, которыми оно оперирует.</p>

    <p>Допустим, у нас есть интернет-магазин, который торгует книгами, тогда человек — это только пользователь приложения или еще и автор книги? Эти важные вопросы должны быть решены во время проектирования модели.</p>

    <p>Дальше идут наборы правил: что можно делать, что нельзя, какие наборы данных допустимы, а какие нет. Может ли книга быть без автора? А автор без книг? Может ли дата рождения пользователя быть в 300 году и тому подобное.</p>

    <p>Модель дает контроллеру представление данных, которые запросил пользователь (сообщение, страницу книги, картинки, и тому подобное). Модель данных будет одинаковой, вне зависимости от того, как мы хотим представлять их пользователю. Поэтому мы выбираем любой доступный вид для отображения данных.</p>

    <p><span class="text-bold">Модель содержит наиболее важную часть логики нашего приложения</span>, логику, которая решает задачу, с которой мы имеем дело (форум, магазин, банк и тому подобное). Контроллер содержит в основном организационную логику для самого приложения (прямо как твой Project Manager).</p>

    <h4>Вид (View)</h4>

    <p>View обеспечивает различные способы представления данных, которые получены из модели. Он может быть шаблоном, который заполняется данными. Может быть несколько различных views и контроллер выбирает, какой подходит наилучшим образом для текущей ситуации.</p>

    <p>Веб-приложение обычно состоит из набора контроллеров, моделей и видов (views). Контроллер может быть только на бэкенде, но также может быть вариант нескольких контроллеров, когда его логика размазывается и по frontend’у тоже. Хороший пример такого подхода — любое мобильное приложение.</p>

    <h2>Пример MVC в вебе</h2>

    <p>Допустим тебе нужно разработать интернет-магазин, который будет заниматься продажей книг. Пользователь может выполнять следующие действия: просматривать книги, регистрироваться, покупать, добавлять пункты к текущему заказу, отмечать понравившиеся книги и покупать их.</p>

    <p>В твоем приложении должна быть <span class="text-bold">модель</span>, которая отвечает за всю бизнес-логику. Также нужен <span class="text-bold">контроллер</span>, который будет обрабатывать все действия пользователей и превращать их в вызовы методов из бизнес-логики. При этом один метод контроллера может вызвать много различных методов модели.</p>

    <p>Также тебе нужны наборы views: список книг, информация об одной книге, корзина, список заказов. Каждая страница веб-приложения — это фактически и есть отдельный view, который отображает пользователю определенный аспект модели.</p>

    <p>Давай посмотрим, что произойдет, если пользователь откроет список рекомендованных магазином книг для просмотра названий. Всю последовательность действий можно описать в виде 6 шагов:</p>

<img data-max-width="800" data-id="a7f52906-62ff-44d9-8cb4-3357b5b9fe63" src="https://cdn.javarush.com/images/article/a7f52906-62ff-44d9-8cb4-3357b5b9fe63/800.jpeg" alt="Пример MVC в вебе">

    <p>Шаги:</p>

    <ol>
        <li>Пользователь кликает по ссылке «рекомендованы» и <span class="text-bold">браузер отправляет запрос</span> на, допустим, /books/recommendations.</li>
        <li><span class="text-bold">Контроллер проверяет запрос</span>: пользователь должен быть залогинен. Или у нас должны быть подборки книг для незалогиненных пользователей. Затем контроллер обращается к модели и просит ее отдать список книг, рекомендованных пользователю N.</li>
        <li><span class="text-bold">Модель</span> обращается в базу данных, достает оттуда информацию о книгах: популярные сейчас книги, книги, купленные пользователем, книги, купленные его друзьями, книги из его wish list. На основе этих данных модель строит список из 10 рекомендованных книг и возвращает их контроллеру.</li>
        <li><span class="text-bold">Контроллер</span> получает список рекомендованных книг и смотрит на него. На этом этапе контроллер принимает решения! Если книг мало или список вообще пустой, то он запрашивает список книг для незалогиненного пользователя. Если сейчас идет акция, то контроллер может добавить в список акционные книги.</li>
        <li><span class="text-bold">Контроллер</span> определяется с тем, какую страницу показать пользователю. Это может быть страница с ошибкой, страница со списком книг, страница поздравление о том, что пользователь стал миллионным посетителем.</li>
        <li>Сервер отдает клиенту страницу (<span class="text-bold">view</span>), выбранную контроллером. Она заполняется нужными данными (имя пользователя, список книг) и уходит к клиенту.</li>
        <li>Клиент получает страницу и отображает ее пользователю.</li>
    </ol>

    <p><span class="text-bold">В чем преимущества такого подхода?</span></p>

    <p>Самое очевидное преимущество, которое мы получаем от использования концепции MVC — это четкое разделение логики представления (интерфейса пользователя) и логики приложения (серверная часть).</p>

    <p>Второе преимущество — это разделение серверной части на две: умная модель (<span class="text-bold">исполнитель</span>) и контроллер (<span class="text-bold">центр принятия решений</span>).</p>

    <p>В предыдущем примере был момент, когда контроллер мог получить от модели пустой список рекомендованных книг и решал, что ему с ним делать. Теоретически эту логику можно было бы засунуть сразу в модель.</p>

    <p>Сначала при запросе рекомендованных книг модель бы решала, что делать, если список пустой. Затем пришлось бы в это же место добавить код, что делать, если сейчас идет акция, затем еще разные варианты.</p>

    <p>Потом оказалось, что админ магазина хочет посмотреть, как будет выглядеть страница пользователя без акции, или наоборот сейчас акции нет, а он хочет посмотреть, как будет отображаться будущая акция. А методов-то для этого нет. Поэтому и было решено отделить центр принятия решений (контроллер) от бизнес-логики (модель).</p>

    <p>Помимо изолирования видов от логики приложения, концепция MVC существенно уменьшает сложность больших приложений. Код получается гораздо более структурированным, и, тем самым, облегчается поддержка, тестирование и повторное использование решений.</p>

    <p>Понимая концепцию MVC, ты как разработчик осознаешь, где нужно добавить сортировку списка книг:</p>

    <ul>
        <li>На уровне запроса к базе данных.</li>
        <li>На уровне бизнес-логики (модели).</li>
        <li>На уровне бизнес-логики (контроллер).</li>
        <li>В представлении — на стороне клиента.</li>
    </ul>

    <p>И это не риторический вопрос. Вот прямо сейчас и подумай: где и почему нужно добавить код по сортировке списка книг. </p>

    <h2>Классическая модель MVC</h2>

    <p>Взаимодействие между компонентами MVC реализуется по-разному в веб-приложениях и в мобильных приложениях. Это происходит из-за того, что веб-приложение — короткоживущее, обрабатывает один запрос пользователя и завершается, а мобильное приложение обрабатывает много запросов без перезапуска.</p>

    <p>В веб-приложениях обычно используется "пассивная" модель, а в мобильных приложениях — "активная". Активная модель, в отличие от пассивной, позволяет подписываться и получать уведомления об изменении в ней. В случае с веб-приложениями этого не требуется.</p>

    <p>Примерно вот так выглядит взаимодействие компонентов в различных моделях:</p>
<img data-max-width="1024" data-id="1c742354-ab89-423e-85e5-40dfdc9d0691" src="https://cdn.javarush.com/images/article/1c742354-ab89-423e-85e5-40dfdc9d0691/1024.jpeg" alt="Классическая модель MVC">
    <p>В мобильных приложениях (активная модель) активно используются <span class="text-bold">события</span> и механизм подписки на события. При таком подходе view (<span class="text-bold">вид</span>) подписывается на изменения модели. Затем, когда происходит какое-то событие (например, пользователь нажимает кнопку), вызывается <span class="text-bold">контроллер</span>. Он дает и <span class="text-bold">модели</span> команду на изменение данных.</p>

    <p>Если какие-то данные изменились, то модель генерирует событие об изменении этих данных. Все view, которые подписались на это событие (для которых важно изменение именно этих данных), получают это событие и обновляют данные в своем интерфейсе.</p>

    <p>В веб-приложениях все организовано немного по-другому. Основное техническое отличие — это то, что <span class="text-red">клиент не может получать сообщения со стороны сервера по инициативе сервера</span>.</p>

    <p>Поэтому контроллер в веб-приложении обычно не присылает view какие-либо сообщения, а отдает клиенту новую страницу, которая технически является новым view или даже новым клиентским приложением (если одна страница ничего не знает о другой).</p>

    <p>В нынешнее время эта проблема частично решена с помощью таких подходов:</p>

    <ul>
        <li>Регулярный опрос сервера на счет изменения важных данных (раз в минуту или чаще).</li>
        <li>WebSocket’ы позволяют клиентку подписываться на сообщения сервера.</li>
        <li>Web-push-уведомления со стороны сервера.</li>
        <li>Протокол HTTP/2 позволяет серверу инициировать отправку сообщений клиенту.</li>
    </ul>