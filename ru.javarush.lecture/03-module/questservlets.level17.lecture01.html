Поведенческие паттерны, часть 2
<p>----------------------------------------</p>
State
Strategy
Template Method
Chain of Responsibility
Memento
<p>----------------------------------------</p>
<h2>2.1 State</h2>
<p><strong>Состояние (State)</strong> — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.</p>
<img data-max-width="800" data-id="643b446c-be6c-4841-a190-37ccdec4fd71" src="https://cdn.javarush.com/images/article/643b446c-be6c-4841-a190-37ccdec4fd71/800.jpeg" alt="Состояние (State)">
<p>Паттерн состоит из 3 блоков:</p>
<p>Context — класс, объекты которого должны менять своё поведение в зависимости от состояния.</p>
<p>State — интерфейс, который должен реализовать каждое из конкретных состояний. Через этот интерфейс объект Context взаимодействует с состоянием, делегируя ему вызовы методов. Интерфейс должен содержать средства для обратной связи с объектом, поведение которого нужно изменить.</p>
<p>Для этого используется <strong>событие</strong> (паттерн Publisher — Subscriber). Это необходимо для того, чтобы в процессе выполнения программы заменять объект состояния при появлении событий. Возможны случаи, когда сам Context периодически опрашивает объект состояния на наличие перехода.</p>
<p>ConcreteState1, ConcreteState2 — классы конкретных состояний. Должны содержать информацию о том, при каких условиях и в какие состояния может переходить объект из текущего состояния. Например, из ConcreteState1 объект может переходить в состояние ConcreteState2 и ConcreteState3, а из ConcreteState2 — обратно в ConcreteState1 и так далее. Объект одного из них должен содержать Context при создании.</p>
<p>Например, ты пишишь игру, где персонаж может бегать, плавать и летать. Если твой персонаж попал в воду, то разумно ограничить его поведение в воде: он теперь не может стрелять, но у него сохранились какие-то действия: плыть вперед, вправо, влево и т.п.</p>
<p>Состояние твоего персонажа можно описать объектом State, у которого есть методы, которые можно вызывать и которые будут что-то делать. И после того, как твой персонаж залез в воду, ты просто меняешь у него внутри ссылку на другой объект State — и он меняет свое состояние.</p>
<h2>2.2 Strategy</h2>
<p><strong>Стратегия (Strategy)</strong> — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса.</p>
<p>Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.</p>
<img data-max-width="800" data-id="aba01b4f-cb28-4f98-849d-5df79c83f61f" src="https://cdn.javarush.com/images/article/aba01b4f-cb28-4f98-849d-5df79c83f61f/800.jpeg" alt="Стратегия (Strategy)">
<p>Паттерн Стратегия позволяет использовать различные бизнес-правила или алгоритмы в зависимости от контекста. Применяется в случаях, когда в одном и том же месте в зависимости от текущего состояния системы (или её окружения) должны использоваться различные алгоритмы.</p>
<p><strong>Сильные стороны:</strong></p>
<ul>
    <li>инкапсуляция реализации различных алгоритмов, система становится независимой от возможных изменений бизнес-правил;</li>
    <li>вызов всех алгоритмов одним стандартным образом;</li>
    <li>отказ от использования переключателей и/или условных операторов.</li>
</ul>
<p>Этот паттерн чем-то похож на паттерн State, однако тут акцент сделан не на состояние, а на поведение. Допустим, персонаж в твоей игре может менять оружие. Тогда при смене оружия можно просто поменять ссылку на объект, которые описывает, как это оружие работает. </p>
<h2>2.3 Template Method</h2>
<img data-max-width="800" data-id="2e185d04-7701-4c65-a4ce-ba3c52449afb" src="https://cdn.javarush.com/images/article/2e185d04-7701-4c65-a4ce-ba3c52449afb/800.jpeg" alt="Template Method">
<p><strong>Abstract class</strong> (абстрактный класс) — определяет абстрактные операции, замещаемые в наследниках для реализации шагов алгоритма; реализует шаблонный метод, определяющий скелет алгоритма. Шаблонный метод вызывает замещаемые и другие, определенные в Abstract class, операции.</p>
<p><strong>Concrete class</strong> (конкретный класс) — реализует замещаемые операции необходимым для реализации способом. Concrete class предполагает, что инвариантные шаги алгоритма будут выполнены в AbstractClass.</p>
<p>Этот паттерн часто используется, когда надо:</p>
<ul>
    <li>Однократное использование инвариантной части алгоритма с оставлением изменяющейся части на усмотрение наследникам.</li>
    <li>Локализация и вычленение общего для нескольких классов кода для избегания дублирования.</li>
    <li>Разрешение расширения кода наследниками только в определенных местах.</li>
</ul>
<p>Да, этот паттерн описывает использование пары: абстрактный класс и его реализация.</p>
<h2>2.4 Chain of Responsibility</h2>
<p><strong>Цепочка обязанностей (Chain of responsibility)</strong> — поведенческий шаблон проектирования, предназначенный для организации в системе уровней ответственности</p>
<img data-max-width="800" data-id="6567c227-7bcc-425e-83ac-2fee211fea97" src="https://cdn.javarush.com/images/article/6567c227-7bcc-425e-83ac-2fee211fea97/800.jpeg" alt="Цепочка обязанностей (Chain of responsibility)">
<p>Шаблон рекомендован для использования в условиях, когда:</p>
<ul>
    <li>в разрабатываемой системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа;</li>
    <li>все сообщения должны быть обработаны хотя бы одним объектом системы;</li>
    <li>сообщения в системе обрабатываются по схеме “обработай сам или перешли другому”, то есть одни сообщения обрабатываются на том уровне, где они получены, а другие пересылаются объектам другого уровня.</li>
</ul>
<h2>2.5 Memento</h2>
<p><strong>Хранитель (Memento)</strong> — поведенческий шаблон проектирования, позволяющий не нарушая инкапсуляцию зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние. </p>
<img data-max-width="800" data-id="251fd61c-5a0a-4626-b206-e09129af58ad" src="https://cdn.javarush.com/images/article/251fd61c-5a0a-4626-b206-e09129af58ad/800.jpeg" alt="Хранитель (Memento)">
<p>Шаблон Хранитель используется, когда:</p>
<ul>
    <li>необходимо сохранить снимок состояния объекта (или его части) для последующего восстановления;</li>
    <li>прямой интерфейс получения состояния объекта раскрывает детали реализации и нарушает инкапсуляцию объекта.</li>
</ul>