Антипаттерны
<p>----------------------------------------</p>
Знакомство с анти-паттернами. 
Магические числа и строчки. 
Класс бога. 
Преждевременная оптимизация. 
Изобретение велосипеда. 
Изобретение велосипеда с квадратными колесами.
<p>----------------------------------------</p>
    <h2>Знакомство с анти-паттернами</h2>

    <p>Анти-паттерны — полная противоположность паттернам. Напомним, паттерны проектирования — это примеры практик хорошего программирования, то есть шаблоны решения определённых задач. А вот анти-паттерны — их полная противоположность, то есть шаблоны ошибок, которые совершаются при решении различных задач.</p>

    <p>Частью практик хорошего программирования является именно избежание анти-паттернов. Не надо думать, что это такая непонятная теоретическая фигня — это конкретные проблемы, с которыми сталкивался практически каждый разработчик. Кто осведомлен, тот и вооружён!</p>

    <p>Рассмотрим несколько анти-паттернов, распространённых среди новичков:</p>

    <ul>
        <li>Магические числа и строки</li>
        <li>Класс бога</li>
        <li>Преждевременная оптимизация</li>
        <li>Изобретение велосипеда</li>
        <li>Изобретение одноколесного велосипеда</li>
    </ul>

    <h2>Магические числа и строки</h2>

    <p><span class="text-bold">Магическое число</span> — константа, использованная в коде для чего-либо (чаще всего — идентификации данных), само число которой не несёт никакого смысла без соответствующего комментария. Числа не несут абсолютно никакой семантики.</p>

    <p>Когда в коде вашего проекта начинаются появляться числа, значение которых не является очевидным, — это очень плохо. Программист, который не является автором такого кода, с трудностями сможет объяснить, как это работает. Со временем и автор кода с магическими числами не сможет объяснить его.</p>

    <p>Числа затрудняют понимание кода и его рефакторинг. Главные причины этой ошибки — спешка при разработке и отсутствие практики программирования. Этот анти-паттерн надо пресекать на корню, оговаривая использование числовых констант перед началом разработки.</p>

    <p>Для решения такой проблемы нужно создать переменную, имя которой объясняет назначение числовой константы, и присвоить ей требуемое значение.</p>

    <h2>Класс бога</h2>

    <p><span class="text-bold">Божественный объект</span> — анти-паттерн, который довольно часто встречается у разработчиков ООП. Такой объект берет на себя слишком много функций и/или хранит в себе практически все данные. В итоге мы имеем непереносимый код, в котором, к тому же, сложно разобраться.</p>

    <p>К тому же подобный код довольно сложно поддерживать, учитывая, что вся система зависит практически только от него. Причины этой ошибки: некомпетентность разработчика, взятие одним разработчиком большой части работы (особенно, когда объем работы превышает уровень опыта этого разработчика).</p>

    <p>Бороться с таким подходом надо, разбивая задачи на подзадачи, которыми смогут заниматься разные разработчики.</p>

    <h2>Преждевременная оптимизация</h2>

    <p><span class="text-bold">Преждевременная оптимизация</span> — это оптимизация, которую выполняют до того, как у программиста есть вся информация, необходимая для принятия взвешенных решений по поводу того, где и как нужно её проводить.</p>

    <p>На практике сложно предсказать, где встретится узкое место. <span class="text-green">Попытки навести оптимизацию до получения эмпирических результатов приведут к усложнению кода и появлению ошибок, а пользы не принесут.</span></p>

    <p>Как избежать? Сначала пиши чистый, читаемый, работающий код, используя известные и проверенные алгоритмы и инструменты. При необходимости используй инструменты для профилирования для поиска узких мест. Полагайся на измерения, а не на догадки и предположения.</p>

    <h4>Примеры и признаки</h4>

    <p>Кэширование до того, как провели профилирование. Использование сложных и недоказанных эвристических правил вместо математически верных алгоритмов. Выбор новых, непротестированных фреймворков, которые могут повести себя плохо под нагрузкой.</p>

    <h4>В чём сложность</h4>

    <p>Непросто определить, когда оптимизация будет преждевременной. Важно заранее оставлять место для роста. Нужно выбирать решения и платформы, которые позволят легко оптимизировать и расти. Также иногда преждевременную оптимизацию используют в качестве оправдания за плохой код. Например, берут алгоритм O(n2) только из-за того, что алгоритм был бы O(n) сложнее. </p>

    <h2>Изобретение велосипеда</h2>

    <p>Смысл этого анти-паттерна в том, что программист разрабатывает собственное решение задачи, для которой уже существуют решения, и зачастую куда более удачные.</p>

    <p>Разработчик считает себя умнее, поэтому для каждой задачи пытается придумать собственное решение, несмотря на опыт его предшественников. Чаще всего это приводит только к потере времени и понижению эффективности работы программиста. Ведь решение скорее всего окажется неоптимальным, если вообще будет найдено.</p>

    <p>Конечно, нельзя полностью отбрасывать возможность самостоятельного решения, так как это прямой дорогой приведет к программированию копипастом. Разработчик должен ориентироваться в задачах, которые могут предстать перед ним, чтобы грамотно их решить, используя при этом готовые решение или изобретая собственные.</p>

    <p>Очень часто причиной этого анти-паттерна является банальная нехватка времени. А время — это деньги.</p>

    <h2>Изобретение велосипеда с квадратными колесами</h2>

    <p>Этот анти-паттерн очень тесно связан с простым изобретением велосипеда — это создание собственного плохого решения, когда существует более удачное решение.</p>

    <p>Этот анти-паттерн вдвойне забирает время: сначала время тратится на изобретение и реализацию собственного решения, а потом — на его рефакторинг или замену.</p>

    <p><span class="text-bold">Программист должен знать о существовании различных решений</span> для определённых кругов задач, ориентироваться в их преимуществах и недостатках.</p>

    <p>Все проблемы, с которыми ты столкнешься как программист, можно поделить на две части:</p>

    <ul>
        <li>эту проблему умные люди решили 30 лет назад</li>
        <li>эту проблему умные люди решили 50 лет назад</li>
    </ul>

    <p>Большинство проблем в программировании были <span class="text-bold">успешно решены еще до твоего рождения</span>. Не нужно ничего изобретать — просто изучай опыт других людей (для этого и пишут книги).</p>

    <p>В 2022 году мы можем отпраздновать такие дни рождения:</p>

    <ul>

        <li>Языки программирования
            <ul>
                <li>Языку С исполнилось 50 лет (1972)</li>
                <li>Языку Java исполнилось 27 лет (1995)</li>
                <li>Языку Python исполнился 31 год (1991)</li>
            </ul>
        </li>

        <li>Связь
            <ul>
                <li>Интернету исполнилось 39 лет (1983)</li>
                <li>Мобильному телефону исполнилось 49 лет (1973)</li>
                <li>Первую СМС отправили 30 лет назад (1992)</li>
            </ul>
        </li>

        <li>Паттерны
            <ul>
                <li>Паттерну MVC исполнилось 44 года (1978)</li>
                <li>SQL придумали 48 лет назад (1974)</li>
                <li>Java Beans придумали 26 лет назад (1996)</li>
            </ul>
        </li>

        <li>Библиотеки
            <ul>
                <li>Hibernate придумали 21 год назад (2001)</li>
                <li>Spring придумали 20 лет назад (2002)</li>
                <li>Tomcat выпустили 23 года назад (1999)</li>
            </ul>
        </li>

        <li>Операционные системы
            <ul>
                <li>Unix выпустили в 51 год назад (1971)</li>
                <li>Windows увидела свет 37 лет назад (1985)</li>
                <li>Mac OS выпустили 21 год назад (2001)</li>
            </ul>
        </li>

    </ul>

    <p>И все эти вещи были не просто так придуманы, они были разработаны как решения проблем, которые были очень распространены и актуальны в то время.</p>