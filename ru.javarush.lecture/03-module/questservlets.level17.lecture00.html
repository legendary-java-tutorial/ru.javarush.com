Поведенческие паттерны
<p>----------------------------------------</p>
Iterator. 
Command. 
Observer. 
Visitor. 
Mediator.
<p>----------------------------------------</p>
    <h2>Iterator</h2>

    <p><span class="text-bold">Iterator</span> — поведенческий шаблон проектирования. Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из агрегированных объектов.</p>

<img data-max-width="800" data-id="a5c6aaa0-2382-4756-a67d-016b446e4b32" src="https://cdn.javarush.com/images/article/a5c6aaa0-2382-4756-a67d-016b446e4b32/800.jpeg" alt="Iterator">

    <p>Например, такие элементы как дерево, связанный список, хеш-таблица и массив могут быть пролистаны (и модифицированы) с помощью объекта Итератор.</p>

    <p>Перебор элементов выполняется объектом итератора, а не самой коллекцией. Это упрощает интерфейс и реализацию коллекции, а также способствует более логичному разделению обязанностей.</p>

    <p>Особенностью полноценно реализованного итератора является то, что код, использующий итератор, может ничего не знать о типе итерируемого агрегата.</p>

    <p>Такой подход используется очень часто. Например, ты отправляешь базе данных SQL-запрос, а в ответ она возвращает тебе итератор (в терминах SQL его обычно называют курсором). И ты с помощью полученного итератора можешь поочередно брать стоки из SQL-ответа. </p>

    <h2>Command</h2>

    <p><span class="text-bold">Команда (Command)</span> — поведенческий шаблон проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.</p>

<img data-max-width="800" data-id="79b0150a-e986-414f-a259-5ad472343eb7" src="https://cdn.javarush.com/images/article/79b0150a-e986-414f-a259-5ad472343eb7/800.jpeg" alt="Команда (Command)">

    <p>Чтобы вызывать какой-то метод, обычно нужны:</p>

    <ul>
        <li>ссылка на объект</li>
        <li>имя метода (ссылка на метод)</li>
        <li>значения параметров метода</li>
        <li>ссылка на контекст, который содержит используемые объекты</li>
    </ul>

    <p>Все эти данные нужно упаковать в один объект — Команда (<span class="text-bold">command</span>).</p>

    <p>Но и это еще не все: ведь команду должен кто-то выполнить. Так что в состав этого паттерна входят еще четыре сущности: команды (<span class="text-bold">command</span>), приёмник команд (<span class="text-bold">receiver</span>), вызывающий команды (<span class="text-bold">invoker</span>) и клиент (<span class="text-bold">client</span>).</p>

    <p>Объект <mark class="green">Command</mark> знает о приёмнике и вызывает метод приемника. Значения параметров приёмника сохраняются в команде. Вызывающий объект (invoker) знает, как выполнить команду и, возможно, делает учёт и запись выполненных команд. Вызывающий объект (invoker) ничего не знает о конкретной команде, он знает только об интерфейсе.</p>

    <p>Оба объекта (вызывающий объект и несколько объектов команд) принадлежат объекту клиента (client). Клиент решает, какие команды выполнить и когда. Чтобы выполнить команду, он передает объект команды вызывающему объекту (invoker).</p>

    <p>Использование командных объектов упрощает построение общих компонентов, которые необходимо делегировать или выполнять вызовы методов в любое время без необходимости знать методы класса или параметров метода.</p>

    <p>Использование вызывающего объекта (invoker) позволяет вести учёт выполненных команд без необходимости знать клиенту об этой модели учёта (такой учёт может пригодиться, например, для реализации отмены и повтора команд).</p>

    <p>Например, ты пишишь программу, которая позволяет выполнять различные задания по расписанию. С одной стороны твоя программа ведет учет заданий и управляет их запуском, с другой у нее может быть несколько исполнителей, каждый из которых умеет выполнять команды своего типа. Например, рассылка SMS, рассылка писем, рассылка сообщений в Telegram и т. п.</p>

    <h2>Observer</h2>

    <p><span class="text-bold">Наблюдатель (Observer)</span> — поведенческий шаблон проектирования. Реализует механизм класса, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними.</p>

<img data-max-width="800" data-id="c312130f-fa93-408f-b324-54b2d542d837" src="https://cdn.javarush.com/images/article/c312130f-fa93-408f-b324-54b2d542d837/800.jpeg" alt="Наблюдатель (Observer)">

    <p>Классы, на события которых другие классы подписываются, называются субъектами (<span class="text-bold">Subjects</span>), а подписывающиеся классы называются наблюдателями (<span class="text-bold">Observers</span>).</p>

    <p>При реализации шаблона Наблюдатель обычно используются следующие классы:</p>

    <ul>
        <li><span class="text-neon"><span class="text-bold"><em>Observable</em></span></span> — интерфейс, определяющий методы для добавления, удаления и оповещения наблюдателей;</li>
        <li><span class="text-neon"><span class="text-bold"><em>Observer</em></span></span> — интерфейс, с помощью которого наблюдатель получает оповещение;</li>
        <li><span class="text-neon"><span class="text-bold"><em>ConcreteObservable</em></span></span> — конкретный класс, который реализует интерфейс <span class="text-neon"><span class="text-bold"><em>Observable</em></span></span>;</li>
        <li><span class="text-neon"><span class="text-bold"><em>ConcreteObserver</em></span></span> — конкретный класс, который реализует интерфейс <span class="text-neon"><span class="text-bold"><em>Observer</em></span></span>.</li>
    </ul>

    <p>Шаблон Наблюдатель применяется в тех случаях, когда в системе:</p>

    <ul>
        <li>существует как минимум один объект, рассылающий сообщения;</li>
        <li>имеется не менее одного получателя сообщений, причём их количество и состав могут изменяться во время работы приложения;</li>
        <li>позволяет избежать сильного зацепления взаимодействующих классов.</li>
    </ul>

    <p>Этот шаблон часто применяют в ситуациях, в которых отправителя сообщений не интересует, что делают получатели с предоставленной им информацией.</p>

    <h2>Visitor</h2>

    <p><span class="text-bold">Посетитель (Visitor)</span> — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.</p>

    <p>Шаблон демонстрирует классический приём восстановления информации о потерянных типах, не прибегая к понижающему приведению типов при помощи двойной диспетчеризации.</p>

<img data-max-width="800" data-id="c9ff643d-3d9f-4f65-b257-486723c24078" src="https://cdn.javarush.com/images/article/c9ff643d-3d9f-4f65-b257-486723c24078/800.jpeg" alt="Посетитель (Visitor)">

    <p>Необходимо сделать какие-то несвязные операции над рядом объектов, но нужно избежать загрязнения их кода. И нет возможности или желания запрашивать тип каждого узла и осуществлять приведение указателя к правильному типу, прежде чем выполнить нужную операцию.</p>

    <p>Шаблон следует использовать, если:</p>

    <ul>
        <li>имеются различные объекты разных классов с разными интерфейсами, но над ними нужно совершать операции, зависящие от конкретных классов;</li>
        <li>над структурой необходимо выполнить различные усложняющие структуру операции;</li>
        <li>часто добавляются новые операции над структурой.</li>
    </ul>

    <h2>Mediator</h2>

    <p><span class="text-bold">Посредник (Mediator)</span> — поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабое зацепление и избавляя объекты от необходимости явно ссылаться друг на друга.</p>

<img data-max-width="800" data-id="c0565a96-358c-449c-9cd7-cd15c21e85ce" src="https://cdn.javarush.com/images/article/c0565a96-358c-449c-9cd7-cd15c21e85ce/800.jpeg" alt="Посредник (Mediator)">

    <p>Паттерн Посредник позволяет обеспечить взаимодействие множества объектов, сформировав при этом слабую связанность и избавив объекты от необходимости явно ссылаться друг на друга.</p>

    <p><span class="text-bold">Посредник</span> определяет интерфейс для обмена информацией с объектами <mark class="green">Коллеги</mark>, <span class="text-bold">Конкретный посредник</span> координирует действия объектов <mark class="green">Коллеги</mark>.</p>

    <p>Каждый класс <span class="code"><span class="text-green">Коллеги</span></span> знает о своем объекте <mark class="green">Посредник</mark>, все <span class="code"><span class="text-green">Коллеги</span></span> обмениваются информацией только с посредником, при его отсутствии им пришлось бы обмениваться информацией напрямую.</p>

    <p><mark class="green">Коллеги</mark> посылают запросы <span class="text-bold">Посреднику/span> и получают запросы от него. <span class="text-bold">Посредник</span> реализует кооперативное поведение, пересылая каждый запрос одному или нескольким <mark class="green">Коллегам</mark>.</p>