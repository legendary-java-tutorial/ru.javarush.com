Грокаем алгоритмы или безболезненное введение в алгоритмы
<p>----------------------------------------</p>
Обзор книги "Грокаем алгоритмы". Немного личного мнения, немного примеров. Надеюсь, данный обзор поможет понять, хочется ли вам читать данную книгу или она не займёт своё место на Вашей полке. WARNING ...
<p>----------------------------------------</p>
Обзор книги "Грокаем алгоритмы". Немного личного мнения, немного примеров. Надеюсь, данный обзор поможет понять, хочется ли вам читать данную книгу или она не займёт своё место на вашей полке. WARNING: Очень много текста )

<h2>«Грокаем алгоритмы» или безболезненное введение в алгоритмы</h2><h3>Введение</h3>Практически любая вакансия уровня Junior имеет требования вида «знание структур данных и алгоритмов».  У кого есть профильное образование, то алгоритмы входят в общий курс и проблем быть не должно. Но что если в разработку «занесло» из других степей? Остаётся только учиться самому. На вопрос «кто виноват» ответ есть, а вот на вопрос «что делать» ответ надо искать. Будем искать в книгах. И про одну я хочу рассказать. 
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="f512f420-b699-494f-aff5-682aa78ca4b3" data-max-width="650" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 1" src="https://cdn.javarush.com/images/article/f512f420-b699-494f-aff5-682aa78ca4b3/1024.jpeg"></div></div><h3>Грокаем алгоритмы</h3>Наткнулся среди всех трудов на такую книгу, как «Грокаем алгоритмы». Подробнее можно будет узнать тут: "<a href="https://habr.com/company/piter/blog/323310/" target="_blank" rel="nofollow">Книга «Грокаем алгоритмы. Иллюстрированное пособие для программистов и любопытствующих</a>". Книгу приметил давно, но на озоне она стоила 680 рублей. Дорого или дёшево – каждый решает для себя сам. Я уже вторую книгу на авито беру за пол цены. Так что нашёл её в СПб, купил, и пошёл грокать. О чём и решил поделиться с Вами. Да, в книге нет кода на Java, но есть… другой код, но об этом позже.
<h3>Введение в алгоритмы (Сортировка выбором)</h3>Итак, в лёгкой форме повествования мы доходим до первой в нашем исполнении сортировки. Это сортировка выбором (Selection Sort). Суть её заключается в том, что мы идём по элементам слева направо (от 0 элемента к последнему), и ищем среди оставшихся элементов самый большой. Если находим, то меняем местами элемент, на котором мы сейчас и самый большой элемент. 

Самый простой способ сначала представить себе массив: [5, 3, 6, 2, 10]. Взять листочек, ручку (самый простой и бюджетный способ) и представить, как у нас есть левая граница (left), текущий индекс (или правая граница), есть индекс минимального элемента. И как мы с этим работаем. Например:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="b0a261a2-0510-49c6-b0a8-731d7ace03ec" data-max-width="378" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 2" src="https://cdn.javarush.com/images/article/b0a261a2-0510-49c6-b0a8-731d7ace03ec/1024.jpeg"></div></div>Часто алгоритмы описывают в псевдокоде, например, на википедии. У нас не совсем псевдокод, но об этом несколько позже. А пока посмотрим:

<pre class="line-numbers"><code>
def selectionSort(array):
    for left in range(0, len(array)):
        minIndex = left
        for right in range (left+1, len(array)):
            if array[right] &lt; array[minIndex]:
                minIndex = right
        if minIndex != left:
            temp = array[left]
            array[left] = array[minIndex]
            array[minIndex] = temp
    return array

print(selectionSort([5, 3, 6, 2, 10]))
</code></pre>
А теперь представим его в виде Java кода:

<pre class="lang-java line-numbers"><code>
public static void selectionSort(int[] array) {
        for (int left = 0; left &lt; array.length; left++) {
            int minIndex = left;
            for (int right = left+1; right &lt; array.length; right++) {
                if (array[right] &lt; array[minIndex]) {
                    minIndex = right;
                }
            }
            if (minIndex != left) {
                int temp = array[left];
                array[left] = array[minIndex];
                array[minIndex] = temp;
            }
        }
}
</code></pre>
Как видно, код почти не отличается. Первый код - пример из книги. Второе - моё вольное исполнение в Java коде.
<h3>Рекурсия</h3>Далее нам рассказывают про то, что есть такая штука как рекурсия. Первым делом, приводится задача про фермера, у которого есть поле размера AxB. Необходимо это поле разбить на равные «квадраты». И тут после этого упоминается Алгоритм Эвклида. Что мне не нравится, так это то что не попытались написать его код. А ведь алгоритм Эвклида простой и эффективный:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="8cc1ae3a-3ec5-48b4-8801-f377b569096e" data-max-width="587" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 3" src="https://cdn.javarush.com/images/article/8cc1ae3a-3ec5-48b4-8801-f377b569096e/1024.jpeg"></div></div>Если честно, мне не хватило в книге некоторых подробностей, как в этом видео: «<a href="https://www.youtube.com/watch?time_continue=29&amp;v=n9oXAOvP3Xs" target="_blank" rel="nofollow">Информатика. Теория алгоритмов. Алгоритм Евклида</a>». 

Например про то, что если a будет меньше b, то при первом прогоне b и a поменяются местами и второй раз большее будет делиться на меньшее. Поэтому, порядок аргументов не важен.

Как обычно, сначала мы можем алгоритм «пощупать» на бумажке:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="ea7dff21-1fe9-4fd9-8b9a-c578416f8d44" data-max-width="396" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 4" src="https://cdn.javarush.com/images/article/ea7dff21-1fe9-4fd9-8b9a-c578416f8d44/1024.jpeg"></div></div>А теперь посмотрим на код:

<pre class="line-numbers"><code>
def euclidean(a, b):
    if a == 0 : return b
    if b == 0 : return a
    return euclidean (b, a % b)
</code></pre>
Этот же код напишем на Java. При желании можем воспользоваться <a href="https://www.tutorialspoint.com/compile_java_online.php" target="_blank" rel="nofollow">онлайн-компилятором</a>:

<pre class="lang-java line-numbers"><code>
public static int euclid(int a, int b) {
        if (a == 0) return b;
        if (b == 0) return a;
        return euclid(b, a%b);
}
</code></pre>
В начале книги так же упоминался факториал. Факториал числа n (n!) – это произведение чисел от 1 до n. Зачем заниматься этим? Тут есть одно практическое применение. Если у нас есть n объектов (например, n городов), то мы можем составить из них n! Комбинаций.

Про рекурсию можно подробнее почитать ещё и здесь: "<a href="https://habr.com/post/275813/" target="_blank" rel="nofollow">Рекурсия. Тренировочные задачи</a>".

Сравнение итерационного и рекурсионного подходов: "<a href="https://stepik.org/lesson/30043/step/3" target="_blank" rel="nofollow">РекурсиЯ</a>".
<h3>Быстрая сортировка</h3>Быстрая сортировка – довольно интересный алгоритм. В книге ему не очень много внимания уделено. Более того, код приведён только для самого неудачного случая, когда выбирается первый элемент. Впрочем, возможно, для первого знакомства данный пример запомнится легче. И лучше написать плохую быструю сортировку, чем не написать никакую.

Вот пример из книги:

<pre class="line-numbers"><code>
def quicksort(array):
    if len(array) &lt; 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i &lt;= pivot]
        greater = [i for i in array[1:] if i &gt; pivot]
    return quicksort(less) + [pivot] + quicksort(greater)
</code></pre>
Тут всё сверх просто. Если у нас массив из 0 или 1 элемента – его сортировать не нужно. Если больше – мы берём первый элемент массива и считаем его «опорным элементом». Составляем 2 новых массива – один содержит элементы большие чем pivot, а второй – элементы меньшие. И повторяем рекурсивно. Не лучший вариант, но опять же, запоминается лучше. 

Давайте реализуем на Java этот алгоритм, но более правильно. В этом нам поможет материал из обзора «<a href="https://medium.com/devschacht/nicholas-c-zakas-computer-science-in-javascript-quicksort-afa07c0a47f0" target="_blank" rel="nofollow">Информатика в JavaScript: Быстрая сортировка (Quicksort)</a>».

И прежде чем писать код, снова порисуем, чтобы «ощутить» алгоритм:

Для начала, опять порисуем на бумажке, чтобы осознать алгоритм:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="dec8a5ef-c101-4279-9b5d-4800d5147674" data-max-width="433" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 5" src="https://cdn.javarush.com/images/article/dec8a5ef-c101-4279-9b5d-4800d5147674/1024.jpeg"></div></div>Мне кажется, один из самых опасных моментов – решать задачи целиком. Поэтому, выполним реализацию как несколько маленьких этапов:
<ul>
<li><p>Нам нужно уметь менять местами элементы в массиве:</p>
<pre class="lang-java line-numbers"><code>
private static void swap(int[] array, int firstIndex, int secondIndex) {
        int temp = array[firstIndex];
        array[firstIndex] = array[secondIndex];
        array[secondIndex] = temp;
}
</code></pre></li><br>
<li><p>Нам нужен метод, который делит массив в указанном промежутке на 3 части</p><br>
<pre class="lang-java line-numbers"><code>
private static int partition(int[] array, int left, int right) {
        int pivot = array[(right + left) / 2];
        while (left &lt;= right) {
            while (array[left] &lt; pivot) {
                left++;
            }
            while (array[right] &gt; pivot) {
                right--;
            }
            if (left &lt;= right) {
                swap(array, left, right);
                left++;
                right--;
            }
        }
        return left;
}
</code></pre>
<p>Подробности по ссылке выше. Если кратко, то двигаем левый курсор, пока не элемент меньше чем pivot. Аналогично двигаем с другого конца правый курсор. И делаем свап, если курсоры не сошлись. Продолжаем пока курсоры не сошлись. Возвращаем индекс, который делит дальнейшую обработку на 2 части.</p></li>
<li><p>Разделение есть, нужна сама сортировка:</p>
<pre class="lang-java line-numbers"><code>
public static void quickSort(int[] array, int left, int right) {
        int index = 0;
        if (array.length &gt; 1) {
            index = partition(array, left, right);
            if (left &lt; index - 1) {
                quickSort(array, left, index - 1);
            }
            if (index &lt; right) {
                quickSort(array, index, right);
            }
        }
}
</code></pre>
<p>То есть если массив состоит как минимум из двух элементов, то их уже можно отсортировать. Сначала делим весь массив на две части, меньшие чем pivot элементы и большие. Потом аналогичные действия выполняем и для каждой из полученной частей.</p>
<p>И для теста:</p>
<pre class="lang-java line-numbers"><code>
public static void main(String []args){
        int[] array = {8,9,3,7,6,7,1};
        quickSort(array, 0, array.length-1);
        System.out.println(Arrays.toString(array));
}
</code></pre></li></ul>
В книге указано, что данный алгоритм относится к так называемым алгоритмам «Разделяй и властвуй», когда обрабатываемый набор данных каждый раз делится пополам.  Сложность алгоритма: O(nLogn)
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="ab48afaa-e65a-44c3-a097-7f89b565c172" data-max-width="360" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 6" src="https://cdn.javarush.com/images/article/ab48afaa-e65a-44c3-a097-7f89b565c172/1024.jpeg"></div></div>Что плохо (т.е. что мне не понравилось), что в книге упоминается вскользь сортировка слиянием (merge sort), но не приводится никакого примера или кода.

Подробнее можно посмотреть тут: "<a href="https://www.youtube.com/watch?v=wQMSowIS2FY" target="_blank" rel="nofollow">Информатика. Алгоритмы поиска и сортировки: Сортировка слиянием</a>".

Поэтому, давайте для последовательности сами сделаем.

Сам алгоритм, конечно, по своей сути прост и незамысловат:

<pre class="lang-java line-numbers"><code>
public static void mergeSort(int[] source, int left, int right) {
    if ((right - left) &gt; 1) {
        int middle = (right + left) / 2;
        mergeSort(source, left, middle);
        mergeSort(source, middle + 1, right);
    }
    merge(source, left, right);
}
</code></pre>
Определяем середину и делим массив пополам. Для каждой половины выполняем тоже самое и так дальше. Условие остановки или базовый случай – у нас должно быть больше одного элемента, так как один элемент на два мы не разделим.

Теперь нужно реализовать слияние, то есть merge:

<pre class="lang-java line-numbers"><code>
public static void merge(int[] array, int from, int to) {
    int middle = ((from + to) / 2) + 1;
    int left = from;
    int right = middle;
    int cursor = 0;

    int[] tmp = new int[to - from + 1];
    while (left &lt; middle || right &lt;= to) {
        if (left &gt;= middle) {
            tmp[cursor] = array[right];
            System.out.println("Остаток справа: " + array[right]);
            right++;
        } else if (right &gt; to) {
            tmp[cursor] = array[left];
            System.out.println("Остаток слева: " + array[left]);
            left++;
        } else if (array[left] &lt;= array[right]) {
            tmp[cursor] = array[left];
            System.out.println("Слева меньше: " + array[left]);
            left++;
        } else if (array[right] &lt; array[left]) {
            tmp[cursor] = array[right];
            System.out.println("Справа меньше: " + array[right]);
            right++;
        }
        cursor++;
    }
    System.arraycopy(tmp, 0, array, from, tmp.length);
}
</code></pre>
Тут комментировать особо нечего. Из названий переменных и <code>println</code> всё понятно.

Ну и для проверки:

<pre class="lang-java line-numbers"><code>
int array[] = {1, 7, 3, 6, 7, 9, 8, 4};
mergeSort(array, 0, array.length - 1);
System.out.println(Arrays.toString(array));
</code></pre>
<h3>Хэш-таблицы</h3>В книге также затронуты хэш-таблицы. Реализовывать самим не приходится, да и суть хэш-таблиц довольно проста. Ведь в Java тоже есть реализация хэш-таблиц, java.util.HashTable. Если посмотреть устройство HashTable, то мы увидим, что внутри живёт массив Entry. Entry – это некоторая запись, представляющая собой связку Key – Value. У HashTable есть initialCapacity – то есть изначальный размер. И loadFactor – коэффициент загрузки. По умолчанию равен 0.75. Это число говорит, при какой загрузке массива (кол-во элементов/общее количество) необходимо увеличить размер. В Java он увеличивается в 2 раза.

В книге рассказывается, что Hash-таблицы хэш-таблицами называются потому, что на основе хэш-функции вычисляется ячейка массива (корзина), в которую будут помещены <code>Entry</code>.

Подробнее можно прочитать так же здесь: Структуры данных в картинках. <a href="https://habr.com/post/128017/" target="_blank" rel="nofollow">HashMap</a> и <a href="https://habr.com/post/129037/" target="_blank" rel="nofollow">LinkedHashMap</a>.

А так же можно прочитать в книгах. Например, здесь: "<a href="https://goo.gl/tQtRcA" target="_blank" rel="nofollow">HashTable basics</a>"
<h3>Графы, Поиск в ширину (поиск кратчайшего пути)</h3>Наверно, одна из самых интересных тем – это графы. И тут, надо отдать должно, в книге уделено им много внимания. Возможно, ради этого стоит прочитать эту книгу. Хотя, возможно, можно было бы изложить чуть понятнее )) Но, у нас есть интернет и в добавку к книге можно посмотреть вот этот плэйлист по теории для «<a href="https://www.youtube.com/results?search_query=%D1%84%D0%BE%D0%BA%D1%81%D1%84%D0%BE%D1%80%D0%B4+%D0%B3%D1%80%D0%B0%D1%84%D1%8B" target="_blank" rel="nofollow">впервые слышащих о графах</a>».

Ну, и естественно, в самом начале книги даётся алгоритм поиска в ширину, <code>breadth-first-search</code>, он же BFS. В книге приведён следующий граф:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="95d69bae-1cdf-4be0-a5f5-c5db03b7bd52" data-max-width="331" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 7" src="https://cdn.javarush.com/images/article/95d69bae-1cdf-4be0-a5f5-c5db03b7bd52/1024.jpeg"></div></div>В книге указано, что нам поможет очередь. Причём такая, чтобы мы могли добавлять элементы в конец, а обрабатывать очередь с начала. Такие очереди называются двусторонними или Deque на английском.

В книге предлагают воспользоваться структурой данных – hash-таблица. Чтобы соотносить имя и соседей. При нумерованных вершинах, использовать можно просто массив. Такое хранение вершин называется «Список смежных вершин», о чём в книге не сказано. За этом им минус.

Реализуем это на Java:

<pre class="lang-java line-numbers"><code>
private Map&lt;String, String[]&gt; getGraph() {
    Map&lt;String, String[]&gt; map = new HashMap&lt;&gt;();
    map.put("you", new String[]{"alice", "bob", "claire"});
    map.put("bob", new String[]{"anuj", "peggy"});
    map.put("alice", new String[]{"peggy"});
    map.put("claire", new String[]{"thom", "jonny"});
    map.put("annuj", null);
    map.put("peggy", null);
    map.put("thom", null);
    map.put("johny", null);
    return map;
}
</code></pre>
Теперь и сам поиск, построенный на этих данных:

<pre class="lang-java line-numbers"><code>
private String search() {
    Map&lt;String, String[]&gt; graph = getGraph();
    Set&lt;String&gt; searched = new HashSet&lt;&gt;();
    Deque&lt;String&gt; searchQue = new ArrayDeque&lt;&gt;();
    searchQue.add("you");
    while (!searchQue.isEmpty()) {
        String person = searchQue.pollFirst();
        System.out.println(person);
        if (personIsSeller(person)) {
            return person;
        } else {
            String[] friends = graph.get(person);
            if (friends == null) continue;
            for (String friend : friends) {
                if (friend != null &amp;&amp; !searched.contains(friend)) {
                    searchQue.addLast(friend);
                }
            }
        }
    }
    return null;
}
</code></pre>
Как видно, ничего сложного. Если сравнить с кодом из книги, то почти тоже самое.
<h3>Графы, Алгоритм Дейкстры</h3>Разобравшись более менее с BFS автор книги предлагает нам разобраться с алгоритмом Дейсктры и взвешенными графами. Для решения предлагается следующий граф:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="7f7a2de1-70bb-46b1-b6f5-d27afa92ee25" data-max-width="288" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 8" src="https://cdn.javarush.com/images/article/7f7a2de1-70bb-46b1-b6f5-d27afa92ee25/1024.jpeg"></div></div>Для начала, нужно понять, как представить наши графы. Мы могли бы представить в виде матрицы. Тут нам поможет статья на хабре: <a href="https://habr.com/post/111361/" target="_blank" rel="nofollow">Алгоритм Дейкстры. Поиск оптимальных маршрутов на графе</a>.

Воспользуемся матрицей смежности:

<pre class="lang-java line-numbers"><code>
public Integer[][] getGraphMatrix(int size) {
    Integer[][] matrix = new Integer[size][size];
    matrix[0][1] = 6;
    matrix[0][2] = 2;
    matrix[2][1] = 3;
    matrix[1][3] = 1;
    matrix[2][3] = 5;
    return matrix;
}
</code></pre>
А теперь сама логика:

<pre class="lang-java line-numbers"><code>
@Test
public void dijkstra() {
    Integer[][] graph = getGraphMatrix();           // Данные графа
    Integer[] costs = new Integer[graph.length];    // Стоимость перехода
    Integer[] parents = new Integer[graph.length];  // Родительский узел
    BitSet visited = new BitSet(graph.length);      // "Ферма" маркеров посещённости

    Integer w = 0;
    do {
        System.out.println("-&gt; Рассматриваем вершину: " + w);
        Integer min = null;
        for (int i = 0; i &lt; graph.length; i++) {    // Обрабатываем каждую дугу
            if (graph[w][i] == null) continue;      // Дуги нет - идём дальше
            if (min == null || (!visited.get(i) &amp;&amp; graph[w][min] &gt; graph[w][i])) {
                min = i;
            }
            if (costs[i] == null || costs[i] &gt; costs[w] + graph[w][i]) {
                System.out.print("Меням вес с " + costs[i]);
                costs[i] = (costs[w] != null ? costs[w] : 0) + graph[w][i];
                System.out.println(" на " + costs[i] + " для вершины " + i);
                parents[i] = w;
            }
        }
        System.out.println("Вершина с минимальным весом: " + min);
        visited.set(w);
        w = min;
    } while (w != null);

    System.out.println(Arrays.toString(costs));
    printPath(parents, 3);
}

public void printPath(Integer[] parents, int target) {
    Integer parent = target;
    do {
        System.out.print(parent + " &lt;- ");
        parent = parents[parent];
    } while (parent != null);
}
</code></pre>
В книге довольно пошагово разбирается. Если в интернете добавить статью на хабре + посмотреть на код – можно запомнить. Мне пошаговый разбор показался несколько загромождённым. Но за саму пошаговость плюс. В целом, нормально, хотя могло быть и лучше )
<h3>Жадные алгоритмы </h3>Следующий раздел посвящается «жадным алгоритмам». Этот раздел интересен тем, что он использует множества (java.util.Set). Наконец-то видно, зачем оно может понадобится.

Как входные данные используем список штатов:

<pre class="lang-java line-numbers"><code>
Set&lt;String&gt; statesNeeded = new HashSet();
statesNeeded.addAll(Arrays.asList("mt", "wa", "or", "id", "nv", "ut", "ca", "az" ));
</code></pre>
А также список радиостанций, покрывающих некоторые из этих штатов:

<pre class="lang-java line-numbers"><code>
Map&lt;String, Set&lt;String&gt;&gt; stations = new HashMap&lt;&gt;();
stations.put("kone", new HashSet(Arrays.asList("id", "nv", "ut")));
stations.put("ktwo", new HashSet(Arrays.asList("wa", "id", "mt")));
stations.put("kthree", new HashSet(Arrays.asList("or", "nv", "ca")));
stations.put("kfour", new HashSet(Arrays.asList("nv", "ut")));
stations.put("kfive", new HashSet(Arrays.asList("ca", "az")));
</code></pre>
Далее в книге указывается и объясняется сам алгоритм:

<pre class="lang-java line-numbers"><code>
Set&lt;String&gt; finalStations = new HashSet();
while (!statesNeeded.isEmpty()) {
    String bestStation = null;
    Set&lt;String&gt; statesCovered = new HashSet();
    for (String station: stations.keySet()) {
        Set covered = new HashSet(statesNeeded);
        covered.retainAll(stations.get(station));
        if (covered.size() &gt; statesCovered.size()) {
           bestStation = station;
           statesCovered = covered;
        }
    }
    statesNeeded.removeAll(statesCovered);
    finalStations.add(bestStation);
}
System.out.println(finalStations);
</code></pre>
<h3>Динамическое программирование</h3> В книге так же описывается такие задачи, к которым применяется подход, называемый «динамическим программированием». Даётся задача:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="2f762eed-1991-4716-924d-0a788c79367c" data-max-width="399" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 9" src="https://cdn.javarush.com/images/article/2f762eed-1991-4716-924d-0a788c79367c/1024.jpeg"></div></div>У нас есть мешок вместимостью 4 фунта. Нужно найти максимально выгодные предметы для данного веса. Для начала, составим список предметов:

<pre class="lang-java line-numbers"><code>
List&lt;Thing&gt; things = new ArrayList&lt;&gt;();
things.add(new Thing("guitar", 1, 1500));
things.add(new Thing("tape recorder", 4, 3000));
things.add(new Thing("notebook", 3, 2000));
</code></pre>
Теперь сам алгоритм:

<pre class="lang-java line-numbers"><code>
int bagSize = 4;
int cell[][] = new int[things.size()][bagSize];
// Заполняем первую строку без условий
for (int i = 0; i &lt; bagSize; i++) {
    cell[0][i] = things.get(0).cost;
}
// Заполняем оставшиеся
for (int i = 1; i &lt; cell.length; i++) {
    for (int j = 0; j &lt; cell[i].length; j++) {
        // Если вещь не влезает - берём прошлый максимум
        if (things.get(i).weight &gt; j+1) {
            cell[i][j] = cell[i - 1][j];
        } else {
            // Иначе текущая стоимость + предыдущий максимум оставшегося размера
            cell[i][j] = things.get(i).cost;
            if (j + 1 - things.get(i).weight &gt; 0) {
                cell[i][j] += cell[i-1][j + 1 - things.get(i).weight];
            }
        }
    }
}
System.out.println(Arrays.deepToString(cell));
</code></pre>
Так же приведена интересная задача на поиск наиболее похожих слов. Интересно, не правда ли? Подробнее тут: <a href="https://github.com/egonSchiele/grokking_algorithms/blob/master/09_dynamic_programming/java/01_longest_common_subsequence/src/LongestCommonSubsequence.java" target="_blank" rel="nofollow">LongestCommonSubsequence.java</a>
<h3>Поиск к ближайших соседей</h3>Так же в книге очень наглядно рассказывает про алгоритм k ближайших соседей:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="57ab1573-f0bd-428b-ab9f-bf7ee4322e55" data-max-width="416" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 10" src="https://cdn.javarush.com/images/article/57ab1573-f0bd-428b-ab9f-bf7ee4322e55/1024.jpeg"></div></div>И приводится формула для расчёта:

<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="ff66eeb3-ea21-4394-8016-49af9081d2ec" data-max-width="373" alt="«Грокаем алгоритмы» или безболезненное введение в алгоритмы - 11" src="https://cdn.javarush.com/images/article/ff66eeb3-ea21-4394-8016-49af9081d2ec/1024.jpeg"></div></div>
<h3>Итог</h3>Книга заканчивается интересным разделом "Что дальше?", в котором представлен беглый обзор интересных алгоритмов. Тут кратко описано, в чём заключается смысл деревьев и других алгоритмов. В целом - книга мне понравилась. Её не стоит серьёзно воспринимать, как какую-то исчерпывающую информацию. Вам придётся самим искать и допонимать. Но как вводная информация, чтобы заинтересовать и дать начальное представление - вполне неплохо. Да, код в книге написан на питоне. Так что все указанные примеры компилируемы)

Надеюсь, данный обзор поможет составить представление о наполнении книги и о том, стоит ли её покупать.
<h3>Дополнительно</h3>В тему можно так же ознакомиться со следующими ресурсами:
<ol>
<li><a href="https://courses.edx.org/courses/course-v1:UC3Mx+IT.1.3x+3T2017/course/" target="_blank" rel="nofollow">EdX - Introduction to Java Programming: Fundamental Data Structures and Algorithms</a></li>
<li><a href="https://www.linkedin.com/learning/introduction-to-data-structures-algorithms-in-java" target="_blank" rel="nofollow">LinkedIn - Introduction to Data Structures &amp; Algorithms in Java</a> (платно)</li>
<li><a href="https://proglib.io/p/27-puzzle-websites-to-sharpen-your-skills/" target="_blank" rel="nofollow">27 сайтов с задачками для оттачивания навыков программирования</a></li>
<li><a href="http://codingbat.com/java" target="_blank" rel="nofollow">Java CodingBat</a></li>
<li><a href="https://tproger.ru/category/problems/" target="_blank" rel="nofollow">Задачи для программистов, ответы на задания различной сложности</a></li>
</ol>
#Viacheslav