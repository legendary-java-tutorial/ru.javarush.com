Безопасность в Java: best practices
<p>----------------------------------------</p>
В серверных приложениях один из самых важных показателей — это безопасность. Это один из видов Non-Functional Requirements (нефункциональных требований). Безопасность включает в себя множество компонентов. Разумеется, чтобы охватить в полной мере и объеме все те...
<p>----------------------------------------</p>
В серверных приложениях один из самых важных показателей — это безопасность. Это один из видов <a href="https://en.wikipedia.org/wiki/Non-functional_requirement" rel="nofollow" target="_blank">Non-Functional Requirements</a> (нефункциональных требований).
<img data-max-width="800" data-id="0b2f7b30-4236-4863-82b4-b34826db5fd6" src="/images/article/0b2f7b30-4236-4863-82b4-b34826db5fd6/800.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 1">Безопасность включает в себя множество компонентов. Разумеется, чтобы охватить в полной мере и объеме все те защитные принципы и действия, которые известны, нужно написать не одну статью, так что остановимся на самом важном.

Человек, который хорошо разбирается в этой теме, сможет настроить все процессы и проследить, чтобы они не создавали новых дыр в безопасности, будет нужен в любой команде. 

Конечно, не стоит думать, что если следовать этим практикам, то приложение будет однозначно безопасно. Нет! Но оно точно будет более безопасным с ними. Поехали.
<h2>1. Обеспечить безопасность на уровне языка Java</h2>Прежде всего, безопасность в Java начинается прямо на уровне возможностей языка. Вот что бы мы делали, если бы не было модификаторов доступа?... Анархия, не иначе.

Язык программирования помогает нам писать безопасный код, а также пользоваться многими неявными функциями безопасности:
<ol>
<li><span class="text-bold">Строгая типизация. Java</span> — это язык со статической типизацией, который дает возможность обнаружения ошибок, связанных с типами, во время выполнения.</li>
<li><span class="text-bold">Модификаторы доступа.</span> Благодаря им мы можем настраивать доступ к классам, методам и полям классов так, как нам нужно.</li>
<li><span class="text-bold">Автоматическое управление памятью.</span> Для этого дела у нас (у джавистов ;)) есть Garbage Collector, который освобождает от настройки вручную. Да, иногда возникают проблемы.</li>
<li><span class="text-bold">Проверка байткода:</span> Java компилируется в байткод, который проверяет <span class="text-bold">runtime</span>, прежде чем запустить его.</li>
</ol>Помимо всего прочего, есть <a href="https://www.oracle.com/java/technologies/security.html" rel="nofollow" target="_blank">рекомендации от Оракла</a> по безопасности. Конечно написано не “высоким слогом” и можно уснуть несколько раз при прочтении, но оно стоит того. 

В особенности важен документ <a href="https://www.oracle.com/technetwork/java/seccodeguide-139067.html" rel="nofollow" target="_blank">Secure Coding Guidelines for Java SE</a>, в котором есть советы, как писать безопасный код. Этот документ несет много полезного. Если есть возможность — обязательно стоит прочесть. 

Для разогрева интереса к этому материалу, приведу несколько интересных советов:
<ol>
<li>Избегайте сериализации чувствительных к безопасности (secure-sensitive) классов. В этом случае можно получить по сериализованному файлу интерфейс класса, не говоря уже о данных, которые сериализуются.</li>
<li>Старайтесь избегать mutable классов для данных. Это дает все преимущества неизменяемых классов (например, потокобезопасность). Если будет изменяемый объект, то это может привести к неожиданному поведению.</li>
<li>Создавайте копии возвращаемых изменяемых объектов. Если метод возвращает ссылку на внутренний изменяемый объект, тогда клиентский код может изменить внутреннее состояние объекта.</li>
<li>И так далее…</li>
</ol>В общем, в Secure Coding Guidelines for Java SE собран набор советов и рекомендаций по тому, как правильно и безопасно писать код на Java.
<h2>2. Устранить SQL injection уязвимость</h2>Уникальная уязвимость. Уникальность ее состоит в том, что она одновременно и одна из самых известных, и одна из самых частых уязвимостей. Если не интересоваться вопросом безопасности, то об этом и не узнаешь. 

Что такое SQL injection? Это атака базы данных посредством внедрения дополнительного SQL-кода там, где это не ожидается.

Допустим, у нас есть метод, который принимает какой-то параметр для запроса в базу данных. Например, имя пользователя. Код с уязвимостью будет выглядеть примерно так:

<pre class="lang-java line-numbers"><code>
// Метод достает из базы данных всех пользователей с определенным именем
public List&lt;User&gt; findByFirstName(String firstName) throws SQLException {
   // Создается связь с базой данных
   Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);
  
   // Пишем sql запрос в базу данных с нашим firstName
   String query = "SELECT * FROM USERS WHERE firstName = " + firstName;
  
   // выполняем запрос
   Statement statement = connection.createStatement();
   ResultSet result = statement.executeQuery(query);

   // при помощи mapToUsers переводит ResultSet в коллекцию юзеров.
   return mapToUsers(result);
}

private List&lt;User&gt; mapToUsers(ResultSet resultSet) {
   //переводит в коллекцию юзеров
}
</code></pre>
В этом примере sql запрос готовится заранее в отдельной строке. Казалось бы, в чем проблема, да? Может, проблема в том, что лучше бы использовать <code>String.format</code>? Нет? А в чем тогда? 

Поставим себя на место тестировщика и подумаем, что можно передать в значении <code>firstName</code>. Например:
<ol>
<li>Можно передать то, что ожидается — имя пользователя. Тогда база данных вернет всех пользователей с таким именем.</li>
<li>Можно передать пустую строку: тогда вернутся все пользователи.</li>
<li>А можно передать следующее: “‘’; DROP TABLE USERS;”. И здесь уже будут бооольшие проблемы. Этим запросом удалится таблица из базы данных. Со всеми данными. ВСЕМИ.</li></ol>Представляете, какие проблемы могут быть из-за этого? Далее можно писать что угодно. Можно поменять имя у всех пользователей, можно удалить их адреса. Простор для вредительства обширен.

Чтобы избежать этого, нужно прекратить внедрение уже готового запроса и вместо этого — формировать его при помощи параметров. Это должен быть единственный способ создания запросов к базе данных. Таким образом можно устранить эту уязвимость. 

Пример:

<pre class="lang-java line-numbers"><code>
// Метод достает из базы данных всех пользователей с определенным именем
public List&lt;User&gt; findByFirstName(String firstName) throws SQLException {
   // Создается связь с базой данных
   Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

   // Создаем параметризированный запрос.
   String query = "SELECT * FROM USERS WHERE firstName = ?";

   // Создаем подготовленный стейтмент с параметризованным запросом
   PreparedStatement statement = connection.prepareStatement(query);
  
   // Передаем значение параметра
   statement.setString(1, firstName);

   // выполняем запрос
   ResultSet result = statement.executeQuery(query);

   // при помощи mapToUsers переводим ResultSet в коллекцию юзеров.
   return mapToUsers(result);
}

private List&lt;User&gt; mapToUsers(ResultSet resultSet) {
   //переводим в коллекцию юзеров
}
</code></pre>
Таким образом избегают данной уязвимости.
 
Для тех, кому хочется погрузиться в вопрос глубже этой статьи — <a href="https://habr.com/ru/post/148151/" rel="nofollow" target="_blank">вот отличный пример</a>.

Как понять, что вы поняли эту часть? Если шутейка ниже стала понятной, то это верный признак, что суть уязвимости ясна :D
<img data-max-width="800" data-id="dc9fc7cc-6c42-4199-812f-8d754da2dcb9" src="/images/article/dc9fc7cc-6c42-4199-812f-8d754da2dcb9/800.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 2"><h2>3. Сканировать и держать обновленными зависимости</h2>Что это значит? Для тех, кто не знает, что такое зависимость (dependency) поясню: это jar архив с кодом, который подключают к проекту при помощи систем автоматической сборки (Maven, Gradle, Ant) для того, чтобы переиспользовать чье-то решение. Например, <a href="https://projectlombok.org/" rel="nofollow" target="_blank">Project Lombok</a>, который за нас генерирует в рантайме геттеры, сеттеры и т.д.

А если говорить о больших приложениях, так они используют множество различных зависимостей. Некоторые — транзитивно (то есть, у каждой зависимости могут быть свои зависимости, и так далее). 

Поэтому злоумышленники все чаще обращают внимание на open-source зависимости, так как их регулярно используют, и из-за них у множества клиентов могут быть проблемы. Важно убедиться, что во всем дереве зависимостей (а именно так это и выглядит) нет известных уязвимостей. А для этого есть несколько путей.
<h3>Использовать Snyk для мониторинга</h3>Инструмент <a href="https://snyk.io/" rel="nofollow" target="_blank">Snyk</a> проверяет все зависимости проекта и отмечает известные уязвимости. Там можно зарегистрироваться и импортировать свои проекты через GitHub, например.
<img data-max-width="800" data-id="9e0e99e0-ac2b-4459-8775-19f76df22b65" src="/images/article/9e0e99e0-ac2b-4459-8775-19f76df22b65/800.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 3">Также, как видно из картинки выше, если в более новой версии есть решение этой уязвимости, Snyk предложит сделать это и создать Pull-Request. Использовать его можно бесплатно для open-source проектов. 

Проекты будут сканироваться с какой-то периодичностью: раз в неделю, раз в месяц.

Я зарегистрировался и добавил все свои публичные репозитории в сканирование Snyk (в этом нет ничего опасного: они и так в открытом доступе для всех). 

Далее Snyk показал результат сканирования:
<img data-max-width="1024" data-id="2ea60bb0-6e43-4853-aaf3-b02c3d264f4b" src="/images/article/2ea60bb0-6e43-4853-aaf3-b02c3d264f4b/1024.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 4">А через некоторое время, Snyk-bot подготовил несколько Pull-Request’ов в проектах, где нужно обновить зависимости:
<img data-max-width="800" data-id="f9456b32-95db-4ee1-b9f2-560a7dde4712" src="/images/article/f9456b32-95db-4ee1-b9f2-560a7dde4712/800.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 5">И вот еще:
<img data-max-width="800" data-id="01c21b1f-6a24-4eae-9eee-018b6bfd5923" src="/images/article/01c21b1f-6a24-4eae-9eee-018b6bfd5923/800.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 6">Так что это отличный инструмент для поиска уязвимостей и мониторинга по обновлению новых версий.
<h3>Использовать GitHub Security Lab</h3>Те, кто работает GitHub, могут воспользоваться и их встроенными инструментами. Более детально про этот подход можно почитать в моем переводе из их блога <a href="https://javarush.com/groups/posts/2376-anons-github-security-lab-zajshita-vsego-koda-vmeste" target="_blank">Анонс GitHub Security Lab</a>. 

Этот инструмент, конечно, попроще, чем Snyk, но пренебрегать им точно не стоит. 

Плюс ко всему количество известных уязвимостей будет только расти, поэтому и Snyk, и GitHub Security Lab будут расширяться и улучшаться.
<h3>Активировать Sonatype DepShield</h3>Если пользоваться GitHub’ом для хранения своих репозиториев, можно добавить к себе на проекты из MarketPlace одно из приложений — Sonatype DepShield. При его помощи можно также сканировать проекты на зависимости. 

Более того, если он найдет что-то, будет создано GitHub Issue с соответствующим описанием, как показано ниже:
<img data-max-width="800" data-id="28344ac3-3581-4fb0-964b-d8f6cb2393ab" src="/images/article/28344ac3-3581-4fb0-964b-d8f6cb2393ab/800.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 7"><h2>4. Осторожно обращаться с конфиденциальными данными</h2><img data-max-width="800" data-id="bf38ad94-faf3-4a51-8035-73cf7fefd71c" src="/images/article/bf38ad94-faf3-4a51-8035-73cf7fefd71c/800.jpeg" class="img-fluid" alt="Безопасность в Java: best practices - 8">В английской речи чаще встречается словосочетание “sensitive data”. Раскрытие персональных данных, номеров кредитных карт и прочей личной информации клиента может нанести непоправимый вред.

Прежде всего, нужно внимательно посмотреть на дизайн приложения и определить, действительно ли нужны какие-то данные. Возможно, в части из них никакой потребности нет, а добавили их для будущего, которое не наступило и вряд ли наступит. К тому же, во время логирования проекта может произойти утечка таких данных.

Простой способ предотвратить попадание конфиденциальных данных в ваши логи  — очистить методы <code>toString()</code> доменных сущностей (таких как User, Student, Teacher и так далее). Таким образом нельзя будет распечатать конфиденциальные поля случайно. Если использовать Lombok для генерации метода <code>toString()</code>, то можно использовать аннотацию <code>@ToString.Exclude</code>, чтобы поле не использовалось в выводе через метод <code>toString()</code>.

Кроме того, будьте очень осторожны, передавая данные внешнему миру. Например, есть http endpoint, который показывает имена всех пользователей. Нет необходимости показывать внутренний уникальный идентификатор пользователя. 

Почему? Потому что по нему злоумышленник может получить другую, более конфиденциальную информацию о каждом из пользователей. 

Например, если задействовать Jackson для сериализации и десериализации <a href="https://ru.wikipedia.org/wiki/POJO" rel="nofollow" target="_blank">POJO</a> в <a href="https://ru.wikipedia.org/wiki/JSON" rel="nofollow" target="_blank">JSON</a>, то можно использовать аннотации <code>@JsonIgnore</code> и <code>@JsonIgnoreProperties</code>, чтобы исключить сериализацию и десериализацию конкретных полей. 

А вообще нужно использовать различные POJO классы для различных мест. Что это значит?
<ol>
<li>Для работы с базой данных использовать одни POJO — Entity.</li>
<li>Для работы с бизнес логикой — переводить Entity в Model.</li>
<li>Для работы с внешним миром и с отправкой на http запросы — использовать третьи     сущности — DTO.</li>
</ol>Таким образом можно четко определить, какие именно поля будут видны снаружи, а какие — нет.
<h2>Использовать надежные алгоритмы шифрования и хеширования</h2>Конфиденциальные данные клиентов нужно хранить надежно. Для этого нужно использовать шифрование. 

В зависимости от задачи, нужно решить, какой тип шифрования использовать. 

Далее, более сильное шифрование требует больше времени, поэтому опять же нужно учитывать, насколько его необходимость оправдывает затраченное на это время. 

Разумеется, можно написать алгоритм самому. Но это излишне. Можно воспользоваться уже существующими решениями в этой области. 

Например, <a href="https://github.com/google/tink" rel="nofollow" target="_blank">Google Tink</a>:

<pre class="lang-java line-numbers"><code>
&lt;!-- https://mvnrepository.com/artifact/com.google.crypto.tink/tink --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.google.crypto.tink&lt;/groupId&gt;
   &lt;artifactId&gt;tink&lt;/artifactId&gt;
   &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
Посмотрим, как им пользоваться, на примере того, как провести шифровку в одну и другую сторону:

<pre class="lang-java line-numbers"><code>
private static void encryptDecryptExample() {
   AeadConfig.register();
   KeysetHandle handle = KeysetHandle.generateNew(AeadKeyTemplates.AES128_CTR_HMAC_SHA256);

   String plaintext = "Цой жив!";
   String aad = "Юрий Клинских";

   Aead aead = handle.getPrimitive(Aead.class);
   byte[] encrypted = aead.encrypt(plaintext.getBytes(), aad.getBytes());
   String encryptedString = Base64.getEncoder().encodeToString(encrypted);
   System.out.println(encryptedString);

   byte[] decrypted = aead.decrypt(Base64.getDecoder().decode(encrypted), aad.getBytes());
   System.out.println(new String(decrypted));
}
</code></pre><h3>Шифрование паролей</h3>Для этой задачи безопаснее всего использовать асимметричное шифрование. Почему? Потому что в приложении реально не нужно расшифровывать пароли обратно. 

Таков общий подход. В реальности, когда пользователь вводит пароль, система шифрует его и сравнивает с тем, что лежит в хранилище паролей. Шифрование проходит одним и тем же средством, поэтому можно ожидать, что они совпадут (при вводе правильного пароля ;), разумеется).

Для этого дела подходят BCrypt и SCrypt. Оба являются односторонними функциями (криптографическими хешами) с вычислительно сложными алгоритмами, которые занимают много времени. Это как раз то, что нужно, так как расшифровка в лоб займет целую вечность.

Например, Spring Security поддерживает целый спектр алгоритмов. Можно воспользоваться <code>SCryptPasswordEncoder</code> и <code>BCryptPasswordEncoder</code>.

То, что сейчас является сильным алгоритмом шифрования, в следующем году может быть уже слабым. Вследствие этого делаем вывод, что нужно проверять используемые алгоритмы и обновлять библиотеки с алгоритмами. 
<h2>Вместо вывода</h2>Сегодня мы поговорили о безопасности и, разумеется, множество вещей осталось за кадром. Я лишь приоткрыл вам дверь в новый мир: мир, который живет своей жизнью. 

С безопасностью все так же, как с политикой: если вы не будете заниматься политикой, политика займется вами. 

Традиционно предлагаю подписаться на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мой гитхаб аккаунт</a>. Я там выкладываю свои наработки по разным технологиям, которые изучаю и применяю на работе.
<h2>Полезные ссылки</h2>Да, почти все статьи на почитать написаны на английском. Хотим мы этого или нет, но английский — это язык для коммуникации программистов. Все самые новые статьи, книги, журналы по программированию пишут на английском. 

Поэтому и ссылки мои на рекомендации в основном на английском:
<ol>
<li>Хабр: <a href="https://habr.com/ru/post/148151/" rel="nofollow" target="_blank">SQL Injection для начинающих</a></li>
<li>Oracle: <a href="https://www.oracle.com/java/technologies/security.html" rel="nofollow" target="_blank">Java Security Resource Center</a></li>
<li>Oracle: <a href="https://www.oracle.com/technetwork/java/seccodeguide-139067.html" rel="nofollow" target="_blank">Secure Coding Guidelines for Java SE</a></li>
<li>Baeldung: <a href="https://www.baeldung.com/java-security-overview" rel="nofollow" target="_blank">The Basics of Java Security</a></li>
<li>Medium: <a href="https://medium.com/myheritage-engineering/10-tips-to-power-up-your-java-security-f3daa4522530" rel="nofollow" target="_blank">10 tips to power-up your Java security</a></li>
<li>Snyk: <a href="https://snyk.io/blog/10-java-security-best-practices/" rel="nofollow" target="_blank">10 java security best practices</a></li>
<li>JR: <a href="https://javarush.com/groups/posts/2376-anons-github-security-lab-zajshita-vsego-koda-vmeste" target="_blank">Анонс GitHub Security Lab: защита всего кода вместе</a></li></ol>