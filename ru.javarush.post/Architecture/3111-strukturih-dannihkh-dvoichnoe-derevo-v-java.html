Структуры данных: двоичное дерево в Java
<p>----------------------------------------</p>
Привет-привет! Сложно быть сильным программистом без базовых знаний. И здесь имеется в виду не только знание синтаксиса родного языка программирования, но и основ и концепций программирования в целом. Одними из таких основ...
<p>----------------------------------------</p>
Привет-привет!

Сложно быть сильным программистом без базовых знаний. И здесь имеется в виду не только знание синтаксиса родного языка программирования, но и основ и концепций программирования в целом. Одними из таких основ являются алгоритмы и структуры данных. 

Как правило в данном вопросе кто-то осведомлен больше, кто-то меньше, но есть некоторая база, которую должны знать все.

Среди баз для структур данных обязательно стоит разобраться с деревьями двоичного поиска.

<img data-max-width="800" data-id="fab7b7d7-155b-4199-927d-62c1116ce8a9" src="/images/article/fab7b7d7-155b-4199-927d-62c1116ce8a9/800.jpeg" alt="Структуры данных: двоичное дерево в Java - 1">Собственно, сегодня мы рассмотрим саму структуру с её особенностями и узнаем, как можно реализовать <span class="text-bold">двоичное дерево в Java</span>. 

Для начала давайте же разберемся, что такое двоичное дерево.

<span class="text-bold">Двоичное де́рево</span> — структура данных, в которой <span class="text-bold">каждый</span> узел (родительский) имеет не более двух потомков (правый и левый наследник).<img data-max-width="512" data-id="8030ee86-0c5a-4df7-826c-29d28520d806" src="/images/article/8030ee86-0c5a-4df7-826c-29d28520d806/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 2">На практике обычно используются два вида двоичных деревьев — <span class="text-bold">двоичное дерево поиска</span> и <span class="text-bold"><a href="https://javarush.com/groups/posts/3083-strukturih-dannihkh-piramida-dvoichnaja-kucha-v-java" target="_blank" rel="nofollow">пирамида</a></span> (куча). Сегодня мы рассмотрим двоичное дерево поиска.<h2>Преимущества двоичного дерева</h2>В чем состоит преимущество хранения данных в виде двоичного дерева поиска? Представьте,  что у нас есть справочник на 100 страниц, и нам нужно найти определенную страницу, на которой будет записаны необходимые нам данные. Также мы знаем по содержанию, какая конкретно страница нам нужна. 
 
Если мы будет идти обычным путем, придется перелистывать подряд по одной странице, пока не доберемся до необходимой нам. То есть, мы переберем от 1 до 100 страниц, покуда не окажемся на нужном месте. 
 
К примеру, если нам нужна 77 страница, то у нас будет 77 переборов. Если говорить о временной сложности, то это будет <span class="text-bold">О(N)</span>. Но ведь это же можно сделать более эффективно? 
 
Давайте попробуем сделать то же самое, но уже с помощью <span class="text-bold">двоичного поиска</span>:<ol>
<li>Делим справочник на две части, первая — от 1 до 50, вторая 51-100. Мы точно знаем, в которой из этих частей наша страница: если опять же брать 77 страницу — во второй части книги.</li>

<li>Далее рассматриваем вторую часть и делим её на две — от 51 до 75, от 76 до 100. В этом случае наша страница будет опять во второй половине, в промежутке 76-100.</li>

<li>Далее делим и этот промежуток на 2 и получаем 76-88 и 89-100. Страница входит в первый промежуток, поэтому второй отметаем.</li>

<li>Далее промежутки: 76-81 и 82-88, берем первый.</li>

<li>76-78 и 79-81, берем первый.</li>

<li>76 и 77-78, берем второй.</li>
 
<li>77 и 78, берем первый и получаем нашу страницу — 77.</li>

</ol>Вместо 77 шагов нам понадобилось всего 7!

Временная сложность данного поиска будет <span class="text-bold">O(log(N))</span>.<h2>Правила построения дерева двоичного поиска</h2>Двоичное дерево поиска строится по определенным правилам:<ul>
<li>каждый узел имеет не более двух детей;</li>
<li>каждое значение, меньшее, чем значение узла, становится левым ребенком или ребенком левого ребенка;</li>
<li>каждое значение, большее или равное значению узла, становится правым ребенком или ребенком правого ребенка.</li>
</ul>К примеру, у нас есть ряд из чисел от 1 до 10. Давайте посмотрим, как будет выглядеть дерево двоичного поиска для этого ряда:<img data-max-width="512" data-id="ce643ead-8387-4c2a-bfa2-f14089ad98c3" src="/images/article/ce643ead-8387-4c2a-bfa2-f14089ad98c3/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 3">Давайте подумаем, соблюдаются ли тут все условия бинарного дерева:<ul>
<li>все узлы имеют не более двух наследников, первое условие соблюдается;</li>
<li>если мы рассмотрим к примеру узел со значением 7(или любой другой), то увидим что все значения элементов в левом поддереве будут меньше, в правом — больше. А это значит, что условия 2 и 3 соблюдены.</li>
 
</ul>Разберем, каким образом происходят основные операции — вставка, удаление, поиск.<h2>Поиск элемента</h2>При поиске элемента с заданным значением мы начинаем с корневого элемента:<ol>

<li>Если он равен искомому значению, корневой элемент и есть искомый, если нет — сравниваем значения корневого и искомого.</li>

<li>Если искомый элемент больше, мы переходим к правому потомку, если нет — к левому.</li>

<li>Если элемент не найден, применяем шаги 1 и 2, но уже к потомку (правому или левому) до тех пор, пока элемент не будет найден.</li>

</ol>К примеру, в продемонстрированном выше дереве двоичного поиска мы хотим найти элемент со значением 5:<ul>
<li>сравниваем его с корневым элементом, видим, что корневой больше, поэтому мы переходим к левому потомку, который имеет значение 3;</li>
<li>сравниваем искомый и элемент со значением 3, видим, что искомый больше, поэтому нам нужен правый потомок рассматриваемого элемента, а именно — элемент со значением 5;</li>
<li>сравниваем этого потомка с искомым и видим, что значения равны — элемент найден.</li><img data-max-width="512" data-id="6ff96893-86bd-407c-9ccd-469d4b912ab8" src="/images/article/6ff96893-86bd-407c-9ccd-469d4b912ab8/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 4"></ul><h2>Вставка элемента</h2>Алгоритм вставки тоже весьма и весьма прост:<ol>

<li><p>Сравниваем новый с корневым (если его нет — новый элемент и есть корневой).</p></li>

<li><p>Если новый элемент:</p><ul>
<li>меньше, то переходим к левому наследнику, если его нет, новый элемент и занимает место левого наследника, и алгоритм закончен;</li>
<li>больше или равен корневому, то мы переходим к правому наследнику. И аналогично, если данного элемента нет, то новый элемент займет место правого элемента и алгоритм закончен.</li></ul><p></p></li>

<li><p>Для нового рассматриваемого элемента, который был правым или левым из предыдущего шага, повторяем шаги 1 и 2 до тех пор, пока вставляемый элемент не станет на свое место. </p>

<p>В качестве примера мы захотим вставить в рассматриваемое выше дерево, элемент со значением 11:</p><ul>
<li>сравниваем с корневым элементом 7 и видим, что корневой меньше, поэтому переходим к правому наследнику;</li>
<li>следующий рассматриваемый элемент имеет значение 9, что меньше чем новый 11, поэтому переходим к правому наследнику;</li>
<li>правый наследник имеет значение 10, что опять же меньше, поэтому мы переходим к первому элементу, а так как его нет, то новый элемент со значением 11 и становится на это место.</li></ul><p></p><img data-max-width="512" data-id="ca7f4622-93b9-4522-aa48-3d172a5b9e8e" src="/images/article/ca7f4622-93b9-4522-aa48-3d172a5b9e8e/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 5"><center>↓</center><img data-max-width="512" data-id="0d23a8f1-b8a1-49b2-86b7-7c1f8e2b6421" src="/images/article/0d23a8f1-b8a1-49b2-86b7-7c1f8e2b6421/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 6"></li></ol><h2>Удаление элемента</h2>Пожалуй, из всех операций с деревьями двоичного поиска, удаление — наиболее сложная. 

В первую очередь происходит поиск удаляемого элемента, после нахождения которого следует этап, у которого могут быть три вариации:<ol>

<li><p><span class="text-bold">Удаляемый узел является листовым (не имеет потомков).</span></p>
<p>Пожалуй, самый простой. Всё сводится к тому, что мы его просто отсекаем от дерева, без лишних манипуляций. К примеру, из нашего дерева мы удаляем узел со значением 8:</p><img data-max-width="512" data-id="bdf36e4e-02d7-4390-a98b-966ae76ef7c7" src="/images/article/bdf36e4e-02d7-4390-a98b-966ae76ef7c7/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 7"><center>↓</center><img data-max-width="512" data-id="880ff4e2-4051-4c6d-9da7-5e26cdc45acc" src="/images/article/880ff4e2-4051-4c6d-9da7-5e26cdc45acc/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 8"></li>


<li><p><span class="text-bold">Удаляемый узел имеет одного потомка. </span></p>
<p>В таком случае мы удаляем выбранный узел, и на его место ставим его потомка (по сути просто вырежем выбранный узел из цепочки). В качестве примера удалим из дерева узел со значением 9:</p><img data-max-width="512" data-id="0dc0a85b-5313-42ac-83bb-3d9342311346" src="/images/article/0dc0a85b-5313-42ac-83bb-3d9342311346/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 9"><center>↓</center><img data-max-width="512" data-id="7136283a-a7b8-406e-856b-1799222ce346" src="/images/article/7136283a-a7b8-406e-856b-1799222ce346/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 10"></li>



<li><p><span class="text-bold">Удаляемый узел имеет двух потомков.</span></p>
<p>Самая интересная часть. Ведь если удаляемый узел имеет сразу двух потомков, нельзя просто так заменить его одним из этих потомков (особенно если у потомка есть собственные потомки).</p>

<p><span class="text-bold">Пример:</span> в рассматриваемом выше дереве, какой узел должен быть левым потомком узла 3? </p>

<p>Если немного задуматься, то станет очевидно, что это должен быть узел со значением 4. Ну а если дерево не будет таким простым? Если оно будет вмещать сотни значений, будет ли так просто понять, кто будет преемником? </p>

<p>Понятное дело, что нет. Поэтому тут нужен свой небольшой алгоритм поиска приемника:</p><ol>

<li>Сперва мы должны перейти к правому потомку выбранного узла, значение которого должно быть больше значения узла.</li>

<li>После мы переходим к левому потомку правого потомка (если такой существует), дальше — к левому потомку левого потомка и т. д., следуя вниз по цепи левых потомков.</li>

<li>Соответственно, последний левый потомок на этом пути и будет являться преемником исходного узла.</li></ol><p></p>

<p>Давайте немного обобщим этот небольшой алгоритм: в поддереве правого потомка исходного узла все узлы больше удаляемого, что можно понять из основных правил дерева двоичного поиска. В этом поддереве мы и ищем наименьшее значение. </p>

<p>Иными словами, мы ищем наименьший узел в наборе узлов, больших исходного узла. Этот наименьший узел среди больших и будет наиболее подходящим преемником. </p>

<p>Как будет выглядеть дерево после удаления узла со значением 3:</p><img data-max-width="512" data-id="bd373293-9542-416f-948f-8d647ca6f4ea" src="/images/article/bd373293-9542-416f-948f-8d647ca6f4ea/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 11"><center>↓</center><img data-max-width="512" data-id="3ad40c4f-4f90-4d6a-a757-2822ca665f35" src="/images/article/3ad40c4f-4f90-4d6a-a757-2822ca665f35/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 12"></li>

</ol>А теперь пришло время перейти от практики к теории. Давайте взглянем, каким же образом можно отобразить данную структуру данных в Java.

Класс одного узла:

<pre class="language-java line-numbers"><code>
class Node {
   private int value; // ключ узла
   private Node leftChild; // Левый узел потомок
   private Node rightChild; // Правый узел потомок

   public void printNode() { // Вывод значения узла в консоль
       System.out.println(" Выбранный узел имеет значение :" + value);
   }

   public int getValue() {
       return this.value;
   }

   public void setValue(final int value) {
       this.value = value;
   }

   public Node getLeftChild() {
       return this.leftChild;
   }

   public void setLeftChild(final Node leftChild) {
       this.leftChild = leftChild;
   }

   public Node getRightChild() {
       return this.rightChild;
   }

   public void setRightChild(final Node rightChild) {
       this.rightChild = rightChild;
   }

   @Override
   public String toString() {
       return "Node{" +
               "value=" + value +
               ", leftChild=" + leftChild +
               ", rightChild=" + rightChild +
               '}';
   }
}
</code></pre>
Ничего особо сложного: каждый элемент имеет ссылку на левого и правого потомка.

А теперь, пожалуй, самый важный класс — класс дерева:

<pre class="language-java line-numbers"><code>
class Tree {
   private Node rootNode; // корневой узел

   public Tree() { // Пустое дерево
       rootNode = null;
   }

   public Node findNodeByValue(int value) { // поиск узла по значению
       Node currentNode = rootNode; // начинаем поиск с корневого узла
       while (currentNode.getValue() != value) { // поиск покуда не будет найден элемент или не будут перебраны все
           if (value &lt; currentNode.getValue()) { // движение влево?
               currentNode = currentNode.getLeftChild();
           } else { //движение вправо
               currentNode = currentNode.getRightChild();
           }
           if (currentNode == null) { // если потомка нет,
               return null; // возвращаем null
           }
       }
       return currentNode; // возвращаем найденный элемент
   }

   public void insertNode(int value) { // метод вставки нового элемента
       Node newNode = new Node(); // создание нового узла
       newNode.setValue(value); // вставка данных
       if (rootNode == null) { // если корневой узел не существует
           rootNode = newNode;// то новый элемент и есть корневой узел
       }
       else { // корневой узел занят
           Node currentNode = rootNode; // начинаем с корневого узла
           Node parentNode;
           while (true) // мы имеем внутренний выход из цикла
           {
               parentNode = currentNode;
               if(value == currentNode.getValue()) {   // если такой элемент в дереве уже есть, не сохраняем его 
                    return;    // просто выходим из метода
                }
                else  if (value &lt; currentNode.getValue()) {   // движение влево?
                   currentNode = currentNode.getLeftChild();
                   if (currentNode == null){ // если был достигнут конец цепочки,
                       parentNode.setLeftChild(newNode); //  то вставить слева и выйти из методы
                       return;
                   }
               }
               else { // Или направо?
                   currentNode = currentNode.getRightChild();
                   if (currentNode == null) { // если был достигнут конец цепочки,
                       parentNode.setRightChild(newNode);  //то вставить справа
                       return; // и выйти
                   }
               }
           }
       }
   }

   public boolean deleteNode(int value) // Удаление узла с заданным ключом
   {
       Node currentNode = rootNode;
       Node parentNode = rootNode;
       boolean isLeftChild = true;
       while (currentNode.getValue() != value) { // начинаем поиск узла
           parentNode = currentNode;
           if (value &lt; currentNode.getValue()) { // Определяем, нужно ли движение влево?
               isLeftChild = true;
               currentNode = currentNode.getLeftChild();
           }
           else { // или движение вправо?
               isLeftChild = false;
               currentNode = currentNode.getRightChild();
           }
           if (currentNode == null)
               return false; // yзел не найден
       }

       if (currentNode.getLeftChild() == null &amp;&amp; currentNode.getRightChild() == null) { // узел просто удаляется, если не имеет потомков
           if (currentNode == rootNode) // если узел - корень, то дерево очищается
               rootNode = null;
           else if (isLeftChild)
               parentNode.setLeftChild(null); // если нет - узел отсоединяется, от родителя
           else
               parentNode.setRightChild(null);
       }
       else if (currentNode.getRightChild() == null) { // узел заменяется левым поддеревом, если правого потомка нет
           if (currentNode == rootNode)
               rootNode = currentNode.getLeftChild();
           else if (isLeftChild)
               parentNode.setLeftChild(currentNode.getLeftChild());
           else
               parentNode.setRightChild(currentNode.getLeftChild());
       }
       else if (currentNode.getLeftChild() == null) { // узел заменяется правым поддеревом, если левого потомка нет
           if (currentNode == rootNode)
               rootNode = currentNode.getRightChild();
           else if (isLeftChild)
               parentNode.setLeftChild(currentNode.getRightChild());
           else
               parentNode.setRightChild(currentNode.getRightChild());
       }
       else { // если есть два потомка, узел заменяется преемником
           Node heir = receiveHeir(currentNode);// поиск преемника для удаляемого узла
           if (currentNode == rootNode)
               rootNode = heir;
           else if (isLeftChild)
               parentNode.setLeftChild(heir);
           else
               parentNode.setRightChild(heir);
       }
       return true; // элемент успешно удалён
   }

   // метод возвращает узел со следующим значением после передаваемого аргументом.
   // для этого он сначала переходим к правому потомку, а затем
   // отслеживаем цепочку левых потомков этого узла.
   private Node receiveHeir(Node node) {
       Node parentNode = node;
       Node heirNode = node;
       Node currentNode = node.getRightChild(); // Переход к правому потомку
       while (currentNode != null) // Пока остаются левые потомки
       {
           parentNode = heirNode;// потомка задаём как текущий узел
           heirNode = currentNode;
           currentNode = currentNode.getLeftChild(); // переход к левому потомку
       }
       // Если преемник не является
       if (heirNode != node.getRightChild()) // правым потомком,
       { // создать связи между узлами
           parentNode.setLeftChild(heirNode.getRightChild());
           heirNode.setRightChild(node.getRightChild());
       }
       return heirNode;// возвращаем приемника
   }

   public void printTree() { // метод для вывода дерева в консоль
       Stack globalStack = new Stack(); // общий стек для значений дерева
       globalStack.push(rootNode);
       int gaps = 32; // начальное значение расстояния между элементами
       boolean isRowEmpty = false;
       String separator = "-----------------------------------------------------------------";
       System.out.println(separator);// черта для указания начала нового дерева
       while (isRowEmpty == false) {
           Stack localStack = new Stack(); // локальный стек для задания потомков элемента
           isRowEmpty = true;

           for (int j = 0; j &lt; gaps; j++)
               System.out.print(' ');
           while (globalStack.isEmpty() == false) { // покуда в общем стеке есть элементы
               Node temp = (Node) globalStack.pop(); // берем следующий, при этом удаляя его из стека
               if (temp != null) {
                   System.out.print(temp.getValue()); // выводим его значение в консоли
                   localStack.push(temp.getLeftChild()); // соохраняем в локальный стек, наследники текущего элемента
                   localStack.push(temp.getRightChild());
                   if (temp.getLeftChild() != null ||
                           temp.getRightChild() != null)
                       isRowEmpty = false;
               }
               else {
                   System.out.print("__");// - если элемент пустой
                   localStack.push(null);
                   localStack.push(null);
               }
               for (int j = 0; j &lt; gaps * 2 - 2; j++)
                   System.out.print(' ');
           }
           System.out.println();
           gaps /= 2;// при переходе на следующий уровень расстояние между элементами каждый раз уменьшается
           while (localStack.isEmpty() == false)
               globalStack.push(localStack.pop()); // перемещаем все элементы из локального стека в глобальный
       }
       System.out.println(separator);// подводим черту
   }
}
</code></pre>
Опять же, ничего особо сложного. Присутствуют операции для дерева двоичного поиска, описанные ранее, плюс метод для отображения дерева в консоли.

Ну а теперь взглянем на дерево в действии:	

<pre class="language-java line-numbers"><code>
public class Application {
   public static void main(String[] args) {
       Tree tree = new Tree();
       // вставляем узлы в дерево:
       tree.insertNode(6);
       tree.insertNode(8);
       tree.insertNode(5);
       tree.insertNode(8);
       tree.insertNode(2);
       tree.insertNode(9);
       tree.insertNode(7);
       tree.insertNode(4);
       tree.insertNode(10);
       tree.insertNode(3);
       tree.insertNode(1);
       // отображение дерева:
       tree.printTree();

       // удаляем один узел и выводим оставшееся дерево в консоли
       tree.deleteNode(5);
       tree.printTree();

       // находим узел по значению и выводим его в консоли
       Node foundNode = tree.findNodeByValue(7);
       foundNode.printNode();
   }
}
</code></pre>
Операции поиска/вставки/удаления в дереве двоичного поиска имеют временную сложность <span class="text-bold">O(log(N))</span>. Но это в лучшем случае.

Вообще, временная сложность операций варьируется от <span class="text-bold">O(log(N))</span> до <span class="text-bold">O(N)</span>. Это зависит от степени вырожденности дерева.<h4>Что такое вырожденное дерево?</h4>Это дерево, в котором элементы попадали при добавлении в позицию крайнего левого узла (наименьшие число) или крайнего большего узла (наибольшие).

Это может случиться, если, например, всё левое дерево пусто на каждом уровне, есть только правые деревья, и в таком случае дерево вырождается в список (идущий вправо).

Да, именно так вырожденное дерево фактически становится односвязным списком, в котором каждый элемент знает только о последующем за ним. В таком случае все операции по данной структуре приближаются ко временной сложности <span class="text-bold">O(N)</span>.<h4>В каком случае дерево может стать вырожденным?</h4>Например, если добавлять список отсортированных элементов. Если список отсортирован по возрастанию, то корнем будет первый, соответственно, наименьший. Следующий после него займет позицию правого потомка.

А тот, который попадет после, будет больше второго и займет позицию его правого преемника, и так далее… Если же список будет по убыванию, то будет то же самое, но уже с крайними левыми элементами.

Чтобы избежать этого, можно после получения ряда элементов попросту их перемешать.
 
Тогда сортированность пропадет, и числа будет более-менее равномерно разбросаны по дереву. <img data-max-width="512" data-id="01ec9a9a-5e6d-4f2e-901b-60bebc56e676" src="/images/article/01ec9a9a-5e6d-4f2e-901b-60bebc56e676/512.jpeg" alt="Структуры данных: двоичное дерево в Java - 13">На этом у меня сегодня всё, спасибо за уделенное внимание!<a href="https://javarush.com/welcome" target="_blank" rel="nofollow"><img data-max-width="1080" data-id="5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628" src="/images/article/5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628/1080.jpeg" alt="Структуры данных: двоичное дерево в Java - 14"></a>