Структуры данных: пирамида (двоичная куча) в Java
<p>----------------------------------------</p>
Привет-привет! Никто не будет отрицать, что алгоритмы и структуры данных — неоспоримый фундамент программирования. Да, можно и работать программистом и без их знания, но увы, далеко вы так не уедете. Поэтому чтобы усилить вашу базу знаний в этой области...
<p>----------------------------------------</p>
Привет-привет!

Никто не будет отрицать, что алгоритмы и структуры данных — неоспоримый фундамент программирования. Да, можно и работать программистом и без их знания, но увы, далеко вы так не уедете.

Поэтому чтобы усилить вашу базу знаний в этой области, хотелось бы поговорить о такой структуре данных как <span>пирамида</span> (еще известная как куча и двоичная куча).

Как правило такие структуры данных применяют в различных планировщиках и других структурах, в которых нужно обозначить приоритетность различных задач.

Итак...<img data-id="ceae024f-6c99-45a5-a5ea-fb1b9f01a47c" src="/images/article/ceae024f-6c99-45a5-a5ea-fb1b9f01a47c/800.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 1">Пирамида — это разновидность дерева, которая обеспечивает <span>вставку/удаление</span> за время <span>O(logN)</span> и обладает следующими свойствами:<ul>

<li>Полнота. Все уровни дерева содержат все возможные узлы, кроме последнего, который может быть заполнен лишь частично и который заполняется слева-направо;</li>
<li>Пирамида как правило реализуется на базе массива;</li>
<li>Для каждого узла в пирамиде есть основополагающее условие, что значение каждого узла больше (или равно) значениям его потомков. Соответственно, максимум будет храниться в верхнем элементе.</li>

</ul>Пирамида, состоящая из вершин, которые хранят значения не выше 10:<img data-id="3043b4e0-231b-4e3d-8478-66aa0d1f1f79" src="/images/article/3043b4e0-231b-4e3d-8478-66aa0d1f1f79/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 2">Хотелось бы отметить, что по сравнению с деревом двоичного поиска пирамида является <span>слабо упорядоченной</span>, так как в дереве двоичного поиска ключ левого потомка меньше ключа правого потомка, а в пирамиде такое условие отсутствует.<h2>Удаление элемента по индексу</h2>Для начала давайте рассмотрим, какова же последовательность действий при удалении выбранного узла:<ol>

<li>Удалить выбранный узел.</li>
<li>Переместить последний узел, в последнем ряду на место удаленного.</li>
<li>Смещать его вниз до тех пор, пока он не окажется ниже большего и выше меньшего узла.</li>

</ol>Когда используют пирамиду, то как правило необходимо уметь удалять вершину (нулевой элемент внутреннего массива) или последний (тогда операции по перемещению можно опустить, оставив только удаление элемента).

В качестве примера удаления элемента по индексу в рассматриваемой нами пирамиде выше мы удалим узел со значением 7:<ol>

<li><p>Удаляем выбранный узел и помещаем на его место последний, который у нас имеет значение 4:</p><img data-id="3db4dc79-e943-41c6-a863-36901833ff04" data-max-width="512" src="/images/article/3db4dc79-e943-41c6-a863-36901833ff04/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 3"><p>Но в таком положении данный узел не соответствует условию, что каждый узел потомок не должен быть больше рассматриваемого, не так ли? </p>

<p>Поэтому:</p></li>

<li><p>Меняем его местами с наибольшим из потомков, который имеет значение 6:</p><img data-id="9189f7a4-64e3-408b-82df-81f93509f54d" data-max-width="512" src="/images/article/9189f7a4-64e3-408b-82df-81f93509f54d/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 4"><p>Далее смотрим, нет ли потомков со значением большим, чем у нашего смещаемого элемента, и видим что нет, а это значит, что элемент стал на свое место.</p></li>
</ol><h2>Вставка нового элемента</h2>Каковы же действия при вставке нового элемента:<ol>
<li><p>Вставляемый узел помещается в конец пирамиды.</p>
<p>Но ведь у нас же есть условие, что дочерний элемент не может иметь значение больше родительского, верно? </p>

<p>Поэтому:</p></li>
<li>Сравниваем новый элемент с родительским элементом. Если новый элемент меньше, то операция закончена, если нет, то он меняется местами с родительским элементом. После — начинает сравниваться с новым родительским элементом, и так далее... До тех пор, пока родительский элемент не будет больше нового.</li>

</ol>К примеру, в пирамиду, которая была получена в результате удаления элемента, мы хотим добавить элемент со значением 8:<ol>

<li><p>Помещаем новый узел в конец пирамиды:</p><img data-id="307b5dd4-4c67-4574-994d-f14cd7731d8c" data-max-width="512" src="/images/article/307b5dd4-4c67-4574-994d-f14cd7731d8c/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 5"></li>
<li><p>Сравниваем новый элемент с родительским элементом, который имеет значение 4.</p>

<p>Так как новый элемент больше родительского, меняем их местами:</p><img data-id="a4d503ed-2acd-4af2-891d-41099d8be326" data-max-width="512" src="/images/article/a4d503ed-2acd-4af2-891d-41099d8be326/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 6"></li>


<li><p>Сравниваем новый элемент с новым его родителем и видим, что наш элемент больше и его (8&gt;7), поэтому меняем местами и их:</p><img data-id="203c79ee-4911-4cd2-b3da-727e98df7b17" data-max-width="512" src="/images/article/203c79ee-4911-4cd2-b3da-727e98df7b17/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 7"><p>Опять же, сравниваем элемент с родительский элементом и видим, что в этот раз родительский элемент больше, а это значит что наш новый элемент стал на свое место.</p></li>


</ol><h2>Замена элемента</h2>При замене элемента сперва нужно заменить элемент с заданным индексом. Логично, не так ли? Ну а что далее?

Ведь новое значение элемента уже другое, и не факт, что оно соответствует условию пирамиды. То есть не факт что все дочерние элементы меньше вставляемого элемента. Также не факт, что родительские элементы больше нового.

Поэтому сперва нужно сравнить со старым значением элемента:<ul>
<li>если новый элемент больше, чем он, то нам нужно сравнивать его с родительскими элементами и при надобности менять их местами;</li>
<li>если же новый элемент меньше, то нужно сравнивать с большим из дочерних элементов и менять местами, если дочерний элемент окажется больше (до тех пор, пока новый элемент не станет на допустимое место).</li>

</ul>Давайте же это рассмотрим на нашем примере. Сейчас мы хотим вставить элемент со значением 1 вместо элемента со значением 9:<ol>

<li>Вставляем элемент на место предыдущего:<img data-id="823d7d56-d91b-48e8-a20e-d7f68db80d86" data-max-width="512" src="/images/article/823d7d56-d91b-48e8-a20e-d7f68db80d86/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 8"></li>
<li>Сравниваем предыдущий элемент 9 и новый 1 и видим, что меньше, а значит, мы будем пробовать смещать вниз.</li>
<li>Сравниваем с большим элементом из дочерних, то есть с тем, который имеет значение 5, и видим, что новый меньше. Поэтому меняем сравниваемые элементы местами:<img data-id="44792def-a433-4444-a2fe-ebb1fa901bb6" data-max-width="512" src="/images/article/44792def-a433-4444-a2fe-ebb1fa901bb6/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 9"></li>
<li>Так как сейчас новых элементов ниже нашего нового уже нет, можно сказать, что элемент встал на свое место.</li>

</ol><h2>Реализация пирамиды на Java</h2>После понимания принципа работы данной структуры самое время рассмотреть <span>реализацию пирамиды на Java</span>:

Класс, представляющий одну вершину и значение, которое она содержит:

<pre class="language-java line-numbers"><code>
public class Node {
  private int value;
 
  public Node(int value) {
     this.value = value;
  }
 
  public int getValue() {
     return this.value;
  }
 
  public void setValue(int value) {
     this.value = value;
  }
}
</code></pre>
Класс, представляющий саму пирамиду:

<pre class="language-java line-numbers"><code>
public class Heap {
  private Node[] heapArray; // массив со всеми вершинами
  private int maxSize; // размер массива
  private int currentSize; // количество узлов массиве
 
  public Heap(int maxSize) { // создание пустой пирамиды
     this.maxSize = maxSize;
     this.currentSize = 0;
     heapArray = new Node[maxSize];
  }
 
  public void printHeap() { // отображение перамиды в консоль
     System.out.println("Массив значений: ");
    
     for (int n = 0; n &lt; currentSize; n++) {
        if (heapArray[n] != null) {
           System.out.println(heapArray[n].getValue() + " ");
        }
        else {
           System.out.println("-");
        }
     }
     System.out.println();
    
     int countOfGaps = 32;
     int itemsPerRow = 1;
     int columnNumber = 0; // номер элемента в данной строке
     String lines = "___________________________________________________________________";
     System.out.println(lines);
     for (int i = 0; i &lt; currentSize; i++) {
        if (columnNumber == 0) {  // проверяем первый элемент ли в текущей строке
           for (int k = 0; k &lt; countOfGaps; k++) { // добавляем предшествующие пробелы
              System.out.print(' ');
           }
        }
        System.out.print(heapArray[i].getValue());// выводим в консоль значение вершины
       
        if (++columnNumber == itemsPerRow) { // проверяем последний ли элемент в строке
           countOfGaps /= 2; // уменьшаем количество оступов применяемое для следующей строки
           itemsPerRow *= 2; // указываем, что элементов может быть вдвое больше
           columnNumber = 0; // сбрасываем счётчик для текущего элемента строки
           System.out.println(); // переходим на нову строку
        }
        else { //переход к следующему элементу
           for (int k = 0; k &lt; countOfGaps * 2 - 2; k++) {
              System.out.print(' '); // добавляем оступы
           }
        }
     }
     System.out.println("\n" + lines); // нижний пункир
  }
 
  public boolean insertNode(int value) { // вставка нового значения
     if (currentSize == maxSize) { // проверяем не выходим ли мы за рамки массива
        return false;
     }
     Node newNode = new Node(value);// создание вершины с данным значением
     heapArray[currentSize] = newNode;// вершину задём в самый низ дерева
     displaceUp(currentSize++);// пытаемся поднять вершину, если значение вершины позволяет
     return true;
  }
 
  public Node removeNode(int index) { // удалить элемент по индексу массива
     if(index &gt; 0 &amp;&amp; currentSize &gt; index) {
        Node root = heapArray[index];
        heapArray[index] = heapArray[--currentSize]; // задаём элементу с переданным индексом, значение последнего элемента
        heapArray[currentSize] = null;// последний элемент удаляем
        displaceDown(index);// проталкиваем вниз новый элемент, чтобы он должное ему место
        return root;
     }
     return null;
  }
 
  public boolean changeNode(int index, int newValue) {
     if (index &lt; 0 || currentSize&lt;=index) {
        return false;
     }
     int oldValue = heapArray[index].getValue(); // сохраняем старое значение
     heapArray[index].setValue(newValue); // присваиваем новое
    
     if (oldValue &lt; newValue) {// если узел повышается
        displaceUp(index);     // выполняется смещение вверх
     }
     else {                  // если понижается
        displaceDown(index);   // смещение вниз
     }
     return true;
  }
 
  private void displaceUp(int index) { //смещение вверх
     int parentIndex = (index - 1) / 2; // узнаем индекс родителя
     Node bottom = heapArray[index]; // берем элемент
     while (index &gt; 0 &amp;&amp; heapArray[parentIndex].getValue() &lt; bottom.getValue()) {// если родительский элемент меньше
        heapArray[index] = heapArray[parentIndex];// то меняем его местами с рассматриваемым
        index = parentIndex;
        parentIndex = (parentIndex - 1) / 2;// берем новый родительский индекс и повторяем сравнение элементов
     }
     heapArray[index] = bottom;// соохраняем результат
  }
 
  private void displaceDown(int index) {// смещение вниз
     int largerChild;
     Node top = heapArray[index]; // сохранение корня, пока у узла есть хотя бы один потомок
     while (index &lt; currentSize / 2) {// если данное условие не выполняется то элемент уже в самом низу пирамиды
        int leftChild = 2 * index + 1; // вычисляем индексы в массиве для левого узла ребенка
        int rightChild = leftChild + 1;// и правого
       
        if (rightChild &lt; currentSize &amp;&amp; heapArray[leftChild].getValue() &lt; heapArray[rightChild].getValue()) {
           largerChild = rightChild;
        }// вычисляем ребенка вершину с наибольшим числовым значением
        else {
           largerChild = leftChild;
        }
       
        if (top.getValue() &gt;= heapArray[largerChild].getValue()) {// если значение вершины больше или равно
           //значени его наибольшего ребенка
           break;// то выходим из метода
        }
       
        heapArray[index] = heapArray[largerChild];// заменяем вершину, большей дочерней вершиной
        index = largerChild; // текущий индекс переходит вниз
     }
     heapArray[index] = top; // задаем конечное местоположение для элемента
  }
}
</code></pre>
И наконец, давайте посмотрим на нашу пирамиду в деле:

<pre class="language-java line-numbers"><code>
public class Solution {
 
  public static void main(String[] args) {
     // задаем начальные данные:
     Heap heap = new Heap(31);
     heap.insertNode(120);
     heap.insertNode(40);
     heap.insertNode(50);
     heap.insertNode(80);
     heap.insertNode(20);
     heap.insertNode(100);
     heap.insertNode(150);
     heap.insertNode(30);
     heap.insertNode(210);
     heap.insertNode(180);
     heap.insertNode(10);
     heap.insertNode(90);
      // выводим начальную пирамиду в консоль
     heap.printHeap();
</code></pre>
Вывод в консоли:<img data-id="d7a92203-0ed4-46ff-9207-23042713f453" data-max-width="512" src="/images/article/d7a92203-0ed4-46ff-9207-23042713f453/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 10">
<pre class="language-java line-numbers"><code>
// изменяем элемент под индексом 0 с 210 на 15, и выводим в консоль измененную пирамиду
     heap.changeNode(0,15);
     heap.printHeap();
</code></pre>
Вывод в консоли:<img data-id="3b15f053-b1a3-4389-9eb6-745c6d68f453" data-max-width="512" src="/images/article/3b15f053-b1a3-4389-9eb6-745c6d68f453/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 11">
<pre class="language-java line-numbers"><code>
// удаляем элемент под индексом 3, который имеет значение 80 и смотрим на изменившуюся пирамиду
     heap.removeNode(3);
     heap.printHeap();
  }
}
</code></pre>
Вывод в консоли:<img data-id="250f9a76-b4f5-4576-8497-755260ce9d4c" data-max-width="512" src="/images/article/250f9a76-b4f5-4576-8497-755260ce9d4c/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 12">Ну вот, собственно, и всё.

Всем спасибо за внимание!<img data-id="ac3c6345-e8a0-4dc7-8179-f593e411e8d6" data-max-width="512" src="/images/article/ac3c6345-e8a0-4dc7-8179-f593e411e8d6/512.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 13"><a href="https://javarush.com/welcome" target="_blank" rel="nofollow"><img data-id="5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628" data-max-width="1080" src="/images/article/5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628/1080.jpeg" alt="Структуры данных: пирамида (двоичная куча) в Java - 14"></a>