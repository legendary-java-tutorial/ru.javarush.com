Паттерны проектирования: Singleton
<p>----------------------------------------</p>
Привет! Сегодня будем подробно разбираться в разных паттернах проектирования, и начнем с шаблона Singleton, который еще называют “одиночка”. Давай вспомним: что мы знаем о шаблонах проектирования в целом? Шаблоны проектирования — это лучшие практики...
<p>----------------------------------------</p>
Привет! Сегодня будем подробно разбираться в разных паттернах проектирования, и начнем с шаблона Singleton, который еще называют “одиночка”. 

<img data-max-width="800" data-id="226faa2c-6d47-48a7-8312-5abe29894e72" src="/images/article/226faa2c-6d47-48a7-8312-5abe29894e72/800.jpeg" class="img-fluid" alt="Паттерны проектирования: Singleton - 1">Давай вспомним: что мы знаем о шаблонах проектирования в целом?

Шаблоны проектирования — это лучшие практики, следуя которым можно решить ряд известных проблем. 

Шаблоны проектирования как правило не привязаны к какому-либо языку программирования. Воспринимай их как свод рекомендаций, следуя которым можно избежать ошибок и не изобретать свой велосипед.
<h2>Что такое синглтон?</h2>Синглтон — это один из самых простых шаблонов (паттернов) проектирования, который применяется к классу. Иногда говорят: “этот класс — синглтон”, подразумевая, что этот класс реализует паттерн проектирования синглтон. 

Иногда необходимо написать класс, у которого можно будет создать только один объект. Например, класс, отвечающий за логирование или подключение к базе данных. 

Шаблон проектирования синглтон описывает, как мы можем выполнить такую задачу. 

Синглтон — это шаблон (паттерн) проектирования, который делает две вещи:
<ol>
<li><p>Дает гарантию, что у класса будет всего один экземпляр класса.</p></li>
<li><p>Предоставляет глобальную точку доступа к экземпляру данного класса.</p></li>
</ol>Отсюда — две особенности, характерные для практически каждой реализации паттерна синглтон: 
<ol>
<li><p>Приватный конструктор. Ограничивает возможность создания объектов класса за пределами самого класса.</p></li>
<li><p>Публичный статический метод, который возвращает экземпляр класса. Данный метод называют <code>getInstance</code>. Это глобальная точка доступа к экземпляру класса. </p></li>
</ol><h2>Варианты реализации</h2>Шаблон проектирования синглтон применяют по-разному. Каждый вариант по-своему хорош и плох. Тут как всегда: идеала нет, но нужно к нему стремиться. 

Но прежде всего давай определимся, что такое хорошо и что такое плохо, и какие метрики влияют на оценку реализации шаблона проектирования.

Начнем с положительного. Вот критерии, которые придают реализации сочности и привлекательности:
<ul>
<li><p>Ленивая инициализация: когда класс загружается во время работы приложения именно тогда, когда он нужен.</p></li>
<li><p>Простота и прозрачность кода: метрика, конечно, субъективная, но важная. </p></li>
<li><p>Потокобезопасность: корректная работа в многопоточной среде.</p></li>
<li><p>Высокая производительность в многопоточной среде: потоки блокируют друг друга минимально, либо вообще не блокируют при совместном доступе к ресурсу.</p></li>
</ul>Теперь минусы. Перечислим критерии, которые выставляют реализацию в нелучшем свете: 
<ul>
<li><p>Не ленивая инициализация: когда класс загружается при старте приложения, независимо от того, нужен он или нет (парадокс, в мире IT лучше быть лентяем)</p></li>
<li><p>Сложность и плохая читаемость кода. Метрика также субъективная. Будем считать, что если кровь пошла из глаз, реализация так себе.</p></li>
<li><p>Отсутствие потокобезопасности. Иными словами, “потокоопасность”. Некорректная работа в многопоточной среде.</p></li>
<li><p>Низкая производительность в многопоточной среде: потоки блокируют друг друга все время либо часто, при совместном доступе к ресурсу.</p></li>
</ul><h2>Код</h2>Теперь мы готовы рассмотреть различные варианты реализации с перечислением плюсов и минусов:
<p id="Simple_Solution"><span class="text-bold">Simple Solution</span></p>
<pre class="lang-java line-numbers"><code>
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
</code></pre>
Самая простая реализация. 

Плюсы:
<ul>
<li><p>Простота и прозрачность кода</p></li>
<li><p>Потокобезопасность</p></li>
<li><p>Высокая производительность в многопоточной среде</p></li>
</ul>Минусы:
<ul>
<li>Не ленивая инициализация.</li>
</ul>В попытке исправить последний недостаток, мы получаем реализацию номер два:

<p id="Lazy_Initialization"><span class="text-bold">Lazy Initialization</span></p>
<pre class="lang-java line-numbers"><code>
public class Singleton {
  private static Singleton INSTANCE;

  private Singleton() {}

  public static Singleton getInstance() {
    if (INSTANCE == null) {
      INSTANCE = new Singleton();
    }
    return INSTANCE;
  }
}
</code></pre>
Плюсы:
<ul>
<li><p>Ленивая инициализация.</p></li>
</ul>Минусы:
<ul>
<li><p>Не потокобезопасно</p></li>
</ul>Реализация интересна. Мы можем инициализироваться лениво, но утратили потокобезопасность. Не беда: в реализации номер три мы все синхронизируем.

<p id="Synchronized_Accessor"><span class="text-bold">Synchronized Accessor</span></p>
<pre class="lang-java line-numbers"><code>
public class Singleton {
  private static Singleton INSTANCE;

  private Singleton() {
  }

  public static synchronized Singleton getInstance() {
    if (INSTANCE == null) {
      INSTANCE = new Singleton();
    }
    return INSTANCE;
  }
}
</code></pre>
Плюсы:
<ul>
<li><p>Ленивая инициализация.</p></li>
<li><p>Потокобезопасность</p></li>
</ul>Минусы:
<ul>
<li><p>Низкая производительность в многопоточной среде</p></li>
</ul>Отлично! В реализации номер три мы вернули потокобезопасность! Правда, медленную… Теперь метод <code>getInstance</code> синхронизирован, и входить в него можно только по одному. 

На самом деле нам нужно синхронизировать не весь метод, а лишь ту его часть, в которой мы инициализируем новый объект класса. Но мы не можем просто обернуть в <code>synchronized</code> блок часть, отвечающую за создание нового объекта: это не обеспечит потокобезопасность. Все немного сложнее. 

Правильный способ синхронизации представлен ниже:

<p id="Double_Checked_Locking"><span class="text-bold">Double Checked Locking</span></p>
<pre class="lang-java line-numbers"><code>
public class Singleton {
    private static Singleton INSTANCE;

  private Singleton() {
  }

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
</code></pre>
Плюсы:
<ul>
<li><p>Ленивая инициализация.</p></li>
<li><p>Потокобезопасность</p></li>
<li><p>Высокая производительность в многопоточной среде</p></li>
</ul>Минусы:
<ul>
<li><p>Не поддерживается на версиях Java ниже 1.5 (в версии 1.5 исправили работу ключевого слова volatile)</p></li>
</ul>Отмечу, что для корректной работы данного варианта реализации обязательно одно из двух условий. Переменная <code>INSTANCE</code> должна быть либо <code>final</code>, либо <code>volatile</code>. 

Последняя реализация, которую мы сегодня обсудим, — <code>Class Holder Singleton</code>.

<p id="Class_Holder_Singleton"><span class="text-bold">Class Holder Singleton</span></p>
<pre class="lang-java line-numbers"><code>
public class Singleton {

   private Singleton() {
   }

   private static class SingletonHolder {
       public static final Singleton HOLDER_INSTANCE = new Singleton();
   }

   public static Singleton getInstance() {
       return SingletonHolder.HOLDER_INSTANCE;
   }
}
</code></pre>
Плюсы:
<ul>
<li><p>Ленивая инициализация.</p></li>
<li><p>Потокобезопасность.</p></li>
<li><p>Высокая производительность в многопоточной среде.</p></li>
</ul>Минусы:
<ul>
<li><p>Для корректной работы необходима гарантия, что объект класса <code>Singleton</code> инициализируется без ошибок. Иначе первый вызов метода <code>getInstance</code> закончится ошибкой <code>ExceptionInInitializerError</code>, а все последующие <code>NoClassDefFoundError</code>.</p></li>
</ul> Реализация практически идеальная. И ленивая, и потокобезопасная, и быстрая. Но есть нюанс, описанный в минусе. 

<span class="text-bold">Сравнительная таблица различных реализаций паттерна Singleton:</span>
<table>
<thead>
<tr>
<th>Реализация</th>
<th>Ленивая инициализация</th>
<th>Потокобезопасность</th>
<th>Скорость работы при многопоточности</th>
<th>Когда использовать?</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#Simple_Solution">Simple Solution</a></td>
<td>-</td>
<td>+</td>
<td>Быстро</td>
<td>Никогда. Либо когда не важна ленивая инициализация. Но лучше никогда.</td>
</tr>
<tr>
<td><a href="#Lazy_Initialization">Lazy Initialization</a></td>
<td>+</td>
<td>-</td>
<td>Неприменимо</td>
<td>Всегда, когда не нужна многопоточность</td>
</tr>
<tr>
<td><a href="#Synchronized_Accessor">Synchronized Accessor</a></td>
<td>+</td>
<td>+</td>
<td>Медленно</td>
<td>Никогда. Либо когда скорость работы при многопоточности не имеет значения. Но лучше никогда</td>
</tr>
<tr>
<td><a href="#Double_Checked_Locking">Double Checked Locking</a></td>
<td>+</td>
<td>+</td>
<td>Быстро</td>
<td>В редких случаях, когда нужно обрабатывать исключения при создании синглтона. (когда неприменим Class Holder Singleton)</td>
</tr>
<tr>
<td><a href="#Class_Holder_Singleton">Class Holder Singleton</a></td>
<td>+</td>
<td>+</td>
<td>Быстро</td>
<td>Всегда, когда нужна многопоточность и есть гарантия, что объект синглтон класса будет создан без проблем.</td>
</tr>
</tbody></table><h2>Плюсы и минусы паттерна Singleton</h2>В целом синглтон делает именно то, что от него ждут: 
<ol>
<li><p>Дает гарантию, что у класса будет всего один экземпляр класса.</p></li>
<li><p>Предоставляет глобальную точку доступа к экземпляру данного класса.</p></li>
</ol>Однако у этого шаблона есть недостатки: 
<ol>
<li><p>Синглтон нарушает SRP (Single Responsibility Principle) — класс синглтона, помимо непосредственных обязанностей, занимается еще и контролированием количества своих экземпляров.</p></li>
<li><p>Зависимость обычного класса или метода от синглтона не видна в публичном контракте класса.</p></li>
<li><p>Глобальные переменные это плохо. Синглтон превращается в итоге в одну здоровенную глобальную переменную.</p></li>
<li><p>Наличие синглтона снижает тестируемость приложения в целом и классов, которые используют синглтон, в частности.</p></li>
</ol>Ну вот и все. Мы рассмотрели с тобой паттерн проектирования синглтон. Теперь в разговоре за жизнь с друзьями программистами ты сможешь сказать не только чем он хорош, но и пару слов о том, чем он плох. 

Удачи в освоении новых знаний.
<h2>Дополнительное чтение:</h2><ul>
<li><a href="https://habr.com/ru/post/116577/" rel="nofollow" target="_blank">Использование паттерна синглтон</a></li>
<li><a href="https://habr.com/ru/post/129494/" rel="nofollow" target="_blank">Правильный Singleton в Java</a></li><li><a href="https://javatalks.ru/topics/45005" rel="nofollow" target="_blank">Singleton "On Demand Holder idiom"</a></li>
<li><a href="https://community.oracle.com/docs/DOC-918906" rel="nofollow" target="_blank">Effective Ways to Implement and Use the Singleton Design Pattern</a></li>
<li><a href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples" rel="nofollow" target="_blank">Java Singleton Design Pattern Best Practices with Examples</a></li>
</ul>