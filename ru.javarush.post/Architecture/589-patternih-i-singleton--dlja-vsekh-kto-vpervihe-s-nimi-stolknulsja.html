Паттерны и Singleton – для всех, кто впервые с ними столкнулся
<p>----------------------------------------</p>
Данная статья ориентирована на тех, кто впервые столкнулся с понятием паттернов, услышал о Singleton’e, либо каким-то образом его сделал, но так ничего и не поняли. Welcome! Впервые с паттернами студенты JavaRush ...
<p>----------------------------------------</p>
Данная статья ориентирована на тех, кто впервые столкнулся с понятием паттернов, услышал о <code>Singleton</code>’e, либо каким-то образом его сделал, но так ничего и не поняли. Welcome! Впервые с паттернами студенты JavaRush сталкиваются на 15 уровне, когда неожиданным образом кэп просит “закрепить” и реализовать паттерн <code>Singleton</code> с ленивой реализацией. У студентов, впервые услышавших про <code>Singleton</code>, мгновенно возникает куча вопросов: что вообще такое паттерн, зачем он нужен, какой еще <code>Singleton</code> и наконец, что еще за ленивая реализация. Начнем отвечать по-порядку:
<img data-id="15de364e-776e-43a7-8638-d3e4dafef2ac" data-max-width="850" alt="Паттерны и Singleton – для всех, кто впервые с ними столкнулся - 1" src="https://cdn.javarush.com/images/article/15de364e-776e-43a7-8638-d3e4dafef2ac/1024.jpeg"><h2>Что вообще такое паттерн</h2>Отвечать на этот вопрос для лучшего понимания, полагаю, стоит с истории. Среди программистов есть такая  знаменитая четверка авторов: Эрих Гамма, Ричард Хелм, Ральф Джонсон и Джон Влиссидес, которым пришла в голову интересная мысль.
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="96dd7ea7-8d3f-457a-936d-f66badabc64a" data-max-width="588" alt="Паттерны и Singleton – для всех, кто впервые с ними столкнулся - 2" src="https://cdn.javarush.com/images/article/96dd7ea7-8d3f-457a-936d-f66badabc64a/1024.jpeg"></div></div>Они заметили, что при написании программ им часто приходится решать приблизительно одни и те же задачи, и писать по структуре однотипный код. Поэтому они решили описать в виде паттернов типовые шаблоны, которые часто приходится использовать в объектно-ориентированном программировании. Книга вышла в 1995 году под названием <a href="https://www.ozon.ru/context/detail/id/2457392/ " target="_blank" rel="nofollow">«Приемы объектно-ориентированного проектирования. Паттерны проектирования» </a>. Название книги оказалось слишком длинным, и ее просто стали называть <strong>«Книгой банды четырех»</strong>. В первом издании было опубликовано 23 паттерна, после чего были открыты и десятки других. Так вот, отвечая на вопрос этого параграфа, — <strong>«Что же такое паттерны»</strong>, подытожим буквально в нескольких словах:
<table>
<tbody><tr>
<td>Паттерн – это стандартизированное решение какой-либо часто встречающейся проблемы.
</td>
</tr>
</tbody></table>И <code>Singleton</code> – это всего-лишь один из таких паттернов.
<h2>Зачем нужны паттерны (шаблоны проектирования)</h2>Программировать получается и без знания паттернов, убедиться в этом можно просто осознав тот факт, что к 15-му уровню на JavaRush вы написали сотни мини-программ, ничего не зная об их существовании. Это говорит о том, что паттерн – это своего рода инструмент, наличие которого и отличает мастера от любителя: 
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="976aacbf-71d7-49c5-ba2e-a6854d8c89bd" data-max-width="1009" alt="Паттерны и Singleton – для всех, кто впервые с ними столкнулся - 3" src="https://cdn.javarush.com/images/article/976aacbf-71d7-49c5-ba2e-a6854d8c89bd/1024.jpeg"></div></div>В паттернах описывается, как правильно следует решать одну из типовых задач. Как следствие, знание паттернов экономит ваше время. Можно привести аналогию с алгоритмами. К примеру, можно придумывать "свой" алгоритм сортировки <s>с блекджеком и цифрами</s> и потратить на это много времени, а можно использовать уже давно описанный и реализовать его. То же самое и с паттернами. Плюс ко всему, с использованием паттернов код становится более стандартизирован, а при использовании нужных шаблонов у вас будет меньше вероятности сделать ошибки, так как их уже давно предвидели и устранили в этом паттернте. Ну и плюс ко всему, знание паттернов позволяет программистам лучше понимать друг друга. Достаточно просто произнести название шаблона, вместо того, чтобы пытаться объяснить своим коллегам-программистам, чего вы от них хотите.

<strong>Итак, подытожим, </strong> шаблоны проектирования помогают:
<table>
<tbody><tr>
<td><ul><li>не изобретать велосипед, а использовать стандартные решения;</li>
<li>стандартизировать код;</li>
<li>стандартизировать терминологию;</li></ul>
</td>
</tr>
</tbody></table>В заключении этого раздела отметим, что все многообразие паттернов можно упрощенно разбить на три большие группы:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="19d3d0c0-1922-468f-a147-65066ef51e38" data-max-width="977" alt="Паттерны и Singleton – для всех, кто впервые с ними столкнулся - 4" src="https://cdn.javarush.com/images/article/19d3d0c0-1922-468f-a147-65066ef51e38/1024.jpeg"></div></div><h2>Наконец-то паттерн Singleton</h2><code>Singleton</code> относится к <u>порождающим паттернам</u>. Его дословный перевод – одиночка.  Этот паттерн гарантирует, что у класса есть только один объект (один экземпляр класса) и к этому объекту предоставляется глобальная точка доступа. Из описания должно быть понятно, что этот паттерн должен применяться в двух случаях:
<ol>
<li>когда в вашей программе должно быть создано не более одного объекта какого-либо класса. Например, в компьютерной игре у вас есть класс «Персонаж», и у этого класса должен быть только один объект описывающий самого персонажа. </li><br>
<li>когда требуется предоставить глобальную точку доступа к объекту класса. Другими словами, нужно сделать так, чтобы объект вызывался из любого места программы. И, увы, для этого не достаточно просто создать глобальную переменную, ведь она не защищена от записи и кто угодно может изменить значение этой переменной и глобальная точка доступа к объекту будет потеряна. Это свойства <code>Singleton</code>'a нужно, например, когда у вас есть объект класса, который работает с базой данных, и вам нужно чтобы к базе данных был доступ из разных частей программы. А <code>Singleton</code> будет гарантировать, что никакой другой код не заменил созданный ранее экземпляр класса.</li>
</ol>Вот  эти две задачи  и решает <code>Singleton</code>: объект в программе должен быть один и к нему есть глобальный доступ. В примере на 15 уровне кэп просит реализовать этот паттерн для следующей задачи (вот ее описание):
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="19790e28-cc64-4e28-b619-e0e4afdee35f" data-max-width="789" alt="Паттерны и Singleton – для всех, кто впервые с ними столкнулся - 5" src="https://cdn.javarush.com/images/article/19790e28-cc64-4e28-b619-e0e4afdee35f/1024.jpeg"></div></div>Внимательно прочитав условие, становится понятно, зачем здесь нужен именно <code>Singleton</code> (Одиночка). Ведь в программе просят создать по одному объекту каждого класса: <code>Sun</code>, <code>Moon</code>, <code>Earth</code>. И логично предположить, что каждый класс в программе должен создавать не больше одного Солнца/Луны/Земли, иначе это будет абсурд, если конечно вы не пишите свою версию звездных воин.

<strong>Особенность реализации <code>Singleton</code> в Java за три шага</strong>

Поведение Одиночки на Java невозможно реализовать с помощью обычного конструктора, потому что конструктор всегда возвращает новый объект. Поэтому все реализации <code>Singleton</code>’a сводятся к тому, чтобы скрыть конструктор и создать публичный статический метод, который будет управлять существованием объекта-одиночки и «уничтожать» всех вновь-появляющихся объектов. В случае вызова <code>Singleton</code>’a он должен либо создать новый объект (если его еще нет в программе), либо вернуть уже созданный. Для этого:   

<strong>#1.</strong> – Нужно добавить в класс приватное статическое поле, содержащее одиночный объект:

<pre class="lang-java line-numbers"><code>
public class LazyInitializedSingleton {
	private static LazyInitializedSingleton instance; //#1
}
</code></pre>
<strong>#2.</strong> – Сделать конструктор класса (конструктор по-умолчанию) приватным (чтобы доступ к нему был закрыть за пределами класса, тогда он не сможет возвращать новые объекты):

<pre class="lang-java line-numbers"><code>
public class LazyInitializedSingleton {
	private static LazyInitializedSingleton instance;
private LazyInitializedSingleton(){} // #2
} 
</code></pre>
<strong>#3</strong>. – Объявить статический создающий метод, который будет использоваться для получения одиночки:

<pre class="lang-java line-numbers"><code>
public class LazyInitializedSingleton {
    private static LazyInitializedSingleton instance;
        private LazyInitializedSingleton(){}
        public static LazyInitializedSingleton getInstance(){ // #3
        if(instance == null){		//если объект еще не создан
            instance = new LazyInitializedSingleton();	//создать новый объект
        }
        return instance;		// вернуть ранее созданный объект
    }
}
</code></pre>
Вышеописанный пример несколько топорный, ведь мы просто скрываем конструктор и предоставляем взамен стандартного конструктора свой метод. Так как эта статья направлена на то, чтобы студенты JavaRush’a смогли впервые соприкоснуться с этим паттерном (и паттернами в принципе), здесь не будут приведены особенности реализации более сложных Одиночек. Отметим лишь, что в зависимости от сложности программы может потребоваться более детальная доработка этого паттерна. Например, в многопоточной среде (см. тему Thread’ы), несколько разных потоков могут одновременно вызвать метод получения Одиночки, и описанный выше код перестанет работать, ибо каждый отдельный поток сможет создать сразу несколько экземпляров класса. Поэтому еще есть несколько разных подходов к созданию правильных Thread-safe одиночек. Но это уже другая история =)

<strong>И напоследок. Что же такое Ленивая Инициализация, о которой просил кэп</strong>

Ленивую инициализацию (Lazy Initialization) еще называют отложенной инициализацией. Это прием в программировании, когда ресурсоемкая операция (а создание объекта – это ресурсоемкая операция) выполняется по требованию, а не заблаговременно. Что в общем-то и происходит в нашем коде <code>Singleton</code>’a. Другими словами, наш объект создается в момент обращения к нему, а не заранее. Не следует полагать, что понятие ленивой инициализации как-то жестко связана именно с <code>Singleton</code>’ом. Отложенная инициализация также используется и в других порождающих паттернах проектирования, например в таких как Proxy (Заместитель) и Factory Method (Фабричный метод), но это тоже другая история =)

<strong>При подготовке материалов статьи использовались следующие источники:</strong>
<ol>
<li><a href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples#lazy-initialization" target="_blank" rel="nofollow">Java Singleton Design Pattern Best Practices with Examples</a></li>
<li><a href="https://refactoring.guru/ru/design-patterns" target="_blank" rel="nofollow">Паттерны проектирования</a></li>
<li><a href="https://habr.com/post/129494/" target="_blank" rel="nofollow">Правильный Singleton в Java</a></li>
</ol>