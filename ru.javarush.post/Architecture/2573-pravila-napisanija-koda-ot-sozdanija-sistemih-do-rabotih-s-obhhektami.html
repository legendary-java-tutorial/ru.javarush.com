Правила написания кода: от создания системы до работы с объектами
<p>----------------------------------------</p>
Всем доброго дня суток: сегодня мне хотелось бы поговорить с вами о правильном написании кода. Когда я только начинал программировать, нигде не было чётко написано, что вот так писать можно, а если вот так...
<p>----------------------------------------</p>
Всем доброго дня суток: сегодня мне хотелось бы поговорить с вами о правильном написании кода.

Когда я только начинал программировать, нигде не было чётко написано, что вот так писать можно, а если вот так напишешь, я найду тебя и…. В итоге в голове у меня было большое количество вопросов: а как правильно писать, каких принципов стоит придерживаться в том или ином участке программы и т.д.

<img src="/images/article/790a7792-f7d3-4638-acaa-9a967cb71a7f/original.png" alt="Правила написания кода: от создания системы до работы с объектами - 1">Ну, не всем вот так сразу хочется вгрызаться в книги типа Clean Code, так как написано в них много, а поначалу понятно мало. Да и пока дочитаешь, всё желание кодить можно отбить.

Поэтому исходя из всего вышесказанного, сегодня я хочу предоставить вам небольшое руководство (свод небольших рекомендаций) для написания более высокоуровневого кода. В этой статье пройдемся по основным правилам и концепциям, которые касаются создания системы, работы с интерфейсами, классами и объектами.

Прочтение этого материала не займёт у вас много времени и, надеюсь, не даст заскучать. Я пойду “сверху вниз”, то есть, от общей структуры приложения к более узконаправленным деталям.

<img src="/images/article/5046de52-1296-44e7-9d79-da8f4f610957/original.jpg" alt="Правила написания кода: от создания системы до работы с объектами - 2"><h2>Система</h2>Общие желательные <span>характеристики системы</span> таковы:
<ul>
<li><span>минимальная сложность</span> — необходимо избегать слишком усложненных проектов. Главное — это простота и понятность (лучшее=простое);</li>
<li><span>простота сопровождения</span> — при создании приложения необходимо помнить, что его нужно будет поддерживать (даже если это будете не вы), поэтому код должен быть понятным и очевидным;</li>
<li><span>слабое сопряжение</span> — это минимальное количество связей между разными частями программы (максимальное использование принципов ООП);</li>
<li><span>возможность переиспользования</span> — проектирование системы с возможностью переиспользовать её фрагменты в других приложениях;</li>
<li><span>портируемость</span> — система должна быть легко адаптирована к другой среде;</li>
<li>единый стиль — проектирование системы в едином стиле в разных её фрагментах;</li>
<li><span>расширяемость (маштабируемость)</span> — улучшение системы без нарушения ее базовой структуры (если добавить или изменить какой-то фрагмент, это не должно влиять на остальные).</li>
</ul>Построить приложение не требующее доработок, без добавления функционала, — фактически невозможно. Нам постоянно нужно будет вводить новые элементы, чтобы наше детище могло идти в ногу со временем. И тут на сцену выходит <span>маштабируемость</span>.

<span>Маштабируемость</span> — это по сути расширение приложения, добавление нового функционала, работа с большим количеством ресурсов (или, по-другому, с большей нагрузкой). То есть мы должны придерживаться некоторых правил, таких как уменьшение связанности системы за счёт увеличения модульности, чтобы было проще добавлять новую логику.
<h3>Этапы проектирования системы</h3><ol>
<li><span>Программная система</span> — проектирование приложения в общем виде.</li>
<li><span>Разделение на подсистемы/пакеты</span> — определение логически разделяемых частей и определение правил взаимодействия между ними.</li>
<li><span>Разделение подсистем на классы</span> — разделение частей системы, на конкретные классы и интерфейсы, а также определение взаимодействия между ними.</li>
<li><span>Разделение классов на методы</span> — полное определение нужных методов для класса, исходя из задачи этого класса.
Проектирование методов — детальное определение функциональности отдельных методов.</li>
</ol>Обычно проектированием и занимаются рядовые разработчики, а теми пунктами, что описаны выше — архитектор приложения.
<h3>Главные принципы и концепции проектирования системы</h3><span>Идиома отложенной инициализации</span>
 
Приложение не тратит время на создание объекта до момента его непосредственного использования, что ускоряет процесс инициализации и уменьшает загрузку сборщика мусора. Но свою очередь, с этим не стоит перегибать, так как это может вести к нарушению модульности. Возможно, стоит перенести все моменты конструирования в какую-то определенную часть, например, main, или в класс работающий по <a href="https://javarush.com/groups/posts/2370-pattern-proektirovanija-factory" target="_blank" rel="nofollow">принципу фабрики</a>.

Один из аспектов качественного кода — отсутствие часто повторяющегося, шаблонного кода. Как правило, такой код выносится в отдельный класс, чтобы его можно было вызвать в нужный момент. 

<span>АОП</span>

Отдельно хотелось бы отметить <span>аспектно ориентированое программирование</span>. Это программирование путём внедрения сквозной логики, то есть повторяющийся код выносится в классы — аспекты, и вызывается при достижении определенных условий. Например, при обращении к методу с определенным названием или обращение к переменной определенного типа.

Иногда аспекты могут путать, так как не сразу понятно, откуда вызывается код, но тем не менее, это очень полезный функционал. В частности, при кешировании или логгировании: мы навешиваем этот функционал, при этом не добавляя дополнительную логику в обычные классы.

Почитать больше про оап можно <a href="https://habr.com/ru/post/114649/" target="_blank" rel="nofollow">тут</a>.

<span>4 правила проектирования простой архитектуры Согласно Кенту Беку</span>
<ol>
<li><span>Выразительность</span> — необходимость чётко выраженной цели класса, достигается путём правильного именования, небольшого размера и соблюдения принципа single responsibility (немного ниже рассмотрим подробнее).</li>
<li><span>Минимум классов и методов</span> — в своём стремлении разбить классы на как можно более мелкие и однонаправленные можно зайти слишком далеко (антипатерн — стрельба дробью). Этот принцип призывает всё же сохранять компактность системы и не заходить слишком далеко, создавая по классу на каждый чих.</li>
<li><span>Отсутствие дублирования</span> — лишний код, который путает, — признак не лучшего проектирования системы, выносится в отдельное место.</li>
<li><span>Выполнение всех тестов</span> — система, прошедшая все тесты, контролируема, так как любое изменение может повлечь за собой падение тестов, что может показать нам — изменение внутренней логики метода потянуло и изменение ожидаемого поведения.</li>
</ol><span>SOLID</span>

При проектировании системы стоит учитывать и общеизвестные принципы SOLID:

<span>S — single responsibility</span> — принцип единственной ответственности;
<span>O — open-closed</span> — принцип открытости/закрытости;
<span>L — Liskov substitution</span> — принцип подстановки Барбары Лисков;
<span>I — interface segregation</span> — принцип разделения интерфейса;
<span>D — dependency inversion</span> — принцип инверсии зависимостей;

Конкретно на каждом принципе останавливаться не будем (это немного выходит за рамки данной статьи, но <a href="https://javarush.com/groups/posts/osnovnye-principy-dizajna-klassov-solid-v-java" target="_blank" rel="nofollow">тут</a> можно ознакомиться подробнее
<h2>Interface</h2>Пожалуй, один из самых важных этапов создания адекватного класса — это создание адекватного интерфейса, который будет представлять хорошую абстракцию, скрывающую детали реализации класса, и при этом будет представлять группу методов, чётко согласующихся между собой.

Рассмотрим подробнее один из принципов SOLID —<span> interface segregation</span>: клиенты (классы) не должны реализовывать ненужные методы, которые они не будут использовать. То есть, если речь идет о построении интерфейсов с минимальным количеством методов, которые направлены на выполнение единственной задачи этого интерфейса (как по мне, очень схоже с <span>single responsibility</span>), лучше вместо одного раздутого интерфейса создать пару более мелких. Благо, класс может реализовывать не один интерфейс, как в случае с наследованием.

Также нужно помнить о правильном именовании интерфейсов: название должно как можно более точно отображать его задачу. И, конечно, чем оно будет короче, тем меньше путаницы вызовет.

Именно на уровне интерфейсов обычно пишут <span>комментарии для документации</span>, которые, в свою очередь, помогают нам подробно описать, что метод должен делать, какие аргументы принимает и что он вернёт.
<h2>Класс</h2><img src="/images/article/016d670a-a878-49a2-acac-b376bef9833e/original.png" alt="Правила написания кода: от создания системы до работы с объектами - 3">Давайте рассмотрим внутреннюю организацию классов. А точнее, некоторые взгляды и правила, которых стоит придерживаться при построении классов.

Как правило, класс должен начинаться со списка переменных, расположенных в определенном порядке:
<ol>
<li>public static константы;</li>
<li>private static константы;</li>
<li>private переменные экземпляра.</li>
</ol>Далее идут разнообразные конструкторы в порядке от меньшего количества аргументов к большему.

После них следуют методы от с более открытого доступа до самых закрытых: как правило приватные методы, скрывающие реализацию некоторого функционала, который мы хотим ограничить, стоят в самом низу.
<h3>Размер класса</h3>Теперь хотелось бы поговорить о размере класса.
<img src="/images/article/8e7f2859-599f-486b-9c2b-ec6cd5cd805e/original.jpg" alt="Правила написания кода: от создания системы до работы с объектами - 4">Вспомним один из принципов SOLID — <span>single responsibility</span>.

<span>Single responsibility</span> — принцип единственной ответственности. Он гласит, что у каждого объекта есть лишь одна цель (ответственность), и логика всех его методов направлена на ее обеспечение.

То есть исходя из этого, мы должны избегать больших, раздутых классов (что по своей природе — антипатерн — «божественный объект»), и если у нас очень много методов разнообразной, разнотипной логики в классе, нужно задуматься о том, чтобы разбить его на пару логичных частей (классов). Это, в свою очередь, повысит читаемость кода, так как нам не нужно много времени, чтобы понять цель метода, если мы знаем примерное назначение данного класса.

Также нужно и <span>следить за именем класса</span>: оно должно отображать содержащуюся в нём логику. Скажем, если у нас класс, в имени которого 20+ слов, нужно задуматься о рефакторинге.

У каждого уважающего себя класса должно быть не такое уж и большое количество внутренних переменных. Фактически каждый метод работает с одной из них или с несколькими, что вызывает большую связанность внутри класса (что и собственно и должно быть, так как класс должен быть как единое целое). 

Как итог, повышение связанности класса приводит к уменьшению его как такового, ну и, понятное дело, у нас увеличивается количество классов. Некоторых это напрягает, так нужно больше ходить по классам, чтобы, увидеть как работает конкретная крупная задача.

Помимо всего прочего, каждый класс — это небольшой модуль, который должен быть минимально связан с другими. Подобная изолированность уменьшает количество изменений, которые нам нужно внести при добавлении дополнительной логики в какой-то класс.
<h2>Объекты</h2><img src="/images/article/2b4c7260-ec49-4b23-9cfb-64d6af5453cd/original.png" alt="Правила написания кода: от создания системы до работы с объектами - 5"><h3>Инкапсуляция</h3>Тут мы в первую очередь поговорим об одном из принципов ООП — <span>инкапсуляции</span>. Итак, скрытие реализации не сводится к созданию прослойки метода между переменными (бездумное ограничение доступа через одиночные методы, геттеры и сеттеры, что не есть хорошо, так как весь смысл инкапсулирования теряется). Скрытие доступа направленно на формирование абстракций, то есть класс предоставляет общие конкретные методы, посредством которых мы работаем с нашими данными. А знать, как именно мы работаем с этими данными, пользователю не обязательно — работает да и ладно.
<h3>Закон Деметры</h3>Также можно рассмотреть закон Деметры: это небольшой набор правил, который помогает в управлении сложностью на уровне классов и методов.

Итак, предположим , что у нас есть обьект <code>Car</code>, и у него есть метод — <code>move(Object arg1, Object arg2)</code>. Согласно закону Деметры, этот метод ограничивается вызовом:
<ul>
<li>методов самого объекта <code>Car</code> (иначе говоря — this);</li>
<li>методов объектов, созданных в <code>move</code>;</li>
<li>методов переданных объектов в качестве аргументов — <code>arg1</code>, <code>arg2</code>;</li>
<li>методов внутренних объектов <code>Car</code>(тот же this).</li>
</ul>
Иначе говоря, <span>закон Деметры</span> — это нечто вроде детского правила — <span>разговаривать можно с друзьями, но не с чужаками</span>.
<h3>Структура данных</h3>Структура данных — это набор связанных элементов. При рассмотрении обьекта как структуры данных — набор элементов данных, с которыми работают методы, существование которых подразумевается неявно.

То есть это обьект, целью которого является хранение и работа (обработка) хранимых данных. Ключевое отличие от обычного объекта заключается в том, что объект — это набор методов, которые работают с элементами данными, существование которых подразумевается неявно. Понимаете? В обычном объекте главным аспектом являются методы, и внутренние переменные направлены на их правильную работу, а в структуре данных наоборот: методы поддерживают, помогают работать с хранимыми  элементами, которые здесь и являются главными.

Одна из разновидностей структур данных — <span>Data Transfer Object (DTO)</span>. Это класс с открытыми переменными и без методов (или только методами для чтения/записи), которые передают данные при работе с базами данных, работают с парсингом сообщений из сокетов и т. д. 

Обычно в таких объектах данные долго не хранятся и почти сразу конвертируются в сущность, с которой и работает наше приложение. Сущность, в свою очередь, тоже получается структурой данных, но ее предназначение — участвовать в бизнес-логике на разных уровнях приложения, а у DTO — транспортировать данные в/из приложения. Пример DTO:

<pre class="lang-java line-numbers"><code>
@Setter
@Getter
@NoArgsConstructor
public class UserDto {
    private long id;
    private String firstName;
    private String lastName;
    private String email;
    private String password;
}
</code></pre>
Всё вроде бы понятно, но тут мы узнаем о существовании гибридов.

<span>Гибриды</span> — это объекты, которые содержат методы для обработки важной логики и хранят внутренние элементы и методы доступа к ним (get/set). Подобные объекты сумбурны, и усложняют добавление новых методов. Не стоит использовать их, так как непонятно, для чего они предназначены — для хранения элементов или выполнения какой-то логики.

Про возможные типы обьектов можно почитать <a href="http://www.matools.com/lang-ru/blog/190399818" target="_blank" rel="nofollow">тут</a>.
<h3>Принципы создания переменных</h3><img src="/images/article/b65b3716-4304-4939-a9d8-e688fa3dced7/original.png" alt="Правила написания кода: от создания системы до работы с объектами - 6">Давайте немного порассуждаем на тему переменных, а точнее, подумаем: какие могут быть принципы их создания:
<ol>
<li>В идеале нужно объявлять и инициализировать переменную непосредственно перед её использованием (а не создали, и забыли про неё).</li>
<li>По возможности объявлять переменные как final, чтобы предотвратить изменение её значения после инициализации.</li>
<li>Не забывать про переменные-счётчики (обычно мы их используем в каком нибудь цикле <code>for</code>, то есть нужно не забывать их обнулить, иначе это может сломать нам всю логику).</li>
<li>Нужно стараться инициализировать переменные в конструкторе.</li>
<li>Если существует выбор между использованием объекта со ссылкой или без (<code>new SomeObject()</code>), делайте выбор в пользу <span>без</span>, так как этот объект после использования удалится во время следующей сборки мусора и не будет использовать ресурсы зря.</li>
<li>Делайте время жизни переменных как можно короче (расстояние между созданием переменной и последним обращением).</li>
<li>Инициализируйте переменные, используемые в цикле, непосредственно перед циклом, а не в начале метода, содержащего цикл.</li>
<li>Начинайте всегда с самой ограниченной области видимости и расширяйте её только при необходимости (нужно стараться делать переменную как можно более локальной).</li>
<li>Используйте каждую переменную только с одной целью.</li>
<li>Избегайте переменных со скрытым смыслом (переменная разрывается между двумя задачами, значит для решения одной из них её тип не подходит).</li>
</ol><a href="https://javarush.com/welcome" target="_blank" rel="nofollow"><img data-id="008ddced-700d-41ca-be65-f2c6e741cf7b" src="/images/article/008ddced-700d-41ca-be65-f2c6e741cf7b/original.png" alt="Правила написания кода: от создания системы до работы с объектами - 7"></a><h3>Методы</h3><img src="/images/article/287158e9-beac-4ed3-ad2b-26a9f56ad5ba/original.jpg" alt="Правила написания кода: от создания системы до работы с объектами - 8">Перейдём непосредственно к реализации нашей логики, а именно — к методам.
<ol>
<li><p><span>Первое правило — это компактность.</span> В идеале один метод не должен превышать 20 строк, поэтому если, скажем, public метод значительно “разбухнет”,  нужно задуматься о выносе отделяемой логики в приватные методы.</p></li>
<li><p><span>Второе правило — блоки в командах <code>if</code>, <code>else</code>, <code>while</code> и так далее, не должны иметь большую вложенность:</span> это значительно понижает читаемость кода. В идеале вложенность  должна быть не более двух блоков<code>{}</code>.</p>
<p>Код в этих блоках тоже желательно делать компактным и простым.</p></li>
<li><p><span>Третье правило — метод должен выполнять только одну операцию.</span> То есть, если метод выполняет сложную разнообразную логику, мы его бьём на подметоды. В итоге сам метод будет фасадом, цель которого — вызов всех остальных операций в правильном порядке.</p>
<p>Но что если операция кажется слишком простой для создания отдельного метода? Да, иногда это может показаться пальбой из пушки по воробьям, но небольшие методы обеспечивают ряд преимуществ:</p><ul>
<li>облегченное чтение кода;</li>
<li>методы имеют свойство усложняться с течением разработки, и если метод изначально был простым, усложнение его функционала будет немного проще;</li>
<li>сокрытие деталей реализации;</li>
<li>облегчение повторного использования кода;</li>
<li>более высокая надёжность кода.</li></ul></li>
<li><p><span>Правило понижения</span> — код должен читаться сверху вниз: чем ниже — тем большее углубление в логику, и наоборот, чем выше — тем более абстрактные методы. Например, команды switch  довольно-аки некомпактны и нежелательны, но если без использования переключателя никак, нужно постараться вынести его как можно ниже, в самые низкоуровневые методы.</p></li>
<li><p><span>Аргументы метода</span> —какое их количество идеально?  В идеале их вовсе нет)) Но разве так бывает? Однако нужно стараться иметь их как можно меньше, ведь чем их меньше, тем проще использовать данный метод и легче его протестировать. Если сомневаешься, попробуй угадать все сценарии использования метода с большим количеством входящих аргументов.</p></li>
<li><p>Отдельно хотелось бы выделить методы, имеющие входящим аргументом некий <span>boolean флаг</span>, так как это само собой подразумевает, что данный метод реализует более одной операции (если true то одна, false — другая),. Как я писал выше, это не есть хорошо и по возможности этого следует избегать.</p></li>
<li><p>Если у метода <span>большое количество входящих аргументов</span> (крайнее значение — 7, но стоит задумываться уже после 2-3), необходимо сгруппировать некоторые аргументы в отдельном объекте.</p></li>
<li><p>Если <span>есть несколько похожих методов (перегруженных)</span>, то похожие параметры необходимо передавать в одном и том же порядке: это повышает читаемость и удобство использования.</p></li>
<li><p>Когда вы передаёте в метод параметры, вы должны быть уверены, что они все будут использованы, иначе зачем нужен этот аргумент? Выпилите его из интерфейса да и всё.</p></li>
<li><p><span><code>try/catch</code></span> выглядит по своей природе не очень красиво, поэтому неплохим ходом было бы вынести его в промежуточный отдельный метод (метод для обработки исключений):</p>
<pre class="lang-java line-numbers"><code>
public void exceptionHandling(SomeObject obj) {
    try {  
        someMethod(obj);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre></li></ol>Насчёт повторяющего кода я говорил выше, но добавлю и здесь:

Если у нас есть пара методов с повторяющимися частями кода, необходимо вынести его в отдельный метод, что повысит компактность как метода, так и класса.

И не стоит забывать о правильных наименованиях. Детали правильного именования классов, интерфейсов, методов и переменных я расскажу в следующей части статьи. 

А нам этом у меня сегодня всё.
<img src="/images/article/53561c00-66ea-45d6-a346-393b6c05929a/original.png" alt="Правила написания кода: от создания системы до работы с объектами - 9"><a href="https://javarush.com/groups/posts/2610-pravila-napisanija-koda-sila-praviljhnihkh-imenovaniy-khoroshie-i-plokhie-kommentarii" target="_blank" rel="nofollow">Правила написания кода: сила правильных именований, хорошие и плохие комментарии</a>