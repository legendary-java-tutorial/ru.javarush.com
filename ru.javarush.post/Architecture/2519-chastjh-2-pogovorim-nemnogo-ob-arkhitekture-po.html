Часть 2. Поговорим немного об архитектуре ПО
<p>----------------------------------------</p>
Этот материал — часть цикла “Введение в Enterprise-разработку”. Первая часть о сети — здесь. Архитектура программного обеспечения — структура, на базе которой создается приложение, взаимодействуют модули и компоненты всей программы...
<p>----------------------------------------</p>
Этот материал — часть цикла “<span class="text-bold">Введение в Enterprise-разработку</span>”. Первая часть о сети — <a href="https://javarush.com/groups/posts/2514-vvedenie-v-enterprise-razrabotku" target="_blank">здесь</a>.
<img data-max-width="850" alt="Часть 2. Поговорим немного об архитектуре ПО - 1" src="https://cdn.javarush.com/images/article/983160cf-f53c-483e-ba50-4736ef2f7bca/original.jpeg">Архитектура программного обеспечения — структура, на базе которой создается приложение, взаимодействуют модули и компоненты всей программы. 

За создание хорошей архитектуры программисты взялись еще очень давно, поэтому неудивительно, что сейчас нам известно немало архитектурных шаблонов. Разбираться в них нужно: когда пишешь веб-приложение, проблема архитектуры становится острой, ведь в ней компонентов и модулей больше, чем в обычном приложении. 

<span class="text-bold">Архитектурный шаблон</span> — это уже придуманный способ решения какой-то задачи по проектированию программного обеспечения. 

Ты уже наверняка сталкивался с такими паттернами проектирования как фабричный метод (Factory Method), абстрактная фабрика (Abstract Factory), строитель (Builder), прототип (Prototype), одиночка (Singleton) и, возможно, другими. Они используются  при простом написании кода, создании классов и планировании их взаимодействия. 

Архитектурные шаблоны задействуют на более высоком уровне абстракции — при планировании взаимодействия пользователя приложения с сервером, данными и другими компонентами проекта. Давай сразу рассмотрим некоторые шаблоны и то, как их использовать.
<h2>Клиент-серверная архитектура</h2>Из названия складывается впечатление, что с этой темой все просто и понятно. Но давай уточним кое-какие моменты, чтобы приступив к изучению условного Спринга ты точно понимал, о чем идет речь.

Допустим, ты написал чат, и вы с приятелем начинаете его использовать. Здесь возможен простой вариант — вы отправляете сообщение друг другу напрямую через интернет по IP-адресам, которые вы знаете:
<img data-max-width="800" data-id="f6f82190-e5a4-4cd0-9707-f1e77215ebad" src="/images/article/f6f82190-e5a4-4cd0-9707-f1e77215ebad/800.jpeg" class="img-fluid" alt="Часть 2. Поговорим немного об архитектуре ПО - 2">Поначалу может показаться, что все отлично работает, пока не появляется еще один ваш друг с вопросом: “А почему вы не добавите меня в свой чат?”. 

И вот когда ты решаешь добавить общего друга в чат, ты сталкиваешься с архитектурной проблемой: каждому пользователю чата нужно обновить информацию о количестве пользователей, добавить IP-адрес нового юзера. А еще при отправке сообщения оно должно доставляться всем участникам. Это самые очевидные проблемы из тех, которые возникнут. Еще куча проблем будет спрятана в самом коде.

Чтобы избежать их, нужно использовать <span class="text-bold">сервер</span>, который будет хранить всю информацию о пользователях, знать их адреса. Сообщение нужно будет отправить только на сервер. А он, в свою очередь, разошлет сообщение всем адресатам. Когда ты решишь добавить серверную часть в свой чат, ты начнешь строить клиент-серверную архитектуру.
<h2>Составляющие клиент-серверной архитектуры</h2>Давай  разберемся, что она представляет из себя.

<span class="text-bold">Клиент-серверная архитектура</span> — шаблон проектирования, основа для создания веб-приложений. Данная архитектура состоит из трех компонентов: 
<img data-max-width="850" alt="Часть 2. Поговорим немного об архитектуре ПО - 3" src="https://cdn.javarush.com/images/article/03864835-058e-4e09-b596-d2435f69bdd8/original.jpeg"><ol>
<li><p>Клиент — из названия становится понятно, что это пользователь сервиса (веб-приложения), который обращается к серверу для получения какой-то информации.</p></li>
<li>Сервер — место, где располагается твое веб-приложение или его серверная часть. Он владеет необходимой информацией о пользователях или может ее запрашивать. Также при обращении клиента сервер возвращает ему запрашиваемую информацию.<p></p></li>
<li><p>Сеть — все просто: обеспечивает обмен информацией между клиентом и сервером.</p></li>
</ol>Сервер может обрабатывать огромное количество запросов от разных юзеров. То есть клиентов может быть много, а если им нужно обменяться информацией между собой, делать это придется через сервер. Таким образом, сервер получает еще одну дополнительную функцию — контроль трафика. Если речь идет о созданном нами многопользовательском чате, весь программный код будет состоять из двух модулей:
<ul>
<li><p>клиентского — содержит графический интерфейс для авторизации, отправки/получения сообщений;</p></li>
<li><p>серверного — веб-приложение, которое размещается на сервере и принимает сообщения от пользователей, обрабатывает их, а потом отправляет адресатам.</p></li>
</ul><img data-max-width="850" alt="Часть 2. Поговорим немного об архитектуре ПО - 4" src="https://cdn.javarush.com/images/article/4e631129-5583-4856-b4cc-5eb7ea9d895f/original.jpeg">Когда мы хотим посмотреть полезную (или не очень полезную) информацию в интернете, мы открываем браузер, в строке поиска вводим запрос, и в ответ получаем информацию от поисковика.

В этой цепочке браузер — это наш клиент. Он отправляет запрос с информацией о том, что мы ищем, серверу. Сервер обрабатывает запрос, находит наиболее релевантные результаты, упаковывает их в понятный для браузера (клиента) формат и отправляет назад.

В таких сложных сервисах как поисковики серверов может быть много. Например, сервер авторизации, сервер для поиска информации, сервер для формирования ответа. Но клиент об этом ничего не знает: для него сервер является чем-то единым. Клиент знает только о точке входа, то есть, адресе сервера, которому нужно отправить запрос.

Вспомним о приложении, которое мы рассматривали в <a href="https://javarush.com/groups/posts/2514-vvedenie-v-enterprise-razrabotku" target="_blank">предыдущей части</a> — для мониторинга средней температуры воздуха во всех странах в режиме реального времени. Его архитектура будет выглядеть примерно так:
<img data-max-width="1024" alt="Часть 2. Поговорим немного об архитектуре ПО - 5" src="https://cdn.javarush.com/images/article/f7d657e1-af21-4b14-b9f8-681403e30468/original.jpeg">Наше приложение располагается на сервере. Скажем, каждые пять секунд оно отправляет запросы на серверы локальных гидрометцентров, получает у них информацию о температуре в конкретной стране, сохраняет эту информацию. Когда клиент обращается к нам с запросом “посмотреть текущую температуру воздуха в мире”, мы возвращаем последнюю сохраненную информацию, рассортированную по странам.

Таким образом наше приложение одновременно и сервер (когда обрабатывает запросы юзеров), и клиент (когда получает информацию у других серверов). 
<table class="table table--striped">
<tbody><tr>
<td>Важно: понятие <span class="text-bold">сервер — не о конкретном компьютере, а о взаимоотношениях абонентов сети</span>.</td>
</tr>
</tbody></table>Простая клиент-серверная архитектура применяется очень редко и только для очень простых приложений. Для действительно больших и сложных проектов используются разные типы архитектур, с которыми ты еще познакомишься в будущем. 

Сейчас же давай рассмотрим модель, очень похожую на клиент-серверную. 
<h2>Трехуровневая архитектура</h2>Это архитектурный шаблон, в котором появляется <span class="text-bold">третий участник — хранилище данных</span>. При использовании этого шаблона, три уровня принято называть слоями:
<img data-max-width="850" alt="Часть 2. Поговорим немного об архитектуре ПО - 6" src="https://cdn.javarush.com/images/article/73e74fea-a56a-4896-93a8-ce59adf542ec/original.jpeg"><ol>
<li><p>Клиентский слой — интерфейс пользователя. Это может быть веб-браузер, которому отправляются HTML-страницы, или графическое приложение, написанное с помощью JavaFX. Главное, чтобы с его помощью пользователь мог отправлять запросы на сервер и обрабатывать его ответы.</p></li>
<li><p>Слой логики — сервер, на котором происходит обработка запросов/ответов. Часто его еще называют серверным слоем. Также здесь происходят все логические операции: математические расчеты, операции с данными, обращения к другим сервисам или хранилищам данных.</p></li>
<li><p>Слой данных — сервер баз данных: к нему обращается наш сервер. В этом слое сохраняется вся необходимая информация, которой пользуется приложение при работе.</p></li>
</ol>Таким образом, наш сервер принимает на себя все обязательства по обращению к данным, не давая возможности юзеру обратиться к ним напрямую. 
<h2>Преимущества трехуровневой архитектуры</h2>Используя такую архитектуру, мы получаем немало плюсов, среди которых:
<ol>
<li><p>Возможность построить защиту от SQL-инъекций — это атака на сервер, при которой передается SQL-код, и при выполнении этого кода злоумышленник может воздействовать на нашу базу данных.</p></li>
<li><p>Разграничение данных, к которым мы хотим регулировать пользовательский доступ.</p></li>
<li><p>Возможность модифицировать данные перед отправкой клиенту.</p></li>
<li><p>Масштабируемость — возможность расширить наше приложение на несколько серверов, которые будут использовать одну и ту же базу данных.</p></li>
<li><p>Меньшие требования к качеству соединения пользователя. Формируя ответ на сервере, мы часто берем из базы данных много различной информации, форматируем ее, оставляя только то, что нужно юзеру. Таким образом мы сокращаем объем информации, который отправим в качестве ответа клиенту.</p></li>
</ol><div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><h2>Как часто нужно использовать архитектурные шаблоны?</h2>Если ты знаком, скажем, с паттерном проектирования <a href="https://javarush.com/groups/posts/2372--patternih-proektirovanija-factorymethod" target="_blank">Фабричный метод</a>, ты наверняка задумывался, когда его стоит использовать. Иногда трудно определиться, что делать: создать объект с помощью оператора new или использовав фабричный метод. Но со временем понимание приходит. 

С архитектурными шаблонами дела обстоят немного иначе. 

Enterprise-фреймворки рассчитаны на то, что программист с их помощью создает проект на основе какого-то общепринятого паттерна. Поэтому перед изучением Spring Framework тебе обязательно нужно понимать, что такое клиент-серверная архитектура, трехуровневая архитектура и MVC-архитектура. Не переживай: об MVC-архитектуре мы еще поговорим.

<a href="https://javarush.com/groups/posts/2514-vvedenie-v-enterprise-razrabotku" target="_blank">Часть 1. Что нужно знать перед изучением Spring и JavaEE</a> 
<a href="https://javarush.com/groups/posts/2521-chastjh-3-protokolih-httphttps" target="_blank">Часть 3. Протоколы HTTP/HTTPS</a>
<a href="https://javarush.com/groups/posts/2523-chastjh-4osnovih-maven" target="_blank">Часть 4.Основы Maven</a>
<a href="https://javarush.com/groups/posts/2529-chastjh-5-servletih-pishem-prostoe-veb-prilozhenie" target="_blank">Часть 5. Сервлеты. Пишем простое веб-приложение</a>
<a href="https://javarush.com/groups/posts/2533-chastjh-6-konteynerih-servletov" target="_blank">Часть 6. Контейнеры сервлетов</a>
<a href="https://javarush.com/groups/posts/2536-chastjh-7-znakomstvo-s-patternom-mvc-model-view-controller" target="_blank">Часть 7. Знакомство с паттерном MVC (Model-View-Controller)</a>
<a href="https://javarush.com/groups/posts/2537-chastjh-8-pishem-neboljhshoe-prilozhenie-na-spring-boot" target="_blank">Часть 8. Пишем небольшое приложение на spring-boot</a>