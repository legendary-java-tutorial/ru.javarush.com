Правила написания кода: сила правильных именований, хорошие и плохие комментарии
<p>----------------------------------------</p>
Как часто вам приходилось разбираться в чужом коде? Когда вместо пары часов ты тратишь дни, чтобы просто разобраться в логике происходящего. Самое забавное, что для человека, писавшего данный код, тут всё ясно...
<p>----------------------------------------</p>

<img data-max-width="256" src="/images/article/ac29136e-db21-4474-b311-aed74a37f929/original.jpeg" class="img-fluid" alt="Правила написания кода: сила правильных именований, хорошие и плохие комментарии - 1">
Как часто вам приходилось разбираться в чужом коде? Когда вместо пары часов ты тратишь дни, чтобы просто разобраться в логике происходящего. Самое забавное, что для человека, писавшего данный код, тут всё ясно и весьма прозрачно. И это не мудрено: ведь совершенный или идеальный код — это весьма размытое понятие, ибо у каждого разработчика своё видение на мир и на код, соответственно, тоже. Не раз сталкивался с ситуацией, когда я и мой коллега смотрели на один и тот же код имели разное мнение насчет его корректности и чистоты.

<img data-max-width="512" src="/images/article/bfd3bcd7-705c-4c57-8ee5-1b2e86d38135/original.jpeg" class="img-fluid" alt="Правила написания кода: сила правильных именований, хорошие и плохие комментарии - 2" border="0">Знакомое чувство, не правда ли? Тем не менее, есть некоторые моменты, проверенные временем, которых стоило бы придерживаться, что в итоге сыграет нам на руку, ведь если вы будете оставлять свой  код в таком состоянии, в каком хотели бы сами хотели его получить, мир стал бы немножечко счастливей и чище.
<img data-max-width="800" src="/images/article/db9f84e6-2b37-4b39-b103-505796470138/original.jpeg" class="img-fluid" alt="Правила написания кода: сила правильных именований, хорошие и плохие комментарии - 3">В своей <a href="https://javarush.com/groups/posts/2573-pravila-napisanija-koda-ot-sozdanija-sistemih-do-rabotih-s-obhhektami" target="_blank">прошлой статье</a> о правилах написания кода (а точнее, небольшом руководстве), мы немного пощупали рекомендации по написанию системы в целом и таких ее элементах как объекты, их интерфейсы, классы, методы и переменные.

Там же я вскользь упоминал про правильные именования тех или иных элементов. Сегодня мне хотелось бы поговорить именно об этом, ведь правильные названия облегчают читаемость кода в разы. Закрывать же тему правильного кода будем с помощью размышлений и небольших примеров   комментариев в коде —  хорошо это или всё же не очень.

Итак, давайте приступим.
<h2>Правильные именования</h2>Правильные названия улучшают читабельность кода, соответственно экономя время на ознакомление, ведь куда проще использовать метод, когда название примерно описывает его функционал. Так как в коде все состоит из названий (переменные, методы, классы, объекты файлы и т. д.), этот пункт становится очень важным при создании правильного, чистого кода.

Исходя из вышесказанного, имя должно передавать смысл, почему, например,  переменная существует, что она делает и как используется. Ещё не раз отмечу, что лучшим комментарием для описания переменной служит ее правильное имя.
<img data-max-width="512" src="/images/article/4fd73291-495e-417a-9992-451d69300875/original.jpeg" class="img-fluid" alt="Правила написания кода: сила правильных именований, хорошие и плохие комментарии - 4"><h3>Именование интерфейсов</h3>Интерфейсы, как правило, используют имена, начинающиеся с большой буквы и написаны в верблюжьем стиле (CamelCase).

Раньше при написании интерфейса хорошей практикой считалось добавить префикс I для обозначения его как интерфейса (например, IUserService), но это выглядит весьма уродливо и отвлекает. В таких случая лучше писать без него (UserService), а к реализации его добавить -Impl (UserServiceImpl). Ну или на крайний случай, к его реализации добавить префикс С (СUserService).  
<h3>Названия классов</h3>Так же, как и у интерфейсов, имена пишутся с большой буквы и используют верблюжий стиль (CamelCase).

Какой бы ни творился апокалипсис, как бы нb горели сроки, но никогда, запомните — никогда имя класса не должно быть глаголом! Имена классов и объектов должны быть существительными и их комбинациями (UserController, UserDetails, UserAccount, и так далее).

Не следует снабжать имя каждого класса аббревиатурой данного приложения, так как это лишь добавит излишнюю сложность (например, у нас приложение User Data Migration, и мы к каждому классу добавим UDM — UDMUserDeatils, UDMUserAccount, UDMUserController).
<h3>Имена методов</h3>Обычно названия методов начинаются с маленькой буквы, но и они юзают верблюжий стиль (СamelCase).

Выше мы говорили про то, что имена классов никогда не должны быть глаголами. Тут же ситуация диаметрально противоположная: наименования методов как раз-таки должны быть  глаголами или их сочетаниями с глаголами: findUserById, findAllUsers, createUser и так далее. 

При создании метода (как впрочем, и переменных и классов), чтобы не запутаться, используйте один подход в именовании. Например, для поиска пользователя метод можно написать как getUserById или findUserById.

И ещё: не используйте в названиях методов юмор, ибо шуточку могут и не понять, как и то, что делает этот метод.
<h3>Названия переменных</h3>В большинстве случаев имена переменных начинаются с маленькой буквы и тоже используют Сamelcase, не считая тех случаев, когда переменная — это глобальная константа. В таких случаях все буквы имени написаны в верхнем регистре и слова разделены нижним подчеркиванием — “_”.

При именовании переменных для удобства можно использовать содержательный контекст. Иначе говоря, когда есть переменная как часть чего-то большего — например, firstName, lastName, status — в таких случаях можно добавить приставку, указывающую на объект, частью которого является данная переменная. Например: userFirstName, userLastName, userStatus.

Ещё нужно избегать похожих имен для переменных, когда они имеют совершенно разную суть. Часто встречаемые антонимы для переменных:
<ul>
<li>begin/end</li>
<li>first/last</li>
<li>locked/unlocked</li>
<li>min/max</li>
<li>next/previous</li>
<li>old/new</li>
<li>opened/closed</li>
<li>visible/invisible</li>
<li>source/target</li>
<li>source/destination</li>
<li>up/down</li>
</ul><h3>Короткие имена переменных</h3>Когда у нас есть переменные вида x или n или что-то вроде этого, мы сходу и не увидим намерения человека, писавшего код. Неочевидно, что делает метод n: он требует более вдумчивого осмысления (а это время время, время).

Например, у нас есть поле — id ответственного пользователя, и вместо какого-нибудь имени типа — x или просто id, мы назовем эту переменную responsibleUserId, что сходу нам повышает читаемость и осмысленность.

Тем не менее, короткие имена вида n имеют место быть в качестве локальных перемен небольших методов, где блок кода с этой переменой — всего лишь пара строк кода, и имя метода прекрасно описывает, что там происходит.

Разработчик, увидев такую переменную, понимает её второстепенность и весьма ограниченную область видимости. По итогу есть некая зависимость от длины имени переменных: чем длиннее оно, тем более глобальная переменная и наоборот. Как пример, метод для поиска последнего сохраненного пользователя по дате:

<pre class="lang-java line-numbers"><code>
public User findLastUser() {
   return findAllUsers().stream()
           .sorted((x, y) -&gt; -x.getCreatedDate().compareTo(y.getCreatedDate()))
           .findFirst()
           .orElseThrow(() -&gt; new ResourceNotFoundException("Any user doesn't exist "));
}
</code></pre>
Тут мы используем короткие именования x и y для задания сортировки стрима, и забываем про них.
<h3>Оптимальная длина</h3>Продолжим тему длины имён. Оптимальная длина имени — где-то между длиной имен maximumNumberOfUsersInTheCurrentGroup и n. 

То есть, слишком короткие страдают от недостатка смысла, а слишком длинные растягивают программу, не добавляя читабельности, и их просто лень каждый раз писать. Не учитывая вышеописанного случая, для переменных с коротким именем вида n нужно придерживаться длины примерно 8 -16 символов. Это не строгое правило: скорее как ориентир.
<h3>Малые различия</h3>Не могу пройти мимо и малозаметных различий в именах, ведь это тоже плохая практика, так как можно просто напутать или потратить много лишнего времени на то, чтобы заметить незначительные различия в именах. Например, различие  между InvalidDataAccessApiUsageException и InvalidDataAccessResourceUsageException беглым взглядом сложно обнаружить. 

Также часто дезинформация может возникнуть при использовании маленьких L и O, ведь их можно легко перепутать с 1 и 0: в некоторых шрифтах различие более очевидное, в некоторых — менее.
<h3>Смысловая часть</h3>Нужно вкладывать смысловую часть в названия, но не переигрывать с синонимами, так как, к примеру, у UserData и UserInfo фактически один и тот же смысл, и придется немного поковыряться в коде, чтобы понять, какой конкретно объект нам нужен.

Избегайте неинформативных слов, к примеру,  firstNameString: к чему нам слово string? Разве может быть имя объектом типа даты? Конечно, нет: поэтому просто — firstName. 

Ещё в качестве примера хотелось бы отметить boolean переменные, например, — flagDelete. Слово flag не несёт никакой смысловой нагрузки. Более разумным было назвать — isDelete.
<h3>Дезинформация</h3>Также хотелось бы сказать пару слов о неправильных именованиях. Допустим, у нас есть именование userActivityList, и при этом названный так объект имеет не тип List, а какой-нибудь другой контейнер или кастомный объект для хранения. Это может ввести рядового программиста в ступор: уж лучше назвать как-то вроде userActivityGroup или userActivities.
<h3>Поиск</h3>Одним из недостатков коротких и простых имен является то, что их сложно искать в большом объёме кода, ведь что будет проще найти: переменную с именем name или NAME_FOR_DEFAULT_USER? Конечно же, второй вариант. 

Нужно избегать в названиях часто встречаемых слов (букв), так это будет лишь увеличивать количество найденных файлов при поиске, что не есть гуд.

Хотелось бы напомнить, что за чтением кода программисты проводят больше времени, нежели за его написанием, так что с головой подходите к наименованию элементов вашего приложения. 

Но что если удачно назвать не получилось? Если название метода плохо описывает его функционал? Тут и выходит на сцену, наш следующий пункт — комментарии
<h3>Комментарии</h3><img data-max-width="512" src="/images/article/aec80831-d348-4436-b041-89029de00cc1/original.jpeg" class="img-fluid" alt="Правила написания кода: сила правильных именований, хорошие и плохие комментарии - 5">Нет ничего лучше уместного комментария, но и ничто не загромождает модуль так, как бессодержательные, устаревшие или ложные комментарии. Палка о двух концах, не правда ли? Всё же не стоит относиться к комментариям как к однозначному добру: скорее как к меньшему злу. Ведь комментарий, по своей сути — это компенсация неудачно выраженной мысли в коде.

К примеру, мы используем их, чтобы как-то донести суть метода, если он оказался уж больно запутан. В такой ситуации лучше грамотно отрефакторить код, нежели писать описывающие пометки.

Чем древнее коммент, тем хуже, ведь код имеет свойство разрастаться и эволюционировать, а комментарий может остаться тем же, и чем дальше, тем более сомнительны эти заметки. Неточные комменты гораздо хуже, нежели их отсутствие, ведь они сбивают с толку и обманывают, давая ложные ожидания. И даже если у нас есть очень хитрый код, всё же то стоит не комментировать его, а переписать.
<h3>Разновидности комментариев</h3><ul>
<li><p><span class="text-bold">юридические комментарии</span> — комментарии, оставляемые в начале каждого файла с исходным кодом, по юридическим соображениям, как например:
</p><pre class="lang-java line-numbers"><code>
* Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
* ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
</code></pre><p></p></li>
<li><p><span class="text-bold">информативные комментарии</span> — комментарии, представляющие пояснение к коду (предоставляющие дополнительную информацию или намерения данного участка кода.</p>
<p>Как пример:
</p><pre class="lang-java line-numbers"><code>
/*
* Объединяет пользователя из бд и пришедшего для обновления
* Когда в requestUser поле пустое, оно заполняется старыми данными из foundUser
*/
private User mergeUser(User requestUser, User foundUser) {
       return new User(
       foundUser.getId(),
       requestUser.getFirstName() == null ? requestUser.getFirstName() : foundUser.getFirstName(),
       requestUser.getMiddleName() == null ? requestUser.getMiddleName() : foundUser.getMiddleName(),
       requestUser.getLastName() == null ? requestUser.getLastName() : foundUser.getLastName(),
       requestUser.getAge() == null ? requestUser.getAge() : foundUser.getAge()
       );
       }
</code></pre><p></p>
<p>В этом случае можно обойтись и без комментариев, так как название метода и его аргументов вкупе с весьма прозрачным функционалом, сами себя неплохо описывают.</p></li>
<li><p><span class="text-bold">предупреждающий комментарий</span> — комментарий, целью которого является предупредить других разработчиков о нежелательных последствиях какого-то действия (например, почему тест был помечен как @Ignore):</p>
<pre class="lang-java line-numbers"><code>
// Слишком долго отрабатывает
// Не запускайте, если не располагаете избытком времени
@Ignore
@Test
public void someIntegrationTest() {
       ……
       }
</code></pre></li>
<li><p><span class="text-bold">TODO</span> — комментарии, которые являются заметкой на будущее, что нужно будет сделать, но по какой-то причине нельзя сделать сейчас. Это неплохая практика, но всё же их нужно регулярно просматривать для удаления неактуальных, чтобы избежать нагромождения.</p>
<p>Примером послужит:
</p><pre class="lang-java line-numbers"><code>
//TODO: Add a check for the current user ID (when will be created security context)

@Override
public Resource downloadFile(File file) {
       return fileManager.download(file);
       }
</code></pre><p></p>
<p>Тут мы помечаем, что нужно добавить проверку юзера, который скачивает (id которого мы вытащим из security контекста) с тем, кто сохранил.</p></li>
<li><p><span class="text-bold">усиливающий комментарий</span> — комментарий, подчеркивающий важность какого-то обстоятельства, что на первый взгляд может показаться несущественным.</p>
<p>Как пример, кусочек метода, заполняющий тестовую БД, некими скриптами:
</p><pre class="lang-java line-numbers"><code>
Stream.of(IOUtils.resourceToString("/fill-scripts/" + x, StandardCharsets.UTF_8)
       .trim()
       .split(";"))
       .forEach(jdbcTemplate::update);
// Вызов trim() очень важен, убирает возможные пробелы в конце скрипта
// чтобы при считке и разбивке на отдельные запросы не было пустых
</code></pre><p></p></li>
<li><p><span class="text-bold">javaDoc</span> — комментарии, которые описывают API определенного функционала для общего пользования. Наверное, самые полезные комментарии, так как с документированным API в разы легче работать, но они также могут устаревать, как и любые другие. Поэтому не забываем, что главный вклад в документацию вносится не комментариями, а хорошим кодом.</p>
<p>Пример вполне обычного метода обновления пользователя:
</p><pre class="lang-java line-numbers"><code>
/**
* Обновляет передаваемые поля для пользователя по id.
*
* @param id  id обновляемого пользователя
* @param user пользователь с заполненными полями для обновления
* @return обновленный пользователь
*/
       User update(Long id, User user);
</code></pre><p></p></li></ul><h3>Плохие сценарии комментариев</h3><img data-max-width="512" src="/images/article/7b415b05-37b7-46f6-bd29-4f758a346d99/original.jpeg" class="img-fluid" alt="Правила написания кода: сила правильных именований, хорошие и плохие комментарии - 7"><ul>
<li><p><span class="text-bold">бормочущий комментарий</span> — комментарии, которые обычно пишут на скорую руку, смысл которых понятен только разработчику, писавшего их, так как только он видит ту ситуацию с теми нюансами, на которые он и ссылается.</p>
<p>Рассмотрим данный пример:
</p><pre class="lang-java line-numbers"><code>
public void configureSomeSystem() {
       try{
       String configPath = filesLocation.concat("/").concat(CONFIGURATION_FILE);
       FileInputStream stream = new FileInputStream(configPath);
       }  catch (FileNotFoundException e) {
       //В случае отсутствия конфигурационного файла, загружается конфигурация по умолчанию 
      }
}
</code></pre><p></p>
<p>Кто загружает эти настройки? Были ли они загружены ранее? Метод предназначен для перехвата исключений и вызова дефолтных настроек? Слишком много вопросов возникает, ответы на которые можно получить лишь углубившись в изучение других частей системы.</p></li>
<li><p><span class="text-bold">избыточный комментарий</span> — комментарий, который не несёт смысловой нагрузки, так как и так понятно что происходит в заданном участке кода (он читается не проще, чем код).</p>
<p>Смотрим пример:
</p><pre class="lang-java line-numbers"><code>
public class JdbcConnection{
public class JdbcConnection{
   /**
    * Журнальный компонент, связанный с текущим классом
    */
   private Logger log = Logger.getLogger(JdbcConnection.class.getName());

   /**
    * Создаёт и возвращает connection с помощью входящих параметров
    */
   public static Connection buildConnection(String url, String login, String password, String driver) throws Exception {
       Class.forName(driver);
       connection = DriverManager.getConnection(url, login, password);
       log.info("Created connection with db");
       return connection;
   }
</code></pre><p></p>
<p>Какой смысл таких комментариев, если мы и так всё прекрасно видим</p></li>
<li><p><span class="text-bold">недостоверные комментарии</span> — комментарии, не соответствующие истине и лишь вгоняющие в заблуждение (дезинформирующие).
Как например:
</p><pre class="lang-java line-numbers"><code>
/**
* Вспомогательный метод, закрывает соединение со сканером, если isNotUsing истинно
*/
private void scanClose(Scanner scan, boolean isNotUsing) throws Exception {
   if (!isNotUsing) {
       throw new Exception("The scanner is still in use");
   } scan.close();
}
</code></pre><p></p>
<p>Что в этом комменте не так? А то, что он немножко врёт нам, ведь соединение закрывается, если isNotUsing = false, но никак не наоборот, как нам вещает пометка.</p></li>
<li><p><span class="text-bold">обязательные комментарии</span> — комментарии, которые считают обязательными (Javadoc), но кои по факту иногда бывают излишне нагромождающими, недостоверными и ненужными (нужно задуматься, а нужны ли здесь такие комментарии).</p>
<p>Пример:</p>
<pre class="lang-java line-numbers"><code>
/**
*  Создание пользователя по переданным параметрам
* @param firstName имя созданного пользователя
* @param middleName среднее имя созданного пользователя
* @param lastName фамилия созданного пользователя
* @param age возраст созданного пользователя
* @param address адресс созданного пользователя
* @return пользователь который был создан
*/
User createNewUser(String firstName, String middleName, String lastName, String age, String address);
</code></pre><p></p>
<p>Смогли бы вы понять, что делает метод без этих комментариев? Скорее всего да, поэтому комментарии в этом случае стают бессмысленными.</p></li>
<li><p><span class="text-bold">журнальные комментарии</span> — комментарии, которые иногда добавляют в начало модуля, при каждом его редактировании (что-то вроде журнала вносимых изменений).
</p><pre class="lang-java line-numbers"><code>
/**
*  Записи ведутся с 09 января 2020;
**********************************************************************
*  09.01.2020  : Обеспечение соединения с БД с помощью Jdbc Connection;
*  15.01.2020  : Добавление интерфейсов уровня дао для работы с БД;
*  23.01.2020  : Добавление интеграционных тестов для БД;
*  28.01.2020  : Имплементация интерфейсов уровня дао;
*  01.02.2020  : Разработка интерфейсов для сервисов,
*  согласно требованиям прописанным в user stories;
*  16.02.2020  : Имплементация интерфейсов сервисов
*  (реализация бизнес логики связанной с работой БД);
*  25.02.2020  : Добавление тестов для сервисов;
*  08.03.2020  : Празднование восьмого марта(Миша опять в хлам);
*  21.03.2020  : Рефакторинг сервис слоя;
*/

</code></pre><p></p>
<p>Когда-то этот проход был оправдан, но с появлением систем управления исходным кодом (например — Git), это стало лишним нагромождением и усложнением кода.</p></li>
<li><p>комментарии ссылки на авторов — комментарии, предназначением которых является, указание человека, писавшего код, чтобы можно было связаться и обсудить, как что и зачем:
</p><pre class="lang-java line-numbers"><code>
* @author  Bender Benderovich
</code></pre><p></p>
<p>Опять же, системы контроля версий прекрасно запоминают, кто и когда добавил данный код, и подобный подход излишен.</p></li>
<li><p><span class="text-bold">закомментированный код</span> — код, который был по тем или иным причинам закомментирован. Одна из самых плохих привычек, ибо вы закомментировали и забыли, а у других разработчиков просто не хватит храбрости его удалить (а вдруг это что-то ценное).
</p><pre class="lang-java line-numbers"><code>
//    public void someMethod(SomeObject obj) {
//    .....
//    }
</code></pre><p></p>
<p>Как итог он — скапливается, как хлам. Ни в коем случае нельзя оставлять подобный код. Если уж очень нужно, не забываем опять же про систему контроля версий.</p></li>
<li><p><span class="text-bold">неочевидные комментарии</span> — комментарии, которые излишне сложно описывают что-либо.
</p><pre class="lang-java line-numbers"><code>
/*
    * Начать с массива, размер которого достаточен для хранения
    * всех байтов данных (плюс байты фильтра) с запасом, плюс 300 байт
    * для данных заголовка
    */
this.dataBytes = new byte[(this.size * (this.deep + 1) * 2)+300];
</code></pre><p></p>
<p>Комментарий должен объяснять код, а не сам нуждаться в объяснениях. А что тут? Что за «байты фильтра»? При чём здесь +1? Почему именно 300?</p></li></ul>Если уж решили писать комменты, вот пара советов по их использованию:
<ol>
<li>Используйте стили, которые будет легко поддерживать: поддерживать слишком причудливые и экзотические стили надоедает и съедает немало времени.</li>
<li>Не используйте комментарии в конце строк, относящихся к одиночным строкам: получается большое нагромождение комментов, при этом трудно придумать выразительный комментарий для каждой строки.</li>
<li>Придумывая комментарий, постарайтесь ответить на вопрос: «почему», а не «как».</li>
<li>Избегайте сокращений. Как и говорил выше, нам не нужно объяснение для комментария: комментарий и есть объяснение.</li>
<li>Можно использовать комментарии для пометки единиц измерения и диапазона допустимых величин.</li>
<li>Располагайте комментарии близко к описываемому ими коду.</li>
</ol>Как итог всё же хочется напомнить:  лучшие комментарий — это отсутствие комментария, а вместо него — грамотное именование в приложении.

Как правило, большинство времени мы будем уже работать уже с готовым кодом, с его поддержанием и расширением. Гораздо удобнее, когда данный код удобно читаем и понятен, ведь плохой код мешает, ставит те еще палки в колёса и спешка — его верный товарищ. И чем больше у нас плохого кода, тем больше падает производительность, поэтому нужно время от времени устраивать рефакторинг. Но если с самого начала стараться писать код, за который вас не захотят найти и убить следующие разработчики, то и рефакторить его нужно будет реже. Но всё же нужно будет, так как условия, требования к продукту постоянно меняются, дополняются навешивая дополнительные связи, и от этого не убежать.

Напоследок оставлю пару интересных ссылок для ознакомления с данной темой <a href="https://refactoring.guru/ru/refactoring/what-is-refactoring" rel="nofollow" target="_blank">тут</a>, <a href="https://dou.ua/lenta/articles/perfect-code/" rel="nofollow" target="_blank">тут</a> и <a href="https://javarush.com/groups/posts/560-kak-napisatjh-chistihy-kod" target="_blank">тут</a>

Пожалуй, на этом у меня сегодня всё, спасибо всем кто дочитал))
<img data-max-width="512" src="/images/article/004ee61b-7330-46e6-9aef-9ca32d1b5edd/original.jpeg" class="img-fluid" alt="Правила написания кода: сила правильных именований, хорошие и плохие комментарии - 8">