Как устроен рефакторинг в Java
<p>----------------------------------------</p>
Помимо написания кода, в задачи программиста входят поддержка и рефакторинг кода — изменение его структуры без изменения функционала. Сегодня разберем “запахи” кода и техники рефакторинга. Во время обучения программированию много времени уделяется написанию кода...
<p>----------------------------------------</p>
Во время обучения программированию много времени уделяется написанию кода. Большинство начинающих разработчиков считают, что в этом и состоит их будущая деятельность. Отчасти это так, но в задачи программиста также входят поддержка и рефакторинг кода. Сегодня поговорим о рефакторинге. 

<img data-id="8d1cc9b5-7dcb-42f6-8a4e-981edbc3fc46" data-max-width="850" alt="Как устроен рефакторинг в Java - 1" src="https://cdn.javarush.com/images/article/8d1cc9b5-7dcb-42f6-8a4e-981edbc3fc46/1024.jpeg"><h2>Рефакторинг в курсе JavaRush</h2>В курсе JavaRush тема рефакторинга затрагивается дважды:
<ul>
<li><a href="https://javarush.com/quests/lectures/questmultithreading.level05.lecture16" target="_blank">Большая задача на уровне 5 квеста Multithreading</a>;</li>
<li><a href="https://javarush.com/quests/lectures/questcollections.level09.lecture07" target="_blank">Лекция о рефакторинге в Intellij IDEA на 9 уровне квеста Java Collections</a>.</li>
</ul>Благодаря большой задаче, есть возможность познакомиться с настоящим рефакторингом на практике, а лекция о рефакторинге в IDEA поможет разобраться с автоматическими средствами, которые невероятно облегчают жизнь.
<h2>Что такое рефакторинг?</h2>Это изменение структуры кода без изменения его функционала. Например, есть метод, который сравнивает 2 числа и возвращает <em>true</em>, если первое больше, и <em>false</em> в обратном случае:

<pre class="lang-java line-numbers"><code>
   public boolean max(int a, int b) {
       if(a &gt; b) {
           return true;
       } else if(a == b) {
           return false;
       } else {
           return false;
       }
   }
</code></pre>
Получился очень громоздкий код. Даже новички редко пишут подобное, однако такой риск есть. Казалось бы, зачем тут блок <code>if-else</code>, если можно написать метод на 6 строк короче:

<pre class="lang-java line-numbers"><code>
public boolean max(int a, int b) {
     return a&gt;b;
}
</code></pre>
Теперь этот метод выглядит просто и элегантно, хотя выполняет то же действие, что и пример выше. Так и работает рефакторинг: меняет структуру кода, не затрагивая его суть. Существует множество методов и техник рефакторинга, которые рассмотрим подробнее.
<h2>Для чего нужен рефакторинг?</h2>Существует несколько причин. Например, погоня за простотой и лаконичностью кода. Сторонники этой теории считают, что код должен быть максимально кратким, даже если для его понимания нужно несколько десятков строк комментарий. Другие разработчики уверены, что код должен подвергаться рефакторингу настолько, чтобы он был понятен с минимальным количеством комментариев. 

Каждая команда выбирает свою позицию, но нужно помнить, что <strong>рефакторинг — это не сокращение</strong>. 

<strong>Его главная цель — улучшить структуру кода.</strong>

В эту глобальную цель можно включить несколько задач:
<ol>
<li>Рефакторинг улучшает понимание кода, который написан другим разработчиком;</li>
<li>Помогает искать и устранять ошибки;</li>
<li>Позволяет повысить скорость разработки ПО;</li>
<li>В целом улучшает композицию программного обеспечения.</li>
</ol>Если долгое время не проводить рефакторинг, могут возникнуть сложности в разработке вплоть до полной остановки работы. 
<h2>“Запахи кода“</h2>Когда код требует рефакторинга говорят, что он “пахнет”. Конечно, не буквально, но такой код действительно выглядит не совсем приятно. Ниже рассмотрим основные техники рефакторинга для начального этапа. 
<h3>Неоправданно большие элементы</h3>Существуют громоздкие классы и методы, с которыми невозможно эффективно работать именно из-за их огромного размера. 
<h4>Большой класс</h4>У такого класса есть огромное количество строк кода и много различных методов. Обычно разработчику легче добавить фичу в существующий класс, а не создавать новый, из-за чего он и растет. Как правило, функционал такого класса перегружен. В этом случае помогает выделение части функционала в отдельный класс. Об этом поговорим подробнее в разделе техник рефакторинга.
<h4>Большой метод</h4>Этот “запах” возникает, когда разработчик добавляет в метод новый функционал. “Зачем мне выносить проверку параметров в отдельный метод, если я могу написать ее тут?”, “Для чего необходимо выделять метод поиска максимального элемента в массиве, оставим его тут. Так код яснее”, — и прочие заблуждения. 

<strong>Есть два правила рефакторинга большого метода:</strong>
<ol>
<li>Если при написании метода хочется добавить комментарий в код, необходимо выделить этот функционал в отдельный метод;</li>
<li>Если метод занимает более 10-15 строк кода, следует определить задачи и подзадачи, которые он выполняет, и попробовать вынести подзадачи в отдельный метод.</li>
</ol>Несколько способов устранить большой метод:
<ul>
<li>Выделить часть функционала метода в отдельный метод;</li>
<li>Если локальные переменные не дают вынести часть функционала, можно передать весь объект в другой метод.</li>
</ul><h4>Использование множества примитивных типов данных</h4>Обычно такая проблема возникает, когда с течением времени в классе растет количество полей для хранения данных. Например, если использовать примитивные типы вместо маленьких объектов для хранения данных (валюта, дата, телефонные номера и т.д.) или константы для кодирования какой-либо информации.

Хорошей практикой в этом случае будет логическая группировка полей и вынос в отдельный класс (выделение класса). Также в класс можно включить методы для обработки этих данных.
<h4>Длинный список параметров</h4>Достаточно распространенная ошибка, особенно в совокупности с большим методом. Обычно она возникает, если функционал метода перегружен, или метод объединяет несколько алгоритмов в себе.

В длинных списках параметров очень трудно разбираться, и использовать такие методы неудобно. Поэтому лучше передать объект целиком. Если у объекта нет достаточно данных, стоит использовать более общий объект или разделить функционал метода, чтобы он обрабатывал логически связанные данные.
<h4>Группы данных</h4>Часто в коде появляются логически связанные группы данных. Например, параметры подключения в БД (URL, имя пользователя, пароль, имя схемы и тд). Если из перечня элементов нельзя удалить ни одно поле, значит перечень — это группа данных, которую необходимо вынести в отдельный класс (выделение класса). 
<h3>Решения, которые портят концепцию ООП</h3>“Запахи” этого типа возникают, когда разработчик нарушает дизайн ООП. Такое происходит, если он не до конца понимает возможности этой парадигмы, использует их не до конца или неправильно.
<h4>Отказ от наследования</h4>Если подкласс использует минимальную часть функций родительского класса, тут пахнет неправильной иерархией. Обычно в таком случае ненужные методы просто не переопределяются или выбрасывают исключения. Если класс унаследован от другого, это подразумевает под собой практически полное использование его функционала. Пример правильной иерархии:
<img data-id="60869144-96bb-4fcd-9e05-62751a30791d" data-max-width="850" alt="Как устроен рефакторинг в Java - 2" src="https://cdn.javarush.com/images/article/60869144-96bb-4fcd-9e05-62751a30791d/1024.jpeg">
Пример неправильной иерархии:
<img data-id="84ac1328-587a-42d8-bf33-8beef0f0f476" data-max-width="850" alt="Как устроен рефакторинг в Java - 3" src="https://cdn.javarush.com/images/article/84ac1328-587a-42d8-bf33-8beef0f0f476/1024.jpeg"><h4>Оператор switch</h4>Что плохого может быть в операторе <code>switch</code>? Он плох, когда его конструкция очень сложная. Также сюда относятся и множество вложенных блоков <code>if</code>.
<h4>Альтернативные классы с разными интерфейсами</h4>Несколько классов фактически выполняют одно и то же, но их методы называются по-разному. 
<h4>Временное поле</h4>Если в классе заложено временное поле, которое нужно объекту лишь изредка, когда он заполняется значениями, а в остальное время — пустое или, не дай бог, <code>null</code>, значит код “попахивает”, а такой дизайн — сомнительное решение.
<h3>Запахи, которые затрудняют модификацию</h3>Эти “запахи” более серьезные. Остальные в основном ухудшают понимание кода, тогда как эти не дают возможность его модифицировать. При внедрении каких-либо фич половина разработчиков уволится, а половина сойдет с ума.
<h4>Параллельные иерархии наследования</h4>При создании подкласса какого-либо класса необходимо создавать еще один подкласс для другого класса.
<h4>Равномерное распределение зависимости</h4>При выполнении любых модификаций приходится искать все зависимости (использования) этого класса и вносить множество мелких правок. Одно изменение — правки во множестве классов.
<h4>Сложное дерево модификаций</h4>Этот запах противоположен предыдущему: изменения затрагивают большое количество методов одного класса. Как правило, зависимость в таком коде каскадная: изменив один метод, нужно поправить что-то в другом, а затем в третьем и так далее. Один класс — множество изменений.
<h3>“Мусорные запахи”</h3>Достаточно неприятная категория запахов, которая вызывает головную боль. Бесполезный, ненужный, старый код. К счастью, современные IDE и линтеры научились предупреждать о таких запахах.
<h4>Большое количество комментариев в методе</h4>У метода очень много поясняющих комментариев практически на каждой строке. Обычно это связано со сложным алгоритмом, поэтому лучше разделить код на несколько методов поменьше и дать им говорящие названия.
<h4>Дублирование кода</h4>В разных классах или методах используются одинаковые блоки кода. 
<h4>Ленивый класс</h4>Класс берет на себя очень малый функционал, хотя планировался большой.
<h4>Неиспользуемый код</h4>Класс, метод или переменная не используется в коде и являются “мертвым грузом”.
<h3>Излишняя связанность</h3>Эта категория запахов характеризуется большим количеством неоправданных связей в коде.
<h4>Сторонние методы</h4>Метод использует данные другого объекта гораздо чаще, чем собственные данные.
<h4>Неуместная близость</h4>Класс использует служебные поля и методы другого класса.
<h4>Длинные вызовы классов</h4>Один класс вызывает другой, тот запрашивает данные у третьего, тот у четвертого и так далее. Такая длинная цепь вызовов означает высокий уровень зависимости от текущей структуры классов.
<h4>Класс-таск-дилер</h4>Класс нужен только для того, чтобы передать задание другому классу. Может быть, его стоит удалить?
<h3>Техники рефакторинга</h3>Ниже пойдет речь о начальных техниках рефакторинга, которые помогут устранить описанные “запахи” кода.
<h4>Выделение класса</h4>Класс выполняет слишком много функций, часть необходимо вынести в другой класс.

Например, имеется класс <code>Human</code>, в котором также содержится адрес проживания и метод, предоставляющий полный адрес:

<pre class="lang-java line-numbers"><code>
class Human {
   private String name;
   private String age;
   private String country;
   private String city;
   private String street;
   private String house;
   private String quarter;

   public String getFullAddress() {
       StringBuilder result = new StringBuilder();
       return result
                       .append(country)
                       .append(", ")
                       .append(city)
                       .append(", ")
                       .append(street)
                       .append(", ")
                       .append(house)
                       .append(" ")
                       .append(quarter).toString();
   }
}
</code></pre>
Хорошим тоном будет вынести информацию об адресе и метод (поведение обработки данных) в отдельный класс:

<pre class="lang-java line-numbers"><code>
class Human {
   private String name;
   private String age;
   private Address address;

   private String getFullAddress() {
       return address.getFullAddress();
   }
}
class Address {
   private String country;
   private String city;
   private String street;
   private String house;
   private String quarter;

   public String getFullAddress() {
       StringBuilder result = new StringBuilder();
       return result
                       .append(country)
                       .append(", ")
                       .append(city)
                       .append(", ")
                       .append(street)
                       .append(", ")
                       .append(house)
                       .append(" ")
                       .append(quarter).toString();
   }
}
</code></pre><h4>Выделение метода</h4>Если в методе какой-либо функционал можно сгруппировать, следует вынести его в отдельный метод. Например, метод, который вычисляет корни квадратного уравнения:

<pre class="lang-java line-numbers"><code>
   public void calcQuadraticEq(double a, double b, double c) {
       double D = b * b - 4 * a * c;
       if (D &gt; 0) {
           double x1, x2;
           x1 = (-b - Math.sqrt(D)) / (2 * a);
           x2 = (-b + Math.sqrt(D)) / (2 * a);
           System.out.println("x1 = " + x1 + ", x2 = " + x2);
       }
       else if (D == 0) {
           double x;
           x = -b / (2 * a);
           System.out.println("x = " + x);
       }
       else {
           System.out.println("Equation has no roots");
       }
   }
</code></pre>
Вынесем вычисление всех трех возможных вариантов в отдельные методы:

<pre class="lang-java line-numbers"><code>
   public void calcQuadraticEq(double a, double b, double c) {
       double D = b * b - 4 * a * c;
       if (D &gt; 0) {
           dGreaterThanZero(a, b, D);
       }
       else if (D == 0) {
           dEqualsZero(a, b);
       }
       else {
           dLessThanZero();
       }
   }

   public void dGreaterThanZero(double a, double b, double D) {
       double x1, x2;
       x1 = (-b - Math.sqrt(D)) / (2 * a);
       x2 = (-b + Math.sqrt(D)) / (2 * a);
       System.out.println("x1 = " + x1 + ", x2 = " + x2);
   }

   public void dEqualsZero(double a, double b) {
       double x;
       x = -b / (2 * a);
       System.out.println("x = " + x);
   }

   public void dLessThanZero() {
       System.out.println("Equation has no roots");
   }
</code></pre>
Код каждого метода стал гораздо короче и понятнее.
<h4>Передача всего объекта</h4>При вызове метода с параметрами иногда можно встретить такой код:

<pre class="lang-java line-numbers"><code>
public void employeeMethod(Employee employee) {
    // Некоторые действия
    double yearlySalary = employee.getYearlySalary();
    double awards = employee.getAwards();
    double monthlySalary = getMonthlySalary(yearlySalary, awards);
    // Продолжение обработки
}

public double getMonthlySalary(double yearlySalary, double awards) {
     return (yearlySalary + awards)/12;
}
</code></pre>
В методе <code>employeeMethod</code> целых 2 строки отводится на получение значений и сохранение их в примитивных переменных. Иногда такие конструкции занимают до 10 строчек. Гораздо проще передать в метод сам объект, откуда можно извлечь необходимые данные:

<pre class="lang-java line-numbers"><code>
public void employeeMethod(Employee employee) {
    // Некоторые действия
    double monthlySalary = getMonthlySalary(employee);
    // Продолжение обработки
}

public double getMonthlySalary(Employee employee) {
    return (employee.getYearlySalary() + employee.getAwards())/12;
}
</code></pre>
Просто, кратко и лаконично.
<h3>Логическая группировка полей и вынос в отдельный класс</h3>Несмотря на то, что вышеописанные примеры — очень простые и при взгляде на них многие могут задаться вопросом “Да кто вообще так делает?”, многие разработчики от невнимательности, нежелания проводить рефакторинг кода или просто “И так сойдет” допускают подобные структурные ошибки.
<h2>Почему рефакторинг эффективен</h2>Итог хорошего рефакторинга — программа, код которой легко читать, модификации логики программы не становятся угрозой, а внесение новых фич не превращается в ад разбора кода, а приятным занятием на пару дней.

Рефакторинг не стоит применять, если программу проще переписать с нуля. Например, команда оценивает трудозатраты на разбор, анализ и рефакторинг кода выше, чем на реализацию такого же функционала с нуля. Или у кода, который нужно отрефакторить, есть множество ошибок, сложных в отладке.

Знание, как улучшить структуру кода обязательно в работе программиста. Ну а изучать программирование на Java лучше на JavaRush — онлайн-курсе с акцентом на практику. 1200+ задач с мгновенной проверкой, около 20 минипроектов, задачи-игры — все это поможет почувствовать себя уверенно в кодинге. Лучшее время, чтобы начать — сейчас :)
<a href="https://javarush.com/" target="blank"><img data-id="e00c6973-8822-4b1e-9d09-eab8f8d26842" data-max-width="350" alt="Как устроен рефакторинг в Java - 4" src="https://cdn.javarush.com/images/article/e00c6973-8822-4b1e-9d09-eab8f8d26842/1024.jpeg"></a><h2>Ресурсы для дополнительного погружения в рефакторинг</h2>Самая известная книга о рефакторинге — это “Рефакторинг. Улучшение проекта существующего кода” Мартина Фаулера.

Также есть интересное издание о рефакторинге, написанное на основе предыдущей книги — “Рефакторинг с использованием шаблонов” Джошуа Кириевски.

Кстати о шаблонах. При рефакторинге всегда очень полезно знать основные паттерны проектирования приложений. В этом помогут эти отличные книги:
<ol>
<li>“Паттерны проектирования” — авторства Эрика Фримена, Элизабет Фримен, Кэтти Сьерра, Берта Бейтса из серии Head First;</li>
<li>“Читаемый код, или программирование как искусство” — Дастин Босуэлл, Тревор Фаучер.</li>
<li>“Совершенный код” Стива Макконнелла, в которой изложены принципы красивого и элегантного кода.</li>
</ol>Ну и несколько статей о рефакторинге:
<ol>
<li><a href="https://javarush.com/groups/posts/38-adskaja-zadachka-pristupaem-k-refaktoringu-unasledovannogo-koda-" target="_blank">Адская задачка: приступаем к рефакторингу унаследованного кода</a>;</li>
<li><a href="https://javarush.com/groups/posts/894-refaktoring" target="_blank">Рефакторинг</a>;</li>
<li><a href="https://www.ibm.com/developerworks/opensource/library/os-ecref/?\=105XGA99" rel="nofollow" target="_blank">Refactoring for everyone</a>.</li>
<ol></ol></ol>