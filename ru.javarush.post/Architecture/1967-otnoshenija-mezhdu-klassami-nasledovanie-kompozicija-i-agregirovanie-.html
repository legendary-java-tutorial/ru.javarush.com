Отношения между классами. Наследование, композиция и агрегирование 
<p>----------------------------------------</p>
Привет! Сегодня мы подробно рассмотрим еще один принцип объектно-ориентированного программирования (ООП) — наследование. Заодно изучим другие типы отношений между классами — композицию ...
<p>----------------------------------------</p>
Привет! Сегодня мы подробно рассмотрим еще один принцип объектно-ориентированного программирования (ООП) — наследование. Заодно изучим другие типы отношений между классами — композицию и агрегирование.

Эта тема не будет сложной: ты уже много раз сталкивался с наследованием и его примерами в прошлых лекциях. Сегодня главным будет закрепить твои знания, подробнее рассмотреть механизм наследования и еще раз пробежаться по примерам :) 

Итак, поехали!<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="1b6c4908-c764-4724-b12a-8d639b1e50a8" data-max-width="710" alt="Отношения между классами. Наследование, композиция и агрегирование  - 1" src="https://cdn.javarush.com/images/article/1b6c4908-c764-4724-b12a-8d639b1e50a8/1024.jpeg"></div></div><h2>Наследование в Java и его преимущества</h2>Как ты наверняка помнишь,<em><strong> наследование (inheritance)</strong></em> — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом.

Давай вспомним пример наследования из предыдущих лекций:

<pre class="lang-java line-numbers"><code>
public class Car {

   private String model;
   private int maxSpeed;
   private int yearOfManufacture;

   public Car(String model, int maxSpeed, int yearOfManufacture) {
       this.model = model;
       this.maxSpeed = maxSpeed;
       this.yearOfManufacture = yearOfManufacture;
   }


public void gas() {
       //...газ
   }

public void brake() {
       //...тормоз
   }
}


public class Truck extends Car {

   public Truck(String model, int maxSpeed, int yearOfManufacture) {
       super(model, maxSpeed, yearOfManufacture);
   }
}



public class Sedan extends Car {
   public Sedan(String model, int maxSpeed, int yearOfManufacture) {
       super(model, maxSpeed, yearOfManufacture);
   }
}
</code></pre>
Есть некая программа, в рамках которой мы работаем с различными типами автомобилей. Даже если ты не автолюбитель, наверняка знаешь, что типов этих самых автомобилей на свете великое множество :)

Поэтому общие свойства автомобилей выделяем в общий класс-родитель — <code>Car</code>. А что общего у всех автомобилей вне зависимости от типа?

У любой машины есть год выпуска, название модели и максимальная скорость. Эти свойства выносим в поля <code>model</code>, <code>maxSpeed</code>, <code>yearOfManufacture</code>.

Что касается поведения, любая машина может газовать и тормозить :) Это поведение мы определяем в методах <code>gas()</code> и <code>brake()</code>.

Какие выгоды это нам дает? Прежде всего — сокращение объема кода.

Конечно, можем обойтись и без родительского класса. Но поскольку каждая машина должна уметь газовать и тормозить, нам придется создавать методы <code>gas()</code> и <code>brake()</code> в классе <code>Truck</code>, в классе <code>Sedan</code>, в классе <code>F1Car</code>, в классе <code>Sportcar</code> и во всех остальных классах машин. 

Представь, сколько лишнего кода мы при этом напишем. Не забывай и о полях model, maxSpeed и yearOfManufacture: если откажемся от родительского класса, будем создавать их в каждом из классов-машин!
<img data-id="c69af702-f57c-4ad4-aea3-11522ad2c17e" data-max-width="850" alt="Отношения между классами. Наследование, композиция и агрегирование  - 2" src="https://cdn.javarush.com/images/article/c69af702-f57c-4ad4-aea3-11522ad2c17e/1024.jpeg">
Когда у нас наберется пара десятков классов-машин, объем повторяющегося кода станет действительно серьезным.

Вынесение общих полей и методов (еще говорят — «состояния» и «поведения») в класс-родитель позволит нам сэкономить кучу времени и места.

Если же у какого-то типа есть свойства или методы, уникальные только для него и отсутствующие у других типов машин, — не беда. Их всегда можно создать в классе-потомке, отдельно от всех остальных.

<pre class="lang-java line-numbers"><code>
public class F1Car extends Car {

   public void pitStop() {
      
       //...пит-стоп делают только гоночные автомобили
   }

   public static void main(String[] args) {
      
       F1Car formula1Car = new F1Car();
       formula1Car.gas();
       formula1Car.pitStop();
       formula1Car.brake();
   }
}
</code></pre>
Возьмем случай с гоночными машинами Формулы-1. У них, в отличие от «сородичей», есть уникальное поведение — время от времени они заезжают на пит-стоп.

Нам это не мешает. Общее поведение мы уже описали в родительском классе <code>Car</code>, а специфическое поведение классов-потомков можем добавить внутри классов.
<img data-id="f8abca9b-b5e0-4fc8-b91a-236a70946b11" data-max-width="850" alt="Отношения между классами. Наследование, композиция и агрегирование  - 3" src="https://cdn.javarush.com/images/article/f8abca9b-b5e0-4fc8-b91a-236a70946b11/1024.jpeg">
Это касается и полей: если у дочернего класса есть уникальные свойства, спокойно объявляем эти поля внутри него и не переживаем :) <strong>Возможность повторного использования кода — главное преимущество наследования.</strong>

Для программиста очень важно не писать лишний объем кода. Ты не раз столкнешься с этим в работе.

Пожалуйста, запомни еще одну крайне важную вещь: <strong>в Java нет множественного наследования.</strong> Каждый класс наследуется только от одного класса. О причинах этого подробнее поговорим в будущих лекциях, пока просто запомни. 

Этим Java, кстати, отличается от некоторых других ООП-языков. Например, в С++ множественное наследование есть.

С наследованием все более-менее ясно — идем дальше.
<h2>Композиция и агрегирование</h2>Классы и объекты могут быть связаны друг с другом. Наследование описывает связь «является» (или по-английски «IS A»). Лев является Животным. Такое отношение легко выразить с помощью наследования, где <code>Animal</code> будет родительским классом, а <code>Lion</code> — потомком.

Однако не все связи отношения в мире описываются таким образом. К примеру, клавиатура определенно как-то связана с компьютером, но <strong>она не является компьютером</strong>. Руки как-то связаны с человеком, но они не являются человеком.

В этих случаях в его основе лежит другой тип отношения: не «является», а «является частью» («HAS A»). Рука не является человеком, но является частью человека. Клавиатура не является компьютером, но является частью компьютера.

Отношения HAS A можно описать в коде, используя механизмы <strong>композиции</strong> и <strong>агрегирования</strong>. Разница между ними заключается в «строгости» этих связей.

Приведем простой пример:

У нас есть наш <code>Car</code> — машина. 
У каждой машины есть двигатель. 

Кроме того, у каждой машины есть пассажиры внутри.

В чем же принципиальная разница между полями <code>Engine engine</code> и <code>Passenger [] passengers</code>? Если у машины внутри сидит пассажир <code>А</code>, это не значит, что в ней не могут находиться пассажиры <code>B</code> и <code>C</code>.

Одна машина может соответствовать нескольким пассажирам. Кроме того, если всех пассажиров высадить из машины, она продолжит спокойно функционировать.

Связь между классом <code>Car</code> и массивом пассажиров <code>Passenger [] passengers</code> менее строгая. Она называется <em>агрегацией</em>.

Есть неплохая статья на эту тему: <a href="http://java-course.ru/begin/relations/" rel="nofollow" target="_blank">Отношения между классами (объектами)</a>.

В ней приведен еще один хороший пример агрегации. Допустим, у нас есть класс <code>Student</code>, обозначающий студента, и класс <code>StudentsGroup</code> (группа студентов). Студент может входить и в клуб любителей физики, и в студенческий фан-клуб «Звездных войн» или команду КВН.

<em>Композиция</em> — более строгий тип связи. При использовании композиции объект не только является частью какого-то объекта, но и не может принадлежать другому объекту того же типа. 

Самый простой пример — двигатель автомобиля. Двигатель является частью автомобиля, но не может быть частью другого автомобиля.

Как видишь, их связь гораздо более строгая, чем у <code>Car</code> и <code>Passengers</code>.
<img data-id="2aa305d5-f7c0-49d2-860a-1cba259b91f9" data-max-width="850" alt="Отношения между классами. Наследование, композиция и агрегирование  - 4" src="https://cdn.javarush.com/images/article/2aa305d5-f7c0-49d2-860a-1cba259b91f9/1024.jpeg">