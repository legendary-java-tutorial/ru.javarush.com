Паттерн проектирования Proxy
<p>----------------------------------------</p>
В программировании важно правильно спланировать архитектуру приложения. Незаменимое средство для этого — шаблоны проектирования. Сегодня поговорим о Proxy, или по-другому — Заместителе. Этот паттерн помогает решить проблемы, связанные с контролируемым доступом...
<p>----------------------------------------</p>
В программировании важно правильно спланировать архитектуру приложения. Незаменимое средство для этого — шаблоны проектирования. Сегодня поговорим о Proxy, или по-другому — Заместителе.<h2>Для чего нужен Заместитель</h2>Этот паттерн помогает решить проблемы, связанные с контролируемым доступом к объекту. У тебя может возникнуть вопрос: “Для чего нужен такой контролируемый доступ?”. Давай рассмотрим пару ситуаций, которые помогут тебе разобраться, что к чему. 
<h3>Пример 1</h3>Представим, что у нас есть большой проект с кучей старого кода, где есть класс, отвечающий за выгрузку отчетов из базы данных. Класс работает синхронно, то есть вся система простаивает, пока база обрабатывает запрос. В среднем отчет генерируется за 30 минут. Из-за этой особенности его выгрузка запускается в 00:30, и руководство получает этот отчет утром. 

При анализе выяснилось, что необходимо получать отчет сразу после его генерации, то есть в течение дня. Перенести время запуска нельзя, так как система будет ждать ответ от базы. Выход — изменить принцип работы, запустив выгрузку и генерацию отчета в отдельном потоке.

Такое решение позволит системе работать в обычном режиме, а руководство будет получать свежие отчеты. Однако есть проблема: текущий код переписывать нельзя, так как его функции используют другие части системы. 

В этом случае можно ввести промежуточный прокси-класс с помощью паттерна Заместитель, который будет получать запрос на выгрузку отчета, логировать время начала и запускать отдельный поток. Когда отчет сгенерируется, поток завершит свою работу и все будут счастливы.
<h3>Пример 2</h3>Команда разработчиков создает сайт-афишу. Чтобы получить данные о новых мероприятиях, они обращаются к стороннему сервису, взаимодействие с которым реализовано через специальную закрытую библиотеку. При разработке появилась проблема: сторонняя система обновляет данные раз в сутки, а запрос к ней происходит каждый раз, когда пользователь обновляет страницу. Это создает большое количество запросов, и сервис перестает отвечать.

Решение — кэшировать ответ сервиса и предоставлять посетителям сохраненный результат при каждой перезагрузке, обновляя этот кэш по необходимости. В этом случае использование паттерна Заместитель — отличное решение без изменения готового функционала.
<h2>Принцип работы паттерна</h2>Чтобы внедрить этот паттерн, нужно создать класс-прокси. Он реализует интерфейс сервисного класса, имитируя его поведение для клиентского кода. Таким образом вместо реального объекта клиент взаимодействует с его заместителем. Как правило, все запросы передаются далее сервисному классу, но с дополнительными действиями до или после его вызова.

Проще говоря, этот прокси-объект — прослойка между клиентским кодом и целевым объектом.

Рассмотрим пример с кэшированием запроса из очень медленного старого диска. Пусть это будет расписание электропоездов в каком-нибудь древнем приложении, чей принцип действия нельзя изменять. Диск с обновленным расписанием вставляют каждый день в фиксированное время.

Итак, у нас есть:
<ol>
<li>Интерфейс <code>TimetableTrains</code>.</li>
<li>Класс <code>TimetableElectricTrains</code>, который реализует этот интерфейс.</li>
<li>Именно через этот класс клиентский код взаимодействует с файловой системой диска.</li>
<li>Класс-клиент <code>DisplayTimetable</code>. Его метод <code>printTimetable()</code> использует методы класса <code>TimetableElectricTrains</code>.</li>
</ol>Схема простая:
<img data-max-width="800" data-id="24537fe5-dead-4118-bf6d-98c6511edf43" src="/images/article/24537fe5-dead-4118-bf6d-98c6511edf43/800.webp" class="img-fluid" alt="Паттерн проектирования Proxy - 2">В данный момент при каждом вызове метода <code>printTimetable()</code> класс <code>TimetableElectricTrains</code> обращается на диск, выгружает данные и предоставляет их клиенту. Эта система функционирует хорошо, но очень медленно. Поэтому было решено увеличить производительность системы, добавив механизм кэширования.

Это можно сделать с использованием паттерна Proxy:
<img data-max-width="800" data-id="e5d03283-15a5-4cb0-b036-c2f306e5ad99" src="/images/article/e5d03283-15a5-4cb0-b036-c2f306e5ad99/800.webp" class="img-fluid" alt="Паттерн проектирования Proxy - 3">Таким образом класс <code>DisplayTimetable</code> даже не заметит, что взаимодействует с классом <code>TimetableElectricTrainsProxy</code>, а не с предыдущим. 

Новая реализация загружает расписание один раз в день, а при повторных запросах возвращает уже загруженный объект из памяти.
<h2>Для каких задач лучше использовать Proxy</h2>Вот несколько ситуаций, в которых тебе точно пригодится этот паттерн: 
<ol>
<li>Кэширование.</li>
<li>Отложенная реализация, также известная как ленивая. Зачем загружать объект сразу, если можно загрузить его по мере необходимости?</li>
<li>Логирование запросов.</li>
<li>Промежуточные проверки данных и доступа.</li>
<li>Запуск параллельных потоков обработки.</li>
<li>Запись или подсчет истории обращения.</li>
</ol>Есть и другие сценарии использования. Понимая принцип работы этого паттерна, ты сам сможешь найти для него удачное применение. 

На первый взгляд, <span class="text-bold">Заместитель</span> делает то же, что и <span class="text-bold">Фасад</span>, но это не так. У <span class="text-bold">Заместителя</span> есть тот же интерфейс, что и у сервисного объекта.

Также не нужно путать паттерн с <span class="text-bold">Декоратором</span> или <span class="text-bold">Адаптером</span>. <span class="text-bold">Декоратор</span> предоставляет расширенный интерфейс, а <span class="text-bold">Адаптер</span> — альтернативный.
<h2>Преимущества и недостатки</h2><ul style="list-style-type: none;">
<li>+ Можно как угодно контролировать доступ к сервисному объекту;</li>
<li>+ Дополнительные возможности управления жизненным циклом сервисного объекта;</li>
<li>+ Работает без сервисного объекта;</li>
<li>+ Повышает быстродействие и безопасность кода.</li>
<li> - Есть риск ухудшения производительности из-за дополнительных обработок;</li>
<li> - Усложняет структуру классов программы.</li>
</ul><h2>Паттерн Заместитель на практике</h2>Давай реализуем с тобой систему, которая читает расписание поездов с диска:

<pre class="lang-java line-numbers"><code>
public interface TimetableTrains {
   String[] getTimetable();
   String getTrainDepartureTime();
}
</code></pre>
Класс, реализующий основной интерфейс:

<pre class="lang-java line-numbers"><code>
public class TimetableElectricTrains implements TimetableTrains {

   @Override
   public String[] getTimetable() {
       ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
       try {
           Scanner scanner = new Scanner(new FileReader(new File("/tmp/electric_trains.csv")));
           while (scanner.hasNextLine()) {
               String line = scanner.nextLine();
               list.add(line);
           }
       } catch (IOException e) {
           System.err.println("Error:  " + e);
       }
       return list.toArray(new String[list.size()]);
   }

   @Override
   public String getTrainDepartureTime(String trainId) {
       String[] timetable = getTimetable();
       for(int i = 0; i&lt;timetable.length; i++) {
           if(timetable[i].startsWith(trainId+";")) return timetable[i];
       }
       return "";
   }
}
</code></pre>
Каждый раз при попытке получить расписание всех поездов программа читает файл с диска. Но это еще цветочки. Файл также считывается каждый раз, когда нужно получить расписание только по одному поезду! Хорошо, что такой код существует только в плохих примерах :)

Клиентский класс:

<pre class="lang-java line-numbers"><code>
public class DisplayTimetable {
   private TimetableTrains timetableTrains = new TimetableElectricTrains();

   public void printTimetable() {
       String[] timetable = timetableTrains.getTimetable();
       String[] tmpArr;
       System.out.println("Поезд\tОткуда\tКуда\t\tВремя отправления\tВремя прибытия\tВремя в пути");
       for(int i = 0; i &lt; timetable.length; i++) {
           tmpArr = timetable[i].split(";");
           System.out.printf("%s\t%s\t%s\t\t%s\t\t\t\t%s\t\t\t%s\n", tmpArr[0], tmpArr[1], tmpArr[2], tmpArr[3], tmpArr[4], tmpArr[5]);
       }
   }
}
</code></pre>
Пример файла:

<pre><code>
9B-6854;Лондон;Прага;13:43;21:15;07:32
BA-1404;Париж;Грац;14:25;21:25;07:00
9B-8710;Прага;Вена;04:48;08:49;04:01;
9B-8122;Прага;Грац;04:48;08:49;04:01
</code></pre>
Протестируем:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
   DisplayTimetable displayTimetable = new DisplayTimetable();
   displayTimetable.printTimetable();
}
</code></pre>
<span class="text-bold">Вывод:</span>
<pre><code>
Поезд  Откуда  Куда   Время отправления Время прибытия    Время в пути
9B-6854  Лондон  Прага    13:43         21:15         07:32
BA-1404  Париж   Грац   14:25         21:25         07:00
9B-8710  Прага   Вена   04:48         08:49         04:01
9B-8122  Прага   Грац   04:48         08:49         04:01
</code></pre>
<span class="text-bold">Теперь пойдем по шагам внедрения нашего паттерна:</span>
<ol>
<li><p>Определить интерфейс, который позволяет использовать вместо оригинального объекта новый заместитель. В нашем примере это <code>TimetableTrains</code>.</p></li>
<li><p>Создать класс заместителя. В нем должна быть ссылка на сервисный объект (создать в классе или передать в конструкторе);</p>
<p>Вот наш класс-заместитель:</p>
<pre class="lang-java line-numbers"><code>
public class TimetableElectricTrainsProxy implements TimetableTrains {
   // Ссылка на оригинальный объект
   private TimetableTrains timetableTrains = new TimetableElectricTrains();
  
   private String[] timetableCache = null

   @Override
   public String[] getTimetable() {
       return timetableTrains.getTimetable();
   }

   @Override
   public String getTrainDepartureTime(String trainId) {
       return timetableTrains.getTrainDepartureTime(trainId);
   }
  
   public void clearCache() {
       timetableTrains = null;
   }
}
</code></pre>
<p>На этом этапе просто создаем класс со ссылкой на оригинальный объект и передаем все вызовы ему.</p></li>
<li><p>Реализовываем логику класса-заместителя. В основном вызов всегда перенаправляется оригинальному объекту.</p>
<pre class="lang-java line-numbers"><code>
public class TimetableElectricTrainsProxy implements TimetableTrains {
   // Ссылка на оригинальный объект
   private TimetableTrains timetableTrains = new TimetableElectricTrains();

   private String[] timetableCache = null

   @Override
   public String[] getTimetable() {
       if(timetableCache == null) {
           timetableCache = timetableTrains.getTimetable();
       }
       return timetableCache;
   }

   @Override
   public String getTrainDepartureTime(String trainId) {
       if(timetableCache == null) {
           timetableCache = timetableTrains.getTimetable();
       }
       for(int i = 0; i &lt; timetableCache.length; i++) {
           if(timetableCache[i].startsWith(trainId+";")) return timetableCache[i];
       }
       return "";
   }

   public void clearCache() {
       timetableTrains = null;
   }
}
</code></pre>
<p>Метод <code>getTimetable()</code> проверяет, закэширован ли массив расписания в память. Если нет, он посылает запрос для загрузки данных с диска, сохраняя результат. Если же запрос уже выполняется, он быстро вернет объект из памяти.</p>
<p>Благодаря простому функционалу, метод getTrainDepartireTime() не пришлось перенаправлять в оригинальный объект. Мы просто дублировали его функционал в новый метод.</p>
<p>Так делать нельзя. Если пришлось дублировать код или производить подобные манипуляции, значит что-то пошло не так, и нужно посмотреть на проблему под другим углом. В нашем простом примере иного пути нет, но в реальных проектах, скорее всего, код будет написан более корректно.</p></li>
<li><p>Заменить в клиентском коде создание оригинального объекта на объект-заместитель:</p>
<pre class="lang-java line-numbers"><code>
public class DisplayTimetable {
   // Измененная ссылка
   private TimetableTrains timetableTrains = new TimetableElectricTrainsProxy();

   public void printTimetable() {
       String[] timetable = timetableTrains.getTimetable();
       String[] tmpArr;
       System.out.println("Поезд\tОткуда\tКуда\t\tВремя отправления\tВремя прибытия\tВремя в пути");
       for(int i = 0; i&lt;timetable.length; i++) {
           tmpArr = timetable[i].split(";");
           System.out.printf("%s\t%s\t%s\t\t%s\t\t\t\t%s\t\t\t%s\n", tmpArr[0], tmpArr[1], tmpArr[2], tmpArr[3], tmpArr[4], tmpArr[5]);
       }
   }
}
</code></pre>
<p>Проверка</p>
<pre><code>
Поезд  Откуда  Куда   Время отправления Время прибытия    Время в пути
9B-6854  Лондон  Прага    13:43         21:15         07:32
BA-1404  Париж   Грац   14:25         21:25         07:00
9B-8710  Прага   Вена   04:48         08:49         04:01
9B-8122  Прага   Грац   04:48         08:49         04:01
</code></pre>
<p>Отлично, работает корректно.</p>
<p>Можно также рассмотреть вариант с фабрикой, которая будет создавать как оригинальный объект, так и объект-заместитель в зависимости от определенных условий.</p></li>
</ol><h2> Полезная ссылка вместо точки</h2><ol>
<li><p>Отличная <a href="https://javarush.com/groups/posts/2267-patternih-proektirovanija-v-java#%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5_%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B" target="_blank">статья о паттернах и немного о “Заместителе”</a></p></li>
</ol>На сегодня все! Неплохо бы вернуться к обучению и проверить новые знания на практике :)