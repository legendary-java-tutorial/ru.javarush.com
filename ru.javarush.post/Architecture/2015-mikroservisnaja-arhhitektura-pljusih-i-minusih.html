Микросервисная архитектура: плюсы и минусы
<p>----------------------------------------</p>
Вольный перевод статьи с английского ресурса. В статье описаны плюсы и минусы в микросервисной архитектуре в контектсе сравнения с архитектурой монолитных приложений. Статья полезна для всех, хоть для тех, кто уже знаком, хоть для тех, кто еще не знает об этом ...
<p>----------------------------------------</p>
<strong>Микросервисы - это путь разбиения большого приложения на слабо связанные модули, которые коммуницируют друг с другом посредством просто API.</strong>
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="13ff4613-ce16-4962-88f6-62b5a53f2398" data-max-width="710" alt="Микросервисная архитектура: плюсы и минусы - 1" src="https://cdn.javarush.com/images/article/13ff4613-ce16-4962-88f6-62b5a53f2398/1024.jpeg"></div></div>Последнее время о микросервисах не говорит разве что немой. Это становится все популярнее. Модульный архитектурный стиль кажется особенно хорошо подходит для облачных сред(cloud-based environment) и его популярность растет.

Предже чем углубиться в детали, давайте посмотрим на все "с высоты птичьего <s>помета</s> полета". Поэтому: <em>Микросервисы - это способ разбиения большого проекта на небольшие, независимые и слабо связные модули.</em> Независимые модули отвечают за четко отпределенные и дискретные задачи и общаются друг с другом посредством простого и доступного API. 

Другими словами - микросервисы это просто другой архитектурный стиль для проектирования сложных, в основном, веб-приложений. 

Но что такого плохого существующих архитектрных решениях, таких как SOA( Service oriented architecture — сервисно огриентированная архитектура)? Большинство современных ентерпрайз-решений написаны с использованием SOA, похоже работают довольно хорошо.

Пожалуй, это отличное время для того, чтоб поговорить о некоторых вызовах в индустрии, с которыми сталкиваются в наше время...

Давайте начнем с простого примера.

Допустим, мне нужно запустить классическое приложение написанное на Java. Первым я разработаю User Interface, потом слой с бизнес логикой, причем несколько компонентов, которые будут взаимодействовать с UI и, наконец, слой для базы данных, который будет доступен к устойчивой базе данных.

Теперь в соотвествии с тем, что я хочу запустить приложение, я создам WAR/EAR/JAR и смонтирую его на сервер(таких как JBoss, Tomcat или WebLogic). Так как сделано это все в одном, я получаю монолитное приложение, что означает, что все компоненты в одной месте... Пример на картинке:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="e10962fd-e525-4501-a5a6-c41763317c16" data-max-width="754" alt="Микросервисная архитектура: плюсы и минусы - 2" src="https://cdn.javarush.com/images/article/e10962fd-e525-4501-a5a6-c41763317c16/1024.jpeg"></div></div>
Скорее всего, что вы уже знакомы с таким подходом и использовали его, но идея именно в том, что бы на этом примере показать с какими вызовами придется столкнуться разработчикам используя это архитектурное решение.

<strong>Монолитное приложение: <s>вызовы</s> проблемы</strong>
<ul>
<li>Во время того, как растет приложение, растет и количество написанного кода, которое вполне может перегружать среду разработки каждый раз, когда нужно открыть его. Это определенно уменьшает КПД разработчика.</li>
<li>Так как приходится все монтировать в одном месте, это приводит к тому, что переход на другой язык программирования или переход на другие технологии является большой проблемой. Например, вы написали приложение на Java, а через время вышел Kotlin и вы загорелись желанием переписать на него, потому что он <s>распиарен</s> круче-лучше-быстрее. С моноличным приложением даже мысли о рефакторинге будут приничинять реальную боль, не говоря уже о самом процессе. В данный момент есть множество приложений, которые сделаны таким образом и количество строк кода просто невероятно.</li>
<li>Если какой-либо из компонентов по какой-либо причине <s>накроется медным тазом</s> перестанет работать, то все приложение также рухнет. Только представте, что есть веб-приложение, в котором есть модули, такие как, авторизация, оплата, история и тд. И по какой-то причине один из них ломается. Это просто шок для бизнеса и, в следствии, для разработчиков.</li>
<li>Масштабирование монолитного приложения может быть осуществлено только посредством поднятия еще одного такого же приложения. А что если требуется масштабтрование только одного компонента, а не всего приложения. Сколько ресурсов будет потрачено впустую?...</li>
<li>Это может оказать большое влияние на процесс разработки и на процесс монтирования приложения. Чем больше приложение, тем более важно, чтоб разработчики могли разделить приложение на более меклие рабочие части.  Потому что все модули в монолитном приложении связаны друг с другом, разработчики не могут работать/монтировать независимо друг от друга эти модули. Так как разработчики зависят друг от друга, время разработчки увеличивается.</li>
</ul>
Вместе с тем, мы готовы рассмотреть и понять смысл микросервисов, а именно как их можно использовать для восстановления гибкости, которая была потеряна с SOA-стилем.

<strong><s>Бог</s> Микросервисы в помощь</strong>
Одна из самых важных характеристик в любом архитектурном решение - это масштабируемость. Пока я первый раз изучал микросервисы, я видел, что все так похоже на цитаты из книги "Исскуство Машстабирования(The Art of Scalability)". Это отличное начало и место для обсуждения.
В этой книге определяют так называемую модель "Куба Масштабируемости", который описывает трехмерную систему масштабируемости:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="8d46c7fa-95ee-4a67-98cc-1bf1a82ad55c" data-max-width="613" alt="Микросервисная архитектура: плюсы и минусы - 3" src="https://cdn.javarush.com/images/article/8d46c7fa-95ee-4a67-98cc-1bf1a82ad55c/1024.jpeg"></div></div>
Как вы видите, ось X описывает "горизонтальное масштабирование"(которое мы видели также доступно для монолитной архитектурой), ось Y предствляет собой машстабирование в смысле разделения разных <s>компонентов</s> серсисов. Идея Z оси понимается когда данные разделяются и приложение отправляет запросы именно на то место, где находятся данные. То есть они не в одном месте все.

Идея оси Y - именно та, на которой мы остановимся подробнее. Эта ось представляет собой <em>функциональную декомпозицию</em>. В этой стратегии, различные функции можно рассматрировать как независимые сервисы. Поэтому, вместе монтирования цельного приложение только тогда, когда все сделано, разработчики могут монтировать отдельные сервисы независимо друг от друга и не ждать других, пока те закончат работу над своими модулями. Это не только улучшит время разработки, но также предлагает гибкость в изменении и перемонтировании без необходимости волноваться об остальных компонентах приложения. Сравним эту диаграмму с предыдущей монолитной:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="cc94c9c2-dfd3-42b0-a441-d534e8c3c06c" data-max-width="607" alt="Микросервисная архитектура: плюсы и минусы - 4" src="https://cdn.javarush.com/images/article/cc94c9c2-dfd3-42b0-a441-d534e8c3c06c/1024.jpeg"></div></div>

<strong>Микросервисы: преимущества</strong>
Преимущества микросервисов выглядят вполне достаточными что убедили таких ентерпрайз-разработчиков, как Amazon, Netflix, Ebay - начать использовать этот подход.

В отличии от монолитных архитектурных приложений, микросервисы:
<ul>
<li>Улучшает изоляцию сбоя компонентов: большие приложения можут продолжить эффективно работать, даже при неисправности какого-то отдельного модуля.</li>
<li>Устраняет приверженность приложения к одному технологическому стеку:  если хочешь попробовать новый технологический стек на каком-то сервисе - пожалуйста. Зависимости будут гораздло легче, чем при монолитном, к тому же будет намного проще откатить все вспять. Чем меньше кода в одном приложении, тем легче работать.</li>
<li>Делает намного проще для новых сотрудников, чтобы понять функционаьность сервиса.</li>
</ul>

<strong>Микросервисы: особенности монтирования и виртуализации</strong>
Теперь нам понятно, что такое микросервисы. И наибольшее преимущество, что монтируется не одним WAR/EAR/JAR архивом. Но как он монтируется? Самый лучший способ монтирования микросервисов внутри контейнеров. Контейнер - это полностью настроеная виртуальная операционная система с настроенным необходимым окружением, которое помогает изолировать доступ к ресурсам системы железа, на котором стоит контейнер. Самое известное решение на рынке - это конечно <a href="https://www.docker.com/" target="_blank" rel="nofollow">Docker</a>.

Виртуальные машины от IaaS(инфраструктура как сервис), такие как AWS могут также отлично работать для монтирования микросервисов, но относительно легковесные микросервисы могут использовать не все ресурсы, которые есть в виртуальной машине, могут уменьшить выгодность в использовании.

Так же вы можете монтировать свои микросервисы используя <a href="https://ru.wikipedia.org/wiki/OSGi" target="_blank" rel="nofollow">OSGI</a>(Open Service Gateway Initiative) пакет. В этом случае все микросервисы будут запущены в одной JVM, но это связано с проблемами компромиса между управлением и изоляцией.

<strong>Микросервисы: недостатки</strong>
Только из-за того, что "все это круто" и "как мы раньше этого не видели", не означает, что нет своих недостатков.
Ниже приведен список возможных областей боли, которая приносит с собой микросервисная архитектура:
<ul>
<li>Разработка распределенных систем может быть трудной. Под этим я подразумеваю, что все компоненты теперь независимые сервисы - нужно очень аккуратно обрабатывать запросы проходящие между модулями. Может быть сценарий, когда один модуль не отвечает, заставляя писать дополнительный код, чтобы избежать сбоя системы. Это может быть сложнее, если удаленные вызовы чувствительны к <a href="https://en.wikipedia.org/wiki/Latency_(engineering)" target="_blank" rel="nofollow">latency</a>.</li>
<li>Множество баз данных и управление транзакций может быть реальной болью.</li>
<li>тестирование микросервисных приложений может быть громоздко. Используя монолитное приложение, нам нужно только запустить WAR/EAR/JAR архив на сервер и убедиться в связи с базой данных. А в микросервисах, каждый отдельный сервис должен быть запущен перед тем, как начать тестирование.</li>
<li>Монтирование приложений может быть сложным. Они могут требовать координации вокруг множества сервисов, которые могут быть не так просто монтироваться, как WAR контейнер.</li>
</ul>
....
Конечно, с правильными инструментами и подходами можно избежать эти недостатки. Но они и сами требуют поддержки и не полностью решают все проблемы.

Статья была переведена с сайта <a href="https://cloudacademy.com/" target="_blank" rel="nofollow">CloudAcademy</a>. Перевод вольный. 
Все вольны излучать все свои мысли в комментариях. Они будут обязательно прочитаны.

<a href="https://cloudacademy.com/blog/microservices-architecture-challenge-advantage-drawback/" target="_blank" rel="nofollow">Оригинал статьи</a>

<a href="https://github.com/romankh3/" target="_blank" rel="nofollow">Мой Github aккаунт</a>