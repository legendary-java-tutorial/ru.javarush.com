Сериализация как она есть. Часть 2
<p>----------------------------------------</p>
Производительность

Как я уже говорил, стандартная сериализация работает через Reflection API. Что означает, что для сериализации берется класс сериализуемого
<p>----------------------------------------</p>
<h4>Производительность</h4>

Как я уже говорил, стандартная сериализация работает через Reflection API. Что означает, что для сериализации берется класс сериализуемого объекта, у него берется список полей, по всем полям в цикле проверяются различные условия ( <strong>transient</strong> или нет, если объект, то <strong>Externalizable</strong> или <strong>Serializable</strong>), значения пишутся в поток, причем достаются из полей тоже через <strong>reflection</strong>... В общем, ситуация ясна. В противоположность этому методу, вся процедура при использовании расширенной сериализации контролируется самим разработчиком. Осталось выяснить, какие преимущества это дает по скорости.

Итак, условия теста. Объект произвольной структуры. Два варианта – один <strong>Serializable</strong>, второй <strong>Externalizable</strong>. Некоторое количество объектов обоих вариантов инициализируется произвольными (идентичными для каждой пары объектов) данными, после чего помещается в контейнер. Контейнер тоже в одном случае <strong>Serializable</strong>, в другом <strong>Externalizable</strong>. Далее контейнеры будут сериализованы и десериализованы с замерами времени.

Полный код теста вместе с <strong>build</strong>-файлом для ant можно найти тут – serialization.zip (скачать можно с сайта-первоисточника). В тексте я буду приводить только отрывки.

Сериализуемый объект содержит следующий набор полей:

<code>private int fieldInt;
private boolean fieldBoolean;
private long fieldLong;
private float fieldFloat;
private double fieldDouble;
private String fieldString;</code>

Тест содержит три реализации <strong>Externalizable</strong> контейнеров. Первая из них, <strong>ContainerExt1</strong>, простейшая. Это просто сериализация содержащего объекты <strong>java.util.List</strong>:

<code>public void writeExternal(ObjectOutput out) throws IOException {
    out.writeObject(items);
}
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    items = (List<ItemExt>)in.readObject();
}</code>

Вторая реализация, <strong>ContainerExt2</strong>, сериализует последовательно все имеющиеся объекты, предваряя их количеством объектов:<cut>

<code>public void writeExternal(ObjectOutput out) throws IOException {
    out.writeInt(items.size());
    for(Externalizable ext : items)
        out.writeObject(ext);
}
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    int count = in.readInt();
    for(int i=0; i<count; i++){
        ItemExt ext = (ItemExt)in.readObject();
        items.add(ext);
    }
}</code>

Третья реализация, <strong>ContainerExt3</strong>, использует <strong>externalizable</strong>-методы объектов:

<code>public void writeExternal(ObjectOutput out) throws IOException {
    out.writeInt(items.size());
    for(Externalizable ext : items)
        ext.writeExternal(out);
}
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    int count = in.readInt();
    for(int i=0; i<count; i++){
        ItemExt ext = new ItemExt();
        ext.readExternal(in);
        items.add(ext);
    }
}</code>

Запускается тест с помощью команды ant (поскольку задача run запускается по умолчанию). В build-файле задано количество создаваемых объектов – 100000. Другое количество может быть задано с помощью параметра командной строки -Dobjcount=<value>.

Итак, каковы результаты выполнения теста? На 100000 создаваемых объектов (результаты могут незначительно отличаться от запуска к запуску):

<code>Creating 100000 objects
Serializable: written in 3516ms, readed in 3235
Externalizable1: written in 4046ms, readed in 3234
Externalizable2: written in 3875ms, readed in 2985
Externalizable3: written in 235ms, readed in 297</code>

И размеры сериализованных данных (размеры файлов на диске):

<code>cont.ser        5 547 955
contExt1.ser    5 747 884
contExt2.ser    5 747 846
contExt3.ser    4 871 461</code>

Что мы видим? Первый способ реализации <strong>Externalizable</strong> даже несколько хуже стандартной сериализации. Сериализация занимает немного больше времени, десериализация сравнима. Размеры файлов тоже немного в пользу стандартной сериализации. Вывод – простейшая сериализация контейнера преимуществ не дает: +15% при сериализации, десериализация отличается на доли процента, причем как в одну, так и в другую сторону.

Второй способ реализации <strong>Externalizable</strong> по характеристикам практически идентичен первому. Чуть быстрее сериализация, но все равно проигрывает стандартной, десериализация чуть выигрывает. Размер файла практически идентичен первому способу (разница – 38 байт). Выигрыша по сравнению со стандартной сериализацией нет – +10% при сериализации, -8% при десериализации.

Третий способ реализации <strong>Externalizable</strong>. Вот тут есть на что посмотреть! Сериализация быстрее в 15 раз! Естественно, плюс-минус, но тем не менее – разница на порядок! Десериализация быстрее практически в 11 раз! Разница тоже на порядок! Опять же плюс-минус, но мне не удавалось получить разницу меньше, нежели в 5 раз. Ну и разница в размере файла -13%. Как маленькое, но приятное дополнение.

Думаю, комментарии излишни. Получаемые от грамотной реализации <strong>Externalizable</strong> преимущества в скорости с лихвой компенсируют затраты на эту самую реализацию. Грамотной – в смысле, целиком и полностью реализованной самостоятельно, без использования имеющихся механизмов сериализации целых объектов (в основном это методы writeObject/readObject). Использование же имеющихся механизмов и/или смешивание со стандартной сериализацией способно свести скоростные преимущества <strong>Externalizable</strong> на нет.

Однако есть и ...

<h4>Обратная сторона медали</h4>

И прежде всего это нарушение целостности графа. Поскольку протокол сериализации не используется – контроль целостности остается на самом разработчике. И об этом следует помнить, ибо в некоторых случаях можно легко убить все преимущества. Если, к примеру, необходимо сериализовать очень много экземпляров класса A, каждый из которых ссылается на единственный экземпляр класса B, то при неумелом использовании <strong>Externalizable</strong> может получиться так, что экземпляр B будет сериализован по разу на каждый экземпляр A, что даст потерю как в скорости, так и в объеме сериализованных данных. А при десериализации мы вообще получим кучу экземпляров B вместо одного! Что намного хуже.

Поэтому, да и не только, <strong>Externalizable</strong> следует использовать обдуманно. Как, впрочем, и любую другую возможность. Если необходимо сериализовать достаточно сложные графы – пожалуй, лучше все-таки воспользоваться имеющимися механизмами. Если же объемы данных большие, но сложность невелика – можно немного поработать и получить солидный выигрыш в скорости. В любом случае лучше написать небольшой прототип и уже на нем оценивать реальную скорость и сложность реализации целостности.

Перейдем к следующему вопросу, связанному с сериализацией.

<h4>Безопасность данных</h4>

Есть такое правило: проверять входящие данные (входные параметры функций и т.п.) на "правильность" – соответствие определенным требованиям. Причем это не столько правило хорошего тона, сколько правило выживания приложения. Ибо если этого не сделать, то при передаче неверных параметров в лучшем случае (действительно – в лучшем!) приложение просто "упадет". В худшем случае оно тихо примет предложенные данные и может нанести значительно больший урон.

Про это правило худо-бедно, но помнят. Однако конструкторы и открытые методы – не единственный способ поставки данных объекту. Точно так же объект может быть создан с помощью десериализации. И вот тут о контроле внутреннего состояния полученного объекта, как правило, забывают. Между тем, создать поток для получения из него объекта с неверным внутренним состоянием не легко, а очень легко.

Пример номер один. Объект с двумя полями типа <strong>java.util.Date</strong>. Одно поле – начало интервала времени, другое – конец. Следовательно, между ними должно существовать определенное соотношение (конец должен быть не раньше начала). Однако любой человек, знающий байткод, сумеет отредактировать сериализованный объект так, что после десериализации конец интервала будет раньше начала. К чему приведет появление в системе такого объекта – предугадать сложно. В любом случае, ничего хорошего ждать не приходится. Потому, примите для себя...

<blockquote>Правило 1. После десериализации объекта необходимо проверить его внутреннее состояние (инварианты) на правильность, точно так же, как и при создании с помощью конструктора. Если объект не прошел такую проверку, необходимо инициировать исключение <strong>java.io.InvalidObjectException</strong>.</blockquote>

Пример номер два. Объект класса A содержит в себе <strong>private</strong>-поле типа <strong>java.util.Date</strong>. Для изменения снаружи объекта это поле недоступно. Однако возможна следующая операция: к потоку дописывается некоторая информация. Потом, после десериализации из этого потока объекта класса <strong>A</strong> производится десериализация еще одного объекта, но уже типа <strong>Date</strong>. Как мы уже видели в примере ранее, можно создать такой поток (в примере он создавался легально), что при десериализации этот второй объект в действительности будет лишь ссылкой на экземпляр <strong>Date</strong>, казалось бы так надежно спрятанный внутри объекта класса <strong>A</strong>. Соответственно, с этим экземпляром можно делать все, что заблагорасудится.

<blockquote>Не буду вдаваться в подробности. Описание этого приема есть в книге Джошуа Блох. Java. Эффективное программирование, в статье 56. Скажу только, что достаточно к потоку дописать 5 байт, чтобы добиться желаемого.</blockquote>

Чтобы этого избежать, необходимо следовать следующему правилу:

<blockquote>Правило 2. Если в составе класса A присутствуют объекты, которые не должны быть доступными для изменения извне, то при десериализации экземпляра класса A необходимо вместо этих объектов создать и сохранить их копии.</blockquote>

Приведенные выше примеры показывают возможные "дыры" в безопасности. Следование упомянутым правилам, разумеется, не спасает от проблем, но может существенно снизить их количество. Советую по этому поводу почитать книгу Джошуа Блох. Java. Эффективное программирование, статью 56.

Ну и последняя тема, которой я хотел бы коснуться –

<h4>Сериализация объектов Singleton</h4>

Тех, кто не в курсе, что такое <strong>Singleton</strong>, отсылаю к <a href="http://www.skipy.ru/technics/singleton.html" rel="nofollow" >отдельной статье</a>.

В чем проблема сериализации <strong>Singleton</strong>-ов? А проблема в уже упомянутом мной факте – после десериализации мы получим другой объект. Это видно в результатах первого из тестов в этой статье – ссылки на исходный и десериализованный объекты не совпадают. Таким образом, сериализация дает возможность создать Singleton еще раз, что нам совсем не нужно. Можно, конечно, запретить сериализовать <strong>Singleton</strong>-ы, но это, фактически, уход от проблемы, а не ее решение.

Решение же заключается в следующем. В классе определяется метод со следующей сигнатурой

<code>ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException</code>

Модификатор доступа может быть <strong>private</strong>, <strong>protected</strong> и по умолчанию <strong>(default)</strong>. Можно, наверное, сделать его и public, но смысла я в этом не вижу. Назначение этого метода – возвращать замещающий объект вместо объекта, на котором он вызван. Приведу простой пример:

<code>public class Answer implements Serializable{

    private static final String STR_YES = "Yes";
    private static final String STR_NO = "No";

    public static final Answer YES = new Answer(STR_YES);
    public static final Answer NO = new Answer(STR_NO);

    private String answer = null;

    private Answer(String answer){
        this.answer = answer;
    }

    private Object readResolve() throws ObjectStreamException{
        if (STR_YES.equals(answer))
            return YES;
        if (STR_NO.equals(answer))
            return NO;
        throw new InvalidObjectException("Unknown value: " + answer);
    }
}</code>

Класс, приведенный выше – простейший перечислимый тип. Всего два значения – <strong>Answer.YES</strong> и <strong>Answer.NO</strong>. Соответственно, именно эти два значения и должны фигурировать после десериализации. Что делается в методе readResolve? Он вызывается на десериализованном объекте. И возвращать он должен уже существующий экземпляр класса, соответствующий внутреннему состоянию десериализованного объекта. В данном примере – проверяется значение поля <strong>answer</strong>. Если объект, соответствующий внутреннему состоянию, не найден... На мой взгляд, это зависит от ситуации. В приведенном примере стоит инициировать исключение. Возможно, в каких-то ситуациях будет полезно вернуть <strong>this</strong>. Примером этого, например, является реализация <strong>java.util.logging.Level</strong>.

Существует и обратный метод – <strong>writeReplace</strong>, который, как вы, наверное, уже догадались, позволяет выдать замещающий объект вместо текущего, для сериализации. Мне, честно сказать, трудно представить себе ситуации, в которых это может понадобиться. Хотя в недрах кода Sun он как-то используется.

Оба метода, как <strong>readResolve</strong>, так и <strong>writeReplace</strong>, вызываются при использовании стандартных средств сериализации (методов readObject и writeObject), вне зависимости от того, объявлен ли сериализуемый класс как <strong>Serializable</strong> или <strong>Externalizable</strong>.

Самое интересное, что, похоже, из этих методов можно возвращать не только экземпляр класса, в котором этот метод определен, но и экземпляр другого класса. Я видел подобные примеры в глубинах библиотек Sun, во всяком случае, для writeReplace – точно видел. Но по каким принципам можно это делать – не берусь пока судить. Вообще, советую интересующимся просмотреть исходники J2SE 5.0, причем полные. Они доступны по лицензии JRL. Там есть много интересных примеров использования этих методов. Исходники можно взять тут – <a href="http://www.oracle.com/technetwork/java/index.html" rel="nofollow" >http://java.sun.com/j2se/jrl_download.html</a>. Правда, требуется регистрация, но она, естественно, бесплатна.

Отдельно хочу коснуться сериализации перечислений (enum), появившихся в Java 5.0. Поскольку при сериализации в поток пишется имя элемента и его порядковый номер в определении в классе, можно было бы ожидать проблем при десериализации в случае изменения порядкового номера (что может случиться очень легко – достаточно поменять элементы местами). Однако, к счастью, таких проблем нет. Десериализация объектов типа enum контролируется для обеспечения соответствия десериализуемых экземпляров уже имеющимся у виртуальной машины. Фактически, это то, что делает обычно метод <strong>readResolve</strong>, но реализовано где-то существенно глубже. Сопоставление объектов осуществляется по имени. Разработчикам версии 5.0 – респект!

* * *

Наверное, на текущий момент это все, что я хотел рассказать о сериализации. Думаю, теперь она не кажется такой простой, какой казалась до прочтения этой статьи. И хорошо. Пребывание в блаженном неведении к добру не приводит.

Ссылка на первоисточник: http://www.skipy.ru/technics/serialization.html