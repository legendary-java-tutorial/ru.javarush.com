Что такое АОП? Основы аспектно-ориентированного программирования
<p>----------------------------------------</p>
Hello, guys! Без понимания основных концепций довольно сложно вникнуть во фреймворки и подходы к построению функционала. Так что сегодня поговорим об одной из таких концепций — АОП...
<p>----------------------------------------</p>
Hello, guys!

Без понимания основных концепций довольно сложно вникнуть во фреймворки и подходы к построению функционала.

Так что сегодня поговорим об одной из таких концепций — АОП, или <span class="text-bold">аспектно-ориентированное программирование</span>.<img data-max-width="800" data-id="b8aa17e1-5346-43bc-a2ca-5ce20e153a23" src="/images/article/b8aa17e1-5346-43bc-a2ca-5ce20e153a23/800.jpeg" alt="Что такое АОП? Основы аспектно-ориентированного программирования - 1">Это тема не из легких и нечасто применяется напрямую, но во многих  фреймворках и технологиях она используется под капотом. Ну и конечно, иногда на собеседованиях вас могут попросить рассказать в общих чертах, что это за зверь такой и где его можно применить. 

Поэтому давайте рассмотрим основные концепции и несколько несложных примеров <span class="text-bold">AOП на Java</span>.<img data-max-width="512" data-id="6d50d823-a86b-4220-893b-892974ad6eaa" src="/images/article/6d50d823-a86b-4220-893b-892974ad6eaa/512.jpeg" alt="Что такое АОП? Основы аспектно-ориентированного программирования - 2">Итак, <span class="text-bold">АОП</span> — <span class="text-bold">аспектно-ориентированное программирование</span> — это парадигма, направленная на повышение модульности различных частей приложения за счет разделения сквозных задач. Для этого  к уже существующему коду добавляется дополнительного поведение, без изменений в изначальном коде. 

Иными словами, мы как бы навешиваем сверху на методы и классы дополнительную функциональность, не внося поправки в модифицируемый код.

Зачем это нужно? Рано или поздно мы приходим к тому, что обычный объектно-ориентированный подход не всегда может эффективно решить те или иные задачи. В такой момент на помощь приходит <span class="text-bold">АОП</span> и дает нам дополнительные инструменты для постройки приложения. А дополнительные инструменты — это увеличение гибкости при разработке, благодаря которой появляется больше вариантов решения той или иной задачи.<h2>Применение АОП</h2>Аспектно-ориентированное программирование предназначено для решения сквозных задач, которые могут представлять собой любой код, многократно повторяющийся разными методами, который нельзя полностью структурировать в отдельный модуль.

Соответственно, с помощью <span class="text-bold">АОП</span> мы можем оставить это за пределами основного кода и определить его по вертикали.

В качестве примера можно привести применение политики безопасности в каком-либо приложении. 

Как правило безопасность проходит сквозь многие элементы приложения. Тем  более, политика безопасности приложения должна применяться одинаково ко всем существующим и новым частям приложения. При этом используемая политика безопасности может и сама развиваться. 

Вот тут нам отлично может пригодится использование <span class="text-bold">АОП</span>.

Также в качестве еще одного примера можно привести <a href="https://javarush.com/groups/posts/2200-logirovanie-razmotatjh-klubok-stektreysa" target="_blank">логирование</a>.

У использования <span class="text-bold">АОП</span> подхода к логированию есть несколько преимуществ по сравнению с ручной вставкой логирования:<ol>
<li>Код для логирования легко внедрять и удалять: всего-то нужно добавить или удалить пару конфигураций некоторого аспекта.</li>
<li>Весь исходный код для логирования хранится в одном месте и не нужно находить вручную все места использования.</li>
<li>Код, предназначенный для логирования, можно добавить в любое место, будь то уже написанные методы и классы или же новый функционал. Это уменьшает количество ошибок разработчика.<br>
Также при удалении аспекта из конфигурации конструкции можно быть абсолютно уверенным, что весь код трассировки удален и ничего не пропущено.</li>
<li>Аспекты — это вынесенный отдельно код, который можно многократно переиспользовать и улучшать.</li></ol><img data-max-width="512" data-id="e64da72b-9239-4681-9f8c-50a75d3b0302" src="/images/article/e64da72b-9239-4681-9f8c-50a75d3b0302/512.jpeg" alt="Что такое АОП? Основы аспектно-ориентированного программирования - 3">Также АОП используется для обработки исключений, кеширования, выноса некоторого функционала, чтобы сделать его переиспользуемым.<h2>Основные понятия АОП</h2>Чтобы продвинуться дальше в разборе темы, для начала познакомимся с главными понятиями АОП.

<span class="text-bold">Совет (advice)</span> — это дополнительная логика, код, который вызывается из точки соединения. 

Совет может быть выполнен до, после или вместо точки соединения (о них — ниже).
 
Возможные <span class="text-bold">виды советов</span>:<ol>
 
<li><span class="text-bold">Перед (Before)</span> — советы данного типа запускаются перед выполнением целевых методов — точек соединения. При использовании аспектов в виде классов мы берем <span class="code">@Before</span> аннотацию, чтобы пометить тип совета как идущий перед. При использовании аспектов в виде файлов <span class="text-bold">.aj</span> это будет метод <span class="code">before()</span>.</li>
 
<li><span class="text-bold">После (After)</span> — советы, которые выполняются после завершения выполнения методов — точек соединения, как в обычных случаях, так и при бросании исключения.<br>
 При использовании аспектов в виде классов мы можем использовать <span class="code">@After</span> аннотацию для указания, что это совет, идущий после.<br>
При использовании аспектов в виде файлов <span class="text-bold">.aj</span> это будет метод <span class="code">after()</span>.</li>
 
<li><span class="text-bold">После возврата (After Returning)</span> — данные советы выполняются только в том случае, когда целевой метод отрабатывает нормально, без ошибок.<br>
Когда аспекты представлены в виде классов, мы можем использовать аннотацию <span class="code">@AfterReturning</span>, чтобы пометить совет как выполняемый после успешного завершения.<br>
При использовании аспектов в виде файлов <span class="text-bold">.aj это будет метод <span class="code">after() returning (Object obj)</span>.</span></li>
 
<li><span class="text-bold">После бросания (After Throwing)</span> — данный вид советов предназначен для тех случаев, когда метод, то есть точка соединения выдает исключение. Мы можем использовать этот совет для некой обработки неудачного выполнения (к примеру, для отката всей транзакции или логирования с необходимым уровнем трассировки).<br>
 Для аспектов-классов аннотация <span class="code">@AfterThrowing</span> используется, чтобы указать, что этот совет используется при после броска исключения.<br>
При использовании аспектов в виде файлов <span class="text-bold">.aj</span> это будет метод — <span class="code">after() throwing (Exception e)</span>.</li>
 
<li><span class="text-bold">Вокруг (Around)</span> — пожалуй, один из самых важных видов советов,  который окружает метод, то есть — точку соединения, с помощью которого мы можем, к примеру, выбрать, выполнять данный метод точки соединения или нет. <br>
 
Можно написать код совета, который будет выполняться до и после выполнения метода точки соединения.<br>
 
В обязанности <span class="text-bold">around advice</span> входит вызов метода точки соединения и возвращение значений, если метод что-то возвращает. То есть в этом совете можно попросту сымитировать работу целевого метода, не вызывая его, и в качестве результата вернуть что-то свое.<br>
 
При аспектах в виде классов используем <span class="code">@Around</span> аннотацию для создания советов, оборачивающих точку соединения. При использовании аспектов в виде файлов <span class="text-bold">.aj</span> это будет метод <span class="code">around()</span>.</li>
 
</ol><span class="text-bold">Точка соединения (join point)</span> — точка в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет. Иначе говоря, это некоторое регулярное выражение, с помощью которого и находятся места для внедрения кода (места для применения советов).

<span class="text-bold">Срез (pointcut)</span> — набор <span class="text-bold">точек соединения</span>. Срез определяет, подходит ли данная точка соединения к данному совету.

<span class="text-bold">Аспект (aspect)</span> — модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя <span class="text-bold">совет</span> в <span class="text-bold">точках соединения</span>, определенных некоторым <span class="text-bold">срезом</span>. Иными словами, это комбинация советов и точек соединения.

<span class="text-bold">Внедрение (introduction)</span> — изменение структуры класса и/или изменение иерархии наследования для добавления функциональности аспекта в инородный код.

<span class="text-bold">Цель (target)</span> — объект, к которому будут применяться советы.

<span class="text-bold">Плетение (weaving)</span> — это процесс связывания аспектов с другими объектами для создания рекомендуемых прокси-объектов. Это можно сделать во время компиляции, загрузки или во время выполнения. 

Есть три вида плетения:<ul>

<li><span class="text-bold">плетение во время компиляции</span> — если у вас есть исходный код аспекта и код, в котором вы используете аспекты, вы можете скомпилировать исходный код и аспект напрямую с помощью компилятора AspectJ;</li>
<li><span class="text-bold">посткомпиляционное плетение</span> (бинарное плетение) — если вы не можете или не хотите использовать преобразования исходного кода для вплетения аспектов в код, вы можете взять уже скомпилированные классы или jar-файлы и внедрить аспекты;</li>
<li><span class="text-bold">плетение во время загрузки</span> — это просто бинарное плетение, отложенное до момента, когда загрузчик классов загрузит файл класса и определит класс для JVM.<br>
Для поддержки этого требуется один или несколько «загрузчиков классов плетения». Они либо явно предоставляются средой выполнения, либо активируются с помощью «агента плетения.</li>
 
</ul><span class="text-bold">AspectJ</span> — конкретная реализация парадигм <span class="text-bold">АОП</span>, реализующая возможности решения сквозных задач. Документацию можно найти вот <a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/index.html" rel="nofollow" target="_blank">тут</a>.<h2>Примеры в Java</h2>Далее для большего понимания <span class="text-bold">АОП</span> мы рассмотрим небольшие примеры уровня Hello World.<img data-max-width="512" data-id="2c7885ae-f82c-4088-b1af-9ee6fe1329b8" src="/images/article/2c7885ae-f82c-4088-b1af-9ee6fe1329b8/512.jpeg" alt="Что такое АОП? Основы аспектно-ориентированного программирования - 4">Сразу отмечу, что в наших примерах будем использовать <span class="text-bold">плетение во время компиляции</span>.

Сперва нам нужно прописать следующую зависимость в нашем <span class="text-bold">pom.xml</span>:

<pre class="language-java line-numbers"><code>
&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
  &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
Как правило для использования аспектов применяют особый компилятор <span class="text-bold">Ajs</span>. В <span class="text-bold">IntelliJ IDEA</span> по умолчанию его нет, поэтому при выборе его как компилятора приложения нужно указать путь к дистрибутиву <span class="text-bold">AspectJ</span>. Подробнее о способе выбора <span class="text-bold">Ajs</span> как компилятора можно почитать на этой странице.

Это был первый способ, а второй (которым я и воспользовался) — прописать следующий плагин в <span class="text-bold">pom.xml</span>:

<pre class="language-java line-numbers"><code>
&lt;build&gt;
  &lt;plugins&gt;
     &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.7&lt;/version&gt;
        &lt;configuration&gt;
           &lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt;
           &lt;source&gt;1.8&lt;/source&gt;
           &lt;target&gt;1.8&lt;/target&gt;
           &lt;showWeaveInfo&gt;true&lt;/showWeaveInfo&gt;
           &lt;verbose&gt;true&lt;/verbose&gt;
           &lt;Xlint&gt;ignore&lt;/Xlint&gt;
           &lt;encoding&gt;UTF-8&lt;/encoding&gt;
        &lt;/configuration&gt;
        &lt;executions&gt;
           &lt;execution&gt;
              &lt;goals&gt;
                 &lt;goal&gt;compile&lt;/goal&gt;
                 &lt;goal&gt;test-compile&lt;/goal&gt;
              &lt;/goals&gt;
           &lt;/execution&gt;
        &lt;/executions&gt;
     &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
После этого желательно сделать реимпорт у <a href="https://javarush.com/groups/posts/2523-chastjh-4osnovih-maven" target="_blank">Мавена</a> и запустить <span class="text-bold">mvn clean compile</span>.
 
А теперь перейдём непосредственно к примерам.<h3>Пример №1</h3>Давайте создадим класс <span class="code">Main</span>. В нем у нас будет точка запуска и метод, который печатает в консоли переданные ему имена:
 
<pre class="language-java line-numbers"><code>
public class Main {
 
  public static void main(String[] args) {
  printName("Толя");
  printName("Вова");
  printName("Саша");
  }
 
  public static void printName(String name) {
     System.out.println(name);
  }
}
</code></pre>
Ничего сложного: передали имя — вывели его в консоли.

Если мы сейчас запустим, в консоли будет выведено:

<div class="terminal">Толя
Вова
Саша</div>
 Что ж, пришло время воспользоваться возможностями АОП.
 
Сейчас нам нужно создать файл — <span class="text-bold">аспект</span>. Они бывают двух видов: первый — файл с расширением <span class="text-bold">.aj</span>, второй — обычный класс, который реализует возможности <span class="text-bold">АОП</span> при помощи аннотаций.
 
Давайте сперва рассмотрим файл с расширением <span class="text-bold">.aj</span>:

<pre class="language-java line-numbers"><code>
public aspect GreetingAspect {
 
  pointcut greeting() : execution(* Main.printName(..));
 
  before() : greeting() {
     System.out.print("Привет ");
  }
}
</code></pre>
 Данный файл чем-то похож на класс. Разберемся, что здесь происходит:
 
<span class="code">pointcut</span> — срез или набор точек соединения; 
<span class="code">greeting()</span> — название данного среза; 
<span class="code">: execution</span> — при выполнении <span class="code">*</span> — всех, вызов — <span class="code">Main.printName(..)</span> — данного метода.
 
Далее идёт конкретный совет — <span class="code">before()</span> — который выполняется до вызова целевого метода, <span class="code">: greeting()</span> — срез, на который данный совет реагирует, ну а ниже мы видим само тело метода, которое написано на понятном нам языке Java.
 
При запуске <span class="code">main</span> с наличием данного аспекта мы получим вывод в консоль:

<div class="terminal">Привет Толя
Привет Вова
Привет Саша</div>
Мы видим, что каждый вызов метода <span class="code">printName</span> был модифицирован при помощи аспекта.
 
А теперь давайте взглянем, как будет выглядеть аспект, но уже как класс Java с аннотациями:
 
<pre class="language-java line-numbers"><code>
@Aspect
public class GreetingAspect{
 
  @Pointcut("execution(* Main.printName(String))")
  public void greeting() {
  }
 
  @Before("greeting()")
  public void beforeAdvice() {
     System.out.print("Привет ");
  }
}
</code></pre>
 
После файла аспекта <span class="text-bold">.aj</span> тут всё более очевидно:<ul>
 
<li><span class="code">@Aspect</span> обозначает, что данный класс является аспектом;</li>
<span class="code">@Pointcut("execution(* Main.printName(String))")</span> — точка среза, которая срабатывает на все вызовы <span class="code">Main.printName</span> с входящим аргументом типа <span class="code">String</span>;
<li><span class="code">@Before("greeting()")</span> — совет, который применяется до вызова кода описанного в точке среза <span class="code">greeting()</span>.</li>
 
</ul>При запуске <span class="code">main</span> с этим аспектом вывод в консоли не изменится:

<div class="terminal">Привет Толя
Привет Вова
Привет Саша</div><h3>Пример №2</h3>Допустим, у нас есть некоторый метод который осуществляет некоторые операции для клиентов и вызов этого метода из <span class="code">main</span>:

<pre class="language-java line-numbers"><code>
public class Main {
 
  public static void main(String[] args) {
  makeSomeOperation("Толя");
  }
 
  public static void makeSomeOperation(String clientName) {
     System.out.println("Выполнение некоторых операций для клиента - " + clientName);
  }
}
</code></pre>
С помощью аннотации <span class="code">@Around</span> сделаем что-то типа “псевдотранзакции”:

<pre class="language-java line-numbers"><code>
@Aspect
public class TransactionAspect{
 
  @Pointcut("execution(* Main.makeSomeOperation(String))")
  public void executeOperation() {
  }

  @Around(value = "executeOperation()")
  public void beforeAdvice(ProceedingJoinPoint joinPoint) {
     System.out.println("Открытие транзакции...");
     try {
        joinPoint.proceed();
        System.out.println("Закрытие транзакции....");
     }
     catch (Throwable throwable) {
        System.out.println("Операция не удалась, откат транзакции...");
     }
  }
  }
</code></pre>
С помощью метода <span class="code">proceed</span> объекта <span class="code">ProceedingJoinPoint</span> мы вызываем оборачиваемый метод, чтобы определить его место в совете и, соответственно, код в методе, который выше <span class="code">joinPoint.proceed();</span> — это <span class="text-bold">Before</span>, который ниже — <span class="text-bold">After</span>.

Если мы запустим <span class="code">main</span>, в консоли мы получим:

<div class="terminal">Открытие транзакции...
Выполнение некоторых операций для клиента - Толя
Закрытие транзакции....</div>
Если же мы добавим бросок исключения в наш метод (вдруг выполнение операции дало сбой):

<pre class="language-java line-numbers"><code>
public static void makeSomeOperation(String clientName)throws Exception {
  System.out.println("Выполнение некоторых операций для клиента - " + clientName);
  throw new Exception();
}
</code></pre>
То мы получим вывод в консоли:

<div class="terminal">Открытие транзакции...
Выполнение некоторых операций для клиента - Толя
Операция не удалась, откат транзакции...</div>
Получилась такая себе псевдообработка неудачи.<h3>Пример №3</h3>В качестве следующего примера сделаем что-то типа логирования в консоли.

Для начала посмотрим в <span class="code">Main</span>, где у нас происходит псевдо бизнес-логика:

<pre class="language-java line-numbers"><code>
public class Main {
  private String value;
 
  public static void main(String[] args) throws Exception {
     Main main = new Main();
     main.setValue("&lt;некоторое значение&gt;");
     String valueForCheck = main.getValue();
     main.checkValue(valueForCheck);
  }
 
  public void setValue(String value) {
     this.value = value;
  }
 
  public String getValue() {
     return this.value;
  }
 
  public void checkValue(String value) throws Exception {
     if (value.length() &gt; 10) {
        throw new Exception();
     }
  }
}
</code></pre>
В <span class="code">main</span> с помощью <span class="code">setValue</span> мы зададим значение внутренней переменной — <span class="code">value</span>, далее с помощью <span class="code">getValue</span> возьмём это значение и в <span class="code">checkValue</span> проверим, длиннее ли это значение 10 символов. Если да, будет брошено исключение.

Теперь посмотрим на аспект, с помощью которого мы будем логировать работу методов:

<pre class="language-java line-numbers"><code>
@Aspect
public class LogAspect {
 
  @Pointcut("execution(* *(..))")
  public void methodExecuting() {
  }
 
  @AfterReturning(value = "methodExecuting()", returning = "returningValue")
  public void recordSuccessfulExecution(JoinPoint joinPoint, Object returningValue) {
     if (returningValue != null) {
        System.out.printf("Успешно выполнен метод - %s, класса- %s, с результатом выполнения - %s\n",
              joinPoint.getSignature().getName(),
              joinPoint.getSourceLocation().getWithinType().getName(),
              returningValue);
     }
     else {
        System.out.printf("Успешно выполнен метод - %s, класса- %s\n",
              joinPoint.getSignature().getName(),
              joinPoint.getSourceLocation().getWithinType().getName());
     }
  }
 
  @AfterThrowing(value = "methodExecuting()", throwing = "exception")
  public void recordFailedExecution(JoinPoint joinPoint, Exception exception) {
     System.out.printf("Метод - %s, класса- %s, был аварийно завершен с исключением - %s\n",
           joinPoint.getSignature().getName(),
           joinPoint.getSourceLocation().getWithinType().getName(),
           exception);
  }
}
</code></pre>
Что тут происходит?

<span class="code">@Pointcut("execution(* *(..))")</span> — будет соединяться со всеми вызовами всех методов;
<span class="code">@AfterReturning(value = "methodExecuting()", returning = "returningValue")</span> — совет, который будет выполнен после успешного выполнения целевого метода. 

У нас тут есть два случая:<ol>
<li>Когда у метода есть возвращаемое значение <span class="code">if (returningValue != null) {</span></li>
<li>Когда возвращаемого значения нет <span class="code">else {</span></li>

</ol><span class="code">@AfterThrowing(value = "methodExecuting()", throwing = "exception")</span> — совет, который будет срабатывать при ошибке, то есть при падении исключения из метода.

И соответственно, запустив <span class="code">main</span>, мы получим своеобразное логирование в консоли:

<div class="terminal">Успешно выполнен метод - setValue, класса- Main
Успешно выполнен метод - getValue, класса- Main, с результатом выполнения - &lt;некоторое значение&gt;
Метод - checkValue, класса- Main, был аварийно завершен с исключением - java.lang.Exception
Метод - main, класса- Main, был аварийно завершен с исключением - java.lang.Exception</div>
Ну и так как мы не обработали исключения, еще получим его стектрейс:<img data-max-width="512" data-id="91749db7-6e5f-4d97-860f-6fcdd46568ee" src="/images/article/91749db7-6e5f-4d97-860f-6fcdd46568ee/512.jpeg" alt="Что такое АОП? Основы аспектно-ориентированного программирования - 5">Почитать об исключениях и их обработке можно в этих статьях: <a href="https://javarush.com/groups/posts/2433-iskljuchenija-v-java" target="_blank">Исключения в Java</a> и <a href="https://javarush.com/groups/posts/1401-iskljuchenija-i-ikh-obrabotka" target="_blank">Исключения и их обработка</a>. На этом у меня сегодня всё.

Сегодня мы познакомились с <span class="text-bold">АОП</span>, и вы смогли увидеть, что сей зверь не так страшен, как его рисуют.

<span class="text-bold">Goodbye everyone!<span><img data-max-width="512" data-id="ca7a4493-3dfa-4416-ab61-a5edc3c96e6d" src="/images/article/ca7a4493-3dfa-4416-ab61-a5edc3c96e6d/512.jpeg" alt="Что такое АОП? Основы аспектно-ориентированного программирования - 6"></span></span>