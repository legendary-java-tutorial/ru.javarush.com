KotlinRush: а есть ли смысл продолжать писать на Java?
<p>----------------------------------------</p>
Привет, студент JavaRush, пока тебя целиком и полностью не поглотила Java, я хотел бы расширить твой кругозор и обратить внимание на набирающий популярность язык Kotlin! Kotlin — достаточно молодой язык, разработанный компанией JetBrains. Да-да, именно той самой компанией...
<p>----------------------------------------</p>
Привет, студент JavaRush, пока тебя целиком и полностью не поглотила Java, я хотел бы расширить твой кругозор и обратить внимание на набирающий популярность язык <a href="http://kotlinlang.org" target="_blank" rel="nofollow">Kotlin</a>!
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="c055a649-bdc8-4284-965d-006aecd49292" data-max-width="710" alt="KotlinRush: а есть ли смысл продолжать писать на Java? - 1" src="https://cdn.javarush.com/images/article/c055a649-bdc8-4284-965d-006aecd49292/1024.jpeg"></div></div>Kotlin — достаточно молодой язык, разработанный компанией <a href="http://www.jetbrains.com" target="_blank" rel="nofollow">JetBrains</a>. Да-да, именно той самой компанией, которая разработала нашу любимую IDE: IntelliJ&nbsp;IDEA. Kotlin является JVM языком и <u>полностью совместим с Java</u>, то есть из Kotlin-кода можно без проблем обращаться к привычным Java-библиотекам, Да что там к библиотекам: Kotlin и Java классы могут уживаться в одном package!

Kotlin настолько пришелся по душе сообществу программистов, что Google признал его официальным языком разработки под Android, а в последнее время Kotlin начал набирать популярность и в энтерпрайз-проектах.

В данной статье я хотел бы привести несколько сравнительных примеров кода, написанного на Kotlin и на Java, и сделать некоторые выводы. Поехали!

<strong>Начнем по традиции с "Hello World"</strong>

<pre class="lang-java line-numbers"><code>
// Java
public class Application {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
class Application
fun main(vararg args: String) {
    println("Hello World!")
}
</code></pre>
Глядя на пример Kotlin, можно сразу отметить следующее:
<ul>
<li> не нужно писать точку с запятой в конце строки;</li>
<li> все методы описываются ключевым словом <strong>fun</strong>;</li>
<li> чтобы вывести строку достаточно всего одного слова — <em>println()</em>!</li></ul>

<strong>Создание экземпляра</strong>

<pre class="lang-java line-numbers"><code>
// Java (до 10)
final Application application = new Application();
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
val application = Application()
</code></pre>
Отличия Kotlin:
<ul>
<li> не требуется объявлять тип переменной, если он понятен по экземпляру;</li>
<li> вместо типа переменной — <strong>val</strong> (неизменяемая) или <strong>var</strong> (изменяемая);</li>
<li> для создания экземпляра не нужно писать ключевое слово <strong>new</strong>!</li>
</ul>
<strong>Описание методов</strong>

<pre class="lang-java line-numbers"><code>
// Java
public int sum(int a, int b) {
    return (a + b);
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
fun sum(a: Int, b: Int): Int {
return (a + b)
}
</code></pre>
Отличия Kotlin:
<ul>
<li> если из метода нужно что-то вернуть, в сигнатуру добавляется "<strong>: Int</strong>", где <strong>Int</strong> — возвращаемый тип;</li>
<li> описание параметров метода: сначала имя переменной, затем тип;</li>
<li> так как тело метода состоит всего из одной строки, можно опустить <strong>return</strong>:<br>
<pre class="lang-java line-numbers"><code>
fun sum(a: Int, b: Int): Int = (a+b)
</code></pre></li></ul>
<strong>Форматированный вывод строк</strong>

<pre class="lang-java line-numbers"><code>
// Java
public int sum(int a, int b) {
    int result = (a + b);
    System.out.printf("Сумма %d и %d равна %d\n", a, b, result);
    return result;
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
fun sum(a: Int, b: Int): Int {
    val result = (a + b)
    println("Сумма $a и $b равна $result")
    return result
}
</code></pre>
Kotlin поддерживает интерполяцию строк, достаточно использовать символ "$" вначале переменной. Такая запись значительно повышает чистоту и читабельность кода.

<strong>Сравнение экземпляров</strong>

<pre class="lang-java line-numbers"><code>
// Java
object1.equals(object2)
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
object1 == object2
</code></pre>
В Kotlin сравнение "<code>==</code>" для объектных типов транслируется в <code>equals</code>!  А для сравнения ссылок используется "<code>===</code>".

<strong>Исключения</strong>

<pre class="lang-java line-numbers"><code>
// Java
public List&lt;String&gt; getFileContent(String file) throws IOException {
    Path path = Paths.get(file);
    return Files.readAllLines(path);
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
fun getFileContent(file: String): List&lt;String&gt; {
    val path = Paths.get(file)
    return Files.readAllLines(path)
}
</code></pre>
В Kotlin нет <strong>checked</strong>-исключений, теперь не нужно бесконечно прокидывать исключение через всё приложение или городить многоуровневые <code>try-catch</code>.

<strong>Null Safety</strong>

<pre class="lang-java line-numbers"><code>
// Java 
public class Data {
    String value;

    String render() {
        if (value == null) {
            return "Value: undefined";
        } else {
            return "Value:" + value.toUpperCase();
        }
    }
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
class Data {
    var value: String? = null
    fun render(): String =
            "Value: ${value?.toUpperCase() ?: "undefined"}"
}
</code></pre>
В Kotlin озаботились проблемой NPE и ввели ряд требований:
<ul>
<li> все поля класса и переменные обязательно должны быть проинициализированы;</li>
<li> в поле или переменную можно записать "null", но тогда ты обязан явно сказать, что твоя переменная Nullable (написать знак "?");</li>
<li> элвис-оператор "?:" работает следующим образом: если слева Null, возьми то, что указано справа. В случае с нашим примером, когда переменная <em> value</em> не проинициализирована, возьмется значение "<strong>undefined</strong>".</li>
</ul>
<strong>Поля класса и доступ к ним</strong>

<pre class="lang-java line-numbers"><code>
// Java
public class Data {
    private String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
class App {
    void execute() {
           Data data = new Data()
           data.setValue("Foo")
     }
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
class Data {
    var value: String = ""
}
class App {
    fun execute() {
          val data = Data()
          data.value = "Foo" // Под капотом выполнится data.set("Foo")
     }
}
</code></pre>
В Kotlin достаточно просто описать поле и всё: у него уже есть неявные геттеры и сеттеры (привет <a href="https://projectlombok.org" target="_blank" rel="nofollow">lombok</a>), которые при желании в любой момент можно переопределить. При этом читаем и модифицируем значение поля просто обращаясь непосредственно к нему, а под капотом вызывается <code>get()|set()</code>.

<strong>Циклы</strong>

<pre class="lang-java line-numbers"><code>
// Java
void example() {
    for(int i = 1; i &lt;= 10; i++) {
        System.out.println(i);
    }

    for(String line : "a,b,c".split(",")) {
        System.out.println(line);
    }
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
fun example() {
    for(i in 1..10) {
        println(i)
    }

    for(line in "a,b,c".split(",")) {
        println(line)
    }
}
</code></pre>
Kotlin предоставил удобный и единообразный синтаксис обхода последовательностей: ты просто используешь <em>слева</em> переменную, <em>справа</em> последовательность, а между ними — ключевое слово "<strong>in</strong>", тип определяется автоматически по содержимому.

<strong>Синглтон</strong>

<pre class="lang-java line-numbers"><code>
// Java
public class Singleton {
    private static Singleton ourInstance = new Singleton();

    public static Singleton getInstance() {
        return ourInstance;
    }

    private Singleton() {
    }
}
class App {
    void execute() {
         Singleton singleton = Singleton.getInstance()
    }
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
object Singleton {}

class App {
    fun execute() {
          val singleton = Singleton
    }
}
</code></pre>
Знакомый всем паттерн "<em>одиночка</em>" достаточно часто используется на практике, поэтому в Kotlin решили создать отдельное ключевое слово "<strong>object</strong>", которое пишется вместо "<strong>class</strong>" и означает, что класс является синглтоном, при использовании даже не нужно звать конструктор или какие-либо другие методы!

<strong>Именованные параметры методов и дефолтные значения</strong>

<pre class="lang-java line-numbers"><code>
// Java
void setStatus(String code) {
    setStatus(code, "");
}

void setStatus(String code, String desc) {
    this.code = code;
    this.desc = desc;
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
fun setStatus(code: String, desc: String = "") {
    this.code = code;
    this.desc = desc;
}

fun execute() {
    setStatus("200")
    setStatus(code = "200", desc = "Ok")
}
</code></pre>
Случается такое, что не все параметры в методе или конструкторе должны быть обязательными, и в Java мы привыкли создавать набор методов или конструкторов под всевозможную комбинацию параметров. В Kotlin ввели дефолтные параметры, что позволяет объявить 1 метод и передавать в него необходимый набор параметров по ситуации.

<strong>Стримы </strong>

<pre class="lang-java line-numbers"><code>
// Java 
String getFirst(List&lt;String&gt; strings, String alpha) {
    return strings.stream()
            .filter(x -&gt; x.startsWith(alpha))
            .findFirst()
            .orElse("");
}
</code></pre>
<pre class="lang-java line-numbers"><code>
// Kotlin
fun getFirst(strings: List&lt;String&gt;, alpha: String): String {
    return strings.first { it.startsWith(alpha) }
}
</code></pre>
Появившиеся stream в Java 8 стали неотъемлемым функционалом при работе с коллекциями. В Kotlin стримы сделали еще более удобными и функциональными: у каждой коллекции уже есть набор удобных частоиспользуемых методов для работы с данными. Кроме того, обрати внимание на лямбда выражение внутри метода first: если функциональный литерал имеет ровно один параметр, его объявление можно удалить (вместе с&nbsp;-&gt;), и обращаться к нему по имени&nbsp;<strong>it</strong>. 

<strong>Пора бы закругляться...</strong>
Я продемонстрировал лишь малую, базовую часть функционала, но, я уверен, тебе уже захотелось попробовать Kotlin!
По своему опыту я могу сделать следующие выводы:
<ul>
<li> Java разработчику очень легко освоить синтаксис Kotlin и начать писать код;</li>
<li> у Kotlin полная совместимость с Java, и его уже можно пробовать в своих действующих проектах, например, в тестах;</li>
<li> код на Kotlin чище и читабельнее, не нужно писать кучу <a href="https://en.wikipedia.org/wiki/Boilerplate_code" target="_blank" rel="nofollow">бойлерплэйта</a>;</li>
<li> в IDEA есть автоматический конвертер Java в Kotlin, вы можете брать готовый Java-код и автоматически конвертировать его в Kotlin;</li>
<li> новый проект нужно писать на Kotlin, так как с инфраструктурной точки зрения — это та же Java, а по использованию — лучше и удобнее!</li>
</ul>
Если статья понравилась и вообще уместна на ресурсе о Java, могу продолжить писать об опыте использования Kotlin в реальном энтерпрайзном проекте.

<strong>Полезные ссылки:</strong>
<ul>
<li><a href="https://pl.kotl.in/B1erryksX" target="_blank" rel="nofollow">Попробовать написать что-либо на Kotlin в online</a></li>
<li><a href="https://play.kotlinlang.org/byExample/overview" target="_blank" rel="nofollow">Учим Kotlin - набор и описание разнообразных интерактивных примеров</a></li>
<li><a href="https://play.kotlinlang.org/koans/overview" target="_blank" rel="nofollow">Плагин для IDEA для обучения с валидацией (такой mini-JavaRush)</a></li>
<li><a href="http://kotlinlang.org" target="_blank" rel="nofollow">Официальный сайт Kotlin</a></li>
<li><a href="https://kotlinlang.ru" target="_blank" rel="nofollow">Русский сайт Kotlin</a></li>
</ul>