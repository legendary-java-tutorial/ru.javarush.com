Машинное обучение для Java-разработчиков, часть 1
<p>----------------------------------------</p>
Автомобили с автономным управлением, системы распознавания лиц и голосовые помощники — всё они разработаны на базе технологий и фреймворков машинного обучения. И это только первая волна. За следующие 10 лет новое поколение продуктов, преобразит наш мир ...
<p>----------------------------------------</p>
<em>Настройте алгоритм машинного обучения и разработайте свою первую функцию прогнозирования с помощью Java.  </em>

Автомобили с автономным управлением, системы распознавания лиц и голосовые помощники — всё они разработаны на базе технологий и фреймворков машинного обучения. И это только первая волна. За следующие 10 лет новое поколение продуктов, преобразит наш мир, порождая новые подходы к разработке программ, продуктов и приложений.
<img data-id="b6df46c9-8663-4210-ac3a-2bfbf900aec5" data-max-width="850" alt="Машинное обучение для Java-разработчиков, часть 1 - 1" src="https://cdn.javarush.com/images/article/b6df46c9-8663-4210-ac3a-2bfbf900aec5/1024.jpeg">Как Java-программист вы хотите поймать эту волну прямо сейчас, когда технологические компании начинают серьезно инвестировать в машинное обучение. То, что вы изучите сегодня, вы сможете использовать в течение последующих пяти лет. Только вот с чего начать? Данная статья призвана ответить на этот вопрос. 

Вы получите первые впечатления о принципах машинного обучения, следуя нашей небольшой инструкции по реализации и подготовке алгоритма машинного обучения. 

После изучения структуры алгоритма обучения и возможностей, которые вы можете использовать для его тренировки, оценки и выбора функции, обеспечивающей наилучшую точность прогнозов, вы получите представлении об использовании фреймворка для JVM (Weka) для построения решений на базе машинного обучения. Эта статья фокусируется на контролируемом машинном обучении, поскольку именно этот принцип наиболее распространен при разработке «умных» приложений.
<h3>Машинное обучение и искусственный интеллект</h3>Машинное обучение эволюционировало из области искусственного интеллекта, цель которой — создание машин, способных подражать человеческому интеллекту. Хотя термин «машинное обучение» появился в информатике, искусственный интеллект не является новой областью науки. <em><strong>Тест Тьюринга</strong></em>, разработанный математиком Аланом Тьюрингом в начале пятидесятых годов 20-го века, является одним из первых тестов, предназначенных для определения наличия настоящего интеллекта у вычислительной машины. Согласно тесту Тьюринга, вычислительная машина доказывает наличие человеческого интеллекта тем, что выдает себя за человека, и последний не догадывается, что говорит с машиной. 
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="46c2ec6b-45c2-4e3e-9613-693147384956" data-max-width="710" alt="Машинное обучение для Java-разработчиков, часть 1 - 2" src="https://cdn.javarush.com/images/article/46c2ec6b-45c2-4e3e-9613-693147384956/1024.jpeg"></div></div>Многие популярные сегодня подходы в машинном обучении базируются на идеях, которым уже десятки лет. Но последняя декада в вычислительной технике (и распределенных вычислительных платформах) привнесла достаточные мощности для применения алгоритмов машинного обучения. Большинство из них требуют огромного количества операций умножения матриц и других математических вычислений. Двадцать лет назад вычислительные технологии, позволяющие осуществить такие вычисления попросту не существовали, а сейчас они уже стали реальностью. 

Алгоритмы машинного обучения позволяют программам выполнять процесс улучшения качества и расширять свои возможности без участия человека. Программа, разработанная с использованием машинного обучения, способна самостоятельно обновлять или расширять свой собственный код.
<h3>Контролируемое обучение vs неконтролируемое обучение</h3><table>
<tr>
<td>
<a href='https://javarush.com/groups/posts/309-deep-learning-iskusstvennihy-intellekt-i-mashinnoe-obuchenie-dlja-chaynikov-obhhjasnenie-na-prim ' target='_blank'>Deep Learning, искусственный интеллект и машинное обучение для чайников: объяснение на примере</a>
</td>
</tr>
</table>Контролируемое и неконтролируемое обучение являются двумя наиболее популярными подходами к машинному обучению. Для обоих вариантов необходимо давать машине огромное количество записей данных для построения соотношений и обучения. Такие собранные данные обычно называют <em><strong>«вектором признаков»</strong></em>. Например, у нас есть некий жилой дом. В таком случае вектор признаков может содержать такие признаки, как: общая площадь дома, количество комнат, год постройки дома и так далее.

<em><strong>При контролируемом обучении</strong></em>, алгоритм машинного обучения подготавливается для ответа на вопросы, связанные с векторами признаков. Для тренировки алгоритма, ему «скармливают» набор векторов признаков и связанных меток. Связанную метку предоставляет человек (учитель), и она содержит правильный «ответ» на заданный вопрос. Алгоритм обучения анализирует векторы признаков и правильные метки для поиска внутренней структуры и взаимоотношений между ними. Таким образом машина учится правильно отвечать на вопросы.

В качестве примера можно рассмотреть некое интеллектуальное приложение для торговли недвижимостью. Его можно натренировать с помощью вектора признаков, включающего размер, количество комнат, и год постройки для набора домов. Человек должен присвоить каждому дому метку с правильной ценой дома, базируясь на этих факторах. Анализируя эти данные, умное приложение должно натренироваться, чтобы ответить на вопрос «Сколько денег я смогу получить за этот дом?».
<table>
<tr>
<td>
Интересно читать о Java? Вступайте в группу <a href='https://javarush.com/groups/java-developer' target='_blank'>Java Developer</a>!
</td>
</tr>
</table>После того как процесс подготовки закончен, новые входные данные уже больше не маркируются. Машина должна быть способна правильно отвечать на вопросы, даже для не известных, не промаркированных векторов признаков.

При неконтролируемом обучении, алгоритм строится таким образом чтобы предсказывать ответы без маркировки человеком (или даже без вопросов). Вместо определения маркировки или результата, алгоритмы неконтролируемого обучения используют большие массивы данных и вычислительные мощности для выявления ранее не известных взаимоотношений. 

Например, в маркетинге потребительских продуктов можно использовать неконтролируемое обучение для определения скрытых взаимосвязей или группирования клиентов, что в конце концов поможет усовершенствовать маркетинговую программу или создать новую.

В этой статье мы сосредоточимся на контролируемом машинном обучении; в настоящее время этот подход используется чаще всего. 
<h3>Контролируемое машинное обучение</h3>Любое машинное обучение базируется на данных. Для проекта по контролируемому машинному обучению,нужно отметить маркерами данные таким образом, чтобы получить осмысленные ответы на задаваемый вопрос. Ниже, в Таблице-1, каждая запись информации о доме имеет метку «цена дома».

Выявляя взаимосвязь между данными записей и ценой дома, алгоритм в итоге должен быть способным предсказать рыночную цену для домов не входящих в данный список. (Обратите внимание, площадь дома указана в квадратных метрах, а стоимость дома в евро).
<table>
<thead>
<tr>
<td colspan="4"><center>Таблица 1. Список домов</center></td>
</tr>
<tr>
<th>Признак</th>
<th>Признак</th>
<th>Признак</th>
<th>Метка</th>
</tr>
<tr>
<th>Площадь дома</th>
<th>Количество комнат</th>
<th>Возраст дома</th>
<th>Ожидаемая цена дома</th>
</tr>
</thead>
<tbody>
<tr>
<td>90 m2 / 295 ft</td>
<td>2 Комнаты</td>
<td>23 года</td>
<td>249,000 €</td>
</tr>
<tr>
<td>101 m2 / 331 ft</td>
<td>3 Комнаты</td>
<td>n/a</td>
<td>338,000 €</td>
</tr>
<tr>
<td>1330 m2 / 4363 ft</td>
<td>11 комнат</td>
<td>12 лет</td>
<td>6,500,000 €</td>
</tr>
</tbody>
</table>На ранних этапах вы, скорее всего, будете маркировать данные вручную, но в конце концов вы научите вашу программу делать это самостоятельно. Вы, вероятно, уже видели как работает такой подход с клиентами электронной почты, когда для перемещения письма в папку «Спам» вы отвечаете на вопрос «Является ли это письмо не желательным?». Когда вы отвечаете, вы обучаете программу распознавать письма, которые вы не хотите видеть. Спам-фильтр приложения обучается маркировать письма из того же источника, или содержащее такой же контент и управлять ими согласно соответствующим правилам.

Маркированные наборы данных необходимы только для подготовки и тестирования. После того как этот этап окончен, алгоритм машинного обучения работает с немаркированными данными. К примеру, вы можете подать в алгоритм предсказания новую немаркированную запись данных о доме и он должен автоматически предсказать ожидаемую цену дома базируясь на «знаниях» полученных из подготовительных данных.

<h3>Как машина обучается предсказывать</h3>Сложность контролируемого машинного обучения -- в поиске подходящей функции предсказания для определенного вопроса. Математически сложность состоит в том чтобы найти функцию которая получает на вход переменную <code>х</code> и возвращает предсказанное значение <code>у</code>. Эта функция гипотез <code>(hθ)</code> является результатом процесса подготовки. Часто функция гипотез также называется целевой функцией или функцией предсказания.
 
<center><big><big><big><em><mark>y = h<sub>θ</sub> (x)</mark></em></big></big></big></center>
В большинстве случаев, <code>х</code> представляет собой массив данных. В нашем примере -- это двухмерный массив из элементов, определяющих дом, состоящий из количества комнат и площади дома. Массив таких значений является вектором признаков. Задав конкретную целевую функцию, мы можем использовать её для предсказания каждого вектора признаков <code>х</code>. Чтобы предсказать цену дома, вы должны вызвать целевую функцию используя вектор признаков <code>{101.0, 3.0}</code>, состоящий из площади дома и количества комнат:

<pre class='lang-java line-numbers'><code>
// целевая функция h (результат процесса обучения)
Function&ltDouble[], Double&gt h = ...;

// определяем целевой вектор с площадью дома=101 и количеством комнат=3
Double[] x = new Double[] { 101.0, 3.0 };

// и предсказываем цену дома (метка)
double y = h.apply(x);
</code></pre>
В исходном коде из примера-1, значения в массиве <code>х</code> представляют вектор признаков дома. Значение <code>у</code>, возвращаемое целевой функцией, -- это предсказанная цена дома.

Целью машинного обучения является определение целевой функции, которая будет работать максимально точно при неизвестных входных параметров. В машинном обучении, целевая функция <code>(hθ)</code> иногда называется моделью. Эта модель является результатом процесса обучения.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="5c49aabd-0f5f-48c6-939b-4ce569b9f401" data-max-width="710" alt="Машинное обучение для Java-разработчиков, часть 1 - 3" src="https://cdn.javarush.com/images/article/5c49aabd-0f5f-48c6-939b-4ce569b9f401/1024.jpeg"></div></div>Базируясь на маркированных тренировочных образцах, алгоритм обучения ищет структуры или шаблоны в тренировочных данных. Таким образом, он строит модель которая в целом хороша для этих данных.

Как правило, процесс обучения носит исследовательский характер. В большинстве случае процесс повторяют многократно с использованием разных вариантов алгоритмов обучения и конфигураций.

В итоге все модели оцениваются на основе метрик производительности, среди которых выбирается лучшая. И эта модель используется для вычисления предполагаемых значений для будущих не маркированных данных. 

<h3>Линейная регрессия</h3>Чтобы научить машину «думать», сначала нужно выбрать алгоритм обучения, который вы будете использовать. Например, линейную регрессию. Это – один из простейших и самых популярных алгоритмов контролируемого машинного обучения. Алгоритм предполагает что отношение между входными признаками и маркерами результата – линейно. Общая функция линейной регрессии, приведенная ниже, возвращает предсказанное значение путем суммирования всех элементов вектора признаков умноженных на параметр <code>θ</code> <em>(тета)</em>. Этот параметр используется в процессе обучения для адаптации или «подстройки» функции регрессии на основе тренировочных данных.

<center><big><big><big><em><mark>h<sub>θ</sub> (x) = θ<sub>0</sub> * 1 + θ<sub>1</sub> * x<sub>1</sub> + ... θ<sub>n</sub> * x<sub>n</sub></mark></em></big></big></big></center>

В функции линейной регрессии параметр тета и параметры признаков пронумерованы подстрочными индексами. Подстрочный индекс определяет позицию параметра <code>(θ)</code> и параметра признака <code>(х)</code> в векторе. Обратите внимание, что признак x<sub>0</sub> является постоянным элементом сдвига и имеет значение <code>1</code> для вычислительных целях. В результате индекс значимых параметров таких, как площадь дома, начинается с x<sub>1</sub>. Так, если x<sub>1</sub> присвоено первое значение вектора признаков (площадь дома), то x<sub>2</sub> будет принимать следующее значение (количество комнат) и так далее. 

Пример-2 демонстрирует Java-реализацию функции линейной регрессии, математически обозначаемой как h<sub>θ</sub>(x). Для простоты, вычисления выполняются с использованием типа данных <code>double</code>. В методе <code>apply()</code>, предусмотрено, что первый элемент массива будет равен 1.0 и будет установлен за пределами этой функции.

<em>Пример 2. Линейная регрессия на Java</em>

<pre class='lang-java line-numbers'><code>
public class LinearRegressionFunction implements Function&ltDouble[], Double&gt {
 private final double[] thetaVector;

 LinearRegressionFunction(double[] thetaVector) {
 this.thetaVector = Arrays.copyOf(thetaVector, thetaVector.length);
 }

 public Double apply(Double[] featureVector) {
 // с целью упрощения вычислений первый элемент должен быть равен 1.0
 assert featureVector[0] == 1.0;

 // простое последовательное сложение
 double prediction = 0;
 for (int j = 0; j < thetaVector.length; j++) {
 prediction += thetaVector[j] * featureVector[j];
 }
 return prediction;
 }

 public double[] getThetas() {
 return Arrays.copyOf(thetaVector, thetaVector.length);
 }
}
</code></pre>
Чтобы создать новый экземпляр <code>LinearRegressionFunction</code>, нужно задать параметр <code>θ</code>. Этот параметр или вектор используется для адаптации общей функции линейной регрессии к лежащим в основе тренировочных данных. Параметр <code>θ</code>, используемый в программе, будет настроен в процессе обучения, базируясь на тренировочных примерах. Качество обученной целевой функции будет зависеть от качества подготовленных для обучения данных. 

В примере ниже мы используем <code>LinearRegressionFunction</code> для иллюстрации предсказания цены, базируясь на размере дома. Принимая во внимание то, что x<sub>0</sub> должен быть константой со значением 1.0, целевая функция инициализируется, используя два параметра <code>θ</code>, при этом они являются результатом процесса обучения. После создания нового примера, цена дома площадью 1330 квадратных метров будет предсказываться как показано ниже:

<pre class='lang-java line-numbers'><code>
// тета вектор, используемый в этом примере, является результатом процесса обучения
double[] thetaVector = new double[] { 1.004579, 5.286822 };
LinearRegressionFunction targetFunction = new LinearRegressionFunction(thetaVector);

// создание вектора признаков со значениями x0=1 (для удобства вычислений) и //x1=площадь дома
Double[] featureVector = new Double[] { 1.0, 1330.0 };

// выполняем расчеты
double predictedPrice = targetFunction.apply(featureVector);
</code></pre>
На рисунке ниже вы можете видеть график целевой функции предсказаний (синяя линия). Он получен путем вычисления целевой функции для всех значений площади дома. График также содержит пары цена-площадь, используемые для обучения.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="f412d9a1-3a85-4992-9cec-a2fa1b98c2ce" data-max-width="710" alt="Машинное обучение для Java-разработчиков, часть 1 - 4" src="https://cdn.javarush.com/images/article/f412d9a1-3a85-4992-9cec-a2fa1b98c2ce/1024.jpeg"></div></div> Сейчас график предсказаний выглядит достаточно хорошо. Координаты графика (положение и наклон) определяются вектором <code>θ { 1.004579, 5.286822 }</code>. Но как определить, что именно этот <code>θ</code>-вектор лучше всего подходит для вашего применения? Будет ли функция соответствовать лучше, если вы измените первый или может быть второй параметр? Для определения наиболее подходящего тета вектора вам нужна функция полезности, которая будет оценивать насколько хорошо целевая функция справляется с этой задачей.

<em><strong><a href='https://javarush.com/groups/posts/536-mashinnoe-obuchenie-dlja-java-razrabotchikov-chastjh-2' target='_blank'>ПРОДОЛЖЕНИЕ СЛЕДУЕТ</a></strong></em>

<em><strong><a href='https://www.javaworld.com/article/3224505/application-development/machine-learning-for-java-developers.html' target='_blank'>Перевод</a> с английского. Автор — Грегор Рот (Gregor Roth), Software Architect, JavaWorld. </strong></em>

<table>
<tr>
<th>Что еще почитать:
</th>
</tr>
<tr>
<td>
<p><a href='https://javarush.com/groups/posts/254-top-5-bibliotek-mashinnogo-obuchenija-dlja-java' target='_blank'>Топ 5 библиотек машинного обучения для Java</a></p>
<p><a href='https://javarush.com/groups/posts/463-5-tekhnologicheskikh-tendenciy-dlja-postroenija-uspeshnoy-karjherih-v-2018' target='_blank'>5 технологических тенденций для построения успешной карьеры в 2018</a></p>
<p><a href='https://javarush.com/groups/posts/402-ne-pereocenivaem-li-mih-mashinnoe-obuchenie-' target='_blank'>Не переоцениваем ли мы машинное обучение?</a></p>
</td>
</tr>