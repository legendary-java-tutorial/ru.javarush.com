Что должен знать программист на Java о числах Фибоначчи
<p>----------------------------------------</p>
Часто на собеседованиях, особенно в иностранных компаниях, могут расспрашивать об алгоритмах, а в стрессовой ситуации судорожно что-то вспоминать бывает не всегда просто. Поэтому нужно готовиться. Для начала, хотя бы освежить в памяти основные алгоритмы...
<p>----------------------------------------</p>
Часто на собеседованиях, особенно в иностранных компаниях, могут расспрашивать об алгоритмах, а в стрессовой ситуации судорожно что-то вспоминать бывает не всегда просто. Поэтому нужно готовиться. Для начала, хотя бы освежить в памяти основные алгоритмы.
 
Сегодня мы разберем такое явление как числа Фибоначчи и наиболее встречаемые варианты задач, связанных с ними.

<strong>Числа Фибоначчи</strong> — это последовательность натуральных чисел, которая начинается с чисел ноль и один, а каждое последующее число равно сумме двух предыдущих:

<center><p"><big><strong>F = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...}<br>
F<sub>0</sub> = 0, F<sub>1</sub> = 1, F<sub>n</sub> = F<sub>n - 1</sub> + F<sub>n - 2</sub>;<br>
n ≥ 0, n ∈ Z</strong></big><p></p></p"></center>Стоит отметить, что иногда 0 опускается, и ряд начинается с 1 1 2 3…

Как правило в условиях задачи сразу уточняется, с каких первых двух чисел начинается ряд (0,1 или 1,1), поэтому дальше мы будем рассматривать решения для обоих случаев.
<h2>Получение первых n чисел Фибоначчи в Java</h2>Предположим, у нас есть задача по получению первых n чисел Фибоначчи.
<ul>
<li><p>случай 0,1:</p>
<p>К нам приходит некое число n:</p>
<pre class="lang-java line-numbers"><code>
int[] arr = new int[n];
arr[0] = 0;
arr[1] = 1;
for (int i = 2; i &lt; arr.length; ++i) {
  arr[i] = arr[i - 1] + arr[i - 2];
}
</code></pre>
<p>Мы создаём массив размера n. Первые два элемента будут равны нулю и единице, а остальные элементы получаем, проходясь по данному циклу и используя предыдущие числа из массива.</p>
<p>И выводим на экран:</p>
<pre class="lang-java line-numbers"><code>
for (int i = 0; i &lt; arr.length; ++i) {
  System.out.println(arr[i]);
}
</code></pre>
<p>Задаем int n = 10;</p>
<p>И получаем:</p>
<pre><code>
0
1
1
2
3
5
8
13
21
34
</code></pre></li>
<li><p>для случая 1,1 решение фактически не отличается:</p>
<pre class="lang-java line-numbers"><code>
int[] arr = new int[n];
arr[0] = 1;
arr[1] = 1;
for (int i = 2; i &lt; arr.length; ++i) {
  arr[i] = arr[i - 1] + arr[i - 2];
}
</code></pre>
<p>Всё, что нам нужно было изменить — это первый элемент массива arr[0]: с 0 на 1. Соответственно, первые 10 элементов будут:</p>
<pre><code>
1
1
2
3
5
8
13
21
34
55
</code></pre></li></ul><h2>Первые n чисел Фибоначчи через stream</h2>Но мы же хотим показать свой уровень. Поэтому давайте посмотрим, как будем выглядеть данное решение с использованием <a href="" target="_blank">stream</a>.
<ul>
<li><p>для 0,1:</p>
<pre class="lang-java line-numbers"><code>
  Stream.iterate(new int[]{0, 1}, arr -&gt; new int[]{arr[1], arr[0]+ arr[1]})
     .limit(n)
     .map(y -&gt; y[0])
     .forEach(x -&gt; System.out.println(x));
</code></pre>
<p>Статический метод iterate класса <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="nofollow" target="_blank">Stream</a> возвращает бесконечный упорядоченный поток, созданный применением функции к начальному массиву arr. В нашем случае в качестве функции служит задание правила составления каждого нового массива, основываясь на предыдущем. Как итог мы получим поток из массивов:</p>
<pre class="lang-java line-numbers"><code>
{0,1}
{1,1}
{1, 2}
{2, 3}
{3, 5}
{5, 8}
{8, 13}
{13, 21}
{21, 34}
{34, 55}
…..
</code></pre>
<p>Но их будет бесконечное количество, и поэтому с помощью .limit(n) мы урезаем количество элементов до первых n (в нашем случае до 10).</p>
<p>Однако нам не нужен поток массивов, поэтому с помощью .map(y -&gt; y[0]) мы отбираем по первому элементу каждого массива и получаем поток с необходимыми нам числами и с помощью forEach выводим на консоль.</p>
<p>Выглядит покруче, не так ли?</p>
<img data-max-width="512" data-id="61377d55-e903-47dc-b086-1bf298d8d740" src="/images/article/61377d55-e903-47dc-b086-1bf298d8d740/512.jpeg" alt="Что должен знать программист на Java о числах Фибоначчи - 2">при первых элементах 1,1 этот код также будет почти таким же:<p></p>
<pre class="lang-java line-numbers"><code>
Stream.iterate(new int[]{1, 1}, arr -&gt; new int[]{arr[1], arr[0]+ arr[1]})
     .limit(n)
     .map(y -&gt; y[0])
     .forEach(x -&gt; System.out.println(x));
</code></pre>
<p>Опять же, различия — в начальном элементе: вместо {0, 1} задаём {1, 1}</p>
<p>Собственно, результаты будут такими же, как и в предыдущем примере.</p></li></ul><h2>Сумма чисел Фибоначчи</h2>А что если нас попросили получить сумму чисел Фибоначчи по n-ый элемент включительно? Это не должно вызвать у нас трудностей. Возьмем решение со стримом, заменим forEach на пару других методов:
<ul>
<li><p>для 0,1:</p>
<pre class="lang-java line-numbers"><code>
int n = 10;
int result = Stream.iterate(new int[]{0, 1}, arr -&gt; new int[]{arr[1], arr[0]+ arr[1]})
     .limit(n)
     .map(t -&gt; t[0])
     .mapToInt(Integer::intValue)
     .sum();
System.out.println(result);
</code></pre>
<p>C помощью .mapToInt(Integer::intValue) мы переводим наш stream в числовой IntStream и с помощью его метода  .sum() получаем сумму всех элементов.</p></li>
<li>для случая с 1,1 начальным элементом вместо {0, 1} задаём {1, 1}.</li></ul><h2>Получение n-ого число в ряде Фибоначчи</h2>Иногда просят вывести не ряд чисел, а именно n-ое число в ряде Фибоначчи.

Как правило это только облегчает задачу, ведь можно легко адаптировать предыдущие решения для этого.

Ну а как насчёт решения задачи через рекурсию?
<ol>
<li><p>для 0,1:</p>
<pre class="lang-java line-numbers"><code>
public int getFibonacciValue(int n) {
  if (n &lt;= 1) {
     return 0;
  } else if (n == 2) {
     return 1;
  } else  {
     return getFibonacciValue(n - 1) + getFibonacciValue(n - 2);
  }
}
</code></pre>
<p>Для выполнения алгоритма с 0,1 необходимо задать, что при попытке получить первый элемент мы получаем 0, а второй — 1. По сути нам, как и в прошлых решениях, нужно задать первые два элемента.</p></li>
<li><p>реализация для 1,1 будет немного отличаться:</p>
<pre class="lang-java line-numbers"><code>
public int getFibonacciValue(int n) {
  if (n == 0) {
     return 0;
  } else if (n == 1) {
     return 1;
  } else  {
     return getFibonacciValue(n - 1) + getFibonacciValue(n - 2);
  }
}
</code></pre>
<p>В этом случае нам достаточно задать только первый элемент как 1, так как второй элемент будет таким же, и реакция метода будет такой же.</p>
<p>При этом мы задаём реакцию метода на 0, ведь если не задать, то когда придёт 2 как аргумент, рекурсивно вызывается этот же метод, но с аргументом 0. Далее будет запускаться этот же метод, но уже с отрицательными числами и так до отрицательной бесконечности. Как итог мы получим <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StackOverflowError.html" rel="nofollow" target="_blank">StackOverflowError</a>.</p></li></ol>Тем не менее, рекурсивный способ не рекомендуется использовать, потому что в отличие от предыдущих способов, которые работают за линейное время от O(n), рекурсивный способ может работать значительно дольше. Почему?
<img data-max-width="512" data-id="6941c305-d004-4248-8934-5c43659db65b" src="/images/article/6941c305-d004-4248-8934-5c43659db65b/512.jpeg" alt="Что должен знать программист на Java о числах Фибоначчи - 3">Рекурсивный способ может работать долго, так как в процессе расчёта функция будет много раз вызываться от одного и того же аргумента. Например, при вычислении getFibonacciValue(7) функция сделает рекурсивные вызовы к getFibonacciValue(5) и getFibonacciValue(6), оба рекурсивных вызова будут обращаться к getFibonacciValue(4)), что и  приведёт к многоразовому вызову одних и тех же операций.
На собеседовании можно показать этот способ как вариант решения, но при этом рассказать об этих его недостатках и взамен предложить другой способ.

Также стоит отметить, что тип int в Java позволяет хранить от -2147483648 до 2147483647, поэтому получится вычислить только первые 46 чисел Фибоначчи: при попытке получить следующее 47-ое возникнет переполнение, и мы получим отрицательное число. Если же мы будем использовать тип данных long вместо int, то получится правильно вычислить первые 91 число Фибоначчи.

Чтобы вычислять последующие числа Фибоначчи, необходимо воспользоваться классом BigInteger, который реализует логику хранения и арифметических операций действительно БОЛЬШИХ чисел.