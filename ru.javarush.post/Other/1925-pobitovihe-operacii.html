Побитовые операции в Java
<p>----------------------------------------</p>
Тебе наверняка знакомо слово “бит”. Если же нет, давай познакомимся с ним :) Бит — минимальная единица измерения информации в компьютере. Его название происходит от английского “binary digit” — “двоичное число”. Бит может быть выражен одним из двух чисел: 1 или 0. Существует ...
<p>----------------------------------------</p>
Тебе наверняка знакомо слово “бит”. Если же нет, давай познакомимся с ним :)

Бит — минимальная единица измерения информации в компьютере. Его название происходит от английского “<em>binary digit</em>” — “двоичное число”. Бит может быть выражен одним из двух чисел: 1 или 0.

Существует специальная система счисления, основанная на единицах и нулях — двоичная. Не будем углубляться в дебри математики и отметим лишь, что любое число в Java можно сконвертировать в его двоичную форму. Для этого нужно использовать классы-обертки.
<img data-id="e505b693-4f45-40a7-8d13-0ade05b91b0d" data-max-width="850" alt="Побитовые операции - 1" src="https://cdn.javarush.com/images/article/e505b693-4f45-40a7-8d13-0ade05b91b0d/1024.jpeg">Например, вот как можно сделать это для числа <code>int</code>:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       int x = 342;
       System.out.println(Integer.toBinaryString(x));
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
101010110
</code></pre>
1010 10110 (я добавил пробел для удобства чтения) — это число 342 в двоичной системе.

Мы фактически разделили это число на отдельные биты — нули и единицы. Именно с ними мы можем выполнять операции, которые называются побитовыми.
<ul>
<li><p><code>~</code> — побитовый оператор “НЕ”.</p></li></ul>Он работает очень просто: проходится по каждому биту нашего числа и меняет его значение на противоположное: нули — на единицы, единицы — на нули.

Если мы применим его к нашему числу 342, вот что получится:

101010110 — число 342 в двоичной системe
010101001 — результат выражения ~342 

Но так как переменная типа int занимает 4 байта, т.е. 32 бита, на самом деле число в переменной хранится как:

<code>00000000 00000000 00000001 01010110</code> — число 342 в переменной типа int в java
<code>11111111 11111111 11111110 10101001</code> — результат выражения ~342 в java

Попробуем выполнить это на практике:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       int x = 342;
       System.out.println(Integer.toBinaryString(~x));
   }
}
</code></pre>
Вывод в консоль:

<pre><code>11111111111111111111111010101001</code></pre>
<ul>
<li><p><code>&amp;</code> — побитовый оператор “И”</p></li></ul>Он, как видишь, довольно похож по написанию на логический “И” (<code>&amp;&amp;</code>).

Оператор <code>&amp;&amp;</code>, как ты помнишь, возвращает <code>true</code> только если оба операнда являются истинными. Побитовый <code>&amp;</code> работает схожим образом: он сравнивает два числа по битам. Результатом этого сравнения является третье число.

Для примера, возьмем числа 277 и 432:

100010101 — число 277 в двоичной форме
110110000 — число 432 в двоичной форме

Далее оператор <code>&amp;</code> сравнивает первый бит верхнего числа с первым битом нижнего. Поскольку это оператор “И”, то результат будет равен 1 только в том случае, если оба бита равны 1. Во всех остальных случаях результатом будет 0.

   100010101 
<code>&amp;</code>
   110110000
_______________
   100010000 — результат работы <code>&amp;</code>

Мы сравниваем сначала первые биты двух чисел друг с другом, потом вторые биты, третьи и т.д.

Как видишь, только в двух случаях оба бита в числах были равны 1 (первый и пятый по счету биты). Результатом всех остальных сравнений стал 0. Поэтому в итоге у нас получилось число 100010000. В десятичной системе ему соответствует число 272. Давай проверим:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       System.out.println(277&amp;432);
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
272
</code></pre><ul>
<li><code>|</code> — побитовое “ИЛИ”. Принцип работы тот же — сравниваем два числа по битам. Только теперь если хотя бы один из битов равен 1, результат будет равен 1. Посмотрим на тех же числах — 277 и 432:</li></ul>
   100010101 
<code>|</code>
   110110000
_______________
    110110101 — результат работы <code>|</code>

Здесь уже результат другой: нулями остались только те биты, которые в обоих числах были нулями.

Результат работы — число 110110101. В десятичной системе ему соответствует число 437.

Проверим:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       System.out.println(277|432);
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
437
</code></pre>
Мы все посчитали верно! :)

<ul>
<li><code>^</code> — побитовое исключающее “ИЛИ” (также известно как XOR)</li></ul>С таким оператором мы еще не сталкивались. Но ничего сложного в нем нет. Он похож на обычное “или”. Разница в одном: обычное “или” возвращает <code>true</code>, если хотя бы один операнд является истинным. Но не обязательно один — если оба будут <code>true</code> — то и результат <code>true</code>. 

А вот исключающее “или” возвращает <code>true</code> только если один из операндов является истинным. 

Если истинны оба операнда, обычное “или” вернет <code>true</code>(“хотя бы один истинный“), а вот исключающее или вернет <code>false</code>. Поэтому он и называется исключающим.

Зная принцип предыдущих побитовых операций, ты наверняка и сам сможешь легко выполнить операцию 277^432. 

Но давай лучше лишний раз разберемся вместе :)

   100010101 
<code>^</code>
   110110000
_______________
   010100101 — результат работы <code>^</code>

Вот и наш результат. Те биты, которые были в обоих числах одинаковыми, вернули 0 (не сработала формула “один из”). А вот те, которые образовывали пару 0-1 или 1-0, в итоге превратились в единицу.

В результате мы получили число 010100101. В десятичной системе ему соответствует число 165.

Давай посмотрим, правильно ли мы посчитали:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       System.out.println(277^432);
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
165
</code></pre>
Супер! Все именно так, как мы и думали :)

Теперь самое время познакомиться с операциями, которые называют битовыми сдвигами.

Название, в принципе, говорит само за себя. Мы возьмем какое-то число и будем двигать его биты влево и вправо :) Давай посмотрим как это выглядит:
<h2>Сдвиг влево</h2>Сдвиг битов влево обозначается знаком <code>&lt;&lt;</code>

Пример:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       int x = 64;//значение
       int y = 3;//количество

       int z = (x &lt;&lt; y);
       System.out.println(Integer.toBinaryString(x));
       System.out.println(Integer.toBinaryString(z));
   }
}
</code></pre>
В этом примере число <code>x=64</code> называется значением. Именно его биты мы будем сдвигать. Сдвигать биты мы будем влево (это можно определить по направлению знака <code>&lt;&lt;</code>)

В двоичной системе число 64 = 1000000

Число <code>y=3</code> называется количеством. Количество отвечает на вопрос “на сколько бит вправо/влево нужно сдвинуть биты числа <code>x</code>”

В нашем примере мы будем сдвигать их на 3 бита влево.

Чтобы процесс сдвига был более понятен, посмотрим на картинке.

У нас в примере используются числа типа int. <code>Int</code>’ы занимают в памяти компьютера 32 бита. Вот так выглядит наше изначальное число 64:
<img data-id="93f02d89-3ef0-4550-9e30-3a566532e649" data-max-width="850" alt="Побитовые операции - 2" src="https://cdn.javarush.com/images/article/93f02d89-3ef0-4550-9e30-3a566532e649/1024.jpeg">А теперь мы, в прямом смысле слова, берем каждый из наших битов и сдвигаем влево на 3 ячейки:
<img data-id="3d6ee824-93b3-4841-a573-4ab82b406816" data-max-width="805" alt="Побитовые операции - 3" src="https://cdn.javarush.com/images/article/3d6ee824-93b3-4841-a573-4ab82b406816/1024.jpeg">Вот что у нас получилось. Как видишь, все наши биты сдвинулись, а из-за пределов диапазона добавились еще 3 нуля. 3 — потому что мы делали сдвиг на 3. Если бы мы сдвигали на 10, добавилось бы 10 нулей.

Таким образом, выражение <code>x &lt;&lt; y</code> означает “сдвинуть биты числа <code>х</code> на y ячеек влево”. Результатом нашего выражения стало число 1000000000, которое в десятичной системе равно 512.

Проверим:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       int x = 64;//значение
       int y = 3;//количество

       int z = (x &lt;&lt; y);
       System.out.println(z);
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
512
</code></pre>
Все верно!

Теоретически, биты можно сдвигать до бесконечности. Но поскольку у нас число <code>int</code>, в распоряжении есть всего 32 ячейки. Из них 7 уже заняты числом 64 (1000000).

Поэтому если мы сделаем, например, 27 сдвигов влево, наша единственная единица выйдет за пределы диапазона и “затрётся”. Останутся только нули!

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       int x = 64;//значение
       int y = 26;//количество

       int z = (x &lt;&lt; y);
       System.out.println(z);
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
0
</code></pre>
Как мы и предполагали, единичка вышла за пределы 32 ячеек-битов и исчезла. У нас получилось 32-битное число, состоящее из одних нулей. 
<img data-id="ba7019a0-4ec5-4e9d-9165-eea36d60b84d" data-max-width="850" alt="Побитовые операции - 4" src="https://cdn.javarush.com/images/article/ba7019a0-4ec5-4e9d-9165-eea36d60b84d/1024.jpeg">Естественно, в десятичной системе ему соответствует 0.

Простое правило для запоминания сдвигов влево: 

При каждом сдвиге влево выполняется умножение числа на 2.

Например, попробуем без картинок с битами посчитать результат выражения

<code>111111111 &lt;&lt; 3</code>

Нам нужно трижды умножить число 111111111 на 2. В результате у нас получается 888888888. Давай напишем код и проверим:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       System.out.println(111111111 &lt;&lt; 3);
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
888888888
</code></pre><h2>Сдвиги вправо</h2>Они обозначаются знаком <code>&gt;&gt;</code>.

Делают то же самое, только в другую сторону! :)

Не будем изобретать велосипед и попробуем сделать это с тем же числом int 64.

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       int x = 64;//значение
       int y = 2;//количество

       int z = (x &gt;&gt; y);
       System.out.println(z);
   }
}
</code></pre>
<img data-id="1591b764-f320-4606-9478-b9f48552ecaf" data-max-width="850" alt="Побитовые операции - 5" src="https://cdn.javarush.com/images/article/1591b764-f320-4606-9478-b9f48552ecaf/1024.jpeg"><img data-id="7d741483-3953-44ed-ba55-0de4d698ab64" data-max-width="850" alt="Побитовые операции - 6" src="https://cdn.javarush.com/images/article/7d741483-3953-44ed-ba55-0de4d698ab64/1024.jpeg">В результате  сдвига на 2 вправо два крайних нуля нашего числа вышли за пределы диапазона и затерлись. У нас получилось число 10000, которому в десятичной системе соответствует число 16

Вывод в консоль:

<pre><code>
16
</code></pre>
Простое правило для запоминания сдвигов вправо:

При каждом сдвиге вправо выполняется деление на два с отбрасыванием любого остатка.

Например,

<code>35 &gt;&gt; 2</code> 

означает, что нам нужно 2 раза разделить 35 на 2, отбрасывая остатки

<code>35/2 = 17</code> (отбросили остаток 1)
<code>17:2 = 8</code> (отбросили остаток 1)

Итого, <code>35 &gt;&gt; 2</code> должно быть равно 8.

Проверяем:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       System.out.println(35 &gt;&gt; 2);
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
8
</code></pre><h2>Приоритет операций в Java</h2>В процессе написания или чтения кода тебе часто будут попадаться выражения, в которых одновременно выполняются несколько операций. Очень важно понимать, в каком порядке они будут выполнены, иначе результат может быть неожиданным.

Поскольку операций в Java много, все они были выделены в специальную таблицу:
<p style="text-align: center;">Operator Precedence</p><table>
<thead>
<tr>
<th>Operators</th>
<th>Precedence</th>
</tr>
<tr>
</tr></thead>
<tbody>
<tr>
<td>postfix</td>
<td><code>expr++</code> <code>expr--</code></td>
</tr>
<tr>
<td>unary</td>
<td><code>++expr</code> <code>--expr</code> <code>+expr</code> <code>~</code> <code>!</code></td>
</tr><tr>
<td>Multiplicative</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
</tr><tr>
<td>additive</td>
<td><code>+</code> <code>-</code></td>
</tr><tr>
<td>shift</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></td>
</tr><tr>
<td>relational</td>
<td><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> instanceof</td>
</tr><tr>
<td>equality</td>
<td><code>==</code> <code>!=</code></td>
</tr><tr>
<td>bitwise AND</td>
<td><code>&amp;</code></td>
</tr><tr>
<td>bitwise exclusive OR</td>
<td><code>^</code></td>
</tr><tr>
<td>bitwise inclusive OR</td>
<td><code>|</code></td>
</tr><tr>
<td>logical AND</td>
<td><code>&amp;&amp;</code></td>
</tr><tr>
<td>logical OR</td>
<td><code>||</code></td>
</tr><tr>
<td>ternary</td>
<td><code>?</code> <code>:</code></td>
</tr>
<tr>
<td>assignment</td>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&gt;&gt;&gt;=</code>
</td>
</tr>
</tbody>
</table>Все операции выполняются слева направо, однако с учетом своего приоритета.

Например, если мы пишем: 

<code>int x  = 6 - 4/2;</code>

вначале будет выполнена операция деления (4/2). Хоть она и идет второй по счету, но у нее выше приоритет.

Круглые или квадратные скобки меняют любой приоритет на максимальный. Это ты наверняка помнишь еще со школы. Например, если добавить их к выражению: 

<code>int x  = (6 - 4)/2;</code>

первым выполнится именно вычитание, поскольку оно вычисляется в скобках.

У логического оператора <code>&amp;&amp;</code> приоритет довольно низкий, что видно из таблицы. Поэтому чаще всего он будет выполняться последним. 

Например:

<code>boolean x = 6 - 4/2 &gt; 3 &amp;&amp; 12*12 &lt;= 119;</code>

Это выражение будет выполняться так:
<ul>
<li><p><code>4/2 = 2</code></p>
<pre class="lang-java line-numbers"><code>
boolean x = 6 - 2 &gt; 3 &amp;&amp; 12*12 &lt;= 119;
</code></pre></li>
<li><p><code>12*12 = 144</code>
</p><pre class="lang-java line-numbers"><code>
boolean x = 6 - 2 &gt; 3 &amp;&amp; 144 &lt;= 119;
</code></pre></li>
<li><p><code>6-2 = 4</code></p>
<pre class="lang-java line-numbers"><code>
boolean x = 4 &gt; 3 &amp;&amp; 144 &lt;= 119;
</code></pre></li>
<li><p>Далее будут выполнены операторы сравнения:</p>
<p><code>4 &gt; 3 = true</code></p>
<pre class="lang-java line-numbers"><code>
boolean x = true &amp;&amp; 144 &lt;= 119;
</code></pre></li>
<li><p><code>144 &lt;= 119 = false</code></p>
<pre class="lang-java line-numbers"><code>
boolean x = true &amp;&amp; false;
</code></pre></li>
<li><p>И, наконец, последним, будет выполнен оператор “И” <code>&amp;&amp;</code>.</p>
<p><code>boolean x = true &amp;&amp; false;</code></p>
<code>boolean x = false;</code>
<p>Оператор сложения (<code>+</code>), например, имеет более высокий приоритет, чем оператор сравнения <code>!=</code> (“не равно”);</p>
<p>Поэтому в выражении: </p>
<code>boolean x = 7 != 6+1;</code>
<p>сначала будет выполнена операция 6+1, потом проверка 7!=7 (false), а в конце — присваивания результата <code>false</code> переменной <code>x</code>. У присваивания вообще самый маленький приоритет из всех операций — посмотри в таблице.</p>
</li></ul>Фух! Лекция у нас получилась большая, но ты справился! 

Если ты не до конца понял какие-то части этой и предыдущей лекций — не переживай, мы еще не раз коснемся данных тем в будущем. Вот тебе несколько полезных ссылок:
<ul>
<li><a href="https://javarush.com/groups/posts/logicheskie-operacii-v-java" target="_blank">Логические операторы</a> — лекция JavaRush о логических операциях. Мы до них еще нескоро дойдем, но почитать можно уже сейчас, вреда не будет</li></ul>