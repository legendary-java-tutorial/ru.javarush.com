Сериализация как она есть. Часть 1
<p>----------------------------------------</p>
На первый взгляд, сериализация кажется тривиальным процессом. Действительно, что может быть проще? Объявил класс реализующим интерфейс java.io.Serializable – и все дела. Можно сериализовать класс без проблем. Теоретически это действительно так...
<p>----------------------------------------</p>
На первый взгляд, сериализация кажется тривиальным процессом. Действительно, что может быть проще? Объявил класс реализующим интерфейс <code>java.io.Serializable</code> – и все дела. Можно сериализовать класс без проблем.
<img data-id="1d335648-7d53-43f4-a338-8f180565c58b" data-max-width="850" alt="Сериализация как она есть. Часть 1 - 1" src="https://cdn.javarush.com/images/article/1d335648-7d53-43f4-a338-8f180565c58b/1024.jpeg">Теоретически это действительно так. Практически же – есть очень много тонкостей. Они связаны с производительностью, с десериализацией, с безопасностью класса. И еще с очень многими аспектами. О таких тонкостях и пойдет разговор.

Статью эту можно разделить на следующие части:
<ul>
    <li>Тонкости механизмов</li>
    <li>Зачем нужен <code>Externalizable</code></li>
    <li>Производительность</li>
    <li>Обратная сторона медали</li>
    <li>Безопасность данных</li>
    <li>Сериализация объектов <code>Singleton</code></li>
</ul>Приступим к первой части –
<h2>Тонкости механизмов</h2>Прежде всего, вопрос на засыпку. А сколько существует способов сделать объект сериализуемым? Практика показывает, что более 90% разработчиков отвечают на этот вопрос приблизительно одинаково (с точностью до формулировки) – такой способ один. Между тем, их два. Про второй вспоминают далеко не все, не говоря уж о том, чтобы сказать что-то внятное о его особенностях.

Итак, каковы же эти способы? Про первый помнят все. Это уже упомянутая реализация <code>java.io.Serializable</code>, не требующая никаких усилий. Второй способ – это тоже реализация интерфейса, но уже другого: <code>java.io.Externalizable</code>. В отличие от <code>java.io.Serializable</code>, он содержит два метода, которые необходимо реализовать – <code>writeExternal(ObjectOutput)</code> и <code>readExternal(ObjectInput)</code>. В этих методах как раз и находится логика сериализации/десериализации.

<mark>Замечание.</mark> В дальнейшем сериализацию с реализацией <code>Serializable</code> я буду иногда называть стандартной, а реализацию <code>Externalizable</code> – расширенной.

Еще одно <mark>замечание</mark>. Я намеренно не затрагиваю сейчас такие возможности управления стандартной сериализацией, как определение <code>readObject</code> и <code>writeObject</code>, т.к. считаю эти способы в некоторой степени некорректными. Эти методы не определены в интерфейсе <code>Serializable</code> и являются, фактически, подпорками для обхода ограничений и придания стандартной сериализации гибкости. В <code>Externalizable</code> же методы, обеспечивающие гибкость, заложены изначально.

Зададимся еще одним вопросом. А как, собственно, работает стандартная сериализация, с использованием <code>java.io.Serializable</code>? А работает она через Reflection API. Т.е. класс разбирается как набор полей, каждое из которых пишется в выходной поток. Думаю, понятно, что операция эта неоптимальна по производительности. Насколько именно – выясним позднее.

Между упомянутыми двумя способами сериализации существует еще одно серьезное отличие. А именно – в механизме десериализации. При использовании <code>Serializable</code> десериализация происходит так: под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается.

Тут надо еще отдельно рассмотреть такую ситуацию. Хорошо, наш класс сериализуемый. А его родитель? Совершенно необязательно! Более того, если наследовать класс от <code>Object</code> – родитель уж точно НЕсериализуемый. И пусть о полях <code>Object</code> мы ничего не знаем, но в наших собственных родительских классах они вполне могут быть. Что будет с ними? В поток сериализации они не попадут. Какие значения они примут при десериализации?

Посмотрим на этот пример:

<pre class='lang-java line-numbers'><code>
package ru.skipy.tests.io;

import java.io.*;

/**
 * ParentDeserializationTest
 *
 * @author Eugene Matyushkin aka Skipy
 * @since 05.08.2010
 */
public class ParentDeserializationTest {

    public static void main(String[] args){
        try {
            System.out.println("Creating...");
            Child c = new Child(1);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            c.field = 10;
            System.out.println("Serializing...");
            oos.writeObject(c);
            oos.flush();
            baos.flush();
            oos.close();
            baos.close();
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            System.out.println("Deserializing...");
            Child c1 = (Child)ois.readObject();
            System.out.println("c1.i="+c1.getI());
            System.out.println("c1.field="+c1.getField());
        } catch (IOException ex){
            ex.printStackTrace();
        } catch (ClassNotFoundException ex){
            ex.printStackTrace();
        }
    }

    public static class Parent {
        protected int field;
        protected Parent(){
            field = 5;
            System.out.println("Parent::Constructor");
        }
        public int getField() {
            return field;
        }
    }

    public static class Child extends Parent implements Serializable{
        protected int i;
        public Child(int i){
            this.i = i;
            System.out.println("Child::Constructor");
        }
        public int getI() {
            return i;
        }
    }
}
</code></pre>
Он прозрачен – у нас есть несериализуемый родительский класс и сериализуемый дочерний. И вот что получается:

<pre class='lang-java line-numbers'><code>
Creating...
Parent::Constructor
Child::Constructor
Serializing...
Deserializing...
Parent::Constructor
c1.i=1
c1.field=5
</code></pre>
То есть при <strong>десериализации вызывается конструктор без параметров родительского НЕсериализуемого класса</strong>. И если такого конструктора не будет – при десериализации возникнет ошибка. Конструктор же дочернего объекта, того, который мы десериализуем, не вызывается, как и было сказано выше.

Так ведут себя стандартные механизмы при использовании <code>Serializable</code>. При использовании же <code>Externalizable</code> ситуация иная. Сначала вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal, который и вычитывает, собственно, все свои данные. Потому – любой реализующий интерфейс Externalizable класс обязан иметь public конструктор без параметров! Более того, поскольку все наследники такого класса тоже будут считаться реализующими интерфейс <code>Externalizable</code>, у них тоже должен быть конструктор без параметров!

Пойдем дальше. Существует такой модификатор поля как <code>transient</code>. Он означает, что это поле не должно быть сериализовано. Однако, как вы сами понимаете, указание это действует только на стандартный механизм сериализации. При использовании <code>Externalizable</code> никто не мешает сериализовать это поле, равно как и вычитать его. Если поле объявлено transient, то при десериализации объекта оно принимает значение по умолчанию.

Еще один достаточно тонкий момент. При стандартной сериализации поля, имеющие модификатор <code>static</code>, не сериализуются. Соответственно, после десериализации это поле значения не меняет. Разумеется, при реализации <code>Externalizable</code> сериализовать и десериализовать это поле никто не мешает, однако я крайне не рекомендую этого делать, т.к. это может привести к трудноуловимым ошибкам.

Поля с модификатором <code>final</code> сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable. Ибо <code>final-поля</code> должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно – если вам необходимо сериализовать объект, имеющий <code>final</code>-поле, вам придется использовать только стандартную сериализацию.

Еще один момент, который многие не знают. При стандартной сериализации учитывается порядок объявления полей в классе. Во всяком случае, так было в ранних версиях, в JVM версии 1.6 реализации Oracle уже порядок неважен, важны тип и имя поля. Состав же методов с очень большой вероятностью повлияет на стандартный механизм, при том, что поля могут вообще остаться теми же. Чтобы этого избежать, есть следующий механизм. В каждый класс, реализующий интерфейс <code>Serializable</code>, на стадии компиляции добавляется еще одно поле – <code>private static final long serialVersionUID</code>. Это поле содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса – полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение.

Это поле записывается в поток при сериализации класса. Кстати, это, пожалуй, единственный известный мне случай, когда <code>static</code>-поле сериализуется. При десериализации значение этого поля сравнивается с имеющимся у класса в виртуальной машине. Если значения не совпадают – инициируется исключение наподобие этого:

<pre class='lang-java line-numbers'><code>
java.io.InvalidClassException: test.ser2.ChildExt;
    local class incompatible: stream classdesc serialVersionUID = 8218484765288926197,
                                   local class serialVersionUID = 1465687698753363969
</code></pre>
Есть, однако, способ эту проверку если не обойти, то обмануть. Это может оказаться полезным, если набор полей класса и их порядок уже определен, а методы класса могут меняться. В этом случае сериализации ничего не угрожает, однако стандартный механизм не даст десериализовать данные с использованием байткода измененого класса. Но, как я уже сказал, его можно обмануть. А именно – вручную в классе определить поле <code>private static final long serialVersionUID</code>. В принципе, значение этого поля может быть абсолютно любым. Некоторые предпочитают ставить его равным дате модификации кода. Некоторые вообще используют 1L. Для получения стандартного значения (того, которое вычисляется внутренним механизмом) можно использовать утилиту serialver, входящую в поставку SDK. После такого определения значение поля будет фиксировано, следовательно, десериализация всегда будет разрешена.

Более того, в версии 5.0 в документации появилось приблизительно следующее: крайне рекомендуется всем сериализуемым классам декларировать это поле в явном виде, ибо вычисление по умолчанию очень чувствительно к деталям структуры класса, которые могут различаться в зависимости от реализации компилятора, и вызывать таким образом неожиданные <code>InvalidClassException</code> при десериализации. Объявлять это поле лучше как <code>private</code>, т.к. оно относится исключительно к классу, в котором объявляется. Хотя в спецификации модификатор не оговорен.

Рассмотрим теперь вот какой аспект. Пусть у нас есть такая структура классов:

<pre class='lang-java line-numbers'><code>
public class A{
    public int iPublic;
    protected int iProtected;
    int iPackage;
    private int iPrivate;
}

public class B extends A implements Serializable{}
</code></pre>
Иначе говоря, у нас есть класс, унаследованный от несериализуемого родителя. Можно ли сериализовать этот класс, и что для этого надо? Что будет с переменными родительского класса?

Ответ такой. Да, сериализовать экземпляр класса <code>B</code> можно. Что для этого нужно? А нужно, чтобы у класса <code>A</code> был конструктор без параметров, <code>public</code> либо <code>protected</code>. Тогда при десериализации все переменные класса <code>A</code> будут инициализированы с помощью этого конструктора. Переменные класса <code>B</code> будут инициализированы значениями из потока сериализованных данных.

Теоретически можно в классе <code>B</code> определить методы, о которых я говорил в начале – <code>readObject</code> и <code>writeObject</code>, – в начале которых производить (де-)сериализацию переменных класса <code>B</code> через <code>in.defaultReadObject/out.defaultWriteObject</code>, а потом – (де-)сериализацию доступных переменных из класса <code>A</code> (в нашем случае это <code>iPublic</code>, <code>iProtected</code> и <code>iPackage</code>, если <code>B</code> находится с том же пакете, что и <code>A</code>). Однако, на мой взгляд, для этого лучше использовать расширенную сериализацию.

Следующий момент, которого я хотел бы коснуться – сериализация нескольких объектов. Пусть у нас есть следующая структура классов:

<pre class='lang-java line-numbers'><code>
public class A implements Serializable{
    private C c;
    private B b;
    public void setC(C c) {this.c = c;}
    public void setB(B b) {this.b = b;}
    public C getC() {return c;}
    public B getB() {return b;}
}
public class B implements Serializable{
    private C c;
    public void setC(C c) {this.c = c;}
    public C getC() {return c;}
}
public class C implements Serializable{
    private A a;
    private B b;
    public void setA(A a) {this.a = a;}
    public void setB(B b) {this.b = b;}
    public B getB() {return b;}
    public A getA() {return a;}
}
</code></pre><img data-id="dbeed1cf-205a-4c73-873b-edba6db8aecf" data-max-width="350" alt="Сериализация как она есть. Часть 1 - 2" src="https://cdn.javarush.com/images/article/dbeed1cf-205a-4c73-873b-edba6db8aecf/1024.jpeg">Что произойдет, если сериализовать экземпляр класса <code>A</code>? Он потащит за собой экземпляр класса <code>B</code>, который, в свою очередь, потащит экземпляр <code>C</code>, который имеет ссылку на экземпляр <code>A</code>, тот же самый, с которого все начиналось. Замкнутый круг и бесконечная рекурсия? К счастью, нет. Посмотрим на следующий тестовый код:

<pre class='lang-java line-numbers'><code>
// initiaizing
A a = new A();
B b = new B();
C c = new C();
// setting references
a.setB(b);
a.setC(c);
b.setC(c);
c.setA(a);
c.setB(b);
// serializing
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(baos);
oos.writeObject(a);
oos.writeObject(b);
oos.writeObject(c);
oos.flush();
oos.close();
// deserializing
ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
A a1 = (A)ois.readObject();
B b1 = (B)ois.readObject();
C c1 = (C)ois.readObject();
// testing
System.out.println("a==a1: "+(a==a1));
System.out.println("b==b1: "+(b==b1));
System.out.println("c==c1: "+(c==c1));
System.out.println("a1.getB()==b1: "+(a1.getB()==b1));
System.out.println("a1.getC()==c1: "+(a1.getC()==c1));
System.out.println("b1.getC()==c1: "+(b1.getC()==c1));
System.out.println("c1.getA()==a1: "+(c1.getA()==a1));
System.out.println("c1.getB()==b1: "+(c1.getB()==b1));
</code></pre>
Что мы делаем? Мы создаем по экземпляру классов <code>A</code>, <code>B</code> и <code>C</code>, ставим им ссылки друг на друга, после чего сериализуем каждый из них. Потом мы десериализуем их обратно и проводим серию проверок. Что получится в результате:

<pre class='lang-java line-numbers'><code>
a==a1: false
b==b1: false
c==c1: false
a1.getB()==b1: true
a1.getC()==c1: true
b1.getC()==c1: true
c1.getA()==a1: true
c1.getB()==b1: true
</code></pre>
Итак, что можно извлечь из этого теста. Первое. Ссылки на объекты после десериализации отличаются от ссылок до нее. Иначе говоря, при сериализации/десериализации объект был скопирован. Этот метод используется иногда для клонирования объектов.

Второй вывод, более сущеcтвенный. При сериализации/десериализации нескольких объектов, имеющих перекрестные ссылки, эти ссылки остаются действительными после десериализации. Иначе говоря, если до сериализации они указывали на один объект, то после десериализации они тоже будут указывать на один объект.

Еще один небольшой тест в подтверждение этого:

<pre class='lang-java line-numbers'><code>
B b = new B();
C c = new C();
b.setC(c);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(baos);
oos.writeObject(b);
oos.writeObject(c);
oos.writeObject(c);
oos.writeObject(c);
oos.flush();
oos.close();
ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
B b1 = (B)ois.readObject();
C c1 = (C)ois.readObject();
C c2 = (C)ois.readObject();
C c3 = (C)ois.readObject();
System.out.println("b1.getC()==c1: "+(b1.getC()==c1));
System.out.println("c1==c2: "+(c1==c2));
System.out.println("c1==c3: "+(c1==c3));
</code></pre>
Объект класса <code>B</code> имеет ссылку на объект класса <code>C</code>. При сериализации <code>b</code> сериализуется вместе с экземпляром класса <code>С</code>, после чего тот же экземпляр c сериализуется трижды. Что получается после десериализации?

<pre class='lang-java line-numbers'><code>
b1.getC()==c1: true
c1==c2: true
c1==c3: true
</code></pre>
Как видим, все четыре десериализованных объекта на самом деле представляют собой один объект – ссылки на него равны. Ровно как это и было до сериализации.

Еще один интересный момент – что будет, если одновременно реализовать у класса <code>Externalizable</code> и <code>Serializable</code>? Как в том вопросе – слон против кита – кто кого поборет?

Поборет <code>Externalizable</code>. Механизм сериализации сначала проверяет его наличие, а уж потом – наличие <code>Serializable</code> Так что если класс B, реализующий <code>Serializable</code>, наследуется от класса A, реализующего <code>Externalizable</code>, поля класса B сериализованы не будут.

Последний момент – наследование. При наследовании от класса, реализующего <code>Serializable</code>, никаких дополнительных действий предпринимать не надо. Сериализация будет распространяться и на дочерний класс. При наследовании от класса, реализующего <code>Externalizable</code>, необходимо переопределить методы родительского класса readExternal и writeExternal. Иначе поля дочернего класса сериализованы не будут. В этом случае надо бы не забыть вызвать родительские методы, иначе не сериализованы будут уже родительские поля.

* * *

С деталями, пожалуй, закончили. Однако есть один вопрос, который мы не затронули, глобального характера. А именно –
<h2>Зачем нужен Externalizable</h2>Зачем вообще нужна расширенная сериализация? Ответ прост. Во-первых, она дает гораздо большую гибкость. Во-вторых, зачастую она может дать немалый выигрыш по объему сериализованных данных. В-третьих, существует такой аспект как производительность, о котором мы <a href='http://www.skipy.ru/technics/serialization.html#performance' rel='nofollow' target='_blank'>поговорим ниже</a>.

С гибкостью вроде как понятно всё. Действительно, мы можем управлять процессами сериализации и десериализации как хотим, что делает нас независимыми от любых изменений в классе (как я говорил чуть выше, изменения в классе способны сильно повлиять на десериализацию). Потому хочу сказать пару слов о выигрыше по объему.

Допустим, у нас есть следующий класс:

<pre class='lang-java line-numbers'><code>
public class DateAndTime{

  private short year;
  private byte month;
  private byte day;
  private byte hours;
  private byte minutes;
  private byte seconds;

}
</code></pre>
Остальное несущественно. Поля можно было бы сделать типа int, но это лишь усилило бы эффект примера. Хотя в реальности поля могут быть типа <code>int</code> по соображениям производительности. В любом случае, суть понятна. Класс представляет собой дату и время. Нам он интересен прежде всего с точки зрения сериализации.

Возможно, проще всего было бы хранить простейший timestamp. Он имеет тип long, т.е. при сериализации он занял бы 8 байт. Кроме того, этот подход требует методов преобразования компонент в одно значение и обратно, т.е. – потеря в производительности. Плюс такого подхода – совершенно сумасшедшая дата, которая может поместиться в 64 бита. Это огромный запас прочности, чаще всего в реальности не нужный. Класс же, приведенный выше, займет 2 + 5*1 = 7 байт. Плюс служебные издержки на класс и 6 полей.

Можно ли как-нибудь ужать эти данные? Наверняка. Секунды и минуты лежат в интервале 0-59, т.е. для их представления достаточно 6 бит вместо 8. Часы – 0-23 (5 бит), дни – 0-30 (5 бит), месяцы – 0-11 (4 бита). Итого, всё без учета года – 26 бит. До размера int еще остается 6 бит. Теоретически, в некоторых случаях этого может хватить для года. Если нет – добавление еще одного байта увеличивает размер поля данных до 14 бит, что дает промежуток 0-16383. Этого более чем достаточно в реальных приложениях. Итого – мы ужали размер данных, необходимых для хранения нужной информации, до 5 байт. Если не до 4.

Недостаток тот же, что и в предыдущем случае – если хранить дату упакованной, то нужны методы преобразования. А хочется так – хранить в отдельных полях, а сериализовать в упакованном виде. Вот тут как раз целесообразно использовать <code>Externalizable</code>:

<pre class='lang-java line-numbers'><code>
// data is packed into 5 bytes:
//  3         2         1
// 10987654321098765432109876543210
// hhhhhmmmmmmssssssdddddMMMMyyyyyy yyyyyyyy
public void writeExternal(ObjectOutput out){
    int packed = 0;
    packed += ((int)hours) << 27;
    packed += ((int)minutes) << 21;
    packed += ((int)seconds) << 15;
    packed += ((int)day) << 10;
    packed += ((int)month) << 6;
    packed += (((int)year) >> 8) & 0x3F;
    out.writeInt(packed);
    out.writeByte((byte)year);
}

public void readExternal(ObjectInput in){
    int packed = in.readInt();
    year = in.readByte() & 0xFF;
    year += (packed & 0x3F) << 8;
    month = (packed >> 6) & 0x0F;
    day = (packed >> 10) & 0x1F;
    seconds = (packed >> 15) & 0x3F;
    minutes = (packed >> 21) & 0x3F;
    hours = (packed >> 27);
}
</code></pre>

Собственно, это все. После сериализации мы получаем служебные издержки на класс, два поля (вместо 6) и 5 байт данных. Что уже существенно лучше. Дальшейшую упаковку можно оставить специализированным библиотекам.

Приведенный пример весьма прост. Его основное предназначение – показать, как можно применять расширенную сериализацию. Хотя возможный выигрыш в объеме сериализованных данных – далеко не основное преимущество, на мой взгляд. Основное же преимущество, помимо гибкости... (плавно переходим к следующему разделу...)

Ссылка на первоисточник: <a href='http://www.skipy.ru/technics/serialization.html' rel='nofollow' target='_blank'>Сериализация как она есть</a>