Кофе-брейк #65. 5 полезных советов по поддержке чужого кода. Java Collection и ответы на самые распространенные вопросы на собеседованиях 
<p>----------------------------------------</p>
Из вашей команды кто-то уходит? Вам передают устаревший код? Вы меняете место работы? Это лишь некоторые из причин, из-за которых...
<p>----------------------------------------</p>
<h2>5 полезных советов по поддержке чужого кода</h2>Источник: <a href="https://dev.to/funbeedev/5-effective-tips-for-maintaining-code-written-by-someone-else-821" rel="nofollow" target="_blank">Dev.to</a>

Из вашей команды кто-то уходит? Вам передают устаревший код? Вы меняете место работы? Это лишь некоторые из причин, из-за которых разработчики могут столкнуться с задачей поддержки чужого кода.<img data-max-width="800" data-id="b01904d2-31a4-4398-86d6-bf2e98f31595" src="https://cdn.javarush.com/images/article/b01904d2-31a4-4398-86d6-bf2e98f31595/800.jpeg" alt="Кофе-брейк #65. 5 полезных советов по поддержке чужого кода. Java Collection и ответы на самые распространенные вопросы на собеседованиях  - 1">Работа с кодом, который писал кто-то другой, может привести к некоторым проблемам. Код может относиться к незнакомой для вас технологии. Возможно, этот код требует доработки. Или может возникнуть необходимость срочно исправить баг, обнаруженный в старой кодовой базе.

Чтобы лучше справляться с такими задачами, важно знать о вероятных проблемах и иметь систематический способ их решения.

Если вы профессиональный разработчик, то вы уже наверняка сталкивались с подобными ситуациями. Но если нет — поверьте мне, это лишь вопрос времени!

В этой статье мы рассмотрим несколько советов, способных облегчить работу с legacy-кодом.<h3>1. Проведите сеанс передачи кода с автором</h3>Если у вас еще есть контакт с человеком, который написал этот код, проведите с ним сеанс передачи. Или два! А может даже и три.

Используйте эти сеансы передачи как способ ускорить процесс ознакомления с кодовой базой. Иначе вам придется разбираться во всем самостоятельно, а это займет больше времени. Разработчик, создавший этот код, может рассказать вам о его логике, а также указать на скрытые секреты.

Перед сеансом передачи обязательно сами просмотрите код и запишите вопросы, которые у вас возникли. Так во время совместного просмотра кода с его автором вы не забудете прояснить все нужные детали. Разумеется, во время совместных сеансов ведите записи.

Передача кода с его автором — вероятно, самый быстрый способ познакомиться с новой для вас кодовой базой.
Поэтому, если у вас еще есть возможность обратиться к этому разработчику, непременно ею воспользуйтесь. Если ваш коллега собирается покинуть компанию, позаботьтесь о том, чтобы передача кода прошла до его ухода.

Бывают и другие ситуации, когда полезно пройтись по кодовой базе вместе с кем-то, кто ее хорошо знает. Например, если вы поменяли команду, нужно, чтобы кто-то из ваших новых коллег рассказал вам о структуре кода. Это ускорит ваше знакомство с новым кодом.<h3>2. Прочтите всю доступную документацию</h3>Документация — это все доступные документы, относящиеся к проекту, для которого был написан код.

Спецификации проекта? Спецификации программы? Файлы README? Прочтите все это. Время, потраченное на чтение этих документов, вы сэкономите в будущем.

Вместо того, чтобы тратить огромное количество времени на попытки выяснить, почему код был реализован именно так, просто прочитайте README. Вместо того чтобы пытаться самостоятельно понять назначение разделов кода, все это можно узнать в спецификациях программного обеспечения.

Читать документацию важно, даже если вы провели сеанс передачи кода с его автором. Все эти документы написаны не просто так. А сеансы передачи вряд ли могут все охватить.

Чтение документации особенно важно для устаревшего программного обеспечения. Речь идет о случаях, когда у вас нет шанса встретиться с автором кода. Поскольку сеанс передачи невозможен, все, что у вас есть, — это исходный код и любая доступная документация.

Последний совет по этому поводу: помните, что файлы README не зря называются README (прочти меня).<h3>3. Запустите программу и поработайте с ней</h3>Этот совет нужно понимать буквально. Запустите код и попробуйте использовать приложение так, как задумано. Так вы сможете лучше понять, что оно делает.

Это может показаться очевидным, но практика показывает, что многие игнорируют этот этап.

Многие разработчики совершают ошибку, составляя представление о программе лишь по ее коду. Обязательно запустите приложение и оцените его как обычный пользователь. Так вы получите общее понимание того, что на самом деле делает приложение, а также представление о его функциях и ограничениях. В результате вам будет проще разобраться в коде.

Это также относится и к софту, написанному для определенного оборудования или платформ. Получите доступ ко всему необходимому и запустите приложение на этих платформах.

Если вы пытаетесь исправить ошибку, запуск кода станет для вас логичным первым шагом в процессе отладки. Хотя это и так очевидно, лучше еще раз об этом напомнить.<h3>4. Тестируйте, тестируйте, тестируйте!</h3>Если вы имеете дело с незнакомой кодовой базой, прежде чем вносить какие-либо изменения, убедитесь в наличии тестов для проверки работоспособности программы. Тесты помогут подтвердить, что после внесения изменений ничто не сломалось. Безопасно внести изменения бывает еще сложнее, чем просто ознакомиться с чужим кодом.

И если предположить, что вам передали код только для исправления багов и внесения улучшений, то наличие тестов имеет решающее значение.

Если тестов нет, попробуйте написать их самостоятельно. Это могут быть модульные тесты, дымовые, ручные или автоматизированные. Любое тестирование обычно лучше, чем его отсутствие.<h3>5. Примите вызов</h3>Взявшись за поддержку чужого кода, попробуйте принять это как личный вызов. 

Во-первых, вы усовершенствуете навыки чтения и интерпретации чужого кода. Это позволит вам лучше улавливать идеи других разработчиков. Благодаря практике вы сможете легче справляться с задачами поддержки программ.

Во-вторых, поддерживая чужой код, вы сможете перенять полезные методы и приемы, которые улучшат ваш собственный код. Чтение незнакомого кода можно считать методом непрямого обучения. Только будьте осторожны — выбирайте лишь те методы, которые считаются передовыми, и избегайте не очень хороших.

Осознание того, что в конечном итоге вы получите выгоду от этого опыта, должно вас мотивировать. Так что не бойтесь и принимайте брошенный вам вызов!<h3>Вывод</h3>Поддержание кода, написанного кем-то другим, безусловно, связано со многими проблемами. Но это всего лишь еще одна сторона работы разработчика, с которой нам всем когда-нибудь придется столкнуться.

И вы сможете куда лучше подготовиться к работе с чужим кодом, если не только будете следовать советам из этой статьи, но и разработаете собственные систематические методы при работе с незнакомой кодовой базой.<h2>Java Collection и ответы на самые распространенные вопросы на собеседованиях</h2>Источник: <a href="https://dzone.com/articles/top-java-collection-interview-questions-for-2021" rel="nofollow" target="_blank">DZone</a> 

Чтобы закрепить ваши знания в Java, давайте вспомним Java Collection и ответим на некоторые часто задаваемых вопросов, которые ставят новичкам на технических собеседованиях.<h3>Collections в Java</h3>Java Collection — это структура, которая поддерживает архитектуру хранения и управления группами объектов. Структура коллекций с классами и интерфейсами определена в JDK 1.2. Двумя основными интерфейсами классов Java Collection являются интерфейс Collection (java.util.Collection) и интерфейс Map (java.util.Map).

Коллекции Java могут выполнять операции с данными, такие как поиск, сортировка, вставка, манипулирование и так далее. Java Collection Framework предоставляет такие интерфейсы, как Set, List, Queue, Deque, и классы, такие как ArrayList, Vector, LinkedList, HashSet, PriorityQueue, TreeSet и LinkedHashSet.<h4>Необходимость в отдельной структуре коллекций</h4>Если мы не используем структуру коллекций, стандартными методами группировки объектов Java являются массивы, векторы или хеш-таблицы. Все они не имеют общего интерфейса. Все их реализации определяются независимо, и между ними нет корреляции. Таким образом, становится очень трудно запомнить все различные методы, синтаксис и конструкторы, присутствующие в разных классах.

Например, чтобы добавить элемент в вектор, мы используем функцию <span class="code">addElement()</span>, тогда как для добавления элемента в Hashtable мы используем функцию <span class="code">put()</span>.<span class="text-bold">Преимущества системы коллекций:</span><ul>
<li>Снижает нагрузку в процессе программирования: разработчик может больше сосредоточиться на наилучшем использовании коллекции, а не на дизайне коллекции. Это помогает в реализации абстракции.</li>
<li>Улучшает скорость выполнения программы: коллекции обеспечивают высокопроизводительную реализацию структур данных, что повышает производительность.</li>

</ul><span class="text-bold">Поскольку Java является широко используемым языком программирования, множество компаний создают свои продукты именно на этом языке. Поэтому давайте пройдемся по ответам на вопросы базового уровня в Java, которые помогут вам успешно пройти собеседование.</span><h3>Некоторые часто задаваемые вопросы на собеседовании для новичков</h3><h4>Вопрос 1. Что такое фреймворк в Java?</h4><span class="text-bold">Ответ:</span> Фреймворк (структура) — это набор классов и интерфейсов, которые поддерживают готовую архитектуру. Оптимальный объектно-ориентированный дизайн всегда включает фреймворк с набором классов, так что все классы выполняют одинаковые задачи.<h4>Вопрос 2. Что такое фреймворк коллекций в Java?</h4><span class="text-bold">Ответ:</span> Java Collections Framework — это набор интерфейсов и классов, которые помогают эффективно хранить и обрабатывать данные. Java Collection Framework имеет такие интерфейсы, как Set, List, Queue, Deque, и классы, такие как ArrayList, Vector, LinkedList, HashSet, PriorityQueue, TreeSet и LinkedHashSet.<h4>Вопрос 3: Каковы различия между ArrayList и Vector в Java Collection Framework?</h4><span class="text-bold">Ответ:</span>

ArrayList:<ul>
<li>Не синхронизируется.</li>
<li>Может увеличить свой размер на 50% от размера массива.</li>
<li>Не потокобезопасный (thread-safe).</li>
<li>Не является унаследованным классом (legacy class).</li>

</ul>Vector:<ul>
<li>Синхронизируется.</li>
<li>Может вдвое увеличить свой размер.</li>
<li>Потокобезопасный.</li>
<li>Унаследованный класс.</li>

</ul><h4>Вопрос 4. В чем состоят отличия между Iterator и Enumeration?</h4><span class="text-bold">Ответ:</span>

Iterator:<ul>
<li>Может работать как с устаревшими, так и с неустаревшими элементами.</li>
<li>Он медленнее, чем Enumeration.</li>
<li>Он может выполнять операции remove при обходе коллекции.</li>
<li>Он безотказный.</li>

</ul>Enumeration (Перечисляемый тип):<ul>
<li>Может перемещаться только по устаревшим элементам.</li>
<li>Он быстрее, чем итератор.</li>
<li>Он может выполнять с коллекцией только операции traverse.</li>
<li>Он не безотказный.</li>

</ul><h4>Вопрос 5. В чем разница между LinkedList и ArrayList?</h4><span class="text-bold">Ответ:</span>

ArrayList:<ul>
<li>Этот класс реализует интерфейс списка.</li>
<li>Этот класс использует динамический массив для хранения элементов.</li>
<li>Операции вставки и удаления равны O (1) в лучшем случае и O (n) в худшем случае. Операция поиска (то есть доступ к элементу по определенному индексу) занимает время O (1).</li>
<li>ArrayList лучше работает при хранении данных и доступе к ним.</li>

</ul>LinkedList:<ul>
<li>Этот класс реализует как интерфейс списка, так и интерфейс двухсторонней очереди.</li>
<li>Этот класс использует двусвязный список для хранения элементов.</li>
<li>Операции вставки и удаления дают производительность O (1). Операция поиска (то есть доступ к элементу по определенному индексу) занимает O (n) времени.</li>
<li>LinkedList лучше работает при манипулировании сохраненными данными.</li>

</ul><h4>Вопрос 6. Объясните разницу между poll() и remove() в методе интерфейса очереди (Queue).</h4><span class="text-bold">Ответ:</span> Оба метода возвращают и удаляют заголовок очереди. Они отличаются своим поведением только тогда, когда очередь пуста; <span class="code">remove()</span> выдает исключение, тогда как <span class="code">poll()</span> возвращает null для пустой очереди.<h4>Вопрос 7. В чем различия между Comparable и Comparator.</h4><span class="text-bold">Ответ:</span>

Comparable:<ul>
<li>Предоставляет метод <span class="code">compareTo()</span> для сортировки элементов.</li>
<li>Присутствует в пакете java.lang.</li>
<li>Логика сортировки должна быть в том же классе, чей объект мы хотим отсортировать.</li>
<li>Он обеспечивает единую последовательность сортировки.</li>
<li>Фактический класс изменен.</li>

</ul>Comparator:<ul>
<li>Предоставляет метод <span class="code">compare()</span> для сортировки элементов.</li>
<li>Присутствует в пакете java.util.</li>
<li>Логика сортировки должна быть в другом классе, чтобы писать разные сортировки на основе разных атрибутов объектов.</li>
<li>Он обеспечивает несколько последовательностей сортировки.</li>
<li>Фактический класс не изменяется.</li>

</ul><h4>Вопрос 8. Что такое стек с точки зрения компьютерной памяти?</h4><span class="text-bold">Ответ:</span> Стек — это особая область памяти компьютера, в которой хранятся временные переменные, созданные функцией. В стеке переменные объявляются, сохраняются и инициализируются во время выполнения.<h4>Вопрос 9. Составьте список из представлений коллекции в интерфейсе Map.</h4><span class="text-bold">Ответ:</span> Методы представления коллекции позволяют просматривать map как коллекцию тремя способами:<ul>

<li>Key-set view: Набор ключей, содержащихся в Map.</li>
<li>Value-set view: Коллекция значений, содержащихся в Map. Эта коллекция не является набором, потому что несколько ключей могут отображаться в одном и том же значении.</li>
<li>Entry-set view: набор пар «ключ-значение», содержащихся в Map. Интерфейс Map предоставляет небольшой вложенный интерфейс под названием Map.Entry — тип элементов в этом наборе.</li>

</ul><h4>Вопрос 10. Дайте определение EnumSet.</h4><span class="text-bold">Ответ:</span> Это реализация набора (Set), которую можно использовать с перечисляемыми типами. Все элементы должны происходить из одного перечисляемого типа, указанного явно или неявно. Не синхронизируется. Ключи NULL не допускаются.<h4>Вопрос 11. Какие методы делают сборку потокобезопасной?</h4><span class="text-bold">Ответ:</span> Методы:<ul>

<li>Collections.synchronizedList (list);</li>
<li>Collections.synchronizedMap (map);</li>
<li>Collections.synchronizedSet (set).</li>
</ul><h4>Вопрос 12. В чем различия между Queue и Deque?</h4><span class="text-bold">Ответ:</span>

Queue:<ul>
<li>Также известна как односторонняя очередь.</li>
<li>Элементы в очереди (Queue) добавляются или удаляются с одного конца.</li>
<li>Менее универсальна.</li>

</ul>Deque:<ul>
<li>Также известна как двусторонняя очередь.</li>
<li>Элементы в очереди добавляются с любого конца и могут добавляться и удаляться с обоих концов.</li>
<li>Более универсальна.</li>

</ul><h4>Вопрос 13. В чем различия между hashmap и hashtable?</h4><span class="text-bold">Ответ:</span>

Hashmap:<ul>
<li>Несинхронизированный, не потокобезопасный.</li>
<li>Наследует класс <span class="code">AbstractMap</span>.</li>
<li>Допускает один ключ null и несколько значений null.</li>
<li>Обходит iterator.</li>

</ul>Hashtable:<ul>
<li>Синхронизированный, потокобезопасный.</li>
<li>Наследует класс <span class="code">Dictionary</span>.</li>
<li>Не допускает использования ключа null или значения null.</li>
<li>Проходит enumerator и iterator.</li>

</ul><h4>Вопрос 14. Что такое iterator?</h4><span class="text-bold">Ответ:</span> Iterator() — это интерфейс, который предоставляет методы для перебора Collection. Он предоставляет общий способ обхода с использованием элементов коллекции и реализации шаблона проектирования итератора.<h4>Вопрос 15. Что такое Navigable Map?</h4><span class="text-bold">Ответ:</span> Интерфейс NavigableMap входит в Java Collection Framework и принадлежит пакету java.util. Это подинтерфейс SortedMap, который предоставляет удобные методы навигации, такие как lowerKey, floorKey, ceilingKey, and higherKey. Он также помогает создать еще один Map из существующего Map.<h4>Вопрос 16. Что такое peek() в интерфейсе queue?</h4><span class="text-bold">Ответ:</span> <span class="text-bold">Peek()</span> возвращает начало Queue. Он не удаляет никаких элементов. Он возвращает null, когда очередь пуста.