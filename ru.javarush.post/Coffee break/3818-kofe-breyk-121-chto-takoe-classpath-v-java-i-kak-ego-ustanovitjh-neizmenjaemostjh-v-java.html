Кофе-брейк #121. Что такое Classpath в Java и как его установить? Неизменяемость в Java
<p>----------------------------------------</p>
Знание основ программирования и потока выполнения программных файлов помогает нам понять язык. Знание параметра Classpath — одно из основных понятий, которым должен владеть каждый Java-разработчик...
<p>----------------------------------------</p>
<h2>Что такое Classpath в Java и как его установить?</h2>Источник: <a href="https://medium.com/javarevisited/do-you-know-classpath-in-java-3edd297907e5" rel="nofollow" target="_blank">Medium</a>

Знание основ программирования и потока выполнения программных файлов помогает нам понять язык. Знание параметра <span class="code">Classpath</span> — одно из основных понятий, которым должен владеть каждый Java-разработчик. Сегодня мы обсудим, что такое путь к классам (<span class="code">Classpath</span>), как его установить и как он помогает JVM исполнять файлы классов.

<img data-max-width="800" data-id="1bae37cd-589f-4c8b-8e52-5cf7df498bfa" src="https://cdn.javarush.com/images/article/1bae37cd-589f-4c8b-8e52-5cf7df498bfa/800.jpeg" alt="Кофе-брейк #121. Что такое Classpath в Java и как его установить? Неизменяемость в Java - 1"><h3>Что такое Classpath?</h3><span class="code">Classpath</span> является одним из основных параметров в Java, однако новички в программировании часто понимают его неправильно. Если упростить, то <span class="code">Classpath</span> — это просто <span class="text-bold">набор путей</span>, по которым компилятор Java и JVM должны находить необходимые классы для компиляции или выполнения других классов.
<h3>Как Classpath помогает JVM в выполнении файлов классов</h3>Давайте начнем с примера. Предположим, что у нас есть файл <span class="code">Main.java</span>, который находится в папке <em>/Users/vikram/Documents/test-java/src/com/programming/v1/Main.java</em>.

<pre class="language-java line-numbers"><code>
package com.programming.v1;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello classpath");
    }
}
</code></pre>
Допустим, мы находимся в <em>/Users/vikram/Documents</em> и хотим скомпилировать этот класс:

<pre class="language-java line-numbers"><code>
javac test-java/src/com/programming/v1/Main.java
</code></pre>
Теперь, чтобы выполнить этот файл класса, нам нужно сообщить виртуальной машине Java, где искать файл <span class="code">.class</span>, используя <span class="code">classpath</span> или флаг <span class="code">cp</span> в команде <span class="code">java</span>.

<pre class="language-java line-numbers"><code>
vg@lp1 Documents % java -cp "test-java/src" com.programming.v1.Main
Hello classpath
vg@lp1 Documents % java -classpath "test-java/src" com.programming.v1.Main
Hello classpath
</code></pre>
Первый параметр — это корневая папка, в которую записывается пакет. Второй параметр — это имя пакета с именем класса. Когда команда Java исполняется, виртуальная машина Java просматривает папку <em>test-java/src</em>, а затем загружает основной класс для ее выполнения.
<h3>Как установить переменный Classpath</h3>Переменный параметр <span class="code">Classpath</span> может быть установлен, как показано ниже, на компьютерах под управлением Linux:

<pre class="language-java line-numbers"><code>
export CLASSPATH="test-java/src"
</code></pre>
<em>Classpath на компьютере с Windows можно добавить/обновить с помощью переменных среды.</em>

После того, как переменная среды установлена, команду <span class="code">java</span> можно выполнить, как показано ниже:

<pre class="language-java line-numbers"><code>
vg@lp1 Documents % java com.programming.v1.Main
Hello classpath
</code></pre>
Вот и все, что нужно знать о <span class="code">Classpath</span>. Спасибо за чтение! 
<h2>Неизменяемость в Java</h2>Источник: <a href="https://medium.com/@vivekts90/immutability-in-java-321835f1b4d" rel="nofollow" target="_blank">Medium</a>

Переменные в Java бывают двух типов: примитивные и ссылочные. Все в Java передается по значению, но в случае ссылочных типов исходные данные могут обновляться с использованием переданного адреса памяти.
<img data-max-width="800" data-id="80e209e7-a34c-4125-ba4f-e2dc759963f7" src="https://cdn.javarush.com/images/article/80e209e7-a34c-4125-ba4f-e2dc759963f7/800.jpeg" alt="Кофе-брейк #121. Что такое Classpath в Java и как его установить? Неизменяемость в Java - 2">Ключевое слово <span class="code">final</span> используется для того, чтобы переменная действовала как константа, то есть избегала переназначения. Это хорошо работает для примитивов, у которых нет памяти в куче, тогда как для ссылочных типов ограничено только переназначение, а внутреннее состояние может быть изменено. Это может привести к множеству проблем с параллелизмом и условиям гонки (race conditions). Таким образом включение неизменяемых характеристик в обычный тип в Java дает много преимуществ.
<h3>Преимущества неизменяемости в Java</h3><h4>1. Безопасность потоков</h4>Неизменяемые типы невосприимчивы к условиям гонки в многопоточной среде, поскольку объект останется согласованным после его создания. Несколько потоков не могут изменить свое внутреннее состояние, поэтому синхронизация не требуется.
<h4>2. Основополагающий тип</h4><span class="code">String</span> в стандартной библиотеке Java — хороший пример базового класса. Это очень простой и неизменяемый класс, который можно использовать для создания доменов бизнес-логики поверх него. Точно так же неизменяемый тип может выступать в качестве отличного базового типа, на основе которого можно строить.
<h3>Характеристики</h3><h4>1. Поля Private и Final</h4>Поля, содержащие состояние объекта, — это <span class="code">private</span> и <span class="code">final</span>. Частная (<span class="code">private</span>) видимость запрещает прямой доступ к полю, а окончательная (<span class="code">final</span>) гарантирует, что поле назначается только один раз.
<h4>2. Никаких методов-модификаторов</h4>К полю <span class="code">private</span> нельзя получить доступ за пределами класса. Обычно для чтения и записи в поля предусмотрены методы доступа (геттеры) и методы-модификаторы (сеттеры) соответственно. Для обеспечения неизменности модификаторы не допускаются.
<h4>3. Класс Final</h4>Предоставление возможности наследования класса может нарушить неизменяемость. Подкласс, расширяющий неизменяемый класс, может повлиять на состояние объекта. Следовательно, класс является окончательным (<span class="code">final</span>).
<h4>4. Защитные копии (Defensive Copies)</h4>Во время создания объекта вместо того, чтобы назначать аргументы из конструктора непосредственно закрытым полям, создание глубокой копии (или неизменяемой копии) аргументов обеспечит внешнее изменение. Если один из аргументов является ссылочным типом, им можно легко манипулировать на вызывающей стороне. Создание защитных копий позволяет избежать этой манипуляции.

Точно так же для средств доступа (геттеров) вместо прямой ссылки на внутреннее поле можно свободно делиться его копией.
<h3>Реализация</h3><h4>Employee</h4><pre class="language-java line-numbers"><code>
import java.time.LocalDate;
import java.util.List;

import static java.util.List.copyOf;

public final class Employee {
    
    private final long id;
    private final String name;
    private final LocalDate joinDate;
    private final List&lt;String&gt; achievements;

    public Employee(long id,
                    String name,
                    LocalDate joinDate,
                    List&lt;String&gt; achievements) {
        this.id = id;
        this.name = name;
        this.joinDate = joinDate;
        this.achievements = copyOf(achievements);
    }

    public long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public LocalDate getJoinDate() {
        return joinDate;
    }

    public List&lt;String&gt; getAchievements() {
        return achievements;
    }
}
</code></pre>
<ul>
    <li><p>Не все поля имеют защитные копии в конструкторе. Это связано с тем, что <span class="code">id</span> является примитивным, а поля <span class="code">name</span> и <span class="code">joinDate</span> являются неизменяемыми типами. Они не могут быть изменены вызывающей стороной и останутся неизменными, в то время как поле <span class="code">achievements</span> требует копии аргумента, сделанного с помощью метода <span class="code">List.copyOf</span>. Это объясняется тем, что <span class="code">copyOf</span> возвращает неизменяемый <span class="code">List</span>.</p></li>
    <li><p>Точно так же методы доступа возвращают поля напрямую, а не защитные копии, потому что все типы полей являются неизменяемыми (включая <span class="code">achievements</span>) и, следовательно, не могут быть изменены вне класса.</p></li>

</ul><h3>Улучшения</h3><h4>До Java 16</h4>Реализация <span class="code">Employee</span> может быть улучшена с помощью таких библиотек, как <a href="https://projectlombok.org/" rel="nofollow" target="_blank">Lombok</a>. Это уменьшает многословие в коде и помогает ему выглядеть более чистым. Библиотека поставляется с аннотациями для сокращения стандартного кода. <span class="code">@Value</span> (аннотация) может использоваться для создания геттеров и конструктора всех аргументов. Это также создает класс <span class="code">final</span> и поля <span class="code">private</span> и <span class="code">final</span>. В качестве примечания, он также генерирует методы <span class="code">toString</span>, <span class="code">equals</span> и <span class="code">hashCode</span>. Реализация <span class="code">Employee</span> может быть переписана с помощью <span class="code">@Value</span>, как показано ниже:

<pre class="language-java line-numbers"><code>
import lombok.Value;

import java.time.LocalDate;
import java.util.List;

import static java.util.List.copyOf;

@Value
public class Employee {
    
    long id;
    String name;
    LocalDate joinDate;
    List&lt;String&gt; achievements;

    public Employee(long id,
                    String name,
                    LocalDate joinDate,
                    List&lt;String&gt; achievements) {
        this.id = id;
        this.name = name;
        this.joinDate = joinDate;
        this.achievements = copyOf(achievements);
    }
}
</code></pre><h3>Java 16 и более поздние версии</h3>В релизе Java 16 появилась новая функция <span class="code">Record</span>. Она (как утверждает JEP) является классами, которые действуют как прозрачные носители неизменяемых данных и могут рассматриваться как номинальные кортежи (tuples). Класс <span class="code">Employee</span> можно повторно реализовать как <span class="code">record Employee</span>, что показано ниже.

<pre class="language-java line-numbers"><code>
import java.time.LocalDate;
import java.util.List;

import static java.util.List.copyOf;

public record Employee(long id,
                       String name,
                       LocalDate joinDate,
                       List&lt;String&gt; achievements) {
    
    public Employee(long id,
                    String name,
                    LocalDate joinDate,
                    List&lt;String&gt; achievements) {
        this.id = id;
        this.name = name;
        this.joinDate = joinDate;
        this.achievements = copyOf(achievements);
    }
}
</code></pre><h3>Недостатки</h3>Единственная проблема с неизменяемостью — дополнительная память и обработка, которые требуются даже для небольшой модификации. Каждый раз необходимо создавать новый объект, что может быть весьма накладно. Чтобы обойти этот недостаток, можно реализовать такие механизмы, как кэширование и сохранение результатов.