Кофе-брейк #185. Подробное руководство по Java Collection Framework
<p>----------------------------------------</p>
Данное руководство поможет вам лучше изучить работу различных классов и интерфейсов, входящих в Java Collection Framework...
<p>----------------------------------------</p>
Источник: <a href="https://medium.com/@anshita.bhasin/java-collection-framework-ea52a61da22b" rel="nofollow" target="_blank">Medium</a>

<em>Данное руководство поможет вам лучше изучить работу различных классов и интерфейсов, входящих в Java Collection Framework.</em>
<img data-max-width="800" data-id="ea81deee-7b54-4180-87ee-e23fe5409131" src="https://cdn.javarush.com/images/article/ea81deee-7b54-4180-87ee-e23fe5409131/800.jpeg" alt="Кофе-брейк #185. Подробное руководство по Java Collection Framework - 1">Java Collection — это фреймворк, который обеспечивает унифицированную архитектуру для хранения и управления группой объектов. По своей сути, это набор классов и интерфейсов, которые обеспечивают стандартный способ представления коллекций объектов и управления ими на языке Java. Также фреймворк помогает в реализации часто используемых структур данных, таких как List, Set и Map.

Java Collection Framework включает несколько интерфейсов и классов. Вот список некоторых из них:
<h3>Интерфейсы</h3>Интерфейсы в Java Collection Framework определяют общее поведение и операции, которые могут выполняться с коллекциями. Сюда входят добавление или удаление элементов, повторение элементов в коллекции и многое другое.<ul>

<li><span class="code">Collection</span>: корневой (root) интерфейс в иерархии коллекций, представляющий группу объектов, известных как элементы.</li>
<li><span class="code">List</span>: упорядоченная коллекция элементов, допускающая дублирование.</li>
<li><span class="code">Set</span>: коллекция элементов, не допускающих дублирования.</li>
<li><span class="code">Map</span>: коллекция пар ключ-значение (key-value), где каждый ключ уникален.</li>
<li><span class="code">Queue</span>: очередь — это структура данных, которая используется для хранения элементов в порядке появления (First-In-First-Out, FIFO).</li>

</ul>В этот список вошли далеко не все, а только наиболее используемые интерфейсы в Java Collection Framework. Теперь давайте подробно рассмотрим каждый их них.
<h3>Collection</h3>Коллекция (Collection) представляет собой группу объектов, известных как ее элементы. Это объект, который может содержать ссылки на другие объекты. Интерфейс Collection является корнем иерархии коллекций. Это базовый интерфейс для всех коллекций в Java Collection Framework. Он определяет основные методы, которые должны быть реализованы во всех коллекциях, такие как <span class="code">add()</span>, <span class="code">remove()</span> и <span class="code">contains()</span>.

Вот пример использования коллекций в Java Collection Framework. Здесь интерфейс Collection применяется для добавления и удаления элементов из коллекции:

<pre class="language-java line-numbers"><code>
import java.util.Collection;
import java.util.ArrayList;

public class CollectionExample {
    public static void main(String[] args) {
        // Создаем новую коллекцию
        Collection&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();
        
        // Добавляем несколько элементов в коллекцию
        stringCollection.add("hello");
        stringCollection.add("world");
        stringCollection.add("foo");
        stringCollection.add("bar");
        
        // Печатаем число элементов в коллекции
        System.out.println("Number of elements: " + stringCollection.size());
        
        // Удаляем элемент из коллекции
        stringCollection.remove("foo");
        
        // Опять печатаем число элементов в коллекции
        System.out.println("Number of elements: " + stringCollection.size());
    }
}
</code></pre>
На выводе получаем:

<div class="terminal">Number of elements: 4
Number of elements: 3</div>
Как видите, интерфейс Collection представляет собой простой и удобный способ выполнения стандартных операций с коллекцией объектов. Он часто используется в качестве отправной точки при работе с коллекциями в Java.

Java Collection Framework включает в себя несколько интерфейсов, которые определяют общее поведение для разных типов коллекций. Некоторые из них входят в группу интерфейсов <span class="code">java.util.Collection</span>:<ul>

<li><span class="code">java.util.List</span></li>
<li><span class="code">java.util.set</span></li>
<li><span class="code">java.util.Queue</span></li>

</ul><h4>java.util.List</h4>List (список) — это упорядоченный набор объектов, каждый элемент которого занимает определенную позицию в списке. Интерфейс List расширяет интерфейс Collection и добавляет в него несколько методов для работы со списками, таких как методы доступа к элементам по их положению в списке и методы поиска и сортировки списков. List <span class="text-bold"><em>может содержать повторяющиеся элементы</em></span>, доступ к этим элементам можно получить по их положению в списке.

Вот пример использования интерфейса List для добавления, удаления и доступа к элементам в списке:

<pre class="language-java line-numbers"><code>
import java.util.List;
import java.util.ArrayList;

public class ListExample {
    public static void main(String[] args) {
        // Создаем новый список
        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();
        
        // Добавляем несколько элементов в список
        stringList.add("India");
        stringList.add("UAE");
        stringList.add("London");
        stringList.add("US");
        
        // Печатаем первый элемент в списке
        System.out.println("First element: " + stringList.get(0));
        
        // Удаляем второй элемент из списка 
        stringList.remove(1);
        
        // Печатаем второй элемент в списке
        System.out.println("Second element: " + stringList.get(1));
    }
}
</code></pre>
Вывод:

<div class="terminal">First element: India
Second element: London</div>
Как показано выше, интерфейс List обеспечивает удобный способ работы с упорядоченными коллекциями элементов. Он обычно используется, когда вам нужно поддерживать порядок элементов в коллекции или когда вам нужно получить доступ к элементам по их индексу в списке.
<h4>java.util.Set</h4>Set в Java Collection Framework — это неупорядоченное множество уникальных элементов, <span class="text-bold"><em>в котором не допускаются повторяющиеся элементы</em></span>. Интерфейс Set расширяет интерфейс Collection и добавляет в него несколько методов, таких как методы проверки наличия элемента в множестве (set) и методы добавления и удаления элементов из множества.

Вот пример использования интерфейса Set для добавления и удаления элементов из множества в Java Collection Framework:

<pre class="language-java line-numbers"><code>
import java.util.Set;
import java.util.HashSet;

public class SetExample {
    public static void main(String[] args) {
        // Создаем новый set
        Set&lt;String&gt; stringSet = new HashSet&lt;&gt;();
        
        // Добавляем несколько элементов в set
        stringSet.add("Jan");
        stringSet.add("Feb");
        stringSet.add("March");
        stringSet.add("April");
        
        // Проверяем наличие в set элемента "March"
        if (stringSet.contains("March")) {
            System.out.println("The set contains the element 'March'");
        }
        
        // Удаляем элемент "April" из set
        stringSet.remove("April");
        
        // Опять проверяем наличие элемента "April" в set 
        if (!stringSet.contains("April")) {
            System.out.println("The set no longer contains the element 'April'");
        }
    }
}
</code></pre>
Вывод:

<div class="terminal">The set contains the element 'March'
The set no longer contains the element 'April'</div><h4>java.util.Queue</h4>Queue (очередь) — это структура данных, которая используется для хранения элементов в порядке их появления (FIFO). Это означает, что первый элемент, добавленный в очередь, будет первым удаленным. Вот пример того, как использовать очередь в Java Collection Framework:

<pre class="language-java line-numbers"><code>
// Создание очереди
Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

// Добавление элементов в очередь
queue.add("apple");
queue.add("banana");
queue.add("orange");
// Печатаем очередь
System.out.println("Queue: " + queue);
// Удаляем элемент из очереди
String element = queue.remove();
System.out.println("Removed element: " + element);
// Печатаем обновленную очередь
System.out.println("Queue: " + queue);
</code></pre>
В данном примере мы создали очередь строк и добавили в нее три элемента: “apple”, “banana” и “orange”. Затем мы печатаем очередь, чтобы увидеть ее текущее состояние. Далее мы удаляем элемент из очереди и выводим его на консоль. Наконец, мы печатаем обновленную очередь, чтобы убедиться, что удаленный элемент больше не находится в очереди.
<h4>Map</h4>Интерфейс <span class="code">java.util.Map</span> в Java Collection Framework используется для сопоставления ключей со значениями. Он позволяет хранить элементы в виде пар ключ-значение и предоставляет методы для доступа, изменения и повторения элементов на карте. Ниже приведен пример использования интерфейса <span class="code">Map</span>:

<pre class="language-java line-numbers"><code>
// Создаем Map
 Map&lt;String, Integer&gt; map = new  HashMap &lt;&gt;(); 
// Добавляем элементы в Map
map.put("apple", 1);
map.put("banana", 2);
map.put("orange", 3);
// Печать Map
 System.out.println("Map: " + map);
// Получаем значение для определенного ключа 
int  value  = map.get( "banana" ); 
System.out.println("Value for 'banana': " + value);
// Удаляем элемент из Map
map.remove("orange"); 
// Печать обновленной карты
 System.out.println( "Map: " + map);
</code></pre>
В этом примере мы создаем карту (map) строк и целых чисел, добавляя к ней три элемента: “apple” сопоставляется с 1, “banana” сопоставляется с 2 и “orange” сопоставляется с 3. Затем мы печатаем карту, чтобы увидеть ее текущее значение. После этого мы получаем значение ключа “banana” и выводим его на консоль. Наконец, мы удаляем пару ключ-значение для “orange” с карты и печатаем обновленную карту, чтобы увидеть, что удаленного элемента больше на ней нет.
<h4>Classes</h4>Класс (Class) — это конкретная реализация интерфейса коллекции. Он предоставляет конкретные реализации общего поведения и операций, определенных интерфейсами во фреймворке.<ul>

<li><span class="code">ArrayList</span>: реализация интерфейса <span class="code">List</span> с изменяемым размером массива.</li>
<li><span class="code">LinkedList</span>: двусвязный список, реализация интерфейсов <span class="code">List</span> и <span class="code">Deque</span>.</li>
<li><span class="code">HashSet</span>: реализация <span class="code">Set</span>, использующая хеш-таблицу для хранения.</li>
<li><span class="code">TreeSet</span>: реализация <span class="code">Set</span>, использующая дерево для хранения.</li>
<li><span class="code">HashMap</span>: реализация <span class="code">Map</span>, использующая хеш-таблицу для хранения.</li>

</ul>Приведенный выше список является одним из наиболее часто используемых классов в Java Collection Framework. Теперь давайте рассмотрим подробное объяснение этих классов.
<h4>ArrayList</h4>Класс <span class="code">java.util.ArrayList</span> в коллекциях Java используется для хранения изменяемого размера массива элементов в списке. Это широко используемая реализация интерфейса <span class="code">java.util.List</span>, которая использует массив для хранения элементов и предоставляет эффективные методы для доступа, изменения и повторения элементов в списке.

Класс <span class="code">java.util.ArrayList</span> обеспечивает быстрый произвольный доступ к своим элементам, но медленную вставку и удаление в произвольных позициях.

Ниже приведен пример использования класса <span class="code">ArrayList</span> в Java Collection Framework:

<pre class="language-java line-numbers"><code>
// Создаем array list
List&lt;String&gt; list = new ArrayList&lt;&gt;();
// Добавляем элементы в array list
list.add("qa");
list.add("devops");
list.add("dev");
// Печатаем array list
System.out.println("Array list: " + list);
// Доступ к элементу по определенному индексу 
String element = list.get(1);
System.out.println("Element at index 1: " + element);
// Удаление элемента из the array list
list.remove(1);
// Print the updated array list
System.out.println("Array list: " + list);
</code></pre>
Как видите, мы создали массив строк и добавили в него три элемента: “qa”, “devops” и “dev”. Затем мы напечатали список массивов, чтобы увидеть его текущее состояние. После этого мы получаем доступ к элементу с индексом 1 и выводим его на консоль. Наконец, мы удаляем элемент с индексом 1 из списка массивов и печатаем обновленный список массивов, чтобы убедиться, что удаленного элемента больше нет в списке.
<h4>LinkedList</h4>Класс <span class="code">java.util.LinkedList</span> в Java Collection Framework наследует класс <span class="code">AbstractList</span> и реализует интерфейсы <span class="code">List</span> и <span class="code">Deque</span>. Он предоставляет эффективные методы для добавления, удаления и доступа к элементам в начале и конце списка.

Также этот Класс является реализацией интерфейса <span class="code">List</span>, в которой для хранения элементов используется двусвязный список (doubly-linked list). Он обеспечивает быструю вставку и удаление в произвольных позициях, но медленный произвольный доступ к своим элементам.

Вот пример того, как использовать класс <span class="code">LinkedList</span> в Java Collection Framework:

<pre class="language-java line-numbers"><code>
// Создаем linked list
List&lt;String&gt; list = new LinkedList&lt;&gt;();
// Добавляем элементы в linked list
list.add("selenium");
list.add("cypress");
list.add("playwright");
// Печатаем linked list
System.out.println("Linked list: " + list);
// Добавляем элемент в начало списка 
list.add(0, "webdriver.io");
// Печатаем обновленный linked list
System.out.println("Linked list: " + list);
// Удаляем первый элемент в списке
list.remove(0);
// Еще раз печатаем обновленный linked list
System.out.println("Linked list: " + list);
</code></pre>
В данном примере мы создали связанный список (linked list) строк и добавили в него три элемента: “selenium”, “cypress” и “playwright”. Затем мы печатаем связанный список, чтобы увидеть его текущее состояние. Далее мы добавляем элемент “webdriver.io” в начало списка и печатаем обновленный связанный список. Наконец, мы удаляем первый элемент из списка и опять печатаем обновленный связанный список, чтобы увидеть, что удаленного элемента больше нет в списке.
<h4>HashSet</h4>Класс <span class="code">java.util.HashSet</span> в Java Collection Framework используется для хранения коллекции уникальных элементов в set (наборе, можестве). Он обеспечивает реализацию интерфейса <span class="code">java.util.Set</span> на основе хэш-таблицы.

Также он обеспечивает быструю вставку, удаление и поиск, но не сохраняет порядок своих элементов. Ниже приведен пример использования класса <span class="code">HashSet</span> в Java Collection Framework:

<pre class="language-java line-numbers"><code>
// Создаем hash set
Set&lt;String&gt; set = new HashSet&lt;&gt;();

// Добавляем элементы в hash set
set.add("rose");
set.add("lily");
set.add("lotus");
// Попытка добавить повторяющийся элемент
set.add("rose");
// Печатаем hash set
System.out.println("Hash set: " + set);
// Удаляем элемент из hash set
set.remove("lily");
// Печать обновленного hash set
System.out.println("Hash set: " + set);
</code></pre>
Здесь мы создали хеш-набор (hash set) строк и добавили к нему три элемента: “rose”, “lily” и “lotus”. Затем мы снова пытаемся добавить элемент “rose”, но поскольку набор хэшей не допускает дублирования, он не будет добавлен. После этого мы печатаем hash set, чтобы увидеть его текущее состояние. Затем мы удаляем элемент “lily” из set и печатаем обновленный hash set, чтобы увидеть, что удаленного элемента больше нет в set.
<h4>TreeSet</h4>Класс <span class="code">java.util.TreeSet</span> в Java Collection Framework используется для хранения коллекции уникальных элементов в множестве (set), отсортированном в порядке возрастания. Он обеспечивает древовидную реализацию интерфейса <span class="code">java.util.Set</span>, для хранения элементов, не допуская дублирования элементов.

Класс обеспечивает быструю вставку, удаление и поиск и поддерживает порядок своих элементов в соответствии с их естественным порядком или компаратором. Вот пример того, как использовать класс <span class="code">TreeSet</span> в Java Collection Framework:

<pre class="language-java line-numbers"><code>
// Создаем tree set
Set&lt;String&gt; set = new TreeSet&lt;&gt;();

// Добавляем элементы в tree set
set.add("apple");
set.add("banana");
set.add("orange");
// Попытка добавить повторяющийся элемент
set.add("apple");
// Печатаем tree set
System.out.println("Tree set: " + set);
// Удаляем элемент из tree set
set.remove("banana");
// Печатаем обновленный tree set
System.out.println("Tree set: " + set);
</code></pre>
В этом примере мы создаем древовидный набор строк и добавляем к нему три элемента: “apple”, “banana” и “orange”. Затем мы снова пытаемся добавить элемент “apple”, но поскольку tree set не допускает дублирования, он не будет добавлен. После этого мы печатаем tree set, чтобы увидеть его текущее состояние. Поскольку tree set отсортирован в порядке возрастания, элементы будут напечатаны в порядке: “apple”, “banana” и “orange”. Затем мы удаляем элемент “banana” из набора и печатаем обновленный tree set, чтобы увидеть, что удаленного элемента больше нет в наборе.
<h4>HashMap</h4>Класс <span class="code">java.util.HashMap</span> в Java Collection Framework используется для хранения сопоставления ключей со значениями на карте. Он обеспечивает реализацию интерфейса <span class="code">java.util.Map</span> на основе хеш-таблицы и позволяет хранить элементы в виде пар ключ-значение.

Класс обеспечивает быструю вставку, удаление и поиск, но не сохраняет порядок своих элементов. Вот пример того, как использовать класс <span class="code">HashMap</span> в Java Collection Framework:

<pre class="language-java line-numbers"><code>
// Создаем hash map
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();

// Добавляем элементы в hash map
map.put("apple", 1);
map.put("banana", 2);
map.put("orange", 3);
// Печатаем hash map
System.out.println("Hash map: " + map);
// Получаем значение для определенного ключа 
int value = map.get("banana");
System.out.println("Value for 'banana': " + value);
// Удаляем элемент из hash map
map.remove("orange");
// Печатаем обновленный hash map
System.out.println("Hash map: " + map);
</code></pre>
В данном примере мы создаем хэш-карту строк с целыми числами и добавляем к ней три элемента: “apple” сопоставляется с 1, “banana” сопоставляется с 2 и “orange” сопоставляется с 3. Затем мы печатаем хэш-карту, чтобы увидеть его текущее состояние. После этого мы получаем значение ключа “banana” и выводим его на консоль. Наконец, мы удаляем пару ключ-значение для “orange” из хэш-карты и печатаем обновленную хэш-карту, чтобы увидеть, что удаленного элемента в ней больше нет.
<h2>Заключение</h2>Java Collection Framework представляет собой набор классов и интерфейсов, которые обеспечивают стандартный способ представления коллекций объектов и управления ими в языке программирования Java.

Это позволяет разработчикам/тестировщикам работать с коллекциями объектов согласованным и эффективным образом. Фреймворк предоставляет им методы для хранения, доступа и управления элементами в коллекции, а также позволяет легко переключаться между различными реализациями коллекций в зависимости от требований приложения.