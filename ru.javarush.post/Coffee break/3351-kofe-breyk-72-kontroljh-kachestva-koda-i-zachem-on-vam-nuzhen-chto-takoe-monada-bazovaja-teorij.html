Кофе-брейк #72. Контроль качества кода и зачем он вам нужен. Что такое монада? Базовая теория для Java-разработчика
<p>----------------------------------------</p>
Качество кода — важная вещь, верно? Все это знают и все согласны с этим. Но почему же тогда большинство софтверных компаний: не имеют определения качества кода...
<p>----------------------------------------</p>
<h2 id="topic1">Контроль качества кода и зачем он вам нужен</h2>Источник: <a href="https://dzone.com/articles/code-quality-control-and-why-you-need-it" rel="nofollow" target="_blank">DZone</a>

Качество кода — важная вещь, верно? Все это знают и все согласны с этим. Но почему же тогда большинство софтверных компаний:<ul>

<li>не имеют определения качества кода,</li>
<li>непоследовательно используют стандарты качества кода,</li>
<li><span class="text-bold">не контролируют качество своего кода?</span></li>

</ul>В этой статье я собираюсь сосредоточиться на третьей проблеме, а именно на <span class="text-bold">отсутствии контроля над качеством кода</span>.<img data-max-width="800" data-id="849d9400-10ae-4b6d-bd5c-910bfd1dd868" src="https://cdn.javarush.com/images/article/849d9400-10ae-4b6d-bd5c-910bfd1dd868/800.jpeg" alt="Кофе-брейк #72. Контроль качества кода и зачем он вам нужен. Что такое монада? Базовая теория для Java-разработчика - 1">Если команда не контролирует качество исходного кода, то как она определяет, что разработчики действительно создают эффективное программное обеспечение? Низкое качество кода ухудшает производительность и эффективность рабочего процесса. 

Более того, осведомлены ли они о том, что их <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%85%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B4%D0%BE%D0%BB%D0%B3" rel="nofollow" target="_blank">технический долг</a> может увеличиваться? И, как следствие, вырастет стоимость добавления новых фич.<h3>Технический долг?</h3>О техническом долге написаны сотни текстов, но <a href="https://martinfowler.com/articles/is-quality-worth-cost.html" rel="nofollow" target="_blank">этот</a>, написанный Мартином Фаулером, хорошо раскрывает тему.

Итак, что будет если не выплатить технический долг (или, другими словами, к чему приводит отсутствие работы над улучшением кода)?

<span class="text-bold">Если вы плохо заботитесь о своем коде</span>, то это приводит к таким последствиям:<ol>

<li>Код не отвечает современным стандартам написания кода.</li>
<li>Страдают показатели качества вашего кода.</li>
<li>Возникают проблемы с тестированием вашего кода.</li>
<li>Приходится тратить лишнее время на улучшение качество кода (рефакторинг).</li>
<li>Вы <span class="text-bold">больше времени и усилий тратите на сопровождение кода</span>, а не на разработку.</li>

</ol>Может, поначалу эти проблемы вы и не заметите, но со временем все станет ясно.

<em>«Как и в случае с денежным долгом, если технический долг не погашен, он может накапливать «проценты», что затрудняет реализацию изменений».</em>

Это был своего рода финансовый взгляд на последствия плохого качества кода. Но давайте посмотрим на эту проблему <span class="text-bold">с точки зрения разработчиков</span> программного обеспечения. Что для нас значит <span class="text-bold">плохое качество кода</span> и большой технический долг?<ol>

<li><span class="text-bold">Повышенный уровень стресса</span>, поскольку можно не успеть к дедлайну. Чтобы добавить что-то в код, надо больше и больше времени.</li>
<li><span class="text-bold">Опять же, увеличение уровня стресса</span>, потому что на выходных вам приходится заниматься решением проблем с кодом.</li>
<li><span class="text-bold">Утомительная и скучная работа</span> вместо творческого и приятного кодинга.</li>
<li><span class="text-bold">«Почему это занимает столько времени?»</span> — вопрос, который ваше руководство повторяет все чаще и чаще.</li>
<li><span class="text-bold">Разочарование от работы с плохим кодом</span>. Вам это знакомо, правда? ;)</li>

</ol>Хорошо, теперь мы знаем, насколько плохо может быть, если мы недостаточно заботимся о нашем коде. Но что мы можем с этим поделать?<h3>Процесс контроля качества кода</h3>Я почти уверен, вы знаете, что не существует волшебной палочки, которая могла бы превратить плохой код в надежный. Особенно за один день.

Но это не значит, что мы не можем ничего сделать. Мы можем <span class="text-bold">выстроить процесс</span>. Это может быть серия повторяемых шагов, которые:<ul>

<li><span class="text-bold">помогают поддерживать качество кода</span> на высоком уровне для проектов, в которых качество уже удовлетворительное;</li>
<li><span class="text-bold">показывают, что, где и как нужно изменить</span> в существующем коде, чтобы улучшить его качество.</li>

</ul>Однако делать все вручную — не лучший вариант. Во-первых, это неэффективно. Во-вторых, могут возникнуть ошибки.

Вы когда-нибудь пропускали очевидную ошибку в коде во время проверки кода? Я, например, да… :(

Более того, иногда ошибки даже не обнаруживаются во время тестирования (конечно, ручного), но появляются в первый же день после релиза...<h3>Автоматизация — ключ к успеху</h3>Ручная проверка кода хуже, чем автоматическая. <span class="text-bold">Автоматизация</span> может снять с вас бремя постоянной проверки кода. Это позволит вам сосредоточиться на решении реальных проблем с помощью программного обеспечения, а не на решении <span class="text-bold">проблем самого программного обеспечения</span>.

В мире Java-разработки существует много инструментов, способных помочь вам в автоматизации проверки и улучшения качества кода.

Я не знаю ни одного инструмента, который мог бы преобразовать ваш устаревший,  плохо спроектированный и плохо закодированный проект в хорошо организованный и легко поддерживаемый. По крайней мере, не сейчас. И не все можно полностью  автоматизировать (например, ревью кода).

Но можем ли мы избавиться от многих трудно обнаруживаемых ошибок кода и  сделать наш код более чистым и надежным в самом начале цикла разработки (<a href="https://www.techopedia.com/definition/22193/software-development-life-cycle-sdlc" rel="nofollow" target="_blank">SDLC</a>)?

Что еще более важно, автоматизируя процесс, мы можем добиться этого, затратив лишь небольшое количество усилий и времени по сравнению с работой вручную. И все это до того, как команда тестировщиков возьмется за дело. ;)<h3>Что проверять?</h3>Теперь мы знаем, что нам нужен процесс. Более того, мы знаем, что он должен быть максимально автоматическим. Но что мы должны проверить?

Мы можем разделить весь процесс проверки исходного кода на 7 областей:<ul>

<li>проверка стиля оформления кода,</li>
<li>проверка корректности кода и выявление типичных ошибок,</li>
<li>выявление недостатков конструкции,</li>
<li>расчет сложности кода,</li>
<li>проверка безопасности кода и зависимостей,</li>
<li>расчет покрытия кода,</li>
<li>обзор кода.</li>

</ul><h3>Вывод</h3>Качество кода — это очень важная тема и по ней есть много различных мнений. Но что бы вы ни думали о качестве кода, это все равно влияет на нашу (разработчиков) жизнь.

Это может улучшить качество нашей жизни или ухудшить ее. Вы можете гордиться своим кодом или вам может быть за него стыдно. Вы можете решать реальные проблемы или выполнять утомительные и повторяемые задачи каждый день.

Недостаточно обучать разработчиков, организовывать тренинги или делать презентации о качестве кода. Наличие процесса обеспечения качества кода является обязательным, если компания серьезно относится к созданию программного обеспечения. Даже в «звездных» командах разработчиков.<h2 id="topic2">Что такое монада? Базовая теория для Java-разработчика</h2>Источник: <a href="https://dzone.com/articles/what-is-a-monad-basic-theory-for-a-java-developer" rel="nofollow" target="_blank">DZone</a>

Как можно догадаться из названия, основной темой этой статьи будут монады. С помощью класса <span class="code">Optional</span> в Java я постараюсь описать их подробно, погрузившись в структуру и внутреннюю работу монад. В конце публикации я реализую монаду для логов, а затем опишу роль каждого основного фрагмента кода и приведу простой пример его использования.<img data-max-width="800" data-id="f54ea8ef-0475-4991-9482-d0b3baed87d7" src="https://cdn.javarush.com/images/article/f54ea8ef-0475-4991-9482-d0b3baed87d7/800.jpeg" alt="Кофе-брейк #72. Контроль качества кода и зачем он вам нужен. Что такое монада? Базовая теория для Java-разработчика - 2"><h3>Зачем изучать, как работают монады?</h3>Всегда хорошо иметь базовое представление о том, как работают вещи, которые мы используем. Если вы Java-разработчик, то вы, вероятно, используете монады, даже не подозревая об этом. Две из наиболее известных фич Java 8 — это монадные реализации, а именно Stream и Optional. 

Начнем с описания, что такое монада. На мой взгляд, здесь все довольно просто.

<center><em>«Монада — это просто моноид в категории эндофункторов».</em></center>
Это была цитата из книги «<a href="https://link.springer.com/book/10.1007/978-1-4612-9839-7" rel="nofollow" target="_blank">Категории для практикующих математиков</a>» Сондерса Маклейна.

А теперь давайте серьезно...<h2>Что такое монада?</h2>Это концепция, а не класс или интерфейс. Конечно, в дальнейшем ее можно реализовать как класс или интерфейс. Это можно сделать практически на любом языке со статической типизацией с поддержкой универсальных типов. Более того, мы можем рассматривать ее как оболочку, которая помещает наше значение в некоторый контекст и позволяет нам выполнять операции со значением. В этом контексте выходные данные операции на любом этапе являются входными данными для операции на следующем этапе.

Примеры монад в современных языках программирования:<ul>

<li>Stream (Java).</li>
<li>Optional/Option (Java/Scala).</li>
<li>Either (Scala).</li>
<li>Try (Scala).</li>
<li>IO Monad (Haskell).</li>

</ul><h3>Правила монад</h3>Последнее, что нужно вспомнить, говоря о монадах, — это их правила. Если мы хотим рассматривать нашу реализацию как настоящую монаду, мы должны им следовать. Есть три правила: <span class="text-bold">левая идентичность</span>, <span class="text-bold">правая идентичность</span> и <span class="text-bold">ассоциативность</span>. С помощью класса <span class="code">Optional</span> я постараюсь более подробно объяснить эти правила.

Но сначала несколько определений:<ul>

<li>F является функцией с подписью: <span class="code">(T -&gt; Optional&lt;U&gt;) = Optional&lt;U&gt;</span>.</li>
<li>G — функция с подписью <span class="code">(A -&gt; Optional&lt;B&gt;) = Optional&lt;B&gt;</span>.</li>
<li><span class="code">FG = F.apply(value).flatMap(G)</span> с подписью: <span class="code">(T -&gt; Optional&lt;B&gt;) = Optional&lt;B&gt;</span>.</li>

</ul><h4>Левая идентичность</h4>Если мы создадим новую монаду и привяжем ее к функции, результат должен быть таким же, как при применении функции к значению: 

<pre class="language-java line-numbers"><code>
Optional.of(value).flatMap(F).equals(F.apply(value))
</code></pre><h4>Правая идентичность</h4>Результат привязки единичной функции к монаде должен быть таким же, как и при создании новой монады: 

<pre class="language-java line-numbers"><code>
Optional.of(value).flatMap(Optional::of).equals(Optional.of(value))
</code></pre><h4>Ассоциативность</h4>В цепочке функциональных приложений не важно, как функции вложены:

<pre class="language-java line-numbers"><code>
Optional&lt;B&gt; leftSide = Optional.of(value).flatMap(F).flatMap(G)

Optional&lt;B&gt; rightSide = Optional.of(value).flatMap(F.apply(value).flatMap(G))

leftSide.equals(rightSide).
</code></pre><h3>Создание монады</h3>Первое, что нам нужно, это параметризованный тип M&lt;T&gt;, оболочка для нашего значения типа T. Наш тип должен реализовывать две функции:<ul>

<li><span class="code">Unit</span> — используется для надстройки (wrapper) нашего значения и имеет подпись <span class="code">(T) = M&lt;T&gt;</span>.</li>
<li><span class="code">Bind</span> — отвечает за выполнение операций. Здесь мы передаем функцию, которая работает со значением в нашем контексте и возвращает его с другим типом, уже заключенным в контекст. Этот метод должен иметь следующую подпись <span class="code">(T -&gt; M&lt;U&gt;) = M&lt;U&gt;</span>.</li>

</ul>Чтобы сделать все более понятным, я еще раз воспользуюсь <span class="code">Optional</span> и покажу, как в данном случае выглядит приведенная выше структура.

Здесь первое условие выполняется сразу, потому что <span class="code">Optional</span> — это параметризованный тип. Роль функции <span class="code">unit</span> выполняют методы <span class="code">ofNullable</span> и <span class="code">of</span>. <span class="code">FlatMap</span> играет роль функции <span class="code">bind</span>. Конечно, в случае <span class="code">Optional</span>, границы типов позволяют нам использовать более сложные типы, чем в определении выше.<h3>Закончив с теорией, приступим к реализации</h3><pre class="language-java line-numbers"><code>
//imports
public final class LogMonad&lt;T&gt; {

    private final T value;

    private static final Logger LOGGER = 
      Logger.getLogger(LogMonad.class.getName());

    private LogMonad() {
        this.value = null;
    }

    private LogMonad(T value) {
        this.value = value;
    }

    static &lt;T&gt; LogMonad&lt;T&gt; of(T value) {
        Objects.requireNonNull(value, "value is null");
        return new LogMonad&lt;&gt;(value);
    }

    &lt;U&gt; LogMonad&lt;U&gt; flatMap(Function&lt;T, LogMonad&lt;U&gt;&gt; function) {
        Objects.requireNonNull(function, "function is null");
        try {
            return function.apply(value);
        } catch (Throwable t) {
            return new LogMonad&lt;&gt;();
        }
    }

    LogMonad&lt;T&gt; log() {
        LOGGER.log(Level.INFO, "{0}", value);
        return this;
    }

    LogMonad&lt;T&gt; log(Level loggingLevel) {
        Objects.requireNonNull(loggingLevel, "logging level is null");
        LOGGER.log(loggingLevel, "{0}", value);
        return this;
    }
//equals, hashCode &amp; toString
}
</code></pre>
И вуаля, монада реализована. Опишем подробно, что именно я здесь сделал.<h3>Что именно здесь произошло</h3>Основой нашей реализации является параметризованный класс с неизменяемым полем с именем <span class="code">value</span>, который отвечает за хранение нашего значения. Второе поле — <span class="code">Logger</span>, будет отвечать за ключевой эффект нашей монады. Затем у нас есть частный конструктор, который делает невозможным создание объекта каким-либо другим способом, кроме как с помощью нашего метода надстройки. 

Далее у нас есть две основные функции монад, а именно <span class="code">of</span> (эквивалент <span class="code">unit</span>) и <span class="code">flatMap</span> (эквивалент <span class="code">bind</span>), которые гарантируют, что наша реализация выполняет требуемые условия в форме законов монад. Последние два метода отвечают за наш эффект монады, то есть они отвечают за запись текущего значения в стандартный вывод. Один из них позволяет пройти уровень логирования, другой использует уровень "INFO".

Теперь настало время для примера использования. Итак, вот он.

<pre class="language-java line-numbers"><code>
//imports
public final class LogMonad&lt;T&gt; {

    private final T value;

    private static final Logger LOGGER = 
      Logger.getLogger(LogMonad.class.getName());

    private LogMonad() {
        this.value = null;
    }

    private LogMonad(T value) {
        this.value = value;
    }

    static &lt;T&gt; LogMonad&lt;T&gt; of(T value) {
        Objects.requireNonNull(value, "value is null");
        return new LogMonad&lt;&gt;(value);
    }

    &lt;U&gt; LogMonad&lt;U&gt; flatMap(Function&lt;T, LogMonad&lt;U&gt;&gt; function) {
        Objects.requireNonNull(function, "function is null");
        try {
            return function.apply(value);
        } catch (Throwable t) {
            return new LogMonad&lt;&gt;();
        }
    }

    LogMonad&lt;T&gt; log() {
        LOGGER.log(Level.INFO, "{0}", value);
        return this;
    }

    LogMonad&lt;T&gt; log(Level loggingLevel) {
        Objects.requireNonNull(loggingLevel, "logging level is null");
        LOGGER.log(loggingLevel, "{0}", value);
        return this;
    }
//equals, hashCode &amp; toString
}
</code></pre>
В приведенном выше коде помимо того, что мы видим, как работают монады, мы также можем оценить несколько плюсов их использования.

Прежде всего, мы инкапсулируем наш побочный эффект логгирования в монадический контекст. Это обеспечил слой абстракции над нашей логикой. Благодаря этой абстракции мы смогли уменьшить количество шаблонов. Наш код стал более декларативным, более простым для чтения и понимания. Наконец, мы объединили все операции в единый конвейер.

С другой стороны, в немонадической части примера мы можем увидеть все детали реализации. Код менее дескриптивный и его можно использовать повторно. Более того, мы выявили побочный эффект, который может вызвать некоторые проблемы в будущем и сделали наш код менее читабельным. Если мы когда-нибудь решим обработать ошибку из-за вызова функции, нам понадобится много шаблонов.

На мой взгляд, монадический код легче читать и понимать, чем его немонадический аналог.<h3>Подводим итоги</h3>Монада — очень полезное понятие. Вероятно, многие из нас используют его в повседневной жизни. В этой статье я попытался дать простое объяснение его теоретической основы и логики, лежащей в основе понятия. Я внедрил <span class="code">LogMonad</span>, чтобы показать, что это супер сложно, и на самом деле его можно довольно легко реализовать. На примере я показал, как может выглядеть использование монады, каковы потенциальные преимущества такого действия и чем оно может отличаться от обычного вызова методов.