ArrayList в Java
<p>----------------------------------------</p>
При разработке часто бывает сложно предсказать, какого размера понадобятся массивы. Поэтому функция динамического выделения памяти во время работы программы необходима каждому языку программирования. Динамическим называется массив, размер которого может измениться...
<p>----------------------------------------</p>
При разработке часто бывает сложно предсказать, какого размера понадобятся массивы. Поэтому функция динамического выделения памяти во время работы программы необходима каждому языку программирования. Динамическим называется массив, размер которого может измениться во время исполнения программы. В Java для такой цели существует класс <strong>ArrayList</strong>.
<ul>
<li><a href="#Конструкторы_ArrayList">Конструкторы ArrayList</a></li>
<li><a href="#Методы_ArrayList">Методы ArrayList</a></li></ul><h2 id="Что_такое_класс_ArrayList">Что такое класс ArrayList?</h2>ArrayList — реализация изменяемого массива интерфейса List, часть Collection Framework, который отвечает за список (или динамический массив), расположенный в пакете java.utils. Этот класс реализует все необязательные операции со списком и предоставляет методы управления размером массива, который используется для хранения списка.

В основе ArrayList лежит идея динамического массива. А именно, возможность добавлять и удалять элементы, при этом будет увеличиваться или уменьшаться по мере необходимости.
<h2 id="Что_хранит_ArrayList">Что хранит ArrayList?</h2>Только ссылочные типы, любые объекты, включая сторонние классы. Строки, потоки вывода, другие коллекции. Для хранения примитивных типов данных используются классы-обертки.
<h2 id="Конструкторы_ArrayList">Конструкторы ArrayList</h2><ol>
<li><p id="ArrayList"><strong>ArrayList()</strong></p>
<p>Пустой конструктор с начальной емкостью внутреннего массива = 10.</p>
<pre class="lang-java line-numbers"><code>
ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
</code></pre>
<p>В угловых скобках желательно указать тип хранимых значений. В примере выше — <code>String</code>.</p></li>
<li><p id="ArrayList(Collection_<?_extends_E>_c)"><strong>ArrayList(Collection &lt;? extends E&gt; c)</strong></p>
<p>Конструктор принимает другую коллекцию, создавая новый массив с элементами переданной коллекции:</p>
<pre class="lang-java line-numbers"><code>
ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(list);
</code></pre>
<p>Порядок элементов в новом списке будет совпадать с исходным.</p></li>
<li><p id="ArrayList(int initialCapacity)"><strong>ArrayList(int initialCapacity)</strong></p>
<p>В качестве параметра конструктора выступает значения начального размера внутреннего массива.</p>
<pre class="lang-java line-numbers"><code>
ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(10000);
</code></pre>
<p>Если в массиве, который лежит в основе ArrayList, закончилось место при добавлении новых элементов, создается новый массив большего размера, и данные копируются в него. Если при написании кода заранее известно, что в массиве будет обрабатываться большое количество элементов, в целях оптимизации следует указать большее значение.</p></li>
</ol><h2 id="Методы_ArrayList">Методы ArrayList</h2><ul>
<p>Ниже представлены основные методы ArrayList.</p>
<li><p id="add(E_e)"><strong>add(E e)</strong></p>
<p>Добавляет новый элемент в конец списка. Возвращает <code>boolean</code>-значение (<em>true</em> — успех, <em>false</em> — не добавлено):</p>
<pre class="lang-java line-numbers"><code>
ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("Hello");
</code></pre></li>
<li><p id="add(int_index_E_element)"><strong>add(int index, E element)</strong></p>
<p>Добавляет элемент <code>element</code> в позицию index. При добавлении происходит сдвиг всех элементов справа от указанного индекса на 1 позицию вправо:</p>
<pre class="lang-java line-numbers"><code>
list.add(0, "Amigo");
</code></pre>
<p>Очень полезен, когда нужно вставить элемент в произвольное место списка, однако для частых операций вставки в начало и середину ArrayList может оказаться не очень удачным выбором — следует изучить LinkedList.</p></li>
<li><p id="addAll(Collection_<?_extends_E>_collection)"><strong>addAll(Collection &lt;? extends E&gt; collection)</strong></p>
<p>Добавление всех элементов коллекции collection в список в порядке их расположения в collection.</p></li>
<li><p id="addAll(int_index_Collection_<?_extends_E>_collection)"><strong>addAll(int index, Collection &lt;? extends E&gt; collection)</strong></p>
<p>Добавление всех элементов <code>collection</code> в список начиная с индекса <code>index</code>. При этом все элементы сдвинутся вправо на количество элементов в списке <code>collection</code>:</p>
<pre class="lang-java line-numbers"><code>
ArrayList&lt;String&gt; secondList = new ArrayList&lt;&gt;();
secondList.addAll(list);
System.out.println("Первое добавление: " + secondList);
secondList.addAll(1, list);
System.out.println("Второе добавление в середину: " + secondList);
</code></pre>
<p>Вывод:</p>
<pre><code>
Первое добавление: [Amigo, Hello]
Второе добавление в середину: [Amigo, Amigo, Hello, Hello]
</code></pre>
<p>Методы <code>addAll()</code> также возвращают boolean-результат добавления элементов.</p></li>
<li><p id="clear()"><strong>clear()</strong></p>
<p>Удаление всех элементов из списка.</p>
</li><li><strong>clone()</strong>
<p>Возвращает объект-копию массива:</p>
<pre class="lang-java line-numbers"><code>
ArrayList&lt;String&gt; copyOfSecondList = (ArrayList&lt;String&gt;) secondList.clone();
secondList.clear();
System.out.println(copyOfSecondList);
</code></pre>
<p>Вывод:</p>
<pre><code>
[Amigo, Amigo, Hello, Hello]
</code></pre>
<p>Следует обратить внимание, что метод <code>clone()</code> возвращает <code>Object</code>, так что после его вызова потребуется сделать приведение к необходимому классу.</p>
<p>При клонировании создается новый независимый объект. В примере показано, как очищение клонированного объекта не сказалось на составе его клона.</p></li>
<li><p id="contains(Object_o)"><strong>contains(Object o)</strong></p> 
<p>Проверка наличие объекта в списке, возвращает <code>boolean</code>-значение.</p>
<pre class="lang-java line-numbers"><code>
System.out.println(copyOfSecondList.contains("Hello"));
System.out.println(copyOfSecondList.contains("Check"));
</code></pre>
<p>Вывод:</p>
<pre><code>
true
false
</code></pre></li>
<li><p id="ensureCapacity(int minCapacity)"><strong>ensureCapacity(int minCapacity)</strong></p>
<p>Увеличивает размер внутреннего массива, чтобы в него поместилось количество элементов, переданных в <code>minCapacity</code>. Если массив достаточно вместителен, никакие преобразования не производятся.</p>
<p>Этот метод полезен, когда возникает потребность вместить большое количество элементов в несколько итераций. Например, при создании списка емкость его внутреннего массива — 10. При загрузке данных по сети они обрабатываются асинхронно порциями и результаты помещаются в массив. Если ожидается доставка 10 000 элементов, может быть неэффективно просто добавлять эти данные каждый раз: достаточно будет в начале обработки вызвать метод <code>ensureCapaciry(10000)</code> и записывать туда данные по мере необходимости.</p></li>
<li><p id="forEach(Consumer<?_super_E>_action)"><strong>forEach(Consumer&lt;? super E&gt; action)</strong></p>
<p>Обработать в цикле ArrayList можно стандартными способами, цикл for:</p>
<pre class="lang-java line-numbers"><code>
// Первый способ
for(int i = 0; i&lt; secondList.size(); i++) {
   System.out.println(secondList.get(i));
}
И цикл for-each:
// Второй способ
for(String s : secondList) {
   System.out.println(s);
}
</code></pre>
<p>В классе ArrayList есть метод для обработки каждого элемента, который называется также, forEach. В качестве аргумента передается реализация интерфейса Consumer, в котором нужно переопределить метод accept():</p>
<pre class="lang-java line-numbers"><code>
secondList.forEach(new Consumer&lt;String&gt;() {
   @Override
   public void accept(String s) {
       System.out.println(s);
   }
});
</code></pre>
<p>Вывод:</p>
<pre><code>
Amigo
Amigo
Hello
Hello
</code></pre>
<p>Метод accept принимает в качестве аргумента очередной элемент того типа, который хранит в себе ArrayList. Пример для Integer:</p>
<pre class="lang-java line-numbers"><code>
ArrayList&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();
integerList.forEach(new Consumer&lt;Integer&gt;() {
   @Override
   public void accept(Integer integer) {
       System.out.println(integer);
   }
});
</code></pre>
<p>Метод <code>action()</code> будет выполнен для каждого элемента.</p></li>
<li><p id="get(int_index)"><strong>get(int index)</strong></p>
<p>Возвращает элемент, который расположен в указанной позиции списка.</p>
<p>Если <code>index &lt; 0</code> или <code>index &gt;=</code> максимального количества элементов списка, будет выброшено исключение <code>IndexOutOfBoundsException</code>.</p>
<p>Это основной метод получения элемента из списка, время извлечения элемента по индексу всегда будет одинаковым, независимо от размера ArrayList.</p></li>
<li><p id="indexOf(Object_o)"><strong>indexOf(Object o)</strong></p>
<p>Метод возвращает индекс первого вхождения элемента в списке. Если элемента не существует в списке, метод вернет -1.</p></li>
<li><p id="isEmpty()"><strong>isEmpty()</strong></p>
<p>Метод возвращает <em>true</em>, если список пустой, <em>false</em> в обратном случае.</p>
<p>Если в списке содержатся только элементы <code>null</code>, метод вернет <em>false</em>. Иными словами, <code>null</code> элементы также учитываются этим методом.</p></li>
<li><p id="iterator()"><strong>iterator()</strong></p>
<p>Возвращает итератор для списка для последующего использования в цикле или при любой другой обработке.</p>
<p>Итератор для ArrayList — fail-fast. Это значит, что если коллекция изменится во время итерации, будет выброшено исключение ConcurrentModificationException. Подробнее об fail-fast и его противоположности fail-safe можно почитать <a href="https://javarush.com/groups/posts/399-skaz-o-dvukh-iteratorakh-strategii-konkurentnoy-modifikacii-v-java-" target="_blank">здесь</a>.</p></li>
<li><p id="lastIndexOf(Object_o)"><strong>lastIndexOf(Object o)</strong></p>
<p>Функционал метода похож на <code>indexOf()</code>, отличие в том, что возвращается индекс последнего элемента в списке.</p>
<p>Если элемент не найден, также возвращает -1.</p></li>
<li><p id="remove(int_index)"><strong>remove(int index)</strong></p>
<p>Удаление элемента в указанной позиции индекса. После удаления сдвигает все элементы влево для заполнения освободившегося пространства.</p>
<p>Если <code>index&lt;0</code> или <code>&gt;=</code> количество элементов списка, будет выброшено исключение <code>IndexOutOfBoundsException</code>. В результате метод возвращает элемент, который был удален.</p></li>
<li><p id="remove(Object_o)"><strong>remove(Object o)</strong></p>
<p>Метод удаляет из списка переданный элемент <code>o</code>. Если элемент присутствует в списке, он удаляется, а все элементы смещаются влево. Если элемент существует в списке и успешно удален, метод возвращает true, в обратном случае — <em>false</em>.</p></li>
<li><p id="removeAll(Collection<?>_c)"><strong>removeAll(Collection&lt;?&gt; c)</strong></p>
<p>Если необходимо удалить несколько элементов, не стоит делать это в цикле по условию: гораздо удобнее и безопаснее воспользоваться методом <code>removeAll()</code>. Он принимает коллекцию элементов, которая будет удалена из списка.</p>
<p>Коллекция должна содержать элементы того же типа, которые хранит целевой список. В обратном случае будет выброшен <code>ClassCastException</code>. Метод вернет <em>true</em>, если список был изменен в результате вызова метода.</p></li>
<li><p id="set(int_index_E_element)"><strong>set(int index, E element)</strong></p>
<p>Замена элемента в указанной позиции <code>index</code> на переданный <code>element</code>. Индекс также должен быть больше нуля и меньше индекса последнего элемента, иначе будет выброшено исключение <code>IndexOutOfBoundsException</code>.</p></li>
<li><p id="size()"><strong>size()</strong></p>
<p>Лучший способ (практически единственный) для того, чтобы узнать размер массива.</p></li>
<li><p id="sort(Comparator<?_super_E>_c)"><strong>sort(Comparator&lt;? super E&gt; c)</strong></p>
<p>Сортировка списка по заданному правилу. Правило сортировки представляет собой реализованный интерфейс <code>Comparator</code> с переопределенным методом <code>compareTo()</code>.</p> 
<p>Переопределение нужно, если коллекция содержит объекты собственного класса. При работе со стандартными классами (<code>Integer</code>, <code>String</code> и так далее) переопределение <code>compareTo()</code> требуется только для нестандартной сортировки.</p></li>
<li><p id="toArray()"><strong>toArray()</strong></p>
<p>Превращает список в фиксированный массив. Обратите внимание, что метод возвращает массив объектов (<code>Object[]</code>). Если необходимо привести список в массив объектов определенного типа, в качестве параметра в метод можно передать массив, куда будут перемещены элементы списков.</p>Пример:<p></p>
<pre class="lang-java line-numbers"><code>
String[] array = new String[secondList.size()];
secondList.toArray(array);
for(int i = 0; i&lt; array.length; i++) {
   System.out.println(array[i]);
}
</code></pre>
<p>Вывод:</p>
<pre><code>
Amigo
Amigo
Hello
Hello
</code></pre></li>
</ul>
Методы ArrayList в Java изучаются на курсе JavaRush. Первое знакомство происходит на седьмом уровне квеста Java Syntax, на <a href="https://javarush.com/quests/lectures/questsyntax.level07.lecture05" target="_blank">лекции “Класс ArrayList”</a>. На этом же уровне есть подборки задач — <a href="https://javarush.com/quests/lectures/questsyntax.level07.lecture06" target="_blank">раз</a> и <a href="https://javarush.com/quests/lectures/questsyntax.level07.lecture09" target="_blank">два</a>, в которых нужно использовать методы ArrayList, приведены дополнительные примеры работы с ArrayList и дженериками, а также объясняется разница между ArrayList и LinkedList.

Это обширная тема изучения, поэтому в том или ином виде к Arraylist в Java (методы этого класса — лишь часть всего массива знаний, в который стоит углубиться) на курсе возвращаются и на следующих уровнях обучения — Core, Collections, Multithreading.

Мы верим, что ежедневная практика написания кода — главный ключ к успеху в программировании. Поэтому JavaRush на 80% состоит из практических задач, мини проектов, задач-игр. Все это — сотни часов кодинга, которые помогут прокачать скилл. 
<h2>Ссылки на дополнительное чтение</h2><ol>
<li>Подробная <a href="https://javarush.com/groups/posts/dinamicheskie-massivy-java" target="_blank">статья о динамических массивах</a>, а точнее — об <code>ArrayList</code> и <code>LinkedList</code>, которые выполняют их роль в языке Java.</li>
<li>Статья об <a href="https://javarush.com/groups/posts/1935-udalenie-ehlementa-iz-spiska-arraylist" target="_blank">удалении элементов из списка ArrayList</a>.</li>
<li>Лекция <a href="https://javarush.com/groups/posts/1936-rabota-arraylist-v-kartinkakh--" target="_blank">о работе с ArrayList в схемах и картинках</a>.</li>
</ol>