Как работает HashMap в Java
<p>----------------------------------------</p>
Большинство из вас согласятся, что HashMap, на сегодняшний день, является самой любимой темой для дискуссий на собеседованиях. Иногда я проводил подобные дискуссии со своими коллегами и это действительно помогло. Теперь я проведу такую дискуссию с вами ...
<p>----------------------------------------</p>
Большинство из вас согласятся, что <code>HashMap</code>, на сегодняшний день, является самой любимой темой для дискуссий на собеседованиях. Иногда я проводил подобные дискуссии со своими коллегами и это действительно помогло. Теперь я проведу такую дискуссию с вами.
<img data-id="fd0e58f2-905f-4d30-b25b-c9104da64031" data-max-width="850" alt="Как работает HashMap в Java - 1" src="https://cdn.javarush.com/images/article/fd0e58f2-905f-4d30-b25b-c9104da64031/1024.jpeg">Я полагаю, что если вы интересуетесь внутренним устройством и работой HashMap, то вы уже знакомы с основами <a href="https://javarush.com/groups/posts/1940-klass-hashmap-" target="_blank">HashMap</a>, поэтому я пропущу эту часть. Но если вы новичок в этом деле, советую вам проследовать на сайт <a href="https://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html" rel="nofollow">Java Docs</a>.

Прежде чем мы двинемся дальше, я настоятельно рекомендую вам ознакомится с моей предыдущей статьей: Работа с hashCode и методом equals в Java.

<strong>Содержание данной статьи:</strong><ol>
    <li>Единственный возможный ответ.</li>
    <li>Что такое Хеширование.</li>
    <li>Немного о классе <code>Entry</code>.</li> 
    <li>Что делает метод <code>put()</code>.</li>
    <li>Как работает метод <code>get()</code>.</li>
    <li>Примечания</li>
</ol><h2>Единственный возможный ответ</h2>Если кто-нибудь попросит меня объяснить «<em>Как работает HashMap?</em>», я просто отвечу: «<em>По принципам Хеширования</em>». Проще некуда. Чтобы понять это и получить расширенный ответ, надо быть уверенным, что вы знаете основы Хеширования. Правильно? 
<h2>Что такое Хеширование</h2>Хеширование в простейшем представлении, это – способ преобразования любой переменной/объекта в уникальный код после применения любой формулы/алгоритма к их свойствам. Настоящая функция хеширования, должна следовать следующему правилу: 

Хеш-функция должна возвращать одинаковый хеш-код всякий раз, когда она применена к одинаковым или равным объектам. Другими словами, два одинаковых объекта должны возвращать одинаковые хеш-коды по очереди.
<table>
<tbody><tr>
<td>Примечание: Все объекты в java наследуют стандартную реализацию <code>hashCode()</code> функции, описанной в классе <code>Object</code>. Эта функция возвращает хеш-код полученный путем конвертации внутреннего адреса объекта в число, что ведет к созданию уникального кода для каждого отдельного объекта.
</td>
</tr>
</tbody></table>Больше об этом вы можете прочитать здесь: <a href="https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/" rel="nofollow">Работа с hashCode и методом equals в Java</a> 
<h2>Немного о классе Entry</h2>Карта(map) по определению, это – «Объект хранящий попарно значения(values) и ключи(keys)». Довольно просто, да?

Значит, в HashMap должен быть какой-то механизм хранящий пары Значений и Ключей? Ответ – Да. <code>HashMap</code> имеет внутренний класс <code>Entry</code>, который выглядит так: 

<pre class="lang-java line-numbers"><code>
static class Entry implements Map.Entry
{
        final K key;
        V value;
        Entry next;
        final int hash;
        ...//остальной код тут…
}
</code></pre>Естественно класс <code>Entry</code> имеет Ключ и Значение хранящиеся, как атрибуты. Ключ помечен как <code>final</code> и еще мы видим два дополнительных поля: <code>next</code> и <code>hash</code>. Мы постараемся понять назначение этих полей по ходу статьи.
<h2>Что делает Java метод put()</h2>Прежде чем мы углубимся в реализацию метода <code>put()</code>, очень важно понять, что экземпляры класса <code>Entry</code> хранятся в массиве. Класс HashMap определяет эту переменную как:

<pre class="lang-java line-numbers"><code>
/**
* Размер таблицы, изменяется при необходимости. Длина всегда должна быть 
* кратна двум!
*/
    transient Entry[] table;
</code></pre>
Теперь взгляните на код реализации метода <code>put()</code>:

<pre class="lang-java line-numbers"><code>
/**
* Связывает определенное значение с определенным ключом в этой карте(map). 
* Если карта перед этим содержала значение для данного ключа, это значение 
* заменится на новое.  
*
* @param key
*            ключ с которым указанное значение должно быть связано.
* @param value
*            значение которое должно быть связано с ключом.
* @return вернет предыдущее значение связанное с key, или null
*         если не было значений связанных с key. (Вернет null 
*         так же, если перед этим key был связан со значением null)
*/
public V put(K key, V value) {
if (key == null)
return putForNullKey(value);
int hash = hash(key.hashCode());
int i = indexFor(hash, table.length);
for (Entry&lt;k , V&gt; e = table[i]; e != null; e = e.next) {
Object k;
if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
V oldValue = e.value;
e.value = value;
e.recordAccess(this);
return oldValue;
}
}
 
modCount++;
addEntry(hash, key, value, i);
return null;
}
</code></pre>
Давайте разберемся с этим шаг за шагом:
<ul>
<li>Первым делом, проверяем существует ли ключ. Если ключ не существует (<code>null</code>), значение помещается в таблицу на нулевую позицию, потому что хеш-код для значения <code>null</code>, <code>это – всегда 0</code>.</li><br>
<li>На следующем шаге, рассчитывается хеш-значение используя хеш-код ключа, получаемый вызовом метода <code>hashCode()</code>. Это хеш-значение используется для вычисления позиции в массиве, куда будет помещен объект <code>Entry</code>. Дизайнеры <u>JDK</u> предполагали, что плохо написанная функция <code>hashCode()</code> может вернуть слишком высокое или слишком низкое значение хеш-кода. Для решения этой проблемы, они ввели другую <code>hash()</code> функцию, и передали в нее значение хеш-кода объекта, чтобы привести хеш-значение в соответствие с размером массива.</li><br>
<li>Теперь вызывается функция <code>indexFor(hash, table.length)</code>, для вычисления точной позиции, куда будет помещен объект <code>Entry</code>.</li><br>
<li>Здесь начинается главная часть. Теперь, исходя из того, что нам известно, что – два не равных объекта могут иметь равные значения хеш-кодов, зададим вопрос: Будут ли два разных объекта помещаться в одинаковую позицию в массиве [корзина]?Ответом является <code>LinkedList</code>. Если вы помните, класс <code>Entry</code> имеет атрибут «<code>next</code>». Этот атрибут всегда указывает на следующий объект в цепи. Это в точности соответствует поведению <code>LinkedList</code>.</li>
</ul>Итак, объекты <code>Entry</code> хранятся в форме <code>LinkedList</code>. Когда объект <code>Entry</code> должен быть помещен в определенное место, HashMap проверяет нет ли уже в этом месте записи. Если записи нету, то объект помещается в данную позицию. 

Если все же в данной позиции уже есть объект, проверяется следующий атрибут. Если он возвращает <code>null</code> и текущий объект <code>Entry</code> становится следующим звеном в <code>LinkedList</code>. Если следующая переменная не <code>null</code>, процедура повторяется для следующей, пока не найдет <code>null</code>.

Что если мы поместим другой объект с другим значением но с тем же ключом, что был ранее? Логически это должно привести к замене старого значения. Как это происходит? В общем, после определения позиции объекта <code>Entry</code>, во время прохода по <code>LinkedList</code> до расчетной позиции, <code>HashMap</code>вызывает метод сравнения ключа для каждого объекта <code>Entry</code>. Все эти <code>Entry</code> объекты в <code>LinkedList</code> могут иметь аналогичные хеш-коды, но метод <code>equals()</code>проверит их на истинное сходство. Это приведет к замене значения только внутри объекта <code>Entry</code>.

Таким образом HashMapгарантирует уникальность всех ключей.
<h2>Как работает Java метод get()</h2>Теперь мы имеем представление, о том, как пары ключ-значение хранятся в <code>HashMap</code>. Следующим большим вопросом будет: Что происходит, когда объект передается из HashMap в метод <code>get()</code>? Как определяется значение объекта?

Ответ мы уже должны знать, потому что способ которым определяется уникальность ключа в методе <code>put()</code> имеет ту же логику, которую применяет метод <code>get()</code>. Как только <code>HashMap</code> определяет ключ объекта переданного в аргументе, он просто возвращает значение соответствующего объекта <code>Entry</code>.

Если же совпадений не найдено, метод <code>get()</code> вернет <code>null</code>.

Давайте взглянем на код:

<pre class="lang-java line-numbers"><code>
public V get(Object key) {
if (key == null)
return getForNullKey();
int hash = hash(key.hashCode());
for (Entry&lt;k,V&gt;e=table[indexFor(hash,table.length)];e!=null;e=e.next){
Object k;
if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
return e.value;
}
return null;
}
</code></pre>
Код выше подобен методу <code>put()</code> до этого места <code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>, После этого просто возвращает значение объекта.
<h2>Примечания</h2><ul>
    <li>Структура данных для хранения в объекте <code>Entry</code> это массив с именем <code>table</code>и типом <code>Entry</code>.</li>
    <li>Каждая индивидуальная позиция в массиве называется корзина, потому что она может содержать первый элемент <code>LinkedList</code>объектов <code>Entry</code>.</li>
    <li><code>hashCode()</code>Ключа требуется для вычисления позиции объекта <code>Entry</code>.</li>
    <li><code>equals()</code>Ключа используется для проверки уникальности ключа в карте(<code>map</code>).</li>
    <li><code>hashCode()</code>и <code>equals()</code>Значения не используется в методах <code>get()</code>и <code>set()</code>в <code>HashMap</code>.</li>
    <li>Хеш-код для ключей со значением <code>null</code>это всегда 0. И такой объект <code>Entry</code>всегда будет храниться в нулевой позиции массива.</li>
  </ul>Я надеюсь, что корректно передал свои мысли в этой статье. Если вы нашли ошибки или у вас имеются вопросы, пожалуйста оставляйте их в комментариях.

<strong><em>Счастливого обучения!</em></strong>