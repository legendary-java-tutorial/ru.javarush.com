Обёртки, распаковка и запаковка
<p>----------------------------------------</p>
Привет! Ты уже неплохо знаком с примитивными типами, и немало с ними поработал. У примитивов в программировании, и в Java в частности, есть множество преимуществ: они занимают мало памяти, и за счет этого повышается эффективность работы программы ...
<p>----------------------------------------</p>
Привет!

Ты уже неплохо знаком с примитивными типами, и немало с ними поработал.

<img data-id="13450a6c-b249-4fc0-a6f7-b5591ebec0e0" data-max-width="850" alt="Обёртки, распаковка и запаковка - 1" src="https://cdn.javarush.com/images/article/13450a6c-b249-4fc0-a6f7-b5591ebec0e0/1024.jpeg">У примитивов в программировании, и в Java в частности, есть множество преимуществ: они занимают мало памяти, за счет чего повышается эффективность работы программы, и четко разделены по диапазонам значений.

Однако в процессе изучения Java мы уже не раз, словно мантру, повторяли — “<strong>в Java все является объектом</strong>”.

А ведь примитивы — прямое опровержение этих слов. Объектами они не являются. Получается, принцип “все является объектом” является ложным?

На самом деле нет.

В Java у каждого примитивного типа есть свой брат-близнец — <strong>класс-обертка</strong> (<strong><code>Wrapper</code></strong>).

Что такое обертка?

<strong>Обертка — это специальный класс, который хранит внутри себя значение примитива.</strong> 

Но поскольку это именно класс, он может создавать свои экземпляры. Они будут хранить внутри нужные значения примитивов, при этом будут являться настоящими объектами.

Названия классов-оберток очень похожи на названия соответствующих примитивов, или полностью с ними совпадают. Поэтому запомнить их будет очень легко.

<table style="text-align:center" class="table table--striped">
<thead>
<tr>
<th colspan="2">Wrapper Classes for Primitive Data Types 
</th>
</tr>
</thead>
<tbody>
<tr class="table__sub-head">
<td><span class="text-red">Primitive Data Types</span>
</td>
<td><span class="text-red">Wrapper Classes</span>
</td>
</tr>
<tr>
<td>int
</td>
<td>Integer
</td>
</tr>
<tr>
<td>short
</td>
<td>Short
</td>
</tr>
<tr>
<td>long
</td>
<td>Long
</td>
</tr>
<tr>
<td>byte
</td>
<td>Byte
</td>
</tr>
<tr>
<td>float
</td>
<td>Float
</td>
</tr>
<tr>
<td>double
</td>
<td>Double
</td>
</tr>
<tr>
<td>char
</td>
<td>Character
</td>
</tr>
<tr>
<td>boolean
</td>
<td>Boolean
</td>
</tr>
</tbody>
</table>
Объекты классов оберток создаются так же, как и любые другие:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   Integer i = new Integer(682);
  
   Double d = new Double(2.33);
  
   Boolean b = new Boolean(false);
}
</code></pre>
Классы-обертки позволяют нивелировать недостатки, которые есть у примитивных типов.

Самый очевидный из них — <strong>примитивы не имеют методов</strong>.

Например, у них нет метода <strong><code>toString()</code></strong>, поэтому ты не сможешь, например, преобразовать число <code>int</code> в строку.

А вот с классом-оберткой <code>Integer</code> — запросто.

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   Integer i = new Integer(432);
  
   String s = i.toString();
}
</code></pre>
Возникнут сложности и с обратным преобразованием.

Допустим, у нас есть строка, про которую мы точно знаем, что она содержит число.

Тем не менее, в случае с примитивным типом <strong><code>int</code></strong> мы никак не сможем это число из строки достать и превратить, собственно, в число.

Но благодаря классам-оберткам такая возможность у нас появилась.

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   String s = "1166628";

   Integer i = Integer.parseInt(s);

   System.out.println(i);
}
</code></pre>
<strong>Вывод:

<em>1166628</em></strong>

Мы успешно получили число из строки и присвоили его в переменную-ссылку <code>Integer i</code>.

Кстати, по поводу ссылок.

Ты уже знаешь, что параметры передаются в методы по-разному: примитивы — по значению, а объекты — по ссылке.

Ты можешь использовать это знание при создании своих методов: если твой метод работает, например, с дробными числами, но тебе нужна логика именно передачи по ссылке, ты можешь передать в метод параметры <code>Double/Float</code> вместо <code>double/float</code>.

Кроме того, помимо методов в классах-обертках есть очень удобные для использования статические поля.

Например, представь, что перед тобой сейчас стоит задача: <em>вывести в консоль максимально возможное число</em> <code>int</code><em>, а после — минимально возможное.</em> 

Задачка вроде элементарная, а все равно — без гугла вряд ли справишься.

А классы-обертки легко позволяют решать такие “бытовые задачи”:

<pre class="lang-java line-numbers"><code>
public class Main {
   public static void main(String[] args) {

       System.out.println(Integer.MAX_VALUE);
       System.out.println(Integer.MIN_VALUE);
   }
}
</code></pre>
Такие поля позволяют не отвлекаться от выполнения более серьезных задач.
Не говоря уж о том, что в процессе печати числа <em>2147483647</em> (это как раз MAX_VALUE) не мудрено и опечататься:)

Кроме того, в одной из прошлых лекций мы уже обращали внимание на то, что <strong>объекты классов-оберток являются неизменяемыми (Immutable)</strong>.

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   Integer a = new Integer(0);
   Integer b = new Integer(0);

   b = a;
   a = 1;
   System.out.println(b);
}
</code></pre>
<strong>Вывод:

<em>0</em></strong>

Объект, на который изначально указывала ссылка <strong><code>а</code></strong>, не изменил свое состояние, иначе значение <code>b</code> тоже изменилось бы.

Как и в случае со <code>String</code>, вместо изменения состояния объекта-обертки в памяти создается абсолютно новый объект.

Почему же создатели Java, в конечном итоге, приняли решение оставить в языке примитивные типы?

Раз уж все должно являться объектом, и у нас уже есть классы-обертки, которыми можно выразить все, что выражают примитивы, почему вообще не оставить в языке только их, а примитивы удалить?

Ответ прост — производительность.

Примитивные типы потому и называют примитивными, потому что они лишены многих “тяжеловесных” особенностей объектов. Да, у объекта есть много удобных методов, но ведь они не всегда тебе нужны.

Иногда тебе нужно просто число 33, или 2,62, или значение <code>true</code>/<code>false</code>. В ситуациях, когда все преимущества объектов не имеют значения и не нужны для работы программы, примитивы справятся с задачей гораздо лучше.

<h2>Автоупаковка/автораспаковка</h2>Одной из особенностей примитивов и их классов-оберток в Java является автоупаковка/автораспаковка (Autoboxing/Autounboxing)

<img data-id="4f7d6271-9473-4cb8-baf5-5130250065b4" data-max-width="850" alt="Обёртки, распаковка и запаковка - 2" src="https://cdn.javarush.com/images/article/4f7d6271-9473-4cb8-baf5-5130250065b4/1024.jpeg">
Давай разберемся с этим понятием.

Как мы с тобой уже узнали ранее, Java — объектно-ориентированный язык. Это значит, что все программы, написанные на Java, состоят из объектов.

Примитивы не являются объектами.

Но при этом переменной класса-обертки можно присваивать значение примитивного типа. Этот процесс называется <strong>автоупаковкой</strong> (<strong>autoboxing</strong>).

Точно так же переменной примитивного типа можно присваивать объект класса-обертки. <strong>Этот процесс называется автораспаковкой (autounboxing)</strong>.

Например:

<pre class="lang-java line-numbers"><code>
public class Main {
   public static void main(String[] args) {
       int x = 7;
       Integer y = 111;
       x = y; // автораспаковка
       y = x * 123; // автоупаковка
   }
}
</code></pre>
В строке 5 мы присваиваем примитиву x значение y, который является объектом класса-обертки <code>Integer</code>.

Как видишь, никаких дополнительных действий для этого не нужно:<strong> компилятор знает что <code>int</code> и <code>Integer</code>, по сути, одно и то же</strong>. Это и есть автораспаковка.

Так же происходит и автоупаковка в строке 6: объекту y легко присваивается значение примитивов (х*123). Это пример автоупаковки.

Именно поэтому добавляется слово "авто": <strong>для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически</strong>.

Удобно, да? :)

Еще одно очень большое удобство автоупаковки/автораспаковки проявляется в работе методов.

Дело в том, что <strong>параметры методов тоже подлежат автоупаковке и автораспаковке</strong>.

И, например, если какой-то из них принимает на вход два объекта <code>Integer</code> — мы легко можем передать туда обычные примитивы <code>int</code>!

<pre class="lang-java line-numbers"><code>
public class Main {
   public static void main(String[] args) {

       printNumber(7);//обычный int, даже без переменной
   }

   public static void printNumber(Integer i) {
       System.out.println("Вы ввели число " + i);
   }
}
</code></pre>
<strong>Вывод:

<em>Вы ввели число 7</em></strong>

Точно так же работает и наоборот:

<pre class="lang-java line-numbers"><code>
public class Main {
   public static void main(String[] args) {

       printNumber(new Integer(632));
   }

   public static void printNumber(int i) {
       System.out.println("Вы ввели число " + i);
   }
}
</code></pre>
Важный момент, о котором нужно помнить: <strong>автоупаковка и распаковка не работают для массивов</strong>!

<pre class="lang-java line-numbers"><code>
public class Main {
   public static void main(String[] args) {

       int[] i = {1,2,3,4,5};
      
       printArray(i);//ошибка, не компилируется!
   }
  
   public static void printArray(Integer[] arr) {
       System.out.println(Arrays.toString(arr));
   }
}
</code></pre>
Попытка передать массив примитивов в метод, который принимает на вход массив объектов, вызовет ошибку компиляции.

Напоследок, еще раз кратко сравним примитивы и обертки

<strong>Примитивы:</strong>
<ul>
<li>имеют преимущество в производительности</li></ul>
<strong>Обертки:</strong>
<ul>
<li>Позволяют не нарушать принцип “все является объектом”, благодаря чему числа, символы и булевы значения true/false не выпадают из этой концепции</li>
<li>Расширяют возможности работы с этими значениями, предоставляя удобные методы и поля</li>
<li>Необходимы, когда какой-то метод может работать исключительно с объектами</li>
</ul>