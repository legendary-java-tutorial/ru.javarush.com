Устройство вещественных чисел
<p>----------------------------------------</p>
В сегодняшней лекции расскажем о числах в Java, а конкретно — о вещественных числах. Без паники! :) Никаких математических сложностей в лекции не будет. Будем говорить о вещественных числах исключительно с нашей, «программистской» точки зрения ...
<p>----------------------------------------</p>
Привет!

В сегодняшней лекции расскажем о числах в Java, а конкретно — о вещественных числах.

<img data-id="bad6cab4-00e1-45c6-9c10-8c65b13687e8" data-max-width="850" alt="Устройство вещественных чисел - 1" src="https://cdn.javarush.com/images/article/bad6cab4-00e1-45c6-9c10-8c65b13687e8/1024.jpeg">Без паники! :) Никаких математических сложностей в лекции не будет. Будем говорить о вещественных числах исключительно с нашей, «программистской» точки зрения.

Итак, что же такое «вещественные числа»?

<span class="text-bold">Вещественные числа</span> — это числа, у которых есть дробная часть (она может быть нулевой). Они могут быть положительными или отрицательными.  

Вот несколько примеров:

<span class="text-bold">15
56.22
0.0
1242342343445246
-232336.11</span>

Как же устроено вещественное число?

Достаточно просто: оно состоит из целой части, дробной части и знака. У положительных чисел знак обычно не указывают явно, а у отрицательных указывают.

Ранее мы <a href="https://javarush.com/groups/posts/1924-operacii-nad-chislami-v-java" target="_blank">подробно разобрали</a>, какие операции над числами можно совершать в Java. Среди них было много стандартных математических операций — сложение, вычитание и т. д. Было и кое-что новое для тебя: например, остаток от деления.

Но как именно устроена работа с числами внутри компьютера? В каком виде они хранятся в памяти?
<h2>Хранение вещественных чисел в памяти</h2>Думаю, для тебя не станет открытием, что числа бывают большими и маленькими :) Их можно сравнивать друг с другом. Например, число 100 меньше числа 423324. Влияет ли это на работу компьютера и нашей программы? На самом деле — <span class="text-bold">да</span>.

Каждое число представлено в Java определенным <span class="text-bold">диапазоном значений</span>:
<table>
<tbody><tr><th>Тип</th><th>Размер в памяти (бит)</th><th>Диапазон значений</th></tr>
<tr><td><code>byte</code></td><td>8 бит</td><td>от -128 до 127</td></tr>
<tr><td><code>short</code></td><td>16 бит</td><td>от -32768 до 32767</td></tr>
<tr><td><code>char</code></td><td>16 бит</td><td>беззнаковое целое число, которое преставляет собой символ UTF-16 (буквы и цифры)</td></tr>
<tr><td><code>int</code></td><td>32 бита</td><td>от -2147483648 до 2147483647</td></tr>
<tr><td><code>long</code></td><td>64 бита</td><td>от -9223372036854775808 до 9223372036854775807</td></tr>
<tr><td><code>float</code></td><td>32 бита</td><td>от 2<sup>-149</sup> до (2-2<sup>-23</sup>)*2<sup>127</sup></td></tr>
<tr><td><code>double</code></td><td>64 бита</td><td>от 2<sup>-1074</sup> до (2-2<sup>-52</sup>)*2<sup>1023</sup></td></tr>
</tbody></table>Сегодня поговорим именно о последних двух типах — <code><span class="text-bold">float</span></code> и <code><span class="text-bold">double</span></code>. Оба выполняют одну и ту же задачу — представляют дробные числа.

Их еще очень часто называют «<span class="text-bold">числа с плавающей точкой»</span>. Запомни этот термин на будущее :)

Например, число 2.3333 или 134.1212121212.

Довольно странно. Ведь получается, нет никакой разницы между этими двумя типами, раз они выполняют одну и ту же задачу? Но разница есть. Обрати внимание на столбец «размер в памяти» в таблице выше.

Все числа (да и не только числа — вообще вся информация) хранится в памяти компьютера в виде битов. Бит — это самая маленькая единица измерения информации. Она довольно проста. Любой бит равен или 0, или 1. Да и само слово «<span class="text-bold">bit</span>» происходит от английского «<span class="text-bold">binary digit</span>» — двоичное число.

Думаю, ты наверняка слышал о существовании двоичной системы счисления в математике. Любое привычное нам десятичное число можно представить в виде набора единиц и нулей.

Например, число 584.32 в двоичной системе будет выглядеть так: <span class="text-bold">100100100001010001111</span>.

Каждые единица и ноль в этом числе являются отдельным битом. Теперь тебе должна быть более понятна разница между типами данных. Например, если мы создаем число типа <code>float</code>, в нашем распоряжении есть всего 32 бита. При создании числа <code>float</code> именно столько места будет выделено для него в памяти компьютера.

Если же мы хотим создать число 123456789.65656565656565, в двоичном виде оно будет выглядеть так:

<span class="text-bold">11101011011110011010001010110101000000</span>.

Оно состоит из 38 единиц и нулей, то есть для его хранения в памяти нужно 38 бит.

В тип <code>float</code> это число просто не «влезет»! Поэтому число 123456789 можно представить в виде типа <code>double</code>. Для его хранения выделяется целых 64 бита: это нам подходит! Разумеется, и диапазон значений тоже будет подходящим.

Для удобства ты можешь представлять число как маленький ящик с ячейками. Если ячеек хватает для хранения каждого бита, значит, тип данных выбран правильно :)
<img data-id="27b62ec0-7eec-46eb-bebd-1a5369f3fd10" data-max-width="850" alt="Устройство вещественных чисел - 2" src="https://cdn.javarush.com/images/article/27b62ec0-7eec-46eb-bebd-1a5369f3fd10/1024.jpeg">Разумеется, разное количество выделяемой памяти влияет и на само число.

Обрати внимание, что у типов <code>float</code> и <code>double</code> отличается диапазон значений.

Что это означает на практике? Число <code>double</code> может выразить большую точность, чем число <code>float</code>.

У 32-битных чисел с плавающей точкой (в Java это как раз тип <code>float</code>) точность составляет примерно 24 бита, то есть около 7 знаков после запятой. 

А у 64-битных чисел (в Java это тип <code>double</code>) — точность примерно 53 бита, то есть примерно 16 знаков после запятой.

Вот пример, который хорошо демонстрирует эту разницу:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args)  {

       float f = 0.0f;
       for (int i=1; i &lt;= 7; i++) {
           f += 0.1111111111111111;
       }

       System.out.println(f);
   }
}
</code></pre>
Что мы должны получить здесь в качестве результата? Казалось бы, все довольно просто.

У нас есть число 0.0, и мы 7 раз подряд прибавляем к нему 0.1111111111111111. В итоге должно получиться 0.7777777777777777.

Но мы создали число <code>float</code>. Его размер ограничен 32 битами и, как мы сказали ранее, он способен отобразить число примерно до 7 знака после запятой. Поэтому в итоге результат, который мы получим в консоли, будет отличаться от того, что мы ожидали:

<pre><code>
0.7777778
</code></pre>
Число как будто было «обрезано». Ты уже знаешь как хранятся данные в памяти — в виде битов, поэтому тебя не должно это удивлять. Понятно, почему это произошло: результат 0.7777777777777777 просто не влез в выделенные нам 32 бита, поэтому и был обрезан так, чтобы поместиться в переменную типа <code>float</code> :)

Мы можем изменить тип переменной на <code>double</code> в нашем примере, и тогда итоговый результат не будет обрезан:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args)  {

       double f = 0.0;
       for (int i=1; i &lt;= 7; i++) {
           f += 0.1111111111111111;
       }

       System.out.println(f);
   }
}
</code></pre>
<pre><code>
0.7777777777777779
</code></pre>
Здесь уже 16 знаков после запятой, результат «уместился» в 64 бита. Кстати, возможно ты заметил, что в обоих случаях результаты получились не совсем корректными? Подсчет был произведен с небольшими ошибками.

О причинах этого мы поговорим ниже :)

Теперь скажем пару слов о том, как можно сравнить числа между собой.
<h2>Сравнение вещественных чисел</h2>Мы частично уже затрагивали этот вопрос в прошлой лекции, когда говорили об операциях сравнения. Такие операции как <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> повторно разбирать мы не будем.

Вместо этого рассмотрим более интересный пример:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args)  {

       double f = 0.0;
       for (int i=1; i &lt;= 10; i++) {
           f += 0.1;
       }

       System.out.println(f);
   }
}
</code></pre>
Как ты думаешь, какое число будет выведено на экран? Логичным ответом был бы ответ: число 1. Мы начинаем отсчет с числа 0.0 и последовательно прибавляем к нему 0.1 десять раз подряд. Вроде все правильно, должна получиться единица.

Попробуй запустить этот код, и ответ сильно тебя удивит :)

Вывод в консоль:

<pre><code>
0.9999999999999999
</code></pre>
Но почему в таком простом примере возникла ошибка? О_о

Тут бы даже пятиклассник с легкостью верно ответил, но программа на Java выдала неточный результат.

«Неточный» тут более подходящее слово, чем «неправильный». Мы все-таки получили очень близкое к единице число, а не просто какое-то рандомное значение :)
Оно отличается от правильного буквально на миллиметр. Но почему?

Возможно, это просто разовая ошибка. Может, комп заглючил? Попробуем написать другой пример.

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args)  {

       //прибавляем к нулю 0.1 одиннадцать раз подряд
       double f1 = 0.0;
       for (int i = 1; i &lt;= 11; i++) {
           f1 += .1;
       }

       //Умножаем 0.1 на 11
       double f2 = 0.1 * 11;

       //должно получиться одно и то же - 1.1 в обоих случаях
       System.out.println("f1 = " + f1);
       System.out.println("f2 = " + f2);

       // Проверим!
       if (f1 == f2)
           System.out.println("f1 и f2 равны!");
       else
           System.out.println("f1 и f2 не равны!");
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
f1 = 1.0999999999999999
f2 = 1.1
f1 и f2 не равны!
</code></pre>
Так, дело явно не в глюках компа :) Что происходит?

Подобные ошибки связаны с тем, как числа представлены в двоичном виде в памяти компьютера. 

Дело в том, что <span class="text-bold">в двоичной системе невозможно точно представить число 0,1</span>. В десятичной системе, кстати, тоже есть подобная проблема: в ней нельзя правильно представить дроби (и вместо ⅓ мы получим 0.33333333333333…, что тоже не совсем правильный результат).

Казалось бы, мелочь: при таких подсчетах разница может быть в одну стотысячную часть (0,00001) или даже меньше.

Но что, если от этого сравнения будет зависеть весь результат работы твоей Очень Серьезной Программы?

<pre class="lang-java line-numbers"><code>
if (f1 == f2)
   System.out.println("Ракета летит в космос");
else
   System.out.println("Запуск отменяется, все расходятся по домам");
</code></pre>
Мы явно ожидали, что два числа будут равны, но из-за особенностей внутреннего устройства памяти мы отменили запуск ракеты.
<img data-id="f14c5f54-f6c5-48a0-9537-c2f75288d0ef" data-max-width="850" alt="Устройство вещественных чисел - 3" src="https://cdn.javarush.com/images/article/f14c5f54-f6c5-48a0-9537-c2f75288d0ef/1024.jpeg">Раз так, нам нужно определиться, как же все-таки сравнить два числа с плавающей точкой, чтобы результат сравнения был более...эммм...предсказуемым.

Итак, правило №1 при сравнении вещественных чисел мы уже усвоили: <span class="text-bold">никогда не используй <code>==</code> при сравнении чисел с плавающей точкой.</span>

Ок, плохих примеров, думаю, достаточно :) Давай рассмотрим хороший пример!

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args)  {

       final double threshold = 0.0001;

       //прибавляем к нулю 0.1 одиннадцать раз подряд
       double f1 = .0;
       for (int i = 1; i &lt;= 11; i++) {
           f1 += .1;
       }

       //Умножаем 0.1 на 11
       double f2 = .1 * 11;

       System.out.println("f1 = " + f1);
       System.out.println("f2 = " + f2);

       if (Math.abs(f1 - f2) &lt; threshold)
           System.out.println("f1 и f2 равны");
       else
           System.out.println("f1 и f2 не равны");
   }
}
</code></pre>
Здесь мы по сути делаем то же самое, но меняем способ сравнения чисел.

У нас есть специальное «пороговое» число — 0.0001, одна десятитысячная. Оно может быть и другим. Это зависит от того, насколько точное сравнение тебе нужно в конкретном случае. Можно сделать его и больше, и меньше.

С помощью метода <code>Math.abs()</code> мы получаем модуль числа. Модуль — это значение числа независимо от знака. Например, у чисел -5 и 5 модуль будет одинаковым и равен 5.

Мы вычитаем второе число из первого, и если полученный результат, независимо от знака, будет меньше того порога, который мы установили, значит наши числа равны. 

<span class="text-bold">Во всяком случае, они равны до той степени точности, которую мы установили с помощью нашего «порогового числа»</span>, то есть как минимум они равны вплоть до одной десятитысячной. Такой способ сравнения избавит тебя от неожиданного поведения, которое мы увидели в случае с <code>==</code>.

Еще один хороший способ сравнения вещественных чисел — использовать специальный класс <code>BigDecimal</code>. Этот класс специально был создан для хранения очень больших чисел с дробной частью.

В отличие от <code>double</code> и <code>float</code>, при использовании <code>BigDecimal</code> сложение, вычитание и прочие математические операции выполняются не с помощью операторов (<code>+-</code> и т.д.), а с помощью методов.

Вот как это будет выглядеть в нашем случае:

<pre class="lang-java line-numbers"><code>
import java.math.BigDecimal;

public class Main {

   public static void main(String[] args)  {

       /*Создаем два объекта BigDecimal - ноль и 0.1.
       Делаем то же самое что и раньше - прибавляем 0.1 к нулю 11 раз подряд
       В классе BigDecimal сложение осуществляется с помощью метода add()*/
       BigDecimal f1 = new BigDecimal(0.0);
       BigDecimal pointOne = new BigDecimal(0.1);
       for (int i = 1; i &lt;= 11; i++) {
           f1 = f1.add(pointOne);
       }

       /*Здесь тоже ничего не изменилось: создаем два объекта BigDecimal
       и умножаем 0.1 на 11
       В классе BigDecimal умножение осуществляется с помощью метода multiply()*/
       BigDecimal f2 = new BigDecimal(0.1);
       BigDecimal eleven = new BigDecimal(11);
       f2 = f2.multiply(eleven);

       System.out.println("f1 = " + f1);
       System.out.println("f2 = " + f2);

       /*Еще одна особенность BigDecimal - объекты чисел нужно сравнивать между
       собой с помощью специального метода compareTo()*/
       if (f1.compareTo(f2) == 0)
           System.out.println("f1 и f2 равны");
       else
           System.out.println("f1 и f2 не равны");
   }
}
</code></pre>
Какой же вывод в консоль мы получим?

<pre><code>
f1 = 1.1000000000000000610622663543836097232997417449951171875
f2 = 1.1000000000000000610622663543836097232997417449951171875
f1 и f2 равны
</code></pre>
Мы получили ровно тот результат, на который рассчитывали. И обрати внимание, насколько точными получились наши числа, и сколько знаков после запятой в них уместилось! Гораздо больше, чем во <code>float</code> и даже в <code>double</code>!

Запомни класс <code>BigDecimal</code> на будущее, он тебе обязательно пригодится :)
Фух! Лекция получилась немаленькая, но ты справился: молодец! :) 

Увидимся на следующем занятии, будущий программист!