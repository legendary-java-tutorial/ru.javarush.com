Логические операторы в Java
<p>----------------------------------------</p>
Логические операции выполняются с помощью логических операторов. Уж простите за тавтологию, но дела обстоят именно так. Основные логические операции (в программировании и математике) можно применять к логическим аргументам (операндам), а также составлять более...
<p>----------------------------------------</p>
<ul>
<li><a href="#Логические_операторы_в_Java">Логические операторы в Java</a></li>
<li><a href="#Оператор_логического_отрицания">Оператор логического отрицания  !</a></li>
<li><a href="#Логическое_И">Логическое И — &amp;, а также условное И — &amp;&amp;</a></li>
<li><a href="#Логическое_ИЛИ">Логическое ИЛИ — оператор |, а также условное ИЛИ — оператор ||
</a></li><li><a href="#XOR_логическое_исключающее_ИЛИ">XOR — логическое исключающее ИЛИ — оператор ^</a></li>
<li><a href="#Приоритет_логических_операций">Приоритет логических операций</a></li>
<li><a href="#Сложные_логические_выражения">Сложные логические выражения</a></li>
<li><a href="#Поразрядные_операторы_1">Поразрядные (побитовые) операторы</a></li>
<li><a href="#Поразрядные_операторы_2">Поразрядные операторы &amp;, | и ^</a></li>
<li><a href="#Дополнительный_код">Дополнительный код</a></li>
<li><a href="#Побитовый_оператор_отрицания">Побитовый оператор отрицания ~</a></li></ul><img data-id="f8e3f635-c9d6-4c51-8595-755ffddc32e3" data-max-width="850" alt="Логические операции в Java. Поразрядные операции в Java - 1" src="https://cdn.javarush.com/images/article/f8e3f635-c9d6-4c51-8595-755ffddc32e3/1024.jpeg"><h2 id="Логические_операторы_в_Java">Логические операции в Java</h2>Логические операции выполняются с помощью логических операторов. Уж простите за тавтологию, но дела обстоят именно так. Основные логические операции (в программировании и математике) можно применять к логическим аргументам (операндам), а также составлять более сложные выражения, подобно арифметическим действиям над числами. Например выражение: 

<pre><code>
(a | b) | (c &lt; 100) &amp; !(true) ^ (q == 5)
</code></pre> 
представляет собой сложное логическое выражение с четырьмя операндами:

<code>(a | b)</code>, где <code>а</code> и <code>b</code> — переменные типа <code>boolean</code>
<code>(c &lt; 100)</code>
<code>(true)</code>
<code>(q == 5)</code> 

В свою очередь, простое логическое выражение <code>(a | b)</code> также состоит из двух аргументов-операндов.   
 
<strong>Логический операнд</strong> — это выражение, о котором можно сказать что оно является истинным или ложным, <em>true</em> или <em>false</em>. Говоря языком Java, логический операнд — это выражение типа <code>boolean</code> или Boolean, например: 
<ul>
<li><code>(2 &lt; 1)</code> — логический операнд, его значение равно <em>false</em></li>
<li><code>true</code> — логический операнд, значение которого, очевидно, <em>true</em></li>
<li><code>boolean a</code> — тоже может быть логическим операндом, как и <strong>Boolean a</strong></li>
<li><code>int a = 2</code> — <strong>не является логическим операндом</strong>, это просто переменная типа <code>int</code></li>   
<li><code>String a = "true"</code> также <strong>не является логическим операндом</strong>. Это строка, текстовое значение которой — <code>"true"</code>.</li>
</ul>В Java доступны следующие логические операции: 
<ul>
<li><strong>Логическое отрицание</strong>, оно же <code>NOT</code> или инверсия. В Java обозначается символом “<code><strong>!</strong></code>” перед операндом. Применяется к одному операнду.</li>
<li><strong>Логическое и</strong>, оно же <code>AND</code> или конъюнкция. Обозначается символом “<code><strong>&amp;</strong></code>” между двумя операндами, к которым применяется.</li>
<li><strong>Логическое или в Java</strong>, оно же — <code>OR</code>, оно же — дизъюнкция. В Java обозначается символом “<code><strong>|</strong></code>” между двумя операндами.</li>
<li><strong>Исключающее или</strong>, <code>XOR</code>, строгая дизъюнкция. В Java обозначается символом “<code><strong>^</strong></code>” между двумя операндами.</li>
<li>В Java к логическим операторам можно отнести <strong>условное или</strong>, обозначаемое как <code><strong>||</strong></code>, а также <strong>условное и</strong> — <code><strong>&amp;&amp;</strong></code>.</li>
</ul><em><strong>Примечание:</strong></em> также в математической логике рассматривают отношение эквивалентности, проще говоря — равенства. Однако в Java оператор равенства <code>==</code> не принято относить к логическим. 

<strong>Внимание!</strong> В Java логические операторы <code>&amp;</code>, <code>|</code> и <code>^</code> применяются также к целым числам. В этом случае они работают несколько иначе и называются <a href="#Поразрядные_операторы_1">поразрядными</a> (или побитовыми) логическими операторами. О них — ближе к концу статьи. 

Рассмотрим таблицу с кратким описанием каждого из логических операторов Java, а ниже опишем их подробнее и приведем примеры кода. 
<table style="text-align:center;">
<tbody><tr>
<th>Оператор Java</th>
<th style="width:15%;">Имя</th>
<th>Тип</th>
<th style="width:30%;">Краткое описание</th>
<th>Пример</th>
</tr>
<tr>
<td><code>!</code></td>
<td>Логическое “не” (отрицание)</td>
<td>Унарный</td>
<td><code>!x</code> означает “не x”. Возвращает <em>true</em> если операнд является <em>false</em>. Возвращает <em>false</em> если операнд является <em>true</em>.</td>
<td><code>boolean x = true;</code><br>
Тогда<br>
<code>// !x == false</code>
</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>Логическое И (<code>AND</code>, умножение)</td>
<td>Бинарный</td>
<td>Возвращает <em>true</em> если оба операнда равны <em>true</em>.</td>
<td><code>a = true;</code><br>
<code>b = false;</code><br> 
тогда<br>
<code>a &amp; b == false</code></td>
</tr>
<tr>
<td><code>|</code></td>
<td>Логическое ИЛИ (<code>OR</code>, сложение)</td>
<td>Бинарный</td>
<td>Возвращает <em>true</em> если хотя бы один из операндов равен <em>true</em>.</td>
<td><code>a = true;</code><br>
<code>b = false;</code><br>
тогда<br>
<code>a | b == true</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>Логическое исключающее ИЛИ (<code>XOR</code>)</td>
<td>Бинарный</td>
<td>Возвращает <em>true</em>, если один и только один из операндов равен <em>true</em>. Возвращает <em>false</em>, если оба операнда равны <em>true</em> или <em>false</em>. По сути, возвращает <em>true</em>, если операнды — разные.</td>
<td><code>a = true;</code><br>
<code>b = false;</code><br>
тогда<br>
<code>a ^ b == true</code><br></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Условное И (сокращённое логическое И)</td>
<td>Бинарный</td>
<td>То же самое, что и <code>&amp;</code>, но если операнд, находящийся слева от <code>&amp;</code> является <em>false</em>, данный оператор возвращает <em>false</em> без проверки второго операнда.</td>
<td></td>
</tr>
<tr>
<td><code>||</code></td>
<td>Условное ИЛИ (сокращённое логическое ИЛИ)</td>
<td>Бинарный</td>
<td>То же самое, что и <code>|</code>, но если оператор слева является <em>true</em>, оператор возвращает <em>true</em> без проверки второго операнда.</td>
<td></td>
</tr>
</tbody></table>
<table class="table table--striped">
<tbody><tr>
<td><p><strong>Логические операции в курсе JavaRush</strong></p>
<p>Без логических операций никуда не деться, и в курсе JavaRush они появляются с первых уровней, вместе с условиями и типом данных boolean. Пользоваться методами математической логики программисты приучаются постепенно. Для более уверенных манипуляций с логическими конструкциями требуется определённая сноровка и понимание некоторых процессов. Так что подробнее и уже на совсем другом уровне к этим операциям подходят в конце квеста Multithreading, когда большинство студентов уже не слишком отвлекается непосредственно на синтаксис и конструкции, а старается вникать в суть задачи.</p>
<a href="https://javarush.com/"><img data-id="4ec24ca1-70d7-4f09-b4a6-5b67081419aa" data-max-width="350" alt="Логические операции в Java. Поразрядные операции в Java - 2" src="https://cdn.javarush.com/images/article/4ec24ca1-70d7-4f09-b4a6-5b67081419aa/1024.jpeg"></a>
</td>
</tr>
</tbody></table><h2 id="Оператор_логического_отрицания">Оператор логического отрицания !</h2>Этот оператор — унарный, то есть он применяется к одному булевскому выражению или операнду. Понять его очень просто, как и любое отрицание: оператор просто меняет значение выражения на противоположное. 

Таблица истинности или результаты выполнения операции отрицания: 
<table>
<tbody><tr>
<td>Значение <strong>a</strong></td>
<td><strong>!a</strong></td>
</tr>
<tr>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
</tr>
</tbody></table>Пример. Операция логического отрицания 

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {
       boolean a = true;
       System.out.println(!a); // здесь наше логическое выражение меняет значение на противоположное
       System.out.println(!false); // выражение не-false, как можно догадаться, будет равно... чему?
       System.out.println(!(2 &lt; 5)); // выражение (2 &lt; 5) истинно, значит, его отрицание - ложно 

   }
}
</code></pre>
Вывод программы будет следующий:

<pre><code>
false
true
false
</code></pre><h2 id="Логическое_И">Логическое И — &amp;, а также условное И — &amp;&amp;</h2>Логическое И или конъюнкцию применяют к двум выражениям, и результат его действия будет истинным (<em>true</em>) только если оба операнда истинны. То есть, если один из операндов <code>a</code> или <code>b</code> равен <em>false</em>, то выражение <code><strong>a &amp; b</strong></code> будет <em>false</em> независимо от значения второго оператора.

Если представить, что <em>true</em> — это число 1, а <em>false</em> — 0, то оператор <code><strong>&amp;</strong></code> работает точно так же, как обычное умножение. Поэтому логическое И часто называют “логическим умножением”. И, кстати, этот факт помогает быстрее запомнить работу оператора <code>&amp;</code> и не путать его с оператором логического или <code>|</code>. 

Таблица истинности И, она же — результат работы оператора <code>&amp;</code>
<table>
<tbody><tr>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>a &amp; b</strong></td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>Логическое И, оно же — конъюнкция, примеры:

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {
       boolean a = true;
       boolean b = false;
       boolean c = true;
       System.out.println(a &amp; b); // если мы умножим правду на ложь, то определённо получим ложь 
       System.out.println(a &amp; c); // правда на правду будет правда 
       System.out.println(false &amp; (2 &gt; 5));
 System.out.println((2 &lt; 5) &amp; false);
 // независимо от правдивости выражения в скобках, в таком случае нам приходится довольствоваться ложью 
   }
}
</code></pre>
Результат работы программы:

<pre><code>
false
true
false
false
</code></pre>
Оператор <code><strong>&amp;&amp;</strong></code> иногда называют “сокращённым И”. Он выдаёт такой же результат при работе с логическими операндами, что и оператор <code><strong>&amp;</strong></code>. Однако есть разница в самой его работе. Так, вы уже успели заметить, что если в выражении (<code>a &amp; b</code>) операнд <code>a</code> равен <em>false</em>, то не имеет смысла проверять значение операнда <code><strong>b</strong></code>: результат операции точно будет <em>false</em>. Так что если нам принципиально не нужно значение второго операнда, с помощью <code><strong>&amp;&amp;</strong></code> мы сокращаем количество вычислений в программе. Если мы заменим в примере все операторы <code><strong>&amp;</strong></code> на <code><strong>&amp;&amp;</strong></code>, результат работы будет точно таким же, но сама программа будет работать чуточку быстрее (правда, мы этого не заметим, так как речь идёт о мили-микро… короче говоря, об очень маленьких единицах времени). 

<div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><h2 id="Логическое_ИЛИ">Логическое ИЛИ — оператор |, а также условное ИЛИ — оператор ||</h2>Оператор ИЛИ в Java обозначается символом <code>|</code>. Логическое ИЛИ или дизъюнкцию применяют к двум выражениям, и результат его действия будет ложным (<em>false</em>) тогда и только тогда, когда оба операнда ложны. Здесь мы в какой-то мере наблюдаем ту же картину, что и в случае с оператором <code>&amp;</code>, но с точностью до наоборот. То есть, если хотя бы один операнд равен <em>true</em>, то выражение <code><strong>a | b</strong></code> гарантированно будет <em>true</em> независимо от значения второго оператора. 

Если <code><strong>&amp;</strong></code> ведёт себя как логическое умножение, то ИЛИ — это логическое сложение, если представить, что <em>true</em> — это 1, а <em>false</em> — 0. Только следует помнить, что логическое сложение работает не так, как обычное. 1 + 1 в данном случае равно не 2, а 1 (числа 2 в этой системе просто не существует). Иногда дизъюнкцию понимают как максимум из 0 и 1, и в таком случае если хотя бы один операнд равен 1 (<em>true</em>), мы получим именно <em>true</em>. 

Таблица истинности ИЛИ, она же — результат работы оператора <code>|</code>:
<table>
<tbody><tr>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>a | b</strong></td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>Логическое ИЛИ, оно же — дизъюнкция, пример:  

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {
       boolean a = true;
       boolean b = false;
       boolean c = true;
       System.out.println(!a | b); // Скомпонуем использование двух логических операторов: a == true, значит, !a, как мы уже знаем - это false.
       System.out.println(a | c); 
       System.out.println((2 &lt; 5) | false); // выражение (2 &lt; 5) истинно, значит, при любом втором операнде мы получим получим истинный результат
       System.out.println((2 &gt; 5) | true);

   }
}
</code></pre>
Результат: 

<pre><code>
false
true
true
true
</code></pre>
Если мы применим оператор условного ИЛИ — <code>||</code> вместо <code>|</code>, мы получим ровно тот же результат, но, как и в случае с условным И <code>&amp;&amp;</code>, он будет действовать экономно: если мы “нарываемся” на первый операнд равный <em>true</em>, значение второго операнда не проверяется, а сразу выдаётся результат <em>true</em>. 
<h2 id="XOR_логическое_исключающее_ИЛИ">XOR Java — логическое исключающее ИЛИ — оператор ^</h2><code>XOR</code>, сложение по модулю 2, логическое исключающее ИЛИ, логическое вычитание, строгая дизъюнкция, поразрядное дополнение… у оператора <code>^</code> есть много имён в булевой алгебре. Результат применения этого оператора к двум операндам будет равен <em>true</em>, если операнды разные и <em>false</em>, если операнды одинаковые. Поэтому его удобно сравнивать с вычитанием нулей (<em>false</em>) и единиц (<em>true</em>).    

Таблица истинности <code>XOR</code>, она же — результат работы оператора <code>^</code>:
<table>
<tbody><tr>
<td><strong>Boolean a</strong></td>
<td><strong>Boolean b</strong></td>
<td><strong>a ^ b</strong></td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>Пример: 

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {
       boolean a = true;
       boolean b = false;
       boolean c = true;
       System.out.println(!a ^ b); // Скомпонуем использование двух логических операторов: a == true, значит, !a, как мы уже знаем - это false.
       System.out.println(a ^ c);
       System.out.println((2 &lt; 5) ^ false);
       System.out.println((2 &gt; 5) ^ true);
   }
}
</code></pre>
Результат:

<pre><code>
false
false
true
true
</code></pre><h2 id="Приоритет_логических_операций">Приоритет логических операций</h2>Как и в математике, в программировании у операторов есть определённый порядок выполнения, если они встречаются в одном выражении. Унарные операторы имеют преимущества над бинарными, а умножение (даже логическое) над сложением. 

Мы расположили логические операторы в списке тем выше, чем выше их приоритет: 
<ol>
<li><code>!</code></li>
<li><code>&amp;</code></li>
<li><code>^</code></li>
<li><code>|</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
</ol>Рассмотрим примеры. Конъюнкция и дизъюнкция (<code>&amp;</code> и <code>|</code>) имеют разный приоритет:  

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {      
       boolean a = true, b = true, c = false;
       System.out.println(a | b &amp; c);   
}
</code></pre>
Если бы мы действовали слева направо, то есть сначала применили бы оператор <code>|</code>, а затем — <code>&amp;</code>, мы бы получили значение <em>false</em>. 

Но на деле, если вы запустите данную программу на выполнение, то убедитесь, что вывод будет <em>true</em>, поскольку у оператора логического И <code>&amp;</code> приоритет будет выше, нежели у оператора логического ИЛИ <code>|</code>. Чтобы не путаться, нужно помнить, что <code>&amp;</code> ведёт себя как умножение, а <code>|</code> — как сложение. Поменять порядок приоритета, можно. Просто примените скобки, прямо как в школьной математике. Изменим немного код нашего примера: 

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {      
       boolean a = true, b = true, c = false;
       System.out.println((a|b)&amp;c);   
}
</code></pre>
Что тут? Сначала применяем логическое сложение в скобках, а затем уже умножение. Результатом будет <em>false</em>.  
<h2 id="Сложные_логические_выражения">Сложные логические выражения</h2>Разумеется, мы можем комбинировать логические выражения и операторы. 

Вспомним выражение из начала статьи: 

<pre><code>
<strong>(a | b) | (c &lt; 100) &amp; !(true) ^ (q == 5)</strong>
</code></pre>  
Теперь оно выглядит не так страшно. Напишем программу, которая выводит его значение, предварительно определив значения <code>a</code>, <code>b</code>, <code>с</code> и <code>q</code>.

Пример вычисления значения сложного логического выражения

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {
       boolean a = true;
       boolean b = false;
       int c = 25;
       int q = 2;
       System.out.println((a|b) | (c &lt; 100) &amp; !(true)^(q == 5)); 
   }
}
</code></pre>
<mark>Обратите внимание:</mark> переменная <code><strong>q</strong></code> у нас относится к типу <code>int</code>, а вот <code><strong>q == 5</strong></code> — это булево выражение, и оно равно <em>false</em>, поскольку выше мы проинициализировали <code><strong>q</strong></code> числом 2. То же самое и с переменной <code><strong>c</strong></code>. Это число равное 25, а вот (c &lt; 100) — булево выражение, равное <em>true</em>. 

Результат работы этой программы:

<pre><code>
true
</code></pre> 
Сложные логические выражения можно применять для проверки очень запутанных и ветвистых условий, однако не стоит ими злоупотреблять: они затрудняют чтение кода.
<h2 id="Поразрядные_операторы_1">Поразрядные (побитовые) операторы</h2>В начале статьи мы упомянули, что операторы  <code>&amp;</code>, <code>|</code> и <code>^</code> можно употреблять по отношению к целочисленным типам Java. В таком случае они являются поразрядными операторами. Их также называют побитовыми, поскольку один разряд — это и есть один бит, а эти операции работают именно с битами.  

Разумеется, работают они несколько иначе, нежели логические операторы, и чтобы понимать, как именно, нужно знать, что такое двоичная (бинарная) система счисления. Если вы ничего о ней не знаете или совсем забыли, предлагаем для начала ознакомиться со статьёй <a href="https://javarush.com/groups/posts/2175-java-bits-and-bytes" target="_blank">Java: биты и байты</a>, а всем остальным напомним, что в двоичной системе счисления есть всего две цифры —  0 и 1, и все данные в компьютере представлены именно с помощью условных нуликов и единичек. 

Любое из привычных нам чисел (десятичных; для них есть 10 разных цифр от 0 до 9, с помощью которых мы записываем любые числа) представимо в двоичной системе счисления. Перевести десятичное число в двоичное можно с помощью последовательного деления в столбик на основу системы счисления (2). Остатки от деления на каждом шагу, записанные в обратном порядке, и дадут нам искомое двоичное число. Вот, например, перевод десятичного числа 103 в двоичное представление: 
<img data-id="bfbb7d26-10c2-4aa0-9a64-65f960e59d92" data-max-width="650" alt="Логические операции в Java. Поразрядные операции в Java - 3" src="https://cdn.javarush.com/images/article/bfbb7d26-10c2-4aa0-9a64-65f960e59d92/1024.jpeg"><table class="table table--striped">
<tbody><tr>
<td><p><strong>Двоичная система счисления в курсе JavaRush</strong></p>
<p>В курсе JavaRush о двоичной системе счисления рассказывают во время изучения квеста MultiThreading (10 уровень, 1 лекция), после лекции есть несколько задач на закрепление. Однако эта тема совсем не сложная, и даже если вы ещё не прошли по курсу так далеко, скорее всего, вы в ней разберётесь.</p>
</td>
</tr>
</tbody></table>Помимо <code>&amp;</code>, <code>|</code> и <code>^</code> в Java также используются поразрядные операторы:
<ul>
<li> <code>~</code>  поразрядный оператор отрицания</li>
<li><code>&gt;&gt;</code> побитовый сдвиг вправо</li>
<li><code>&gt;&gt;&gt;</code> беззнаковый побитовый сдвиг вправо</li>
<li><code>&lt;&lt;</code> побитовый сдвиг влево</li>
</ul>Новичкам поразрядные операторы кажутся очень непонятными и искусственными. Им чаще всего непонятно, для чего они нужны, кроме как для решения учебных задачек. На самом деле, их можно применять как минимум для организации эффективного деления и умножения, а профессионалы их используют для кодирования/декодирования, шифрования, генерации случайных чисел. 
<h2 id="Поразрядные_операторы_2">Поразрядные операторы &amp;, | и ^</h2>Давайте рассмотрим на примере, как работают эти операторы. Допустим у нас есть два целых числа: 

<pre><code>
<strong>int a = 25; 
int b = 112; </strong>
</code></pre>
Нам нужно применить к ним три операции <code>&amp;</code>, <code>|</code> и <code>^</code> и вывести на экран результат. Вот код программы: 

<pre class="lang-java line-numbers"><code>
public class Solution {
   public static void main(String[] args) {

       int a = 25;
       int b = 112;

       int res1 = a &amp; b;
       int res2 = a | b;
       int res3 = a ^ b;

       System.out.println("a &amp; b = " + res1);
       System.out.println("a | b = " + res2);
       System.out.println("a ^ b = " + res3);
      
   }
}
</code></pre>
Результат работы программы следующий:

<pre><code>
a &amp; b = 16
a | b = 121
a ^ b = 105
</code></pre>
Если не понимать, что происходит, то результат выглядит весьма и весьма загадочным. На самом деле, всё проще, чем кажется. Поразрядные операторы “видят” числа-операнды в их двоичной форме. И затем применяют логические операторы <code>&amp;</code>, <code>|</code> или <code>^</code> к соответствующим друг другу разрядам (битам) обоих чисел. Так, для <code>&amp;</code> последний бит двоичного представления числа 25 логически складывается с последним битом двоичного представления числа 112, предпоследний — с предпоследним, и так далее: 
<img data-id="ebb20a63-ad2f-4e8f-8e45-8005d7b55a7b" data-max-width="650" alt="Логические операции в Java. Поразрядные операции в Java - 4" src="https://cdn.javarush.com/images/article/ebb20a63-ad2f-4e8f-8e45-8005d7b55a7b/1024.jpeg">Та же логика прослеживается в случае с <code><strong>|</strong></code> и <code><strong>^</strong></code>.
<img data-id="de13f67a-c641-4354-95e6-ee04a060eded" data-max-width="650" alt="Логические операции в Java. Поразрядные операции в Java - 5" src="https://cdn.javarush.com/images/article/de13f67a-c641-4354-95e6-ee04a060eded/1024.jpeg"><h2>Побитовый сдвиг влево или вправо</h2>В Java существует несколько операторов побитового сдвига. Чаще всего используют операторы <code>&lt;&lt;</code> и <code>&gt;&gt;</code>. Они сдвигают двоичное представление числа соответственно влево или вправо, причём в случае сдвига вправо — с сохранением знака (что значит сохранение знака, расскажем чуть ниже). Есть ещё один оператор сдвига вправо <code>&gt;&gt;&gt;</code>. Он делает то же самое, что и <code>&gt;&gt;</code> но знак не сохраняет. 

Итак, рассмотрим их работу на примере.

<code><strong>int a = 13</strong></code>
<code><strong>a &lt;&lt; 1</strong></code> смещает все биты двоичного представления числа a влево на 1 бит.

Для упрощения представим число 13 в двоичном виде как 0000 1101. На самом деле это число выглядит так:
00000000 00000000 00000000 00001101, поскольку под числа типа <code>int</code> Java выделяет 4 байта или 32 бита. Однако в примере это роли не играет, так что в этом примере будем мнить наше число однобайтовым. 
<img data-id="01c17e13-048b-446d-9640-965ce25f4022" data-max-width="850" alt="Логические операции в Java. Поразрядные операции в Java - 6" src="https://cdn.javarush.com/images/article/01c17e13-048b-446d-9640-965ce25f4022/1024.jpeg">Освободившийся справа бит заполняется нулями. В результате такой операции мы получим число 26. 

<code><strong>a &lt;&lt; 2</strong></code> смещает все биты двоичного представления числа <code><strong>a</strong></code> влево на 2 бита, и освободившиеся справа два бита заполняются нулями. В результате мы получим число 52. 

<code><strong>a &lt;&lt; 3</strong></code> выдаст результат 104… 
Заметили закономерность? Побитовый сдвиг <code>a</code> влево на n позиций работает как умножение числа <code>a</code> на 2 в степени n. 
Это же касается и отрицательных чисел. Так <code>-13 &lt;&lt; 3</code> выдаст результат -104. 

<code><strong>a &gt;&gt; n</strong></code> смещает двоичное представление число на n позиций вправо. Например, <code>13 &gt;&gt; 1</code>
Превращает число 1101 в число 0110, то есть, 6. А <code>13 &gt;&gt; 2</code> даст в результате 3. 

То есть по сути, тут мы делим число на 2 в степени n, где n — количество сдвигов вправо, но с одним нюансом: если число нечётное, мы при этой операции как бы обнуляем последний бит числа. А вот с отрицательными  дело обстоит несколько иначе. 

Скажем, попробуйте проверить, что выдаст программа, если вы попросите её выполнить операцию <code>-13 &gt;&gt; 1</code>. Вы увидите число -7, а не -6, как можно было бы подумать. Так происходит из-за особенностей хранения отрицательных чисел в Java и других языках программирования. Они хранятся в так называемом дополнительном коде. При этом старший разряд (тот, что слева) отдаётся под знак. В случае с отрицательным числом старший разряд равен 1.
<h2 id="Дополнительный_код">Дополнительный код</h2>Рассмотрим число <code>int a = 13</code>.

Если в программе вы выведем его двоичное представление в консоль помощью команды <code>System.out.println(Integer.toBinaryString(a));</code>, то мы получим 1101. На самом деле это — сокращённая запись, поскольку число типа <code>int</code> занимает в памяти 4 байта, поэтому компьютер “видит” его, скорее так: 

<pre><code>
00000000 00000000 00000000 00001101
</code></pre>
Старший разряд равен нулю, значит, перед нами положительное число. Для перевода в дополнительный код:
<ol>
<li><p>Записываем число -13 в так называемом “прямом коде”. Для этого меняем старший разряд числа на 1.<br>
Результат действия:</p>
<pre><code>
10000000 0000000 0000000 00001101
</code></pre></li>
<li><p>Далее инвертируем все разряды (меняем 0 на 1, а 1 на 0) кроме знакового разряда. Его, по сути, мы уже поменяли.<br> 
Результат действия:</p>
<pre><code>
11111111 11111111 11111111 11110010
</code></pre>
<p>(да, шаги 1 и 2 можно было бы совместить, но лучше представлять именно так)</p></li>
<li>Прибавляем к получившемуся числу 1.<br>
Результат действия:<p></p>
<pre><code>
11111111 11111111 11111111 11110011
</code></pre></li>
</ol>Получившееся двоичное число — это и есть -13, записанное в дополнительном коде и побитовый сдвиг (да и другие операции) будут применяться именно к нему. Просто разница в логике работы заметна далеко не на всех операциях. Скажем, для того же сдвига влево разница незаметна, мы можем работать оперируя отрицательными числами так же, как и положительными числами.  

Теперь выполним сдвиг вправо <code>-13 &gt;&gt; 1</code>. Поскольку наш оператор <code>&gt;&gt;</code> сохраняет знак, то в этой операции все освободившиеся слева биты заполняются не нулями, а единицами. Таким образом сдвигая число     

<pre><code>
11111111 11111111 11111111 11110011
</code></pre>
на один бит вправо, в результате мы получим следующую последовательность бит: 

<pre><code>
11111111 11111111 11111111 11111001
</code></pre>
Если перевести это число в прямой код (то есть сначала отнять 1, затем инвертировать все биты, кроме первого) мы получим число: 

<pre><code>
10000000 00000000 00000000 00000111
</code></pre>	
или -7.

Теперь, когда мы разобрались с оператором сдвига вправо с сохранением знака, станет понятно, в чем его отличие от оператора <code>&gt;&gt;&gt;</code>. 

<code>a &gt;&gt;&gt; n</code> — эта операция является беззнаковым сдвигом, то есть она сдвигает двоичное представление числа <code>a</code> вправо на n разрядов, но освободившиеся слева n разрядов заполняет не единицами, как оператор <code>&gt;&gt;</code>, а нулями. 

Проделаем операцию <code>-13 &gt;&gt;&gt; 1</code>. У нас уже есть число <code>-13</code> в дополнительном коде: 

<pre><code>
11111111 11111111 11111111 11110011
</code></pre>
При сдвиге вправо на 1 бит и заполнении освободившийся бит нулём мы получаем следующее число:

<pre><code>
01111111 11111111 11111111 11111001
</code></pre>
Что в десятичном представлении даёт число <code>2147483641</code>.
<h2 id="Побитовый_оператор_отрицания">Побитовый оператор отрицания ~</h2>Этот унарный оператор работает очень просто: он меняет каждый бит бинарного представления целого числа на противоположный. Возьмем число <code>-13</code>:

<pre><code>
11111111 11111111 11111111 11110011
</code></pre>
Операция побитового отрицания <code>~13</code> просто изменит значение каждого бита на противоположное. В результате мы получим:

<pre><code>
00000000 00000000 00000000 00001100
</code></pre> 
Или <code>12</code> в десятичном виде. 
<h2>Краткие выводы</h2><ul>
<li>Все логические операторы применяются к булевским выражениям, то есть таким, о которых можно сказать, <em>true</em> они или <em>false</em>.</li>
<li>Если операторы <code>&amp;</code>, <code>|</code> или <code>^</code> применяются к числам, речь идёт уже не о логических операциях, а о побитовых. То есть оба числа переводятся в двоичную систему и к этим числам побитово применяют операции логического сложения, умножения или вычитания.</li>
<li>В математической логике операторам <code>&amp;</code> и <code>|</code> соответствуют конъюнкция и дизъюнкция.</li>
<li>Логическое И похоже на умножения 1 (<em>true</em>) и 0 (<em>false</em>).</li>
<li>Логическое ИЛИ напоминает поиск максимума среди 1 (<em>true</em>) и 0 (<em>false</em>).</li>
<li>Для побитового отрицания целого числа a используется операция <code>~a</code>.</li>
<li>Для логического отрицания булевского выражения a используется операция <code>!a</code>.</li>   
<li>Отрицательные числа хранятся и обрабатываются в дополнительном коде.</li>
<li>Поразрядный сдвиг вправо может сохранять знак (<code>&gt;&gt;</code>), а может — не сохранять (<code>&gt;&gt;&gt;</code>).</li>
</ul>