Знакомство с операторами Java: логические, арифметические, побитовые
<p>----------------------------------------</p>
Давай поговорим об операциях в Java: числовых, логических, побитовых. Это теоретический базис, который однозначно нужен, чтобы научиться программировать. Для начала определимся с терминологией...
<p>----------------------------------------</p>
Давай поговорим об операциях в Java: числовых, логических, побитовых. Это теоретический базис, который однозначно нужен, чтобы научиться программировать. 

<img data-max-width="1024" src="/images/article/b59aa94a-b935-498f-a0b7-72a3a76d3deb/original.jpeg" class="img-fluid" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 1" Знакомство="" с="" операторами="" java:="" логические,="" арифметические,="" побитовые="" -="" 1"="">
<ul>
<li><a href="#Какие-бывают-операторы-в-Java">Какие бывают операторы в Java</a></li>
<li><a href="#Операторы-Java-в-курсе-JavaRush">Операторы Java в курсе JavaRush</a></li>
<li><a href="#Операции-над-числами-в-Java">Операции над числами в Java</a></li>
<li><a href="#Логические-операции-в-Java">Логические операции в Java</a></li>
<li><a href="#Побитовые-операции-в-Java">Побитовые операции в Java</a></li>
<li><a href="#Приоритет-операций-в-Java">Приоритет операций в Java</a></li>
<li><a href="#Полезные-примеры-использования">Полезные примеры использования</a></li>
</ul><h2 id="Какие-бывают-операторы-в-Java">Какие бывают операторы в Java</h2>Для любой операции нам нужно как минимум две вещи:
<ul>
<li>оператор;</li>
<li>операнд.</li>
</ul>Примером оператора может быть простой плюс в операции сложения двух чисел. А складываемые друг с другом числа будут в этом случае операндами. Итак, с помощью операторов мы выполняем операции над одним или несколькими операндами.

Операторы, которые осуществляют операции над двумя операндами, называются бинарными. Например, сложение двух чисел.

Операторы, которые осуществляют операции над одним операндом, называются унарными. Например, унарный минус.
<h2 id="Операторы-Java-в-курсе-JavaRush">Операторы Java в курсе JavaRush</h2>Несколько лекций посвящено операторам Java на <a href="https://javarush.com/quests/lectures?quest=QUEST_JAVA_SYNTAX&amp;level=4" target="_blank">четвертом уровне</a> первого квеста — Java Syntax. В частности,<a href="https://javarush.com/quests/lectures/questsyntax.level04.lecture04" target="_blank"> условным операторам, типу boolean</a>. В курсе есть 22 задачи, которые помогут разобраться с работой операторов сравнения, условных, логических операторов.
<h2 id="Операции-над-числами-в-Java">Операции над числами в Java</h2>Самая частая операция, которую программисты производят над числами — присвоение числового значения какой либо переменной. Она, как и оператор <code>=</code> тебе знакомы:

<pre class="lang-java line-numbers"><code>
int a = 1;
int b = 2;
int c = 3;
</code></pre>
Есть также арифметические операции. Они осуществляются с помощью бинарных арифметических операторов:

<center><em>Таблица 1. Бинарные арифметические операторы</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 2" src="https://cdn.javarush.com/images/article/c9bc8057-292e-40b1-9e40-c4de9c156087/original.jpeg">Первые четыре оператора не должны вызывать вопросов: все так же, как в математике. Последний оператор, остаток от деления, также не делает ничего сверхсложного. К примеру, если разделить 24 на 7, мы получим 3 целых и 3 в остатке. Именно остаток и вернет данный оператор:

<pre class="lang-java line-numbers"><code>
System.out.println(24 % 7); // выведет 3
</code></pre>
Вот примеры с сайта официальной документации Oracle:
<img data-max-width="1024" src="/images/article/d14a2043-54d1-4710-81da-b93dfd260909/original.jpeg" class="img-fluid" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 3">Данная программа выведет следующее:
 
<em>1 + 2 = 3
3 - 1 = 2
2 * 2 = 4
4 / 2 = 2
2 + 8 = 10
10 % 7 = 3</em>

Java позволяет комбинировать: например, операторы присваивания и арифметические операторы.
 
Рассмотрим пример:
 
<pre class="lang-java line-numbers"><code>
int x = 0;
x = x + 1; // x = 0 + 1 =&gt; x = 1
x = x + 1; // x = 1 + 1 =&gt; x = 2
x = x + 1; // x = 2 + 1 =&gt; x = 3
</code></pre>
Здесь мы задали переменную <code>x</code> и присвоили ей нулевое значение. Далее в каждой строке мы присваиваем значению <code>x</code> сумму текущего значения переменной <code>x</code> и единицы. В комментариях к каждой строке есть пояснения. Эту процедуру называют наращиванием или инкрементированием переменной.
 
Операцию инкрементирования из примера выше можно заменить на аналогичную с использованием комбинации операторов:
 
<pre class="lang-java line-numbers"><code>
int x = 0;
x += 1; // x = 0 + 1 =&gt; x = 1
x += 1; // x = 1 + 1 =&gt; x = 2
x += 1; // x = 2 + 1 =&gt; x = 3
</code></pre>
Комбинировать оператор присваивания можно с любым арифметическим оператором:
 
<pre class="lang-java line-numbers"><code>
int x = 0;
x += 10; // x = 0 + 10 =&gt; x = 10
x -= 5; // x = 10 - 5 =&gt; x = 5
x *= 5; // x = 5 * 5 =&gt; x = 25
x /= 5; // x = 25 / 5 =&gt; x = 5
x %= 3; // x = 5 % 3 =&gt; x = 2;
</code></pre>
Продемонстрируем работу последнего примера:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559737990697.gif" width="564" height="655" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 4"></center>
Помимо бинарных, в Java есть унарные арифметические операторы.

<center><em>Таблица 2. Унарные арифметические операторы:</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 4" src="https://cdn.javarush.com/images/article/0631cf90-c334-4b37-b1ee-e17d19b6a60a/original.jpeg">Пример унарных плюса и минуса:

<pre class="lang-java line-numbers"><code>
int x = 0;
x = (+5) + (+15); //Скобки для наглядности, можно и без них
System.out.println("x = " + x);

int y = -x;
System.out.println("y = " + y);
</code></pre>
<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738028102.gif" width="665" height="452" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 6"></center>
Операции инкремента и декремента по сути просты. В первом случае происходит увеличение переменной на 1, во втором — уменьшение переменной на 1. Пример ниже:

<pre class="lang-java line-numbers"><code>
int x = 9;
x++;
System.out.println(x); // 10

int y = 21;
y--;
System.out.println(y); // 20
</code></pre>
Есть два типа данных операций — постфиксная и префиксная. В первом случае оператор пишется после переменной, во втором случае — перед переменной. Разница лишь в том, когда выполнится операция инкрементирования или декрементирования. Пример и описание в таблице ниже.

Предположим, у нас есть переменная:

<pre class="lang-java line-numbers"><code>
int a = 2;
</code></pre>
Тогда:
<center><em>Таблица 3. Операторы инкремента-декремента:</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 5" src="https://cdn.javarush.com/images/article/fb5f6ae2-d6a5-4e9b-80d3-7e95c17a11ba/original.jpeg">Демонстрация:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738060892.gif" width="545" height="452" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 8"></center>
Помимо арифметических, существуют операции сравнения (двух чисел). Результатом всегда будет истина либо ложь (<em>true</em> / <em>false</em>).

<center><em>Таблица 4. Операторы сравнения</em></center><img data-max-width="1024" data-id="438975aa-6634-425b-9259-389cda12c5e2" src="https://cdn.javarush.com/images/article/438975aa-6634-425b-9259-389cda12c5e2/original.png" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 9">Примеры:

<pre class="lang-java line-numbers"><code>
int a = 1;
int b = 2;

boolean comparisonResult = a == b;
System.out.println("a == b :" + comparisonResult);

comparisonResult = a != b;
System.out.println("a != b :" + comparisonResult);

comparisonResult = a &gt; b;
System.out.println("a &gt;  b :" + comparisonResult);

comparisonResult = a &gt;= b;
System.out.println("a &gt;= b :" + comparisonResult);

comparisonResult = a &lt; b;
System.out.println("a &lt;  b :" + comparisonResult);

comparisonResult = a &lt;= b;
System.out.println("a &lt;= b :" + comparisonResult);
</code></pre>
Демонстрация:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738083222.gif" width="593" height="786" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 10"></center><h2 id="Логические-операции-в-Java">Логические операции в Java</h2>Рассмотрим логические операции и таблицы истинности каждой из них:
<ul>
<li>операция отрицания (<code>NOT</code>);</li>
<li>операция конъюнкции, логическое И (<code>AND</code>);</li>
<li>операция дизъюнкции, логическое ИЛИ (<code>OR</code>);</li>
<li>операция сложения по модулю, исключающее ИЛИ (<code>XOR</code>).</li>
</ul>Операция отрицания унарная и применяется к одному операнду. Все остальные операции — бинарные.
 
Рассмотрим таблицы истинности данных операций. Здесь <em>0</em> — аналог значения <em>false</em> в Java, а <em>1</em> — значения <em>true</em>.

<center><em>Таблица 5. Таблица истинности оператора отрицания (NOT)</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 7" src="https://cdn.javarush.com/images/article/d7032050-a36a-441e-b3ce-5f11fef9fab0/original.jpeg"><center><em>Таблица 6. Таблица истинности оператора конъюнкции (AND)</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 8" src="https://cdn.javarush.com/images/article/c36c6a30-6473-4a6c-8762-2aeb901d80bf/1024.jpeg"><center><em>Таблица 7. Таблица истинности оператора дизъюнкции (OR)</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 9" src="https://cdn.javarush.com/images/article/16baeeba-904a-4f84-a1cb-6118e277b55c/original.jpeg"><center><em>Таблица 8. Таблица истинности оператора сложения по модулю (XOR)</em></center><img data-max-width="1024" data-id="4c798cf5-810e-4fd6-872d-44ede6d5ed54" src="https://cdn.javarush.com/images/article/4c798cf5-810e-4fd6-872d-44ede6d5ed54/1024.jpeg" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 10">В Java есть те же логические операции:
<ul>
<li><code>!</code> — оператор отрицания;</li>
<li><code>&amp;&amp;</code> — оператор логическое И (сокращенный);</li>
<li><code>||</code> — оператор логическое ИЛИ (сокращенный);</li>
<li><code>&amp;</code> — оператор побитовое И;</li>
<li><code>|</code> — оператор побитовое ИЛИ;</li>
<li><code>^</code> — оператор побитовое  исключающее ИЛИ.</li>
</ul>Разницу между побитовыми и сокращенными операторами рассмотрим чуть ниже, пока давай преобразуем все таблицы истинности в Java код:
 
<pre class="lang-java line-numbers"><code>
public class LogicDemo {

   public static void main(String[] args) {
    notExample();
    andExample();
    orExample();
    xorExample();
   }

   public static void notExample() {
    System.out.println("NOT EXAMPLE:");
    System.out.println("NOT false = " + !false);
       System.out.println("NOT true  = " + !true);
    System.out.println();
   }

   public static void andExample() {
    System.out.println("AND EXAMPLE:");
    System.out.println("false AND false = " + (false &amp; false));
    System.out.println("false AND true  = " + (false &amp; true));
    System.out.println("true  AND false = " + (true &amp; false));
    System.out.println("true  AND true  = " + (true &amp; true));
    System.out.println();
   }

   public static void orExample() {
    System.out.println("OR EXAMPLE:");
    System.out.println("false OR false = " + (false | false));
    System.out.println("false OR true  = " + (false | true));
    System.out.println("true  OR false = " + (true | false));
     System.out.println("true  OR true  = " + (true | true));
    System.out.println();
   }

   public static void xorExample() {
    System.out.println("XOR EXAMPLE:");
    System.out.println("false XOR false = " + (false ^ false));
    System.out.println("false XOR true  = " + (false ^ true));
    System.out.println("true  XOR false = " + (true ^ false));
    System.out.println("true  XOR true  = " + (true ^ true));
    System.out.println();
   }
}
</code></pre>
Данная программа выведет на экран:

<em>NOT EXAMPLE:
NOT false = true
NOT true  = false

AND EXAMPLE:
false AND false = false
false AND true  = false
true  AND false = false
true  AND true  = true

OR EXAMPLE:
false OR false = false
false OR true  = true
true  OR false = true
true  OR true  = true

XOR EXAMPLE:
false XOR false = false
false XOR true  = true
true  XOR false = true
true  XOR true  = false</em>

Логические операторы применимы только к <code>boolean</code> переменным. В нашем случае мы применяли их сразу к значениям, но можно их использовать и с <code>boolean</code> переменными:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738103013.gif" width="514" height="445" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 15"></center>
И к <code>boolean</code> выражениям:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738145913.gif" width="606" height="445" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 16"></center>
Теперь, у нас есть сокращенные операторы (<code>&amp;&amp;</code>, <code>||</code>) и аналогичные побитовые операторы (<code>&amp;</code>, <code>|</code>). В чем между ними разница?
 
Во-первых, побитовые можно применять к целым числам. Об этом мы поговорим чуть позже.
 
А во-вторых, одни сокращенные, а другие — нет. Чтобы понять, как выглядит сокращенность, посмотрим на выражение:
 
<pre><code>
false AND x = ?
true OR x = ?
</code></pre>
Здесь <code>x</code> может принимать любое булево значение. И в целом, согласно законам логики и таблицам истинности, независимо от того, будет <code>x</code> <em>true</em> или <em>false</em>, результатом первого выражения будет <em>false</em>, а результатом второго будет <em>true</em>. Смотри.

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738177183.gif" width="522" height="522" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 17"></center>
Иногда результат выражения можно вычислить уже по первому операнду. Этим и отличаются сокращенные операторы <code>&amp;&amp;</code> и <code>||</code>. В выражениях, аналогичных описанным выше, они не вычисляют значение второго операнда. Вот небольшой пример:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738195986.gif" width="533" height="584" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 18"></center>
В случае с сокращенными операторами не вычисляется вторая часть выражения. Но происходит это только тогда, когда результат выражения очевиден уже по первому операнду. 
<h2 id="Побитовые-операции-в-Java">Побитовые операции в Java</h2>Ну вот мы и подобрались к самому интересному: побитовым операциям. Как можно понять из названия, это операции, которые производятся над битами. Но прежде чем мы погрузимся в эту тему, стоит поговорить о смежных областях.
<h3>Представление чисел в двоичной системе счисления</h3>Числа, как и любая другая информация в программе, хранятся в памяти компьютера в двоичном коде. Двоичный код — набор нулей и единиц. Каждый ноль или единица представляют собой единицу измерения информации, которая называется бит.
<h4>Согласно Википедии:</h4>Бит (от англ. binary digit — двоичное число; также игра слов: англ. bit — кусочек, частица) — единица измерения количества информации. 1 бит информации — это символ или сигнал, который может принимать два значения: включено или выключено, да или нет, высокий или низкий, заряженный или незаряженный; в двоичной системе исчисления это 1 (единица) или 0 (ноль).
<h3>С какими данными работают побитовые операторы?</h3>Побитовые операции в Java осуществляются только над целыми числами. А целые числа хранятся в памяти компьютера в виде набора битов. Можно сказать, что компьютер переводит любую информацию в двоичную систему счисления (в набор битов) и только потом взаимодействует с ней.
 
Но как устроена двоичная система счисления?
 
В десятичной системе счисления у нас есть всего 10 символов: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. С помощью этих символов мы ведем счет. После 9 идет 10, после 19 — 20, после 99 — 100, после 749 — 750. То есть мы используем комбинацию имеющихся 10 символов и можем с их помощью считать «от нуля и до обеда».
 
В двоичной системе счисления вместо десяти символов есть всего два — 0, 1. Но комбинируя эти символы по тому же принципу, что и в десятичной системе, можем считать бесконечно долго.  

<center><em>Продемонстрируем счет от 0 до 15 в десятичной системе и в двоичной:</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 11" src="https://cdn.javarush.com/images/article/ac241c7f-9d09-4c1b-83c2-7ef2dc4703a5/original.jpeg">Как видим, все не так уж и сложно.
 
Помимо битов, есть другие знакомые единицы измерения информации — <em>байты</em>, <em>килобайты</em>, <em>мегабайты</em>, <em>гигабайты</em> и тд.
 
Ты, наверно, знаешь, что <em>в 1 байте — 8 бит</em>. Что это значит? Это значит, что 8 битов подряд занимают 1 байт. Вот примеры, какими могут быть байты:
 
<pre><code>
00000000 - 1 байт
10110010 - 1 байт
01011011 - 1 байт
</code></pre>
Количество возможных неповторяющихся комбинаций битов в одном байте — 256 (2<sup>8</sup> = 256).

Но вернемся ближе к Java. Есть такой целочисленный тип данных — <code>byte</code>. Данный тип может принимать значения от -128 до 127 и одно число в памяти компьютера занимает ровно 8 бит, или 1 байт. Одно число этого типа занимает ровно 1 <code>byte</code> памяти компьютера. И здесь названия совпадают не случайно.
 
Как мы помним, 1 байт может хранить 256 различных значений. И одно число типа <code>byte</code> может принимать 256 различных значений (128 отрицательных, 127 положительных и 1 ноль).
 
Каждому значению числа <code>byte</code> соответствует уникальный набор из восьми битов. Так обстоят дела не только с типом <code>byte</code>, но и со всеми целочисленными типами. Тип <code>byte</code> приведен в пример как самый маленький. Ниже в таблице представлены все целочисленные типы Java и занимаемое ими место в памяти:
<img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 12" src="https://cdn.javarush.com/images/article/3f53b58a-9f56-4322-82f7-4ecccf861ad4/1024.jpeg">Рассмотрим тип <code>int</code>. Он может хранить 2147483648 отрицательных, 2147483647 положительных значений и один ноль. Итого:
 
<pre><code>
2147483648 + 2147483647 + 1 = 4294967296.
</code></pre>
Данный тип занимает в памяти компьютера 32 бита. Количество возможных комбинаций из набора 32-ух нулей и единиц равно:
 
<pre><code>
2<sup>32</sup> = 4294967296.
</code></pre>
То же число, что и у количества значений, вмещаемых в тип <code>int</code>.
 
Это всего лишь демонстрация взаимосвязи между диапазоном значений типа данных и его размером (количество бит в памяти).
 
Любое число любого типа в Java можно перевести в двоичную систему счисления. Давай посмотрим, как легко это можно сделать это с помощью Java языка.
 
Будем учиться на примере типа <code>int</code>. У данного типа есть свой класс-обертка — <code>Integer</code>. А у него — <code>toBinaryString</code>, который и сделает за нас всю работу:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738209148.gif" width="825" height="393" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 21"></center>
Вуаля — все не так уж и сложно. Но все-таки кое-что следует уточнить. <code>int</code> число занимает 32 бита. Но когда мы выводим число 10 в примере выше, мы видим в консоли 1010. Это потому, что ведущие нули не выводятся на печать. Если бы они выводились, вместо 1010 мы бы видели в консоли 00000000000000000000000000001010. Но для удобства восприятия все ведущие нули опускаются.
 
Не так уж и сложно до тех пор, пока не задашься вопросом: а что с отрицательными числами?

Он воспринимает информацию только в двоичной системе. Получается, что знак минус также необходимо прописывать двоичным кодом. Это можно сделать с помощью прямого или дополнительного кода.
<h3>Прямой код</h3>Способ представления чисел в двоичной системе счисления, при котором старший разряд (крайний левый бит) отводится под знак числа. Если число положительное, в крайний левый бит записывается 0, если отрицательное — 1.

<center><em>Рассмотрим это на примере 8-ми битного числа:</em></center><img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 13" src="https://cdn.javarush.com/images/article/bf88eef7-8d01-4b01-aece-03e3d5ca1c58/original.jpeg">Подход несложный и в принципе понятный. Однако у него есть недостатки: возникают трудности с выполнением математических операций. К примеру со сложением отрицательных и положительных чисел. Их нельзя складывать, если не провести дополнительные манипуляции.
<h3>Дополнительный код</h3>Используя дополнительный код, можно избежать недостатков прямого кода. Для получения дополнительного кода числа есть несложный алгоритм.

Попробуем получить дополнительный код числа -5. Представим это число с помощью дополнительного кода в двоичной системе счисления.

Шаг 1. Получаем представление отрицательного числа с помощью прямого кода. Для -5 это будет 10000101.
 
Шаг 2. Инвертируем все разряды, кроме разряда знака. Заменим все нули на единицы, а единицы на нули везде, кроме крайнего левого бита.

<pre><code>
10000101 =&gt; 11111010
</code></pre>
Шаг 3. К полученному значению прибавим единицу:

<pre><code>
11111010 + 1 = 11111011
</code></pre> 
Готово. Мы получили значение числа -5 в двоичной системе счисления с использованием дополнительного кода.
 
Это важно для понимания дальнейшего материала, так как в Java для хранения отрицательных чисел в битах используется дополнительный код.
<h2 id="Типы-побитовых-операций">Типы побитовых операций</h2>Теперь, когда мы разобрались со всеми вводными, поговорим о побитовых операциях в Java.
 
Побитовая операция осуществляется над целыми числами, и ее результатом будет целое число. В процессе число переводится в двоичную систему, над каждым битом выполняется операция, и результат приводится обратно в десятичную систему.
 
Список операций — в таблице ниже:
<img data-max-width="1024" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 14" src="https://cdn.javarush.com/images/article/69429221-dae5-47f8-a8ca-48674eff2f6e/original.jpeg">Как мы уже выяснили числа можно представить в виде набора битов. Побитовые операции осуществляют операции как раз над каждым битом такого представления.

Возьмем <code>NOT</code>, <code>AND</code>, <code>OR</code>, <code>XOR</code>. Вспомним, что недавно мы рассматривали таблицы истинности, только для логических операндов. В данном случае те же операции применяются к каждому биту целого числа.
<h3>Побитовый унарный оператор NOT ~</h3>Данный оператор заменяет все нули на единицы, а единицы — на нули. Предположим, у нас есть число 10 в десятичной системе исчисления. В двоичной системе это число равно 1010. Если применить к данному числу унарный побитовый оператор отрицания, мы получим примерно следующее:
<img data-max-width="265" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 15" src="https://cdn.javarush.com/images/article/16e7c459-501a-4441-98a8-12d4090f2da8/original.jpeg">Давай взглянем как это выглядит в Java коде:
 
<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
   int a = 10;

   System.out.println(" a = " + a + "; binary string: " + Integer.toBinaryString(a));
   System.out.println("~a = " + ~a + "; binary string: " + Integer.toBinaryString(~a));
}
</code></pre>
Теперь посмотрим, что выведется в консоль:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738220058.gif" width="828" height="453" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 25"></center>
В первой строке мы получили значение в двоичной системе счисления без ведущих нулей. Хоть мы их не видим, они есть. Об этом говорит вторая строка, в которой все биты трансформировались в обратные. Именно поэтому мы видим так много ведущих единиц. Это бывшие ведущие нули, которые игнорировались компилятором при выводе в первой строки.
 
Вот небольшая программа, которая выводит для наглядности еще и ведущие нули.

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738276923.gif" width="711" height="709" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 26"></center><h3>Побитовый оператор AND</h3>Данный оператор применим к двум числам. Он производит операцию <code>AND</code> между битами каждого числа. Рассмотрим пример:
<img data-max-width="266" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 16" src="https://cdn.javarush.com/images/article/9569f388-3d97-47df-8529-238eab6eb7af/original.jpeg">Данная операция осуществляется над двумя числами. Пример в Java коде:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738289334.gif" width="819" height="424" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 28"></center><h3>Побитовый оператор OR</h3>OR применим к двум числам. Он производит операцию OR между битами каждого числа:
<img data-max-width="265" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 17" src="https://cdn.javarush.com/images/article/99f418be-4d04-4b1d-8e75-65b0aa23726f/original.jpeg">Теперь взглянем на то, как бы это выглядело в IDEA:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738302264.gif" width="819" height="424" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 30"></center>
<h3>Побитовая операция, исключающее ИЛИ (XOR)</h3>Взглянем на тот же пример, но с новой операцией:
<img data-max-width="266" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 18" src="https://cdn.javarush.com/images/article/2201b0e7-c013-46ec-b902-aaa3100510c9/original.jpeg">Пример кода:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738323975.gif" width="819" height="424" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 32"></center><h3>Побитовый сдвиг влево</h3>Данный оператор применим к двум операндам, то есть в операции <code>x &lt;&lt; y</code>, биты числа <code>x</code> сдвинутся на <code>y</code> позиций влево.
 
Что это значит? Рассмотрим на примере операции <code>10 &lt;&lt; 1</code>
<img data-max-width="650" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 19" src="https://cdn.javarush.com/images/article/727865e7-1477-4673-8ed3-d5adcd6241b3/original.jpeg">Результатом операции будет число 20 в десятичной системе.
 
Как видно из схемы выше, все биты сдвигаются влево на 1. При этой операции значение старшего бита (крайнего левого) теряется. А самый младший бит (крайний правый) заполняется нулем.
 
Что можно сказать об этой операции? 
<ol>
<li><p>Сдвигая биты числа <code>X</code> на <code>N</code> битов влево мы умножаем число <code>X</code> на 2<sup>N</sup>.</p>
<p>Вот пример:</p>

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738337358.gif" width="563" height="542" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 34"></center></li>
<li><p>Но! У нас может измениться знак числа, если бит со значением 1 займет крайнее левое положение.</p></li>
<li><p>Если осуществлять сдвиг влево бесконечно долго, число просто превратится в 0. Продемонстрируем пункты 2 и 3:</p>
<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738359433.gif" width="541" height="819" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 35"></center></li>
</ol><h3>Побитовый сдвиг вправо</h3>Данный оператор применим к двум операндам. Т.е. в операции <code>x &gt;&gt; y</code>, биты числа <code>x</code> сдвинутся на <code>y</code> позиций вправо.

Рассмотрим другой пример. Схематично разберем операцию <code>10 &gt;&gt; 1</code>. Сдвинем все биты числа 10 на одну позицию вправо:
<img data-max-width="650" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 20" src="https://cdn.javarush.com/images/article/091dad90-f41e-4c23-9722-29efdcf15b21/original.jpeg">При операции сдвига мы теряем правые биты. Они попросту исчезают.
 
Крайний левый бит — показатель знака числа (0 — число положительное, 1 — отрицательное). Поэтому в итоговом значении он ставится таким же, как и в исходном числе. Пример с отрицательным числом:
<img data-max-width="650" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 21" src="https://cdn.javarush.com/images/article/40672850-4560-4f39-9907-0761baa32be9/original.jpeg">Крайний правый бит потерялся, а крайний левый бит скопирован из исходного числа, как почетный показатель знака числа.

Как это все осуществить в IDEA? В принципе, ничего сложного, просто берем и сдвигаем:

<center><img src="https://pics.esputnik.com/repository/home/37116/images/msg/41711174/1559738376872.gif" width="819" height="424" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 38"></center>Теперь. Что можно сказать о числах, над которыми осуществляется сдвиг вправо? Они делятся на 2. Каждый раз, осуществляя сдвиг на один бит вправо мы делим исходное число на 2. Если число нацело на 2 не делится, результат будет округлен в сторону минус бесконечности (в меньшую сторону).

Но это работает, только если мы сдвигаем биты ровно на 1.
А если на 2 бита, делим на 4.
На 3 бита — делим на 8.
На 4 бита — на 16.
Видишь? Степени двойки…

При сдвиге числа <code>X</code> на <code>N</code> битов вправо, мы делим число <code>X</code> на 2 в степени <code>N</code>.

Демонстрация:

<pre class="lang-java line-numbers"><code>
public class BitOperationsDemo {

   public static void main(String[] args) {

    for (int i = 1; i &lt;= 10; i++) {

        int shiftOperationResult = 2048 &gt;&gt; i;
        int devideOperationResult = 2048 / (int) Math.pow(2, i);


           System.out.println(shiftOperationResult + " - " + devideOperationResult);
    }

   }

}
</code></pre>
Что тут происходит?
<ol>
<li><p>Цикл, в котором переменная i наращивается от 1 до 10.</p></li>
<li>Каждую итерацию мы вычисляем 2 значения:</li>
<ul><li><p>в переменную <code>shiftOperationResult</code> записываем результат сдвига числа 2048 на i битов вправо;</p></li>
<li><p>в переменную <code>devideOperationResult</code> записываем результат деления числа 2048 на 2 в степени i.</p></li>
</ul>
<li><p>Попарно выводим два полученных значения.</p></li></ol>Результат выполнения программы таков:
 
<em>1024 - 1024
512 - 512
256 - 256
128 - 128
64 - 64
32 - 32
16 - 16
8 - 8
4 - 4
2 - 2</em>
<h3>Побитовый сдвиг вправо с заполнением нулями</h3>Если обычный сдвиг битов вправо сохраняет знак числа (старший бит сохраняет свое значение), в случае со сдвигом вправо с заполнением нулями этого не происходит. А происходит заполнение старшего бита нулем. Давай посмотрим, как это выглядит:
<img data-max-width="800" src="/images/article/c820c7f5-1cf3-4917-814a-2e4ec737f655/original.jpeg" class="img-fluid" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 22"><h3 id="Приоритет-операций-в-Java">Приоритет операций в Java</h3>Как и в математике, в Java есть приоритет операций. В таблице ниже приведен приоритет (от высшего к низшему)  рассмотренных нами операций. 
<img data-max-width="800" src="/images/article/ced4f04c-6e9c-47ae-82b4-8412751584b5/original.jpeg" class="img-fluid" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 23"><h3 id="Полезные-примеры-использования">Полезные примеры использования </h3><h4>Определение четности числа</h4><img data-max-width="1024" src="/images/article/3a8719c1-24f1-4930-90c7-5c09944e90ae/original.jpeg" class="img-fluid" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 24"><h4>Поиск максимального элемента в массиве</h4><img data-max-width="1024" src="/images/article/2d3716f8-efc9-4f2d-b3ad-656d487f29f7/original.jpeg" class="img-fluid" alt="Знакомство с операторами Java: логические, арифметические, побитовые - 25">Для поиска минимального элемента просто меняем знак сравнения в нужном месте.