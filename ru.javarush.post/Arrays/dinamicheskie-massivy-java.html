Динамические массивы в Java
<p>----------------------------------------</p>
В этой статье рассмотрим, как устроены динамические массивы, их функции, а также классы ArrayList и LinkedList, которые выполняют в Java роль этого типа массивов. При создании программ разной степени сложности каждый разработчик использует множество типов данных...
<p>----------------------------------------</p>
При создании программ разной степени сложности каждый разработчик использует множество типов данных, в том числе и массивы. Эта структура хорошо подходит для хранения набора одного типа, дает классную производительность, да и в целом удобна. 

<img data-id="b40148de-d28c-4bd1-bb6b-57f77cdd7390" data-max-width="850" alt="Динамические массивы в Java - 1" src="https://cdn.javarush.com/images/article/b40148de-d28c-4bd1-bb6b-57f77cdd7390/1024.jpeg">Существенный минус массивов — статичность: необходимо заранее задавать их размер. Однако программисты пока не умеют предсказывать будущее (если, конечно, не появится ИИ, который будет обрабатывать информацию невероятно быстро и сможет предугадывать какие-либо события). По этой причине создали структуру, которая сможет изменять размер в момент работы программы. Она получила название <strong>динамический массив</strong>.
<h2>Динамические массивы в курсе JavaRush</h2><p>Очень доходчиво и понятно эта тема <a href="https://javarush.com/quests/lectures?quest=QUEST_JAVA_SYNTAX&amp;level=7" target="_blank">раскрывается на 7</a> и частично — <a href="https://javarush.com/quests/lectures?quest=QUEST_JAVA_SYNTAX&amp;level=8" target="_blank">на 8 уровне</a> курса JavaRush в квесте Java Syntax. В течение нескольких лекций и целых 18 задач раскрываются ключевые вопросы, виды динамических массивов и разница между ними, включая производительность. Эта тема максимально важная, так как динамические массивы избавляют разработчика от депрессии, головной боли и экономят невероятное количество времени.</p>
<h2>Что такое динамический массив?</h2><strong>Динамический массив</strong> — это массив, который умеет изменять свой размер во время выполнения программы. В Java эту роль играют в основном классы ArrayList и LinkedList. 

В отличие от массивов, ArrayList и LinkedList содержат только ссылочные типы данных, то есть сохранить в них можно только объекты. К счастью, в Java существуют механизмы автоупаковки и автораспаковки, которые позволяют хранить в динамических массивах примитивные типы.

Подобно статическому массиву, динамический однороден, то есть может хранить один-единственный тип данных. Однако, благодаря механизму наследования и грамотному использованию интерфейсов, можно сохранять в одном динамическом массиве целый спектр разнообразных классов, которые унаследованы от одного общего, но об этом ниже.

То есть статический массив работает так:
<img data-id="daf20a64-274b-4fc4-a377-a565ac2434da" data-max-width="850" alt="Динамические массивы в Java - 2" src="https://cdn.javarush.com/images/article/daf20a64-274b-4fc4-a377-a565ac2434da/1024.jpeg">А <strong>динамический массив в Java</strong> сработает следующим образом (продолжаем схему с третьего шага):
<img data-id="b74968a8-b692-4020-9aac-e7e5250b5b55" data-max-width="850" alt="Динамические массивы в Java - 3" src="https://cdn.javarush.com/images/article/b74968a8-b692-4020-9aac-e7e5250b5b55/1024.jpeg">В Java используется специальная <strong>нативная</strong> функция для копирования массива, поэтому такой “переезд” обходится не очень дорого.
<h2>Зачем нужен динамический массив?</h2><strong>Динамический массив в Java</strong> используется для обработки наборов однородных данных, размер которых неизвестен на момент написания программы. 

Например, нужно сохранить в кэше данные каждого клиента, который в данный момент использует приложение. Невозможно предсказать количество таких клиентов заранее.

Без динамических массивов эту проблему можно решить следующими вариантами:
<ol>
<li>Создать массив большого размера, который с вероятностью в 100% покроет потребность;</li>
<li>Создать статический массив, который будет выполнять функцию буфера;</li>
<li>Применить другие динамические структуры, например, множества.</li>
</ol>Первый вариант подойдет только в случае жестко ограниченного диапазона. В остальных случаях такой массив займет большое место в памяти, что максимально неэффективно.

Второй потребует реализации дополнительных механик очистки буфера, считывания и так далее. У третьего также есть недостатки из-за различия в функциональности.
<h2>Что выполняет работу динамического массива в Java</h2>В языке Java в качестве динамического массива выступают классы ArrayList и LinkedList. Чаще всего используется ArrayList, так как он выполняет роль классического массива, в отличие от LinkedList, который реализует концепцию двусвязанного списка. О нем речь пойдет немного позже.
<h2>ArrayList, LinkedList — понятия и правила работы</h2>ArrayList — это классический массив, который может расширяться в момент выполнения программы. В его основе лежит обычный массив: его размер при создании — 10 элементов. При увеличении размера емкость увеличивается.

Правила, по которым работает ArrayList:
<ul>
<li>Так же, как и статический массив, индексируется с 0;</li>
<li>Вставка в конец и доступ по индексу очень быстрые — О(1);</li>
<li>Чтобы вставить элемент в начало или середину, понадобится скопировать все элементы на одну ячейку вправо, а затем вставить новый элемент на необходимую позицию;</li>
<li>Доступ по значению зависит от количества элементов — О(n);</li>
<li>В отличие от классического массива, может хранить null;</li>
</ul>В случае с LinkedList все немного сложнее: в его основе лежит двусвязанный список. То есть структурно этот <strong>динамический массив Java</strong> представляет из себя некоторое количество разбросанных объектов, которые ссылаются друг на друга. Легче объяснить на рисунках.

Внутри LinkedList у нас есть главный объект — <code>Head</code>, который хранит информацию о количестве элементов, а также ссылку на первый и последний элементы:
<img data-id="aacc5b05-f7b5-4555-9787-766670051764" data-max-width="850" alt="Динамические массивы в Java - 4" src="https://cdn.javarush.com/images/article/aacc5b05-f7b5-4555-9787-766670051764/1024.jpeg">Сейчас поле <code>size = 0</code>, а <code>first</code> и <code>last = null</code>. Каждый элемент, который добавляется в этот список, — содержимое отдельного внутреннего объекта. Давай добавим элемент <code>Johnny</code>:
<img data-id="94380a69-0fc5-491a-bf7e-3bc94b56d9e5" data-max-width="850" alt="Динамические массивы в Java - 5" src="https://cdn.javarush.com/images/article/94380a69-0fc5-491a-bf7e-3bc94b56d9e5/1024.jpeg">Теперь у нас появилась нода со значением “Johnny”. У главного элемента ссылки на первый и последний элемент указывают на новую ноду. У этого объекта также есть ссылки на предыдущий и следующий элементы. Ссылка на предыдущий у него всегда будет null, так как это первый элемент, а ссылка на следующий — null, потому что его пока нет. Давай это исправим:
<img data-id="6bc56b53-34aa-431a-87ff-a87bed0a0730" data-max-width="850" alt="Динамические массивы в Java - 6" src="https://cdn.javarush.com/images/article/6bc56b53-34aa-431a-87ff-a87bed0a0730/1024.jpeg">Добавлен новый элемент, со значением “Watson”, который стал вторым. Следует обратить внимание, что у первого элемента поле <code>next</code> указывает на следующий элемент, а у нового поле <code>previous</code> указывает на предыдущий. У главного элемента ссылка на последний элемент указывает теперь на новую ноду.

На следующей схеме показан принцип добавления элементов в середину списка:
<img data-id="90bc2953-931f-4e8f-ba82-93076b0444b5" data-max-width="850" alt="Динамические массивы в Java - 7" src="https://cdn.javarush.com/images/article/90bc2953-931f-4e8f-ba82-93076b0444b5/1024.jpeg">Был добавлен новый элемент “Hamish”. Чтобы вставить его в середину списка, достаточно переприсвоить ссылки на элементы, как показано на рисунке.

Данные иллюстрации объясняют процесс работы двусвязного списка на верхнем уровне, не вдаваясь в подробности.

Подводя итог рассказу о LinkedList, можно вывести несколько правил его работы:
<ul>
<li>Так же, как и массив, индексируется с 0;</li>
<li>Доступ к первому и последнему элементу не зависят от количества элементов — О(1);</li>
<li>Получение элемента по индексу, вставка или удаление из середины списка зависят от количества элементов — О(n);</li>
<li>Можно использовать механизм итератора: тогда вставка и удаление будут происходить за константное время;</li>
<li>В отличие от классического массива, может хранить null.</li>
</ul><div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><h2>Примеры кода</h2>Пройдемся немного по примерам. Фрагменты кода включают в себя примеры как для ArrayList, так и для LinkedList.
<h3>Создание</h3><pre class="lang-java line-numbers"><code>
// Создаем новый список
ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
// Создается новый список и указывается начальный размер внутреннего массива
ArrayList&lt;String&gt; arrayListLarge = new ArrayList&lt;&gt;(100000);

// Создаем новый LinkedList
LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();
</code></pre><h3>Добавление элемента</h3><pre class="lang-java line-numbers"><code>
// Новый элемент добавляется в конец
arrayList.add("Johhny");
// Новый элемент добавляется в указанную позицию (в данном случае — в начало)
arrayList.add(0, "Watson");

// Новый элемент добавляется в конец двусвязного списка
linkedList.add("Java");
// Новый элемент добавляется в нулевую позицию списка:
linkedList.addFirst("I think");
// Новый элемент добавляется в конец списка
linkedList.addLast("language");
// Новый элемент добавляется в указанную позицию
linkedList.add(2, "is a terrific");

// Получение размера списков
int arraySize = arrayList.size(); // 2
int linkedSize = linkedList.size(); // 4
</code></pre>
На первый взгляд методы <code>add()</code> И <code>addLast()</code> выполняют один и тот же функционал, однако метод <code>add()</code> пришел в LinkedList из интерфейса <code>List</code>, а метод <code>addLast</code> — из интерфейса <code>Deque</code>. LinkedList реализует оба этих интерфейса.

Хорошей практикой в данном случае будет использовать тот метод, который больше подходит по контексту. Если LinkedList используется в качестве очереди, то лучше всего использовать метод <code>addLast</code>. Если LinkedList используется как список, уместно будет использовать <code>add()</code>.
<h3>Удаление элемента</h3><pre class="lang-java line-numbers"><code>
// Удаление элемента по индексу
arrayList.remove(0);
// Удаление элемента по значению
arrayList.remove("Johnny");

// Удаление первого элемента в списке
linkedList.removeFirst();
// Удаление первого элемента в списке, фактически вызов предыдущего метода
linkedList.remove();
// Удаление последнего элемента в списке
linkedList.removeLast();
// Удаление первого вхождения элемента в список
linkedList.removeFirstOccurrence("language");
// Удаление последнего вхождения элемента в список
linkedList.removeLastOccurrence("Java");
// Удаление по индексу
linkedList.remove(2);
</code></pre>
Если происходит удаление объекта по индексу, метод возвращает удаленный объект.

Если объект удаляется по значению (или у LinkedList удаляется первый или последний элементы), метод возвращает <em>true</em>, если объект найден и удален, <em>false</em> — в ином случае.
<h3>Доступ к элементу и поиск в списке</h3><pre class="lang-java line-numbers"><code>
// Доступ к элементу по индексу
String arrayElement = arrayList.get(2);
// Поиск элемента по значению
int arrayIndex = arrayList.indexOf("Watson");
// Поиск последнего индекса вхождения элемента в список
int lastArrayIndex = arrayList.lastIndexOf("Watson");

// Доступ по индексу
String linkedElement = linkedList.get(3);
// Получение первого элемента
String firstLinkedElement = linkedList.getFirst();
// Получение последнего элемента
String lastLinkedElement = linkedList.getLast();

// Поиск элемента по значению
int linkedIndex = linkedList.indexOf("Java");
// Поиск последнего индекса вхождения элемента в список
int lastLinkedIndex = linkedList.lastIndexOf("Java");
</code></pre><h3>Обход в цикле</h3><pre class="lang-java line-numbers"><code>
// Использование обычного цикла
for(int i = 0; i&lt;arrayList.size(); i++) {
  String value = arrayList.get(i);
  System.out.println(value);
}

for(int i = 0; i&lt;linkedList.size(); i++) {
  String value = linkedList.get(i);
  System.out.println(value);
}

// Использование цикла for-each
for(String s : arrayList) {
  System.out.println(s);
}

for(String s : linkedList) {
  System.out.println(s);
}
</code></pre>
Здесь стоит сказать пару слов о поиске. Многие начинающие разработчики при поиске элемента в списке начинают поиск в цикле, сравнивая все элементы с искомым, несмотря на наличие методов <code>indexOf()</code> и <code>lastIndexOf()</code>.

Также можно использовать метод <code>contains()</code> для получения факта наличия элемента в списке:

<pre class="lang-java line-numbers"><code>
boolean isContainsSherlock = arrayList.contains("Sherlock");
boolean isContainsPhp = linkedList.contains("Php");
</code></pre><h2>Ссылки на дополнительное чтение</h2><ol>
<li><a href="https://javarush.com/groups/posts/1935-udalenie-ehlementa-iz-spiska-arraylist" target="_blank">Вот тут есть отличная статья</a> про удаление элементов из ArrayList. За счет того, что это <strong>динамический массив Java</strong>, есть много тонкостей в удаление элементов.</li>
<li><a href="https://javarush.com/groups/posts/1936-rabota-arraylist-v-kartinkakh--" target="_blank">Здесь</a> подробно иллюстрирована работа ArrayList.</li>
<li><a href="https://javarush.com/groups/posts/1938-linkedlist" target="_blank">Немного подробнее</a> о LinkedList.</li>
<li>Пара статей с хабра об <a href="https://habr.com/ru/post/128269/" rel="nofollow" target="_blank">ArrayList</a> и <a href="https://habr.com/ru/post/127864/" rel="nofollow" target="_blank">LinkedList</a>.</li></ol>