Сложность алгоритмов
<p>----------------------------------------</p>
Привет! Сегодняшняя лекция будет немного отличаться от остальных. Отличаться она будет тем, что имеет лишь косвенное отношение к Java. Тем не менее, эта тема очень важна для каждого программиста. Мы поговорим об алгоритмах. Что такое алгоритм? Говоря простым языком...
<p>----------------------------------------</p>
Привет!

Сегодняшняя лекция будет немного отличаться от остальных. Отличаться она будет тем, что имеет лишь косвенное отношение к Java.

<img data-max-width="800" data-id="6f3c8c4e-be9d-4c36-9eda-64086b94e507" src="/images/article/6f3c8c4e-be9d-4c36-9eda-64086b94e507/800.jpeg" class="img-fluid" alt="Сложность алгоритмов - 1">Тем не менее, эта тема очень важна для каждого программиста. Мы поговорим об <span class="text-bold">алгоритмах</span>.

Что такое алгоритм? 

Говоря простым языком, <span class="text-bold">это некоторая последовательность действий, которые необходимо совершить для достижения нужного результата</span>.

Мы часто используем алгоритмы в повседневной жизни.

Например, каждое утро перед тобой стоит задача: прийти на учебу или работу, и быть при этом:
<ul>
<li>Одетым</li>
<li>Чистым</li>
<li>Сытым</li>
</ul>Какой <span class="text-bold">алгоритм</span> позволит тебе добиться этого результата?
<ol>
   <li>Проснуться по будильнику.</li>
   <li>Принять душ, умыться.</li>
   <li>Приготовить завтрак, сварить кофе/заварить чай.</li>
   <li>Поесть.</li>
   <li>Если не погладил одежду с вечера — погладить.</li>
   <li>Одеться.</li>
   <li>Выйти из дома.</li>
</ol>Эта последовательность действий точно позволит тебе получить необходимый результат.

В программировании вся суть нашей работы заключается в постоянном решении задач. 

Значительную часть этих задач можно выполнить, используя уже известные алгоритмы.

К примеру, перед тобой стоит задача: <span class="text-bold">отсортировать список из 100 имен в массиве</span>.

Задача это довольно проста, но решить ее можно разными способами.

Вот один из вариантов решения:

<span class="text-bold">Алгоритм сортировки имен по алфавиту:</span>
<ol>
   <li>Купить или скачать в Интернете “Словарь русских личных имен” 1966 года издания.</li>
   <li>Находить каждое имя из нашего списка в этом словаре.</li>
   <li>Записывать на бумажку, на какой странице словаря находится имя.</li>
   <li>Расставить имена по порядку, используя записи на бумажке.</li>
</ol><span class="text-bold">Позволит ли такая последовательность действий решить нашу задачу?</span> Да, вполне позволит.

Будет ли это решение <span class="text-bold">эффективным</span>? Вряд ли.

Здесь мы подошли к еще одному очень важному свойству алгоритмов — их <span class="text-bold">эффективности</span>. 

Решить задачу можно разными способами. Но и в программировании, и в обычной жизни мы выбираем способ, который будет наиболее эффективным.

Если твоя задача — сделать бутерброд со сливочным маслом, ты, конечно, можешь начать с того, что посеешь пшеницу и подоишь корову. 

Но это будет <span class="text-bold">неэффективное</span> решение — оно займет очень много времени и будет стоить много денег.

Для решения твоей простой задачи хлеб и масло можно просто купить. А алгоритм с пшеницей и коровой хоть и позволяет решить задачу, слишком сложный, чтобы применять его на практике.

Для оценки сложности алгоритмов в программировании создали специальное обозначение под названием <span class="text-bold">Big-O (“большая О”)</span>.

<span class="text-bold">Big-O позволяет оценить, насколько время выполнения алгоритма зависит от переданных в него данных</span>.

Давай рассмотрим самый простой пример — передачу данных.

Представь, что тебе нужно передать некоторую информацию в виде файла на большое расстояние (например, 5000 километров).

Какой алгоритм будет наиболее эффективным?

Это зависит от тех данных, с которыми ему предстоит работать. К примеру, у нас есть аудиофайл размером 10 мегабайт.
<img data-max-width="800" data-id="c9ad6b49-836b-4619-9c00-faf40e401812" src="/images/article/c9ad6b49-836b-4619-9c00-faf40e401812/800.jpeg" class="img-fluid" alt="Сложность алгоритмов - 2">В этом случае, самым эффективным алгоритмом будет передать файл через Интернет. Это займет максимум пару минут!

Итак, давай еще раз озвучим наш алгоритм:

<span class="text-bold">“Если требуется передать информацию в виде файлов на расстояние 5000 километров, нужно использовать передачу данных через Интернет”.</span>

Отлично. Теперь давай проанализируем его.

<span class="text-bold">Решает ли он нашу задачу?</span> В общем-то да, вполне решает.

А вот что можно сказать насчет его сложности?

Хм, а вот тут уже все интереснее. Дело в том, что наш алгоритм очень сильно зависит от входящих данных, а именно — от размера файлов. 

Сейчас у нас 10 мегабайт, и все в порядке.

А что, если нам нужно будет передать 500 мегабайт?
20 гигабайт?
500 терабайт?
30 петабайт?

Перестанет ли наш алгоритм работать? Нет, все эти объемы данных все равно можно передать. 

<span class="text-bold">Станет ли он выполняться дольше?</span> Да, станет!

Теперь нам известна важная особенность нашего алгоритма: <span class="text-bold">чем больше размер данных для передачи, тем дольше времени займет выполнение алгоритма</span>.

Но нам хотелось бы более точно понимать, как выглядит эта зависимость (между размером данных и временем на их передачу).

В нашем случае сложность алгоритма будет <span class="text-bold">линейной</span>.

“Линейная” означает, что при увеличении объема данных время на их передачу вырастет примерно пропорционально. Если данных станет в 2 раза больше, и времени на их передачу понадобится в 2 раза больше. Если данных станет больше в 10 раз, и время передачи увеличится в 10 раз.

Используя обозначение Big-O, сложность нашего алгоритма определяется как <span class="text-bold">O(N)</span>. Это обозначение лучше всего запомнить на будущее — оно всегда используется для алгоритмов с линейной сложностью.

Обрати внимание: мы вообще не говорим здесь о разных “переменных” вещах: скорости интернета, мощности нашего компьютера и так далее. При оценке сложности алгоритма в этом просто нет смысла — мы в любом случае не можем это контролировать. <span class="text-bold">Big-O оценивает именно сам алгоритм, независимо от “окружающей среды” в которой ему придется работать.</span>

Продолжим работать с нашим примером. Допустим, в итоге выяснилось, что размер файлов для передачи составляет 800 терабайт.

Если мы будем передавать их через Интернет, задача, конечно, будет решена. Есть только одна проблема: передача по стандартному современному каналу (со скоростью 100 мегабит в секунду), который используется дома у большинства из нас, займет примерно 708 дней. 

<span class="text-bold">Почти 2 года! :O</span>

Так, наш алгоритм тут явно не подходит. Нужно какое-то другое решение!

Неожиданно на помощь к нам приходит IT-гигант — компания Amazon! Ее сервис Amazon Snowmobile позволяет загрузить большой объем данных в передвижные хранилища и доставить по нужному адресу на грузовике!
<img data-max-width="800" data-id="9b827fb9-6c82-4c1c-98d1-dc57783a7d6c" src="/images/article/9b827fb9-6c82-4c1c-98d1-dc57783a7d6c/800.jpeg" class="img-fluid" alt="Сложность алгоритмов - 3">Итак, у нас есть новый алгоритм!

<span class="text-bold">“Если требуется передать информацию в виде файлов на расстояние 5000 километров и этот процесс займет больше 14 дней при передаче через Интернет, нужно использовать перевозку данных на грузовике Amazon”.</span>

Цифра 14 дней здесь выбрана случайно: допустим, это максимальный срок, который мы можем себе позволить.

Давай проанализируем наш алгоритм. Что насчет скорости? Даже если грузовик поедет со скоростью всего 50 км/ч, он преодолеет 5000 километров всего за 100 часов. Это чуть больше четырех дней! Это намного лучше, чем вариант с передачей по интернету.

А что со сложностью этого алгоритма? Будет ли она тоже линейной, O(N)?

Нет, не будет. Ведь грузовику без разницы, как сильно ты его нагрузишь — он все равно поедет примерно с одной и той же скоростью и приедет в срок.
Будет ли у нас 800 терабайт, или в 10 раз больше данных, грузовик все равно доедет до места за 5 дней.

Иными словами, у алгоритма доставки данных через грузовик <span class="text-bold">постоянная сложность</span>. “Постоянная” означает, что она не зависит от передаваемых в алгоритм данных.

Положи в грузовик флешку на 1Гб — он доедет за 5 дней. Положи туда диски с 800 терабайтами данных — он доедет за 5 дней.

При использовании Big-O постоянная сложность обозначается как <span class="text-bold">O(1)</span>.

Раз уж мы познакомились с <span class="text-bold">O(N)</span> и <span class="text-bold">O(1)</span>, давай теперь рассмотрим более “программистские” примеры :)

Допустим, тебе дан массив из 100 чисел, и задача — вывести в консоль каждое из них.

Ты пишешь обычный цикл <code>for</code>, который выполняет эту задачу

<pre class="lang-java line-numbers"><code>
int[] numbers = new int[100];
// ..заполняем массив числами

for (int i: numbers) {
   System.out.println(i);
}
</code></pre>
Какая сложность у написанного алгоритма? <span class="text-bold">Линейная, O(N).</span>

Число действий, которые должна совершить программа, зависит от того, сколько именно чисел в нее передали.

Если в массиве будет 100 чисел, действий (выводов на экран) будет 100. Если чисел в массиве будет 10000, нужно будет совершить 10000 действий.

Можно ли улучшить наш алгоритм? Нет.

Нам в любом случае придется совершить <span class="text-bold">N проходов по массиву</span> и выполнить N выводов в консоль.

Рассмотрим другой пример.

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   LinkedList&lt;Integer&gt; numbers = new LinkedList&lt;&gt;();
   numbers.add(0, 20202);
   numbers.add(0, 123);
   numbers.add(0, 8283);
}
</code></pre>
У нас есть пустой <code>LinkedList</code>, в который мы вставляем несколько чисел. Нам нужно оценить сложность алгоритма вставки одного числа в <code>LinkedList</code> в нашем примере, и как она зависит от числа элементов, находящихся в списке.

Ответом будет <span class="text-bold">O(1) — постоянная сложность</span>. Почему?

Обрати внимание: каждый раз мы вставляем число в начало списка. К тому же, как ты помнишь, при вставке числа в <code>LinkedList</code> элементы никуда не сдвигаются — происходит переопределение ссылок (если вдруг забыл, как работает LinkedList, загляни в одну из наших <a href="https://javarush.com/groups/posts/1938-linkedlist" target="_blank">старых лекций</a>).

Если сейчас первое число в нашем списке — число <code>х</code>, а мы вставляем в начало списка число y, все, что для этого нужно:

<pre class="lang-java line-numbers"><code>
x.previous  = y;
y.previous = null;
y.next = x;
</code></pre>
Для этого переопределения ссылок <span class="text-bold">нам неважно, сколько чисел сейчас в <code>LinkedList</code></span> — хоть одно, хоть миллиард.

Сложность алгоритма будет постоянной — O(1).
<h2>Логарифмическая сложность</h2><span class="text-bold">Без паники! :)</span>

Если при слове “логарифмический” тебе захотелось закрыть лекцию и не читать дальше - подожди пару минут. Никаких математических сложностей здесь не будет (таких объяснений полно и в других местах), а все примеры разберем “на пальцах”.

Представь, что твоя задача — найти одно конкретное число в массиве из 100 чисел. Точнее, проверить, есть ли оно там вообще.

Как только нужное число найдено, поиск нужно прекратить, а в консоль вывести запись “Нужное число обнаружено! Его индекс в массиве = ....”

Как бы ты решил такую задачу?

Здесь решение очевидно: нужно перебрать элементы массива по очереди начиная с первого (или с последнего) и проверять, совпадает ли текущее число с искомым.

Соответственно, количество действий прямо зависит от числа элементов в массиве.

Если у нас 100 чисел, значит, нам нужно 100 раз перейти к следующему элементу и 100 раз проверить число на совпадение. Если чисел будет 1000, значит и шагов-проверок будет 1000.

Это очевидно линейная сложность, <span class="text-bold">O(N)</span>.

А теперь мы добавим в наш пример одно уточнение: <span class="text-bold">массив, в котором тебе нужно найти число, отсортирован по возрастанию</span>.

Меняет ли это что-то для нашей задачи? Мы по-прежнему можем искать нужное число перебором.

Но вместо этого мы можем использовать известный <span class="text-bold">алгоритм двоичного поиска</span>.
<img data-max-width="800" data-id="cff243f7-1b8e-45d3-8882-c73f60d732ca" src="https://cdn.javarush.com/images/article/cff243f7-1b8e-45d3-8882-c73f60d732ca/800.jpeg" alt="Сложность алгоритмов - 5">В верхнем ряду на изображении мы видим отсортированный массив. В нем нам необходимо найти число 23.

Вместо того, чтобы перебирать числа, мы просто делим массив на 2 части и проверяем среднее число в массиве. 

Находим число, которое располагается в ячейке 4 и проверяем его (второй ряд на картинке).

Это число равно 16, а мы ищем 23. Текущее число меньше. Что это означает? Что <span class="text-bold">все предыдущие числа (которые расположены до числа 16) можно не проверять</span>: они точно будут меньше того, которое мы ищем, ведь наш массив отсортирован!

Продолжим поиск среди оставшихся 5 элементов.

<mark>Обрати внимание:</mark> мы сделали всего одну проверку, но уже отмели половину возможных вариантов.

У нас осталось всего 5 элементов. Мы повторим наш шаг — снова разделим оставшийся массив на 2 и снова возьмем средний элемент (строка 3 на рисунке). Это число 56, и оно больше того, которое мы ищем.

Что это означает? Что мы отметаем еще 3 варианта — само число 56, и два числа после него (они точно больше 23, ведь массив отсортирован).

У нас осталось всего 2 числа для проверки (последний ряд на рисунке) — числа с индексами массива 5 и 6. 
Проверяем первое из них, и это то что мы искали — число 23! Его индекс = 5!

Давай рассмотрим результаты работы нашего алгоритма, а потом разберемся с его сложностью. (Кстати, теперь ты понимаешь, почему его называют двоичным: его суть заключается в постоянном делении данных на 2).

Результат впечатляет! Если бы мы искали нужное число линейным поиском, нам понадобилось бы 10 проверок, а с двоичным поиском мы уложились в 3!
В худшем случае их было бы 4, если бы на последнем шаге нужным нам числом оказалось второе, а не первое.

А что с его сложностью? Это очень интересный момент :)

<span class="text-bold">Алгоритм двоичного поиска гораздо меньше зависит от числа элементов в массиве, чем алгоритм линейного поиска (то есть, простого перебора).</span>

При <span class="text-bold">10</span> элементах в массиве линейному поиску понадобится максимум 10 проверок, а двоичному — максимум 4 проверки. Разница в 2,5 раза.

Но для массива в <span class="text-bold">1000 элементов</span> линейному поиску понадобится 1000 проверок, а двоичному — <span class="text-bold">всего 10</span>! Разница уже в 100 раз!

<mark>Обрати внимание:</mark> число элементов в массиве увеличилось в 100 раз (с 10 до 1000), а количество необходимых проверок для двоичного поиска увеличилось всего в 2,5 раза — с 4 до 10.

Если мы дойдем до <span class="text-bold">10000 элементов</span>, разница будет еще более впечатляющей: 10000 проверок для линейного поиска, и <span class="text-bold">всего 14 проверок</span> для двоичного.

И снова: число элементов увеличилось в 1000 раз (с 10 до 10000), а число проверок увеличилось всего в 3,5 раза (с 4 до 14).

<span class="text-bold">Сложность алгоритма двоичного поиска логарифмическая</span>, или,если использовать обозначения Big-O, — <span class="text-bold">O(log n)</span>. Почему она так называется?

Логарифм — это такая штуковина, обратная возведению в степень. Двоичный логарифм использует для подсчета степени числа 2.

Вот, например, у нас есть 10000 элементов, которые нам надо перебрать двоичным поиском.
<img data-max-width="850" alt="Сложность алгоритмов - 6" src="https://cdn.javarush.com/images/article/399a6189-5734-41fb-9dca-7871e86bfe59/original.jpeg">Сейчас у тебя есть картинка перед глазами, и ты знаешь что для этого нужно максимум 14 проверок. Но что если картинки перед глазами не будет, а тебе нужно посчитать точное число необходимых проверок?

Достаточно ответить на простой вопрос: <span class="text-bold">в какую степень надо возвести число 2, чтобы полученный результат был &gt;= числу проверяемых элементов?</span>

Для 10000 это будет 14 степень. 

2 в 13 степени — это слишком мало (8192)

А вот <span class="text-bold">2 в 14 степени = 16384</span>, это число удовлетворяет нашему условию (оно &gt;= числу элементов в массиве).

Мы нашли логарифм — 14. Столько проверок нам и нужно! :)

Алгоритмы и их сложность — тема слишком обширная, чтобы вместить ее в одну лекцию.

Но знать ее очень важно: на многих собеседованиях ты получишь алгоритмические задачи.

Для теории я могу порекомендовать тебе несколько книг.

Начать можно с “<a href="https://www.chitai-gorod.ru/catalog/book/960907/" rel="nofollow" target="_blank">Грокаем алгоритмы</a>”: хотя примеры в книге написаны на Python, язык книги и примеры очень просты. Лучший вариант для новичка, к тому же она небольшая по объему.

Из чтения посерьезней — книги <a href="https://www.amazon.com/Data-Structures-Algorithms-Java-2nd/dp/0672324539" rel="nofollow" target="_blank">Роберта Лафоре</a> и <a href="https://www.amazon.com/Algorithms-Java-Parts-1-4-Pts-1-4/dp/0201361205" rel="nofollow" target="_blank">Роберта Седжвика</a>. Обе написаны на Java, что сделает изучение для тебя немного попроще. Ведь ты неплохо знаком с этим языком! :)

Для учеников с хорошей математической подготовкой лучшим вариантом будет <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" rel="nofollow" target="_blank">книга Томаса Кормена</a>. 

Но одной теорией сыт не будешь! 

<span class="text-bold">“Знать” != “уметь”</span>

Практиковать решения задач на алгоритмы можно на <a href="https://www.hackerrank.com/" rel="nofollow" target="_blank">HackerRank</a> и <a href="https://leetcode.com/" rel="nofollow" target="_blank">Leetcode</a>. Задачки оттуда частенько используют даже на собеседованиях в Google и Facebook, так что скучно тебе точно не будет :)

Для закрепления материала лекции, советую посмотреть отличное <a href="https://www.youtube.com/watch?v=ZRdOb4yR0kk" rel="nofollow" target="_blank">видео про Big-O</a> на YouTube.

Увидимся на следующих лекциях! :)