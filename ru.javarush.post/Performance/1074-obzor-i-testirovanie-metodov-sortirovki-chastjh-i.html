Обзор и тестирование методов сортировки. Часть I
<p>----------------------------------------</p>
На днях в комментариях вконтакте у меня возник спор с одним из других студентов проекта. Суть спора заключалась в том, «кто кого» — метод sort() из класса java.util.Arrays или самописные реализации простых алгоритмов: bubble (пузырьковая), insertion (вставками) ...
<p>----------------------------------------</p>
На днях в комментариях вконтакте у меня возник спор с одним из других студентов проекта. Суть спора заключалась в том, «кто кого» — метод <code>sort()</code> из класса <code>java.util.Arrays</code> или самописные реализации простых алгоритмов: <strong>bubble</strong> (пузырьковая), <strong>insertion</strong> (вставками), <strong>selection</strong> (выбором), <strong>shell</strong> (алгоритм Шелла).
<img data-id="f5ac0442-1efa-4ea0-b92a-7bc653705dc2" data-max-width="850" alt="Обзор и тестирование методов сортировки. Часть I - 1" src="https://cdn.javarush.com/images/article/f5ac0442-1efa-4ea0-b92a-7bc653705dc2/1024.jpeg">Для некоторых ответ на данный вопрос может быть очевиден, но раз спор возник, при том что у каждой из сторон были «уважаемые источники» в пользу своей точки зрения, было принято решение провести исследование, поразмяв в процессе серое вещество, реализуя различные алгоритмы. 

<em>TL;DR:</em> <code>java.util.Arrays.sort()</code> <em>безоговорочно лидирует на массивах от 100 000 элементов, при меньшем размере с ним иногда может потягаться метод Шелла. Остальные рассмотренные алгоритмы сливают вчистую и могут быть полезны лишь при каких-то экзотических условиях.</em>

Теперь давайте рассмотрим, как же осуществляется сортировка массивов в наших убер-девайсах из кремния. 
<h2>Selection sort. Сортировка выбором</h2> Начнем с самого простого и очевидного способа. Суть его нам отлично демонстрирует <a href='https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%B4%D0%B6%D0%B2%D0%B8%D0%BA,_%D0%A0%D0%BE%D0%B1%D0%B5%D1%80%D1%82' rel='nofollow' target='_blank'>Роберт Седжвик</a> в своей <a href='https://www.coursera.org/learn/algorithms-part1' rel='nofollow' target='_blank'>видеолекции на coursera</a> (привожу погано пережатую в gif мной анимацию оттуда):

<a href='https://www.dropbox.com/s/otq3781oeae2h42/selectionSort.gif' rel='nofollow' target='_blank'>Посмотреть</a>

Пробегая по массиву с первого элемента, мы на каждом шаге ищем в правой части минимальный элемент, с которым и меняем местами текущий. В результате мы оставляем за собой окончательный вариант нашего массива в отсортированном виде. 
Вот код, реализующий этот алгоритм на Java: 

<pre class='lang-java line-numbers'><code>
public void sort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n; i ++) {
            int minIndex = min(array, i, n - 1);
            swap(array, i, minIndex);
        }
    }

public static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
public static int min(int[] array, int begin, int end) {
        int minVal = array[begin];
        int minIndex = begin;
        for (int i = begin + 1; i <= end; i++) {
            if (array[i] < minVal) {
                minVal = array[i];
                minIndex = i;
            }
        }
        return minIndex;
    }
</code></pre>
Анализ алгоритма показывает, что необходимо на каждом проходе прошерстить весть остаток массива, то есть нам понадобится ровно N + (N-1) + (N-2) + … + 1 = N^2/2 сравнений. Таким образом, сложность алгоритма составляет O(N^2). Что же это означает? А означает это, что, увеличив количество элементов в массиве (N) в 2 раза, мы увеличим время работы алгоритма не в 2, а в 2^2 = 4 раза. Увеличив N в 10 раз, время работы увеличим в 100 раз и так далее. На моем ноутбуке 2012 года с процессором Core i3 под Ubuntu 14.4 я получил следующее время работы: 
<img data-id="33df253d-95c9-4d3a-b238-bac50eaf0e7b" data-max-width="850" alt="Обзор и тестирование методов сортировки. Часть I - 2" src="https://cdn.javarush.com/images/article/33df253d-95c9-4d3a-b238-bac50eaf0e7b/1024.jpeg"><h2>Insertion sort. Сортировка вставками</h2>Здесь идея несколько иная. Опять же, обратимся к анимации от Доктора Седжвика: 

<a href='https://www.dropbox.com/s/xrr5f6xk5korv0s/insertionSort_optimized.gif?dl=0' rel='nofollow' target='_blank'>Посмотреть</a>

То, что впереди, нами еще даже не просмотрено, а все что оставляем позади себя, всегда остается выстроенным по порядку. Суть в том, что каждый новый элемент исходного массива мы «возвращаем» к началу до тех пор, пока он не «упрется» в меньший элемент. 

Таким образом, у нас опять N проходов (для каждого элемента исходного массива), но в каждом проходе в большинстве случаев мы просматриваем не весь остаток, а только часть. То есть вариант 1 + (N-1) + (N-2) + … + N = N^2/2 мы получим, только если каждый следующий элемент нам придется возвращать к самому началу, то есть в случае отсортированного «наоборот» входного массива (не везет, так невезет). В случае же уже отсортированного массива (вот везуха ваще) будет полная халява – на каждом проходе всего одно сравнение и оставление элемента на месте, то есть отработает алгоритм за время, пропорциональное N. Сложность алгоритма же будет определяться худшим теоретическим случаем, то есть O(N^2). Среднестатистически же, время работы будет пропорционально N^2/4, то есть, вдвое быстрее предыдущего алгоритма. В моей реализации из-за неоптимального использования перестановки время работы получилось больше, чем у Selection. Планирую в ближайшее время исправить и обновить пост.

Вот код и результат его работы на той же машине: 

<pre class='lang-java line-numbers'><code>
public void sort(int[] array) {
        int length = array.length;
        for (int i = 1; i &lt; length; i++) {
            for (int j = i; j &gt;= 1; j--) {
                if (array[j] &lt; array[j - 1])
                    swap(array, j, j - 1);
                else
                    break;
            }
        }
    }
</code></pre>
<img data-id="5aedb9d4-6688-4519-ae15-65f0cc14c840" data-max-width="850" alt="Обзор и тестирование методов сортировки. Часть I - 3" src="https://cdn.javarush.com/images/article/5aedb9d4-6688-4519-ae15-65f0cc14c840/1024.jpeg"><h2>Shell sort. Сортировка Шелла</h2>Умный мужик Дональд Шелл аж в 1959-м году заметил, что в алгоритме вставками дороже всего обходятся случаи, когда элемент возвращается очень далеко к началу массива: на каком-то проходе мы вернем элемент к началу на пару позиций, а на другом проходе почти через весь массив к началу – далеко и долго. Нельзя ли это сделать сразу, прыгая через несколько элементов? И такой способ он нашел. Заключается он в последовательном выполнении особых частичных сортировок, называемых в общем виде d-sort или, у Седжвика, h-sort (подозреваю, h означает hop - прыжок).

3-sort, например, будет сравнивать рассматриваемый элемент не с предыдущим, а пропустит два и сравнит с отстоящим на 3 позиции назад. Если поменяли, он его сравнит снова с элементом на 3 позиции назад и так далее.

Суть в том, что полученный в результате массив будет «3-отсортирован», то есть неправильность положения элементов составит менее 3х позиций. Работать с таким алгоритму вставки будет легко и приятно. Кстати, «1-sort» является ничем иным, как просто алгоритмом вставки=)

Последовательно применяя к массиву h-sort с уменьшающимся значением h, мы сможем отсортировать большой массив быстрее. Вот как это выглядит:

<a href='https://www.dropbox.com/s/cs1eig2glqecz8l/ShellSort_optimized.gif?dl=0' rel='nofollow' target='_blank'>Посмотреть</a>

Сложность здесь заключается в том, как выбрать правильную последовательность частичных сортировок. От этого, в итоге, зависит производительность алгоритма. Наиболее распространенной является последовательность, предложенная Дональдом Кнутом: 

h = h*3 + 1, то есть 1, 4, 13, 40, … и так до 1/3 размера массива. Такая последовательность обеспечивает достойную производительность, а также проста в реализации. 

Анализ алгоритма требует тонн матана и мной не осилен. Обширность анализа так же определяется множеством вариантов последовательностей h. Эмпирически же можно сказать, что скорость алгоритма весьма хороша – смотрите сами: 
<img data-id="18e19ced-75aa-4fbe-adb0-3e643737d021" data-max-width="850" alt="Обзор и тестирование методов сортировки. Часть I - 4" src="https://cdn.javarush.com/images/article/18e19ced-75aa-4fbe-adb0-3e643737d021/1024.jpeg">Миллион элементов менее, чем за секунду!

А вот код на Java с кнутовской последовательностью.

<pre class='lang-java line-numbers'><code>
public void sort(int[] array) {
        int h = 1;
        while (h*3 < array.length)
            h = h * 3 + 1;

        while(h >= 1) {
            hSort(array, h);
            h = h/3;
        }
    }

    private void hSort(int[] array, int h) {
        int length = array.length;
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h; j = j - h) {
                if (array[j] < array[j - h])
                    swap(array, j, j - h);
                else
                    break;
            }
        }
    }
</code></pre><h2>Bubble sort. Метод пузырька</h2> Это классика! Этот алгоритм реализует почти каждый начинающий программист. Это настолько классика, что у Доктора Седжвика даже не нашлось анимации для него, потому мне пришлось потрудиться самому. 

<a href='https://www.dropbox.com/s/b8nrxx5qdprm8gn/bubbleSort.gif?dl=0' rel='nofollow' target='_blank'>Посмотреть</a>

Здесь на каждом проходе мы обходим массив с начала до конца, меняя местами соседние элементы, стоящие не по порядку. В результате самые крупные элементы «всплывают» (отсюда и название) в конец массива. Каждый новый проход мы начинаем, оптимистично надеясь, что массив уже отсортирован (<code>sorted = true</code>). В конце прохода, если мы видим, что ошиблись, начинаем новый проход.

Сложность здесь заключается в том, что мы, опять же, обходим весь (почти) массив на каждом проходе. Сравнение происходит на каждом шаге, обмен - почти на каждом, что делает данный алгоритм одним из самых медленных (если рассматривать рационально реализованные, а не "сортировку встряхиванием" и прочие подобные).

Интересно, что формально сложность и здесь будет равна O(N^2), только вот коэффициент гораздо выше, чем у вставок и выборов. Код алгоритма:

<pre class='lang-java line-numbers'><code>
public void sort(int[] array) {
        boolean isSorted;
        int nMinusOne = array.length - 1;
        for(int i = 0; i < nMinusOne; i++) {
            isSorted = true;
            for (int j = 0; j < nMinusOne - i; j++) {
                if (array[j] > array[j + 1]) {
                    swap(array, j, j + 1);
                    isSorted = false;
                }
            }
            if (isSorted)
                return;
        }
    }
</code></pre>
Время работы:
<img data-id="028e0b08-330c-4d2d-9500-c4d5fd19f7f6" data-max-width="850" alt="Обзор и тестирование методов сортировки. Часть I - 5" src="https://cdn.javarush.com/images/article/028e0b08-330c-4d2d-9500-c4d5fd19f7f6/1024.jpeg">Почувствуйте разницу: более получаса на миллионе элементов!

Вывод: <strong>Никогда не исползуйте этот алгоритм!!!</strong>
<h2>Резюме первой части</h2>Как итог предлагаю посмотреть общую таблицу для этих алгоритмов.
<img data-id="60a459c1-70da-41da-b8f8-7f75f3ce273e" data-max-width="850" alt="Обзор и тестирование методов сортировки. Часть I - 6" src="https://cdn.javarush.com/images/article/60a459c1-70da-41da-b8f8-7f75f3ce273e/1024.jpeg">Можете так же сравнить с результатами для встроенного метода <code>java.util.Arrays.sort()</code>. Похоже на какую-то магию — что же может быть быстрее Шелла? Об этом напишу в следующей части. Там мы рассмотрим широко применяемые алгоритмы быстрой сортировки, а также сортировки слиянием, узнаем о разнице в методах сортировки массивов из примитивов и ссылочных типов, а также познакомимся с очень важным в этом деле интерфейсом <code>Comparable</code> ;)

Ниже можете изучить график, построенный в логарифмическом масштабе по данным таблицы. Чем более полого идет линия, тем лучше алгоритм =)
<img data-id="9b914d14-628a-48b2-80dd-3cb608aec195" data-max-width="850" alt="Обзор и тестирование методов сортировки. Часть I - 7" src="https://cdn.javarush.com/images/article/9b914d14-628a-48b2-80dd-3cb608aec195/1024.jpeg">Кто хочет скачать весь проект и прогнать тесты у себя, держите ссылку:

<a href='https://www.dropbox.com/s/7wof1cq60ixan0i/sort.zip?dl=0' rel='nofollow' target='_blank'>Java</a>

До встречи в следующей части! =)