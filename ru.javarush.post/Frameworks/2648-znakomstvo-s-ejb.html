Знакомство с EJB
<p>----------------------------------------</p>
В данной статье рассмотрим EJB — Enterprise JavaBeans. Данная технология является частью спецификации Java EE. Мы коснемся таких вопросов, как: что такое EJB; какова история возникновения EJB; какие есть типы EJB. А еще — напишем небольшое HelloWorld приложение...
<p>----------------------------------------</p>
В данной статье рассмотрим EJB — Enterprise JavaBeans. Данная технология является частью спецификации Java EE. 

Мы коснемся таких вопросов, как: 
<ul>
<li>что такое EJB;</li>
<li>какова история возникновения EJB;</li>
<li>какие есть типы EJB.</li>
</ul>А еще — напишем небольшое HelloWorld приложение с использованием EJB и сервлетов.
<img data-max-width="800" data-id="767c81e1-5829-44bb-b34c-2e76840cf74d" src="/images/article/767c81e1-5829-44bb-b34c-2e76840cf74d/800.webp" class="img-fluid" alt="Знакомство с EJB - 1">Данная статья окажется полезной читателям, которые освоились в Java SE и начинают изучение Java EE. Для полноценного понимания практической части данной статьи рекомендуется сперва ознакомиться со статьей “<a href="https://javarush.com/groups/posts/2640-nastroyka-lokaljhnogo-okruzhenija-dlja-java-ee-razrabotki" target="_blank">Настройка локального окружения</a>”.
<h2>Краткая история EJB</h2>В далеком 1996 году, когда автору данной статьи было 5 лет, Java уже пользовалась популярностью среди разработчиков. Причиной тому были дружелюбный API, автоматическая сборка мусора, и т.д. Java широко использовалась в системах, отвечавших за бэкенд. Однако, несмотря на все прелести языка, программисты того времени нуждались в определенном функционале, еще не реализованном в JDK. Такими потребностями были:
<ul>
<li>обеспечение персистентности данных;</li>
<li>целостность транзакций</li>
<li>конкурентный доступ к данным (управление многопоточностью);</li>
<li>и, скорее всего, что-то еще.</li>
</ul>Все это приводило к естественному росту популяции доморощенных, самописных, закрытых библиотек. Иными словами каждый реализовывал свои потребности как мог. 

Так длилось до тех пор, пока IBM в 1997 году не выступила с лозунгом: "Все должны реализовывать свои потребности одинаково", и не выпустила спецификацию Enterprise Java Bean (EJB). Именно она позволила унифицировать процесс разработки и взять решение типовых проблем (описанных выше как потребности) на сторону фреймворка. 

Компания Sun занималась адаптацией детища IBM на протяжении 2 лет, и в 1999 году выпустила спецификацию EJB 1.0. Так появилась на свет технология, о которой далее речь пойдет в более прикладном ключе.
<h2>Что такое EJB</h2>EJB в некотором смысле — собирательный термин, который в зависимости от контекста может подразумевать под собой либо саму технологию Enterprise JavaBeans в общем, либо некоторый конкретный программный компонент (бин) Enterprise JavaBean, который является частью технологии EJB. 

Определение EJB как технологии приводится на википедии: 

Enterprise JavaBeans (также часто употребляется в виде аббревиатуры EJB) — спецификация технологии написания и поддержки серверных компонентов, содержащих бизнес-логику. Является частью Java EE.

Эта технология обычно применяется, когда бизнес-логика требует как минимум один из следующих сервисов, а часто — все из них:
<ul>
<li>поддержка сохранности данных (persistence): данные должны быть в сохранности даже после остановки программы. Чаще всего достигается с использованием базы данных;</li>
<li>поддержка распределенных транзакций;</li>
<li>поддержка параллельного изменения данных и многопоточность;</li>
<li>поддержка событий;</li>
<li>поддержка именования и каталогов (JNDI);</li>
<li>безопасность и ограничение доступа к данным;</li>
<li>поддержка автоматизированной установки на сервер приложений;</li>
<li>удалённый доступ.</li>
</ul>Сервисы, перечисленные выше — это несомненное преимущество технологии EJB. Еще одним таким преимуществом является то, что все перечисленное выше работает из коробки, сразу же. Т.е. программисту не нужно думать о поддержке распределенных транзакций. Программисту нужно думать только о бизнес-логике, которую он в данный момент пытается реализовать. 

EJB как некоторый конкретный программный компонент — это Java-класс с одной или несколькими аннотациями из спецификации EJB, который содержит в себе некоторую бизнес логику приложения.  

Аннотации из спецификации EJB наделяют помеченный класс определенными полномочиями, силами, суперспособностями. Подробнее об этом читайте ниже. 
<h2>Типы EJB</h2>Резюмируем. EJB — это обычный Java класс, отмеченный одной из специальных аннотаций. Такие классы называют бинами. В зависимости от того, какой аннотацией отмечен класс, он будет являться представителем того или иного типа EJB (бинов).

Есть три основные типа бинов:
<ul>
<li>Message Driven Beans (бины, управляемые сообщениями);</li>
<li>Entity Beans (объектные бины) — определены в спецификации JPA (Java Persistence API) и используются для хранения данных;</li>
<li>Session Beans (cессионные бины).</li>
</ul>Последние (сессионные бины) подразделяются на несколько подвидов: 
<ul>
<li>stateless (без состояния);</li>
<li>stateful (с поддержкой текущего состояния сессии);</li>
<li>singleton (один объект на все приложение; начиная с версии EJB 3.1).</li>
</ul><img data-max-width="800" data-id="cf934e31-21bb-45ff-808c-8e5f35f39451" src="/images/article/cf934e31-21bb-45ff-808c-8e5f35f39451/800.webp" class="img-fluid" alt="Знакомство с EJB - 2">Ниже рассмотрим каждый тип бинов подробнее.
<h2>Session Beans</h2>Session Beans, или сессионные бины — определенный вид бинов. Они инкапсулируют в себе бизнес-логику, которую клиент может программно вызвать посредством вызова методов этого бина. 

Вызов метода может выполнить:
<ul>
<li>локально, другим классом в той же JVM, что и сессионный бин;</li>
<li> удаленно, по сети, из другой JVM, с помощью технологии Java RMI (Remote Method Invocation).</li>
</ul>Слово «сессионный» предполагает, что бин доступен только на время выполнения определенной задачи сервером и безвозвратно уничтожается в случае аварии или остановки сервера. 

Жизненный цикл экземпляра сессионного бина управляется EJB контейнером (подробнее об EJB контейнерах можно почитать в <a href="https://javarush.com/groups/posts/2648-znakomstvo-s-ejb" rel="nofollow" target="_blank">первой лекции цикла</a>). 

<span class="text-bold">Сессионные бины без состояния (stateless)</span> не сохраняют информацию о своем состоянии. Компонент такого типа можно использовать различными клиентами. 

Stateless бины используются для реализации бизнес-процессов, которые можно завершить за одну операцию. Например, проверка кредитной истории клиентов. 

Так как один экземпляр бина может быть использован различными клиентами, разработчик должен обеспечить потокобезопасный доступ к данным бина. 

Создать бин такого типа (впрочем, как и все остальные сессионные бины) довольно просто. Это обычный Java-класс с аннотацией <code>@Stateless</code>. 

Приведем пример ниже: 

<pre class="lang-java line-numbers"><code>
import javax.ejb.Stateless;

@Stateless
public class StatelessEjbExample {
    public String sayHi() {
        return "Hi, I'm Stateless EJB!";
    }
}
</code></pre>
<span class="text-bold">Сессионные бины с поддержкой текущего состояния сессии (Stateful)</span> сохраняют информацию о своем состоянии между обращениями к нему от одного и того же клиента и завершают свое существование по явному запросу от клиента. Достигается это за счет того, что stateful бины уникальны для каждого клиента. 

Пример задачи, за которую может отвечать такой тип бинов — поддержка в актуальном состоянии корзины покупок в интернет-магазине для каждого пользователя. Жизненным циклом данных бинов управляет EJB контейнер. Данные бины также уничтожаются, когда клиент завершает свою работу.

Подобные бины тоже довольно просто создавать. Это Java класс, помеченный аннотацией <code>Stateful</code>. Пример ниже:

<pre class="lang-java line-numbers"><code>
import javax.ejb.Stateful;

@Stateful
public class StatefulEjbExample {
    public String sayHi() {
        return "Hi, I,m Stateful EJB";
    }
}
</code></pre>
<span class="text-bold">Сессионные бины одиночки (singleton)</span> инициируются один раз за время существования приложения и существуют все время "жизни" приложения. Такие бины разрабатываются для ситуаций, в которых одно состояние должно быть разделено между всеми клиентами. 

Подобно stateless бинам, в бинах одиночках разработчику необходимо следить за организацией потокобезопасной среды внутри бина. 

Приведем пример Singleton бина, который также прост в создании как и его собратья, речь о которых шла выше. Нетрудно догадаться, что это Java-класс с аннотацией <code>@Singleton</code>. Однако в данном случае необходимо быть внимательным. Есть две аннотации, идентичные по синтаксису, но различные по назначению и расположенные в разных пакетах: 
<ul>
<li>javax.ejb.Singleton</li>
<li>javax.inject.Singleton</li>
</ul>Для создания EJB необходимо использовать аннотацию из пакета <code>javax.ejb</code>. Пример ниже: 

<pre class="lang-java line-numbers"><code>
import javax.ejb.Singleton;

@Singleton
public class SingletonEjbExample {
    public String sayHi() {
        return "Hi, I'm Singleton EJB!";
    }
}</code></pre><h2>Message Driven Beans</h2>Message Driven Beans, или MDB, или бины управляемые сообщениями, подобно сеансовым бинам реализуют некоторую бизнес-логику. Но в отличие от своих родственников, у MDB есть одно важное отличие. Клиенты никогда не вызывают методы MDB напрямую. Такие бины чаще всего выступают в роли слушателей JMS (Java Message Service) сообщений и служат для организации асинхронного обмена сообщениями между частями системы.

Примером такого сообщения может быть запрос на доставку товарных запасов от автоматизированной системы розничной торговли к системе управления поставками.

Ниже приведем пример MDB  бина. В отличие от сессионных бинов, его создание немного интереснее: 

<pre class="lang-java line-numbers"><code>
import javax.annotation.Resource;
import javax.ejb.MessageDriven;
import javax.ejb.MessageDrivenContext;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

@MessageDriven(mappedName = "jms/TestQueue")
public class MessageDrivenEjbExample implements MessageListener {
    
    @Resource
    private MessageDrivenContext messageDrivenContext;

    public void onMessage(Message message) {
        try {
            if (message instanceof TextMessage) {
                TextMessage msg = (TextMessage) message;
                msg.getText();
            }
        } catch (JMSException e) {
            messageDrivenContext.setRollbackOnly();
        }
    }
    
}
</code></pre>
Аннотация <code>MessageDriven</code> делает наш класс MDB бином. Внутри аннотации с помощью JNDI (читайте про JNDI <a href="https://javarush.com/groups/posts/2650-ispoljhzovanie-jndi-v-java" target="_blank">тут</a>) определяется имя JMS рассылки, слушателем которой становится наш класс. 

Помимо этого, наш класс реализует интерфейс <code>MessageListener</code> и его метод <code>onMessage</code>. Данный метод будет вызван, когда придет некоторое сообщение из очереди/рассылки с именем, определенным внутри аннотации <code>MessageDriven</code>. 
<h2>Entity beans</h2>Частью технологии EJB является JPA спецификация. 

JPA, или Java Persistence API — это спецификация, которая обеспечивает объектно-реляционное отображение (ORM — Object-Relational Mapping) Java объектов (Entity бинов) и предоставляющая API для сохранения, получения и управления такими объектами. 

JPA позволяет представлять данные из БД в виде Java-объектов, а также сохранять Java-объекты в виде записей в базе данных. В роли подобного объекта может выступать не каждый класс, а как раз-таки Entity бины.

Entity Bean — это Java класс, который является отображением некоторой таблицы в базе данных. Отображение (маппинг) достигается за счет использования специальных аннотаций. С их помощью осуществляется сопоставление Java-класса с таблицей в базе данных, а также сопоставление полей Java-класса c полями таблицы БД. 

Приведем пример Entity бина, c комментариями в коде:

<pre class="lang-java line-numbers"><code>
@Entity // Делает данный класс Entity бином
@Table(name = "employee") // "Связывает" данный класс с таблицей employee в БД
public class Employee implements Serializable {

    @Id // Говорит о том, что поле ниже является первичным ключом
    @GeneratedValue(strategy = GenerationType.AUTO) // Определяет тип генерации значений первичного ключа
    private int id;

    @Column(name="name") // "Связывает" поле ниже с полем name в таблице employee в БД
    private String name;

    @Column (name="age") // "Связывает" поле ниже с полем age в таблице employee в БД
    private int age;

    // getters and setters...
}
</code></pre>
Стоит отметить, что данный тип бинов имеет смысл изучать только в контексте изучения спецификации JPA. 
<h2>Пишем приложение: EJB HelloWorld</h2>В данном разделе мы напишем небольшое Java EE HelloWorld приложение, которое развернем на сервере GlassFish. Перед прочтением данной статьи настоятельно рекомендуется прочитать <a href="http://docs.google.com/document/d/1QDwY8JkdKFtmN-HTi8rYpn5XELlZF1lKDUwXhxBHYqA/edit" rel="nofollow" target="_blank">статью о настройке локального окружения</a>. 
<ol>
<li><p>Создаем новый Maven проект в IntelliJ IDEA.</p>
<p><em>File -&gt; New -&gt; Project...</em></p>
<img data-max-width="800" data-id="7e8ba8dd-434d-4f94-b95e-7c95afd643c3" src="/images/article/7e8ba8dd-434d-4f94-b95e-7c95afd643c3/800.webp" class="img-fluid" alt="Знакомство с EJB - 3"></li>
<li><p>Нажимаем <em>Next</em>.</p></li>
<li><p>Заполняем параметры Maven проекта:</p>
<img data-max-width="800" data-id="d4686d74-452a-4feb-9460-6d7583e859fd" src="/images/article/d4686d74-452a-4feb-9460-6d7583e859fd/800.webp" class="img-fluid" alt="Знакомство с EJB - 4"></li>
<li><p>Нажимаем <em>Finish</em></p></li>
<li><p>Проект создан и имеет следующую структуру:</p>
<img data-max-width="512" data-id="4ea75761-dbb5-4762-aded-193573e10179" src="/images/article/4ea75761-dbb5-4762-aded-193573e10179/512.webp" class="img-fluid" alt="Знакомство с EJB - 5"></li></ol>
Файл pom.xml выглядит следующим образом:
<img data-max-width="800" data-id="48fc0e23-dcd8-4310-8ca8-7a81e80ece00" src="/images/article/48fc0e23-dcd8-4310-8ca8-7a81e80ece00/800.webp" class="img-fluid" alt="Знакомство с EJB - 6">Первым делом нам необходимо добавить зависимость от Java EE API, а также указать упаковку нашего проекта в виде архива веб-приложения (war).

Чтобы сделать это, необходимо привести код pom.xml к следующему виду: 

<pre class="lang-java line-numbers"><code>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.javarush.lectures&lt;/groupId&gt;
    &lt;artifactId&gt;ejb_demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax&lt;/groupId&gt;
            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
            &lt;version&gt;7.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
Далее можно приступать к Java-коду. Наше приложение будет наипростейшим. У нас будет 1 сервлет и 1 EJB. Это будет сессионный бин без сохранения состояния (stateless). Внутри EJB мы определим всего 1 метод, который будет возвращать строку “Hello World”. 

Первым делом создадим пакет <code>com.javarush.lectures</code>.

Затем, внутри пакета <code>com.javarush.lectures</code>, создадим наш бин — DemoEJB. Код бина приведен ниже: 

<pre class="lang-java line-numbers"><code>
import javax.ejb.Stateless;

@Stateless
public class DemoEJB {
    public String helloWorld() {
        return "Hello world!";
    }
}
</code></pre>
Как было сказано ранее, все довольно просто. 

Наш следующий шаг — создать сервлет, который будет передавать значение из EJB в качестве ответа на HTTP-запрос. Стоит отметить, что сервлеты не относятся к теме данной статьи, но для демонстрации EJB все же придется их использовать.

Для этого создадим новый сервлет <code>DemoServlet</code> в том же пакете, что и EJB. Его код ниже: 

<pre class="lang-java line-numbers"><code>
@WebServlet("/helloWorld")
public class DemoServlet extends HttpServlet {

    @EJB
    private DemoEJB ejb;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write(ejb.helloWorld());
    }
}
</code></pre>
Приведем небольшие комментарии к коду. 

Аннотация <code>@WebServlet("/helloWorld")</code> — определяет наш класс как сервлет, который будет обрабатывать HTTP запросы на эндпоинт <code>/helloWorld</code>. 

У нашего класса есть одно поле — <code>DemoEJB ejb</code>. Это наш бин, определенный ранее. Аннотация над полем класса — <code>@EJB</code> осуществляет инъекцию зависимости (DI). Т.е. Переменная ejb автоматически инициализируется новым экземпляром, когда это потребуется. 

Наш класс является наследником HttpServlet и переопределяет один из методов суперкласса — <code>doGet</code>. 

Данный метод обрабатывает HTTP GET запросы и принимает в себя два параметра — <code>HttpServletRequest</code> и <code>HttpServletResponse</code>. <code>HttpServletRequest</code> служит для получения информации о поступившем HTTP запросе. <code>HttpServletResponse</code> нужен для формирования ответа на запрос.

Внутри метода мы получаем объект <code>PrintWriter</code> у объекта ответа (<code>HttpServletResponse</code>), с помощью метода <code>getWriter()</code>. Далее мы можем записать в полученный объект некоторое значение с помощью метода <code>write</code>. Чем, собственно мы и пользуемся, записывая в объект <code>PrintWriter</code>-а значение, полученное из определенного нами EJB (значение — строка “Hello World!”). Данное значение клиент, отправивший HTTP-запрос, получит в качестве ответа на свой запрос.

Следующий шаг — запуск приложения на Java EE сервере GlassFish. Для этого создадим новую конфигурацию, как это описано в <a href="https://docs.google.com/document/d/1QDwY8JkdKFtmN-HTi8rYpn5XELlZF1lKDUwXhxBHYqA/edit#heading=h.z2bmeimxq2iu" rel="nofollow" target="_blank">статье о настройке локального окружения</a>. 

Ниже скрин готовой конфигурации для текущего проекта. Убедитесь, что у вас установлен сервер GlassFish перед запуском: 
<img data-max-width="800" data-id="ba932522-60ef-4bc5-9544-8f683a1219ff" src="/images/article/ba932522-60ef-4bc5-9544-8f683a1219ff/800.webp" class="img-fluid" alt="Знакомство с EJB - 7">После создания конфигурации запуска — запускаем приложение с помощью меню <em>Run -&gt; Run ‘ejb_demo’</em> либо с помощью хоткея <em>Shift+F10</em>.

После запуска можно увидеть его логи: 
<img data-max-width="1024" data-id="1ed6b5e2-2596-4581-8099-dd2959f7d57e" src="/images/article/1ed6b5e2-2596-4581-8099-dd2959f7d57e/1024.webp" class="img-fluid" alt="Знакомство с EJB - 8">А также открывшийся браузер: 
<img data-max-width="512" data-id="c061b985-7eec-4ef2-a3d8-e1160a4f5a01" src="/images/article/c061b985-7eec-4ef2-a3d8-e1160a4f5a01/512.webp" class="img-fluid" alt="Знакомство с EJB - 9">Все это говорит о том, что приложение работает, как задумывалось.
<h2>Заключение</h2>В данной статье мы знакомились с EJB — Enterprise JavaBeans. Рассмотрели такие вопросы, как: 
<ul>
<li>Что такое EJB?</li>
<li>История EJB</li>
<li>Различные типы EJB</li>
</ul>Вспомним, что EJB бывают следующих типов: 
<ul>
<li>Message Driven Beans (бины, управляемые сообщениями);</li>
<li>Entity Beans (объектные бины) — определены в спецификации JPA (Java Persistence API) entities и используются для хранения данных;</li>
<li>Session Beans (cессионные бины):
<ul>
<li>stateless (без состояния)</li>
<li>stateful (с поддержкой текущего состояния сессии)</li>
<li>singleton (один объект на все приложение; начиная с версии EJB 3.1)</li>
</ul></li></ul>А также мы написали небольшое HelloWorld приложение с использованием EJB. 

В качестве ДЗ ты можешь повторить практическую часть данной статьи самостоятельно. А затем добавить в свое приложение еще два сервлета, которые будут использовать stateful и singleton бины для получения значения. 