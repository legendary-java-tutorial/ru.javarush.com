Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура
<p>----------------------------------------</p>
Из этого руководства вы узнаете что такое микросервисы Java, как их проектировать и создавать. Также здесь затронуты вопросы о библиотеках микросервисов Java и целесообразности применения микросервисов...
<p>----------------------------------------</p>
Из этого руководства вы узнаете что такое микросервисы Java, как их проектировать и создавать. Также здесь затронуты вопросы о библиотеках микросервисов Java и целесообразности применения микросервисов.

Перевод и адаптация <a href="https://www.marcobehler.com/guides/java-microservices-a-practical-guide#_deploying_and_testing_java_microservices" rel="nofollow" target="_blank">Java Microservices: A Practical Guide</a>.
<h2>Микросервисы Java: основы</h2>Чтобы понять микросервисы, нужно сначала определить, что ими не является. А не является ими “монолит” — Java monolith: что это такое и каковы его преимущества или недостатки?
<img data-max-width="800" data-id="dff44531-5438-48ab-8074-8faa018cb89f" src="/images/article/dff44531-5438-48ab-8074-8faa018cb89f/800.webp" class="img-fluid" alt="Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура - 1"><h3>Что такое Java-монолит?</h3>Представьте, что вы работаете в банке или финтех-стартапе. Вы предоставляете пользователям мобильное приложение, которое можно использовать для открытия нового банковского счета.

В Java-коде это приведет к наличию класса-контроллера. Упрощенно он выглядит следующим образом: 

<pre class="lang-java line-numbers"><code>
@Controller
class BankController {

    @PostMapping("/users/register")
    public void register(RegistrationForm form) {
        validate(form);
        riskCheck(form);
        openBankAccount(form);
        // etc..
    }
}
</code></pre>
Вам нужно, чтобы контроллер:
<ol>
<li>Подтверждал форму регистрации.</li>
<li>Проверял риски по адресу пользователя, чтобы решить, предоставлять ли ему банковский счет.</li>
<li>Открывал банковский счет.</li>
</ol>Класс <code>BankController</code> будет упакован вместе с остальными вашими исходниками в файл bank.jar или bank.war для развертывания — это и есть старый добрый монолит, содержащий весь код, необходимый для работы вашего банка. По грубым прикидкам, изначальный размер .jar (или .war) файла составит от 1 до 100 МБ.

Теперь вы можете просто запустить файл .jar на своём сервере… и это всё, что нужно сделать для развертывания Java-приложения. 
<img data-max-width="800" data-id="7604ffac-8a1a-4af2-8a86-01a1bfe61a40" src="/images/article/7604ffac-8a1a-4af2-8a86-01a1bfe61a40/800.webp" class="img-fluid" alt="Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура - 2">Картинка, левый прямоугольник сверху: развёртывание моно(литного) банка java -jar bank.jar (cp .war/.ear into appserver). Правый прямоугольник: открытый браузер. 
<h3>В чем проблема с Java-монолитами?</h3>По своей сути, в Java-монолитах нет ничего плохого. Однако опыт показал, что если у вас в проекте:
<ul>
<li>Работает много программистов /команд /консультантов ...</li>
<li>...над одним и тем же монолитом под давлением заказчиков с весьма невнятными требованиями…</li>
<li>в течение пары лет...</li>
</ul>… то в таком случае ваш маленький файлик bank.jar превращается в необозримый гигабайт одного только кода, к которому даже подступиться страшно, не говоря уже о развёртывании. 
<h3>Как уменьшить размер монолита Java?</h3>Возникает естественный вопрос: как сделать монолит меньше? Сейчас ваш bank.jar работает на одной JVM, один процесс на одном сервере. Ни больше, ни меньше.

И вот именно сейчас в голову может прийти логичная мысль: «А ведь служба проверки рисков может использоваться и другими отделами в моей компании! Она не имеет непосредственного отношения к моему монолитному банковскому приложению! Возможно, стоит вырезать её из монолита и развернуть, как отдельный продукт? То есть, если говорить технически, запустить его как отдельный процесс Java”. 
<h3>Что такое микросервис Java?</h3>На практике такое словосочетание означает, что теперь вызов метода <code>riskCheck()</code> будет производиться не из BankController: этот метод или bean-компонент со всеми его вспомогательными классами будет перемещён в собственный Maven- или Gradle-проект. Также он будет развёрнут и помещён под систему контроля версий независимо от банковского монолита. 

Однако весь этот процесс извлечения не превращает ваш новый модуль RiskCheck в микросервис как таковой, поскольку определение микросервиса открыто для интерпретации. Это приводит к частым дискуссиям внутри команд и компаний.
<ul>
<li>5-7 классов в проекте — это микро или как?</li>
<li>100 или 1000 классов... всё еще микро?</li>
<li>Микросервис вообще связан с количеством классов или нет?</li>
</ul>Давайте оставим теоретические рассуждения, а вместо них будем придерживаться прагматических соображений и сделаем вот что: 
<ol>
<li>Назовём все отдельно развертываемые сервисы микросервисами, независимо от их размеров или границ домена.</li>
<li>Подумаем, как устроить межсервисное общения. Нашим микросервисам нужны способы общения друг с другом.</li></ol>Итак, подведем итоги: раньше у вас был один JVM-процесс, цельный монолит для работы банка. Теперь у вас есть JVM-процесс банковского монолита и отдельный микросервис RiskCheck, который работает в рамках собственного JVM-процесса. И теперь для проверки рисков ваш монолит должен вызывать этот микросервис. Каким образом это сделать? 
<h3>Как наладить коммуникацию между микросервисами Java?</h3>В целом и общем есть два варианта — синхронная и асинхронная коммуникация.
<h4>Синхронная коммуникация: (HTTP)/REST</h4>Обычно синхронизированная коммуникация между микросервисами осуществляется через HTTP и REST-подобные сервисы, которые возвращают XML или JSON. Разумеется, могут быть и другие варианты — взять хотя бы <a href="https://developers.google.com/protocol-buffers" rel="nofollow" target="_blank">Google Protocol Buffers</a>.

Если вам нужен немедленный ответ, лучше использовать REST-коммуникацию. В нашем примере именно так и нужно делать, поскольку проверка рисков обязательна перед открытием счета. Если нет проверки рисков, нет и счёта. 

Инструменты обсудим ниже, в разделе “<a href="https://javarush.com/groups/posts/2663-rukovodstvo-po-mikroservisam-java-chastjh-3-objshie-voprosih#topic1" target="_blank">Какие библиотеки лучше всего подходят для синхронных вызовов Java REST</a>”. 
<h4>Обмен сообщениями — асинхронная коммуникация</h4>Асинхронная микросервисная связь обычно осуществляется посредством обмена сообщениями с реализацией JMS и/или с помощью протокола, например, <a href="https://www.amqp.org/" rel="nofollow" target="_blank">AMQP</a>. Мы здесь написали “обычно” не просто так: скажем, количество интеграций по электронной почте/SMTP нельзя недооценивать.

Используйте его тогда, когда вам не нужен незамедлительный ответ. Например,  пользователь нажимает кнопку «купить сейчас», а вы в свою очередь хотите сгенерировать счет-фактуру. Этот процесс, безусловно, не должен происходить в рамках цикла запроса-ответа пользователя на покупку.

Ниже мы опишем, какие инструменты лучше всего подходят для <a href="https://javarush.com/groups/posts/2663-rukovodstvo-po-mikroservisam-java-chastjh-3-objshie-voprosih#topic2" target="_blank">асинхронного обмена сообщениями Java</a>. 
<h3>Пример: вызов REST API в Java</h3>Предположим, мы избрали синхронную микросервисную коммуникацию. В таком случае наш Java-код (тот, что мы приводили выше) на низком уровне будет выглядеть примерно так. (под низким уровнем здесь мы понимаем тот факт, что для микросервисной коммуникации обычно создаются клиентские библиотеки, которые абстрагируют вас от реальных HTTP-вызовов).

<pre class="lang-java line-numbers"><code>
@Controller
class BankController {

    @Autowired
    private HttpClient httpClient;

    @PostMapping("/users/register")
    public void register(RegistrationForm form) {
        validate(form);
        httpClient.send(riskRequest, responseHandler());
        setupAccount(form);
        // etc..
    }
}
</code></pre>
Исходя из кода, становится ясно, что теперь нам нужно развернуть два Java-(микро) сервиса, Bank и RiskCheck. В итоге у нас будет запущено два JVM-процесса. 
<img data-max-width="800" data-id="455f7fb3-fff7-4dac-b278-e4a825523060" src="/images/article/455f7fb3-fff7-4dac-b278-e4a825523060/800.webp" class="img-fluid" alt="Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура - 3">Вот и все, что вам нужно для разработки проекта с микросервисами Java: просто создавайте и развёртывайте меньшие фрагменты (файлы .jar или .war) вместо одного монолитного. Остаётся неясным ответ на вопрос, каким образом нам следует разрезать монолит на микросервисы? Насколько мелкими должны быть эти кусочки, как определить правильный размер? Давайте проверим. 
<h2>Архитектура Java Microservices</h2>На практике компании разрабатывают микросервисные проекты по-разному. Подход зависит от того, пытаетесь ли вы преобразовать существующий монолит в проект с микросервисами или же начинаете проект с нуля. 
<h3>От монолита к микросервисам</h3>Одна из самых логичных идей — извлечь микросервисы из существующего монолита. Обратите внимание, что приставка «микро» здесь на самом деле не означает, что извлеченные сервисы будут действительно небольшими, это совершенно не обязательно. Давайте рассмотрим теоретические основы. 
<h4>Идея: разбить монолит на микросервисы</h4>К легаси-проектам можно применить микросервисный подход. И вот почему: 
<ol>
<li>Чаще всего такие проекты сложно поддерживать /изменять/расширять.</li>
<li>Все, начиная от разработчиков и заканчивая руководством, хотят упрощения.</li>
<li>У вас (относительно) четкие границы домена, то есть вы знаете, что именно должно делать ваше программное обеспечение.</li></ol>Возвращаясь к нашему примеру, это означает, что вы можете взглянуть на свой банковский Java-монолит и попытаться разбить его по границам домена.
<ul>
<li>Так, будет разумно выделить в отдельный микросервис «Управление учетными записями», обработку пользовательских данных (таких как имена, адреса, номера телефонов).</li>
<li>Или вышеупомянутый «Модуль проверки рисков, который проверяет уровни риска пользователя и может использоваться многими другими проектами или даже отделами компании.</li>
<li>Или модуль выставления счетов, который отправляет счета в формате PDF или по почте.</li>
</ul><h3>Воплощение идеи: пусть это сделает кто-то другой</h3>Описанный выше подход отлично смотрится на бумаге и UML-подобных диаграммах. Однако всё не так просто. Для его практической реализации нужна серьезная техническая подготовка: пропасть между понимаем того, что было бы неплохо извлечь из монолита и самим процессом извлечения — огромна. 

Большинство корпоративных проектов доходят до стадии, когда разработчики опасаются, скажем, обновить 7-летнюю версию Hibernate до более новой. Вместе с ней обновятся библиотеки, однако существует неиллюзорная опасность что-нибудь поломать. 

И вот, те же разработчики теперь должны копаться в древнем легаси-коде с неясными границами транзакций базы данных и извлекать четко определенные микросервисы? Чаще всего эта задача очень сложна, её не получится “решить” на доске или на совещаниях по архитектуре.
<img data-max-width="800" data-id="cd989204-e4bc-49bd-a943-1e9911943763" src="/images/article/cd989204-e4bc-49bd-a943-1e9911943763/800.webp" class="img-fluid" alt="Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура - 4">Процитирую Twitter  разработчика @simonbrown:

<em><span class="text-bold">Я буду повторять это снова и снова ... если люди не могут правильно строить монолиты, микросервисы не помогут.</span></em>

Саймон Браун
<h3>Проект “с нуля” на базе микросервисной архитектуры</h3>В случае новых Java-проектов три нумерованных пункта из предыдущей части выглядят несколько иначе:
<ol>
<li>Вы начинаете с чистого листа, так что нет “багажа” для обслуживания.</li>
<li>Разработчики хотели бы, чтобы в будущем все было просто.</li>
<li>Проблема: у вас гораздо более туманная картина границ доменов: вы не знаете, что на самом деле должно делать ваше программное обеспечение (подсказка: agile;))</li></ol>Это приводит к тому, что компании пытаются использовать новые проекты с  микросервисами Java.
<h4>Техническая микросервисная архитектура</h4>Первый пункт кажется наиболее очевидным для разработчиков, однако находятся и те, кто крайне не рекомендует его. Хади Харири рекомендует рефакторинг «Extract Microservice» в IntelliJ.

И хотя следующий пример очень упрощён, реализации, наблюдаемые в реальных проектах, к сожалению, не слишком далеко от него ушли.

<span class="text-bold">До микросервисов</span>

<pre class="lang-java line-numbers"><code>
@Service
class UserService {

    public void register(User user) {
        String email = user.getEmail();
        String username =  email.substring(0, email.indexOf("@"));
        // ...
    }
}
</code></pre>
<span class="text-bold">С substring-микросервисом Java</span>

<pre class="lang-java line-numbers"><code>
@Service
class UserService {

    @Autowired
    private HttpClient client;

    public void register(User user) {
        String email = user.getEmail();
        //теперь вызываем substring microservice via http
        String username =  httpClient.send(substringRequest(email), responseHandler());
        // ...
    }
}
</code></pre>
Таким образом, вы, по сути, включаете вызов метода Java в вызов HTTP, без очевидных причин для этого. Одна из причин, однако, заключается в следующем: отсутствие опыта и попытка форсировать подход на основе микросервисов Java.

Рекомендация: не делайте этого.
<h3>Workflow-ориентированная микросервисная архитектура</h3>Следующим распространенным подходом является разделение микросервисов Java на модули на базе workflow.

Пример из реальной жизни: в Германии, когда вы обращаетесь к (общедоступному) врачу, он должен записать ваше посещение в своей медицинской CRM-системе.

Чтобы получить оплату от страховки, он отправит данные о вашем лечении (и лечении других пациентов) посреднику через XML.

Посредник рассмотрит этот XML-файл и (упрощенно):
<ol>
<li>Проверит, правильный ли XML-файл получен.</li>
<li>Проверит правдоподобие процедур: скажем, годовалый ребёнок, получивший три процедуры чистки зубов за один день от врача-гинеколога выглядит несколько подозрительно. </li>
<li>Объединит XML с некоторыми другими бюрократическими данными.</li>
<li>Перешлёт XML-файл в страховую компанию, чтобы инициировать платежи.</li>
<li>И перешлёт результат врачу, снабдив его сообщением «успех» или «пожалуйста, отправьте эту запись еще раз, как только это будет иметь смысл».  </li>
</ol>Примечание. В этом примере коммуникация между микросервисами не играет роли, но вполне может быть выполнена асинхронно брокером сообщений (например, RabbitMQ), поскольку врач все равно не получает немедленной обратной связи.
<img data-max-width="1024" data-id="85982516-ac7f-47cc-b929-e5bf0befca7a" src="/images/article/85982516-ac7f-47cc-b929-e5bf0befca7a/1024.webp" class="img-fluid" alt="Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура - 5">Снова таки, это отлично выглядит на бумаге, но возникают закономерные вопросы: 
<ul>
<li>Есть ли необходимость в развертывании шести приложений для обработки одного XML-файла?</li>
<li>Действительно ли эти микросервисы независимы друг от друга? Могут ли они быть развернуты независимо друг от друга? С разными версиями и схемами API?</li>
<li>Что делает микросервис правдоподобия информации, если микросервис проверки не работает? Система всё еще работает?</li>
<li>Разделяют ли эти микросервисы одну и ту же базу данных (им, безусловно, нужны некоторые общие данные в таблицах БД), или у каждого есть своя собственная?</li>
<li>… и многое другое.</li>
</ul>Интересно, что приведенная выше диаграмма выглядит проще, потому что у каждого сервиса теперь есть свое точное, четко определенное назначение. Раньше это выглядело примерно как этот страшный монолит:
<img data-max-width="512" data-id="c70383eb-9122-4e69-8d47-5dbee864b5ca" src="/images/article/c70383eb-9122-4e69-8d47-5dbee864b5ca/512.webp" class="img-fluid" alt="Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура - 6">Несмотря на то, что можно спорить о простоте этих диаграмм, теперь вам определенно нужно решить эти дополнительные операционные задачи.
<ul>
<li>Вам нужно не просто развернуть одно приложение, а как минимум шесть.</li>
<li>Возможно, даже потребуется развернуть несколько баз данных, в зависимости от того, как далеко вы хотите углубиться в микросервисную архитектуру.</li>
<li>Нужно следить за тем, чтобы каждая система работала в режиме онлайн, причём работала нормально.</li>
<li>Необходимо убедиться, что ваши вызовы между микросервисами действительно устойчивы (см. Как сделать микросервис Java устойчивым?).</li>
<li>И все остальное, что подразумевает эта настройка — от локальных настроек разработки до интеграционного тестирования.</li>
</ul>Так что рекомендация будет следующей: 
<ul>
<li>Если вы не Netflix (скорее всего, вы не Netflix) ...</li>
<li>Если вы не обладаете сверхсильными навыками работы, при которых вы открываете среду разработки, а она вызывает хаосную обезьяну, которая отбрасывает вашу производственную базу данных, которая легко восстанавливается через 5 секунд.</li>
<li>или вы чувствуете себя как @monzo и готовы опробовать 1500 микросервисов просто потому, что можете.</li>
</ul>→ Не делайте этого.

А теперь менее гиперболизировано. 

Попытка моделировать микросервисы после доменных границ кажется вполне разумной. Но  это не означает, что нужно взять один рабочий процесс и разделить его на крошечные отдельные части (получить XML, проверить XML, переслать XML).

Следовательно, всякий раз, когда вы начинаете новый проект с микросервисам Java, и границы домена все еще очень расплывчаты, старайтесь поддерживать размер ваших микросервисов на нижнем уровне. Позднее вы всегда сможете добавить больше модулей.

И убедитесь, что у вас найдётся продвинутый DevOps в команде/компании/подразделении для поддержки вашей новой инфраструктуры.
<h2>Полиглот или командно-ориентированная микросервисная архитектура</h2>Существует третий, почти либертарианский, подход к разработке микросервисов: предоставление командам или даже отдельным лицам возможности реализовывать пользовательские истории с применением любого количества языков или микросервисов (маркетологи называют такой подход “полиглотским программированием”).

Так, описанная выше служба проверки XML может быть написана на Java, а микросервис валидации в то же самое время — на языке Haskell (чтобы сделать его математически обоснованным). Для микросервиса пересылки страховки можно применить язык Erlang (потому что он действительно должен масштабироваться;)).

То, что может показаться забавным с точки зрения разработчика (разработка идеальной системы с вашим идеальным языком в изолированной среде), в сущности, никогда не является тем, чего хочет организация: гомогенизация и стандартизация.

Это означает относительно стандартизированный набор языков, библиотек и инструментов, чтобы другие разработчики могли продолжать поддерживать ваш микросервис Haskell в будущем, когда вы перейдете на более экологичные пастбища.
<img data-max-width="800" data-id="fb4bbf84-771d-4ffb-8f9a-b279a060d429" src="/images/article/fb4bbf84-771d-4ffb-8f9a-b279a060d429/800.webp" class="img-fluid" alt="Руководство по микросервисам Java. Часть 1: основы микросервисов и их архитектура - 8">История показывает, что обычно стандартизация укореняется слишком глубоко. Скажем, разработчикам больших компаний из списка Fortune 500 иногда даже не позволяли использовать Spring, поскольку это «не входит в план компании по технологиям». Впрочем, полный переход на подход полиглота — это почти то же самое, другая сторона той же монеты.

Рекомендация: если вы собираетесь использовать полиглот-программирование, попробуйте меньшее разнообразие в одной и той же экосистеме языка программирования. Так, лучше применять вместе Kotlin и Java (оба языка основаны на JVM и 100% совместимы друг с другом), а не Java и, скажем, Haskell.

В <a href="https://javarush.com/groups/posts/2661-rukovodstvo-po-mikroservisam-java-chastjh-2-razvertihvanie-i-testirovanie" target="_blank">следующей части</a> вы узнаете о развертывании и тестировании микросервисов Java.