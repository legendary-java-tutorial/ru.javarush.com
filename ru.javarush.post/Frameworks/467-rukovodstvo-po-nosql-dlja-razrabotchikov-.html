Руководство по NoSQL для разработчиков 
<p>----------------------------------------</p>
Если вы следите за тенденциями в сферах backend-разработки и Big Data, то, вероятно, уже обратили внимание на шумиху вокруг баз данных NoSQL, характерную для последних лет. Кого-то такой подход к БД вдохновляет, кому-то кажется, что в нём сокрыт какой-то трюк ...
<p>----------------------------------------</p>
Если вы следите за тенденциями в сферах backend-разработки и Big Data, то, вероятно, уже обратили внимание на шумиху вокруг баз данных <em><strong>NoSQL</strong></em>, характерную для последних лет. Кого-то такой подход к БД вдохновляет, кому-то кажется, что в нём сокрыт какой-то трюк: модели данных в них не такие, как в привычных реляционных базах, интерфейсы программирования приложений непривычны, а приложения зачастую непонятны.
<img data-id="6b267f5d-9f92-44d6-b64a-ff40ab75d906" data-max-width="850" alt="Руководство по NoSQL для разработчиков  - 1" src="https://cdn.javarush.com/images/article/6b267f5d-9f92-44d6-b64a-ff40ab75d906/1024.jpeg">В этой статье я расскажу, почему они вообще были созданы, эти базы данных NoSQL, какие задачи они решают и почему вдруг необходимо так много различных баз данных.

Если вы — новичок в NoSQL, вас может особенно заинтересовать последняя часть статьи, в которой перечисляются базы данных этого типа, которые, по моему мнению, стоит изучить прежде всего, чтобы получить полное представление об этой области.
<h2>Зачем нам вдруг нужна новая база данных?</h2>Вы можете недоуменно спросить: а что не так с реляционными базами данных? Дело в том, что они действительно прекрасно работали на протяжении многих лет, но теперь появилась проблема, с которой они больше не могут справиться.

Согласно некоторым предсказаниям, в 2018 году человечество будет генерировать 50000 гигабайт данных в секунду. Это колоссальный объем данных! Его хранение и обработка представляет собой серьезный инженерный вызов. А ещё страшнее то, что этот объем постоянно растёт. 

Как оказалось, реляционные базы данных плохо приспособлены к работе с действительно большими объемами данных. Они спроектированы для работы на одной машине, и если вы хотели бы обрабатывать бОльшее количество запросов, то единственный вариант — купить компьютер с большим количеством оперативной памяти и более мощным процессором. К сожалению, количество запросов, которые способна обработать одна машина, ограничено, а для распределённой работы на нескольких машинах нам требуется другая технология баз данных.

Конечно, некоторые из читателей в этот момент усмехнутся и скажут, что существует два широко распространенных метода использования нескольких машин в случае реляционной базы данных: репликация и шардинг. Оно-то так, но этих методов недостаточно, чтобы справиться с нашими задачами.

<em><strong>Репликация чтения</strong></em> – методика, при которой каждое обновление базы данных распространяется на другие машины, которые могут обрабатывать только запросы на чтение. В этом случае все изменения выполняются одним сервером, называемым ведущим узлом, в то время как другие сервера, называемые репликами чтения, лишь поддерживают копии данных. Пользователь может читать с любой из машин, но изменять данные лишь через ведущий узел. Это удобный и очень популярный метод, но он позволяет лишь обрабатывать больше запросов на чтение и никак не решает задачу обработки требуемых объемов данных.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="c588d03a-22e1-493d-9b43-547ab74954da" data-max-width="710" alt="Руководство по NoSQL для разработчиков  - 2" src="https://cdn.javarush.com/images/article/c588d03a-22e1-493d-9b43-547ab74954da/1024.jpeg"></div><center><em>На рис.:<br />
Leader (read and write): Ведущий узел (читает и записывает)<br />
Read-replicas (read-only): Реплики чтения (только для чтения)</em></center></div><em><strong>Шардинг</strong></em> – ещё один популярный подход, при котором используется несколько экземпляров реляционной базы данных. Каждый из них обрабатывает операции записи и чтения для части данных. Если в базе данных хранится, например, информация о покупателях, с помощью шардинга одна машина может обрабатывать все запросы о покупателях, чьи имена начинаются на A, другая – хранить все данные о покупателях, чьи имена начинаются на B, и так далее. 
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="b4e8bde7-dbde-42a0-aab9-c98370424777" data-max-width="710" alt="Руководство по NoSQL для разработчиков  - 3" src="https://cdn.javarush.com/images/article/b4e8bde7-dbde-42a0-aab9-c98370424777/1024.jpeg"></div><center><em>На рис.:<br /> Multi-master (read and write part of data): Несколько ведущих узлов (читающих и записывающих части данных)</em></center></div>Хотя шардинг позволяет записывать больше данных, управление такой базой данных – настоящий кошмар: приходится выравнивать данные по машинам и масштабировать кластер в обе стороны по мере необходимости. Хотя в теории это выглядит просто, правильная реализация – весьма сложная задача.
<h2>Можно ли усовершенствовать реляционные базы данных?</h2>Думаю, вы уже поверили в то, что реляционные базы данных не лучшим образом приспособлены к генерируемым в современном мире объемам данных. Хотя, возможно, вы всё ещё недоумеваете, почему никто до сих пор не создал "улучшенной" реляционной базы данных, которая могла бы эффективно работать на нескольких машинах. Может показаться, что эта технология просто еще не разработана, и очень скоро появятся распределенные реляционные базы данных.

<em><strong>Увы, этого не произойдет. Это невозможно с точки зрения математики, и ничего поделать с этим нельзя.</strong></em>

Чтобы понять, почему это так, необходимо обратиться к так называемой теореме CAP (она же теорема Брюера). Её доказали в 1999 году, и она утверждает, что у работающая на нескольких машинах распределенная база данных может обладать следующими тремя свойствами:

<em><strong>Согласованностью</strong></em> (<em><strong>C</strong></em>onsistency) – в результате любой операции чтения возвращаются результаты последней соответствующей операции записи. Если система согласована, после записи новых данных, прочитать старые, уже перезаписанные, невозможно.

<em><strong>Доступностью</strong></em> (<em><strong>A</strong></em>vailability) – распределенная система в любой момент может обслужить входящий запрос и вернуть не ошибочный ответ.

<em><strong>Устойчивостью к нарушению связности</strong></em> (<em><strong>P</strong></em>artition tolerance) – база данных продолжает отвечать на запросы на чтение и запись даже в случае, когда часть её серверов временно неспособны взаимодействовать друг с другом. Этот временный сбой называется нарушением связности сети и может вызываться множеством фактором, начиная от физических проблем с сетью из-за медленно работающего сервера и заканчивая физическим повреждением сетевого оборудования.

Все эти свойства, безусловно, удобны, и нам бы очень хотелось, чтобы база данных сочетала их все. Ни один здравомыслящий разработчик не захочет отказаться от, скажем, доступности, не получив ничего взамен. <em><strong>К сожалению, теорема CAP также утверждает, что одновременное выполнение всех трёх свойств — невозможно.</strong></em>

Осознать это может быть непросто, но возможно. Во-первых, если нам нужна распределенная база данных, она обязана быть "устойчивой к нарушению связности". Это даже не обсуждается. Нарушения связности происходят <a href='http://queue.acm.org/detail.cfm?id=2655736' target='_blank'>всё время</a> и наша база данных обязана работать, несмотря на это.

Теперь давайте поймем, почему мы не можем добиться одновременно согласованности и доступности. Представьте, что у нас есть простая база данных, работающая на двух машинах: A и B. Любой её пользователь может выполнять запись на любую из машин, после чего данные копируются на другую.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="d0fcd850-98ed-44e7-806d-57730957b5f8" data-max-width="710" alt="Руководство по NoSQL для разработчиков  - 4" src="https://cdn.javarush.com/images/article/d0fcd850-98ed-44e7-806d-57730957b5f8/1024.jpeg"></div></div>Теперь представьте себе, что эти машины временно утратили возможность обмена сообщениями друг с другом, и машина B не может отправлять данные на машину A или получать данные от неё. Если в этот промежуток времени машина B получит запрос на чтение от клиента, у неё есть две возможности:
<ol>
<li>Вернуть свои локальные данные, даже если они не самые свежие. В этом случае отдается предпочтение доступности (вернуть хоть какие-то данные, даже устаревшие).</li>
<li>Вернуть ошибку. В этом случае отдается предпочтение согласованности: клиент не получит устаревшие данные, но и не получит вообще никаких.</li>
</ol><div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="3a7b1045-229a-4624-8256-6ec90c4c6ac4" data-max-width="710" alt="Руководство по NoSQL для разработчиков  - 5" src="https://cdn.javarush.com/images/article/3a7b1045-229a-4624-8256-6ec90c4c6ac4/1024.jpeg"></div><center><em>На рис.:<br /> Network partition: Нарушение связности сети</em></center></div>Реляционные базы данных стремятся воплотить свойства "согласованности" и "доступности" одновременно, и, следовательно, не могут работать в распределенной среде. Попытка реализовать все возможности реляционной базы данных в распределенной системе окажется или нереалистичной, или просто <a href='https://ferd.ca/beating-the-cap-theorem-checklist.html' target='_blank'>невыполнимой</a>.

С другой стороны, базы данных NoSQL, придают основное значение масштабируемости и производительности. В них обычно отсутствуют такие "базовые" возможности, как соединения и транзакции, а модель данных оказывается совсем другой, возможно, в чем-то даже ограничивающей. Всё это дает возможность хранения больших объемов данных и обработки большего числа запросов, чем было возможно когда-либо ранее.
<h2>Как базам данных NoSQL удается сочетать согласованность и доступность?</h2>Вам может казаться, что выбрав NoSQL БД, вы всегда будете получать или какие-то устаревшие данные, или ошибку в случае любого сбоя. На практике же, доступность и согласованность — отнюдь не единственные возможные варианты. Существует широкий спектр доступных для вашего выбора вариантов.

В реляционных базах данных этих параметров нет, но NoSQL позволяет вам управлять выполнением запросов подобным образом. Так или иначе, они позволяют задавать два параметра при выполнении операций записи или чтения в NoSQL базе данных:

<em><strong>W</strong></em> – сколько машин в кластере должно подтвердить сохранение данных при <em><strong>выполнении операции записи</strong></em>. Чем больше число машин, куда вы запишете свои данные, тем легче будет прочитать наиболее свежие данные при следующей операции чтения, но и тем больше времени это займет.

<em><strong>R</strong></em> – с какого количества машин вы хотели бы <em><strong>читать данные</strong></em>. В распределенной системе, распространение данных по всем машинам кластера может занять некоторое время, так что на некоторых серверах данные будут актуальными, а другие будут отставать. Чем больше число машин, с которых читаются данные, тем выше шансы прочитать актуальные данные.

Рассмотрим практический пример. Если в вашем кластере пять компьютеров, и вы решили записывать данные лишь на один, а затем читать данные с одного случайно выбранного компьютера, то с вероятностью 80% вы прочитаете устаревшие данные. С другой стороны, при этом будет использоваться минимум ресурсов. Так что, если устаревшие данные вас устраивают, это не такой уж плохой вариант. В этом случае параметры W и R равны 1.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="8d01704a-f65e-4432-b370-309678099e94" data-max-width="710" alt="Руководство по NoSQL для разработчиков  - 6" src="https://cdn.javarush.com/images/article/8d01704a-f65e-4432-b370-309678099e94/1024.jpeg"></div></div>С другой стороны, если вы записываете данные на все пять машин в базе данных NoSQL, то можете читать данные с любой машины, и каждый раз гарантированно получите актуальные данные. Выполнение той же операции при большем числе машин займет дольше времени, но если актуальные данные для вас важны, то можно выбрать этот вариант. В этом случае W = R = 5.

Каково минимальное количество операций чтения и записи, необходимое для согласованности база данных? 

Вот простая формула: <em><strong>R + W ≥ N + 1</strong></em>, где N – число машин в кластере. Это значит, что при пяти серверах, можно выбрать или R = 2 и W = 4, или R = 3 и W = 3 или R = 4 и W = 2. 

В этом случае не имеет значения, на какие машины записываются данные, чтение всегда будет производиться, по крайней мере, с одной машины с актуальными данными.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="0c8587ac-0868-4ac2-82b3-0a5e2d242ae8" data-max-width="710" alt="Руководство по NoSQL для разработчиков  - 7" src="https://cdn.javarush.com/images/article/0c8587ac-0868-4ac2-82b3-0a5e2d242ae8/1024.jpeg"></div></div> У других баз данных, например, DynamoDB, ограничения отличаются, и они разрешают лишь согласованные операции записи. Каждый элемент данных хранится на трёх серверах, и при записи любых данных, он записывается на две машины из трех. Но при чтении данных можно выбрать один из двух вариантов:
<ol>
<li>Cтрого согласованное чтение, при котором данные читаются с двух машин из трёх и всегда возвращаются последние записанные данные.</li>
<li>Чтение, согласованное в конечном счёте, при котором выбирается случайным образом одна машина, с которой читаются данные. При этом, однако, могут временно возвращаться устаревшие данные.</li>
</ol><h2>Почему существует так много NoSQL баз данных?</h2>Если вы следите за последними новостями в области разработки программного обеспечения, то наверняка слышали о множестве различных NoSQL баз данных, например, MongoDB, DynamoDB, Cassandra, Redis и многих других. Возможно, вы удивитесь: зачем нужно так много различных NoSQL баз данных? Причина проста: что различные базы данных NoSQL предназначены для решения различных задач. Именно поэтому число конкурирующих баз данных так велико. NoSQL базы данных делятся на четыре основные категории:
<h3>Документно-ориентированные базы данных</h3>Эти базы данных предоставляют возможность хранения сложных вложенных документов, в то время как большинство реляционных баз данных поддерживает лишь одномерные строки. Такая возможность может пригодиться во многих случаях, например, при необходимости хранения в системе информации о пользователе с несколькими адресами. При использовании документно-ориентированной базы данных, в подобном случае можно просто хранить сложный объект, включающий массив адресов, в то время как в реляционной базе данных вам пришлось бы создать две таблицы: одну для информации о пользователе, а вторую для адресов.

Документно-ориентированные базы данных позволяют <a href='https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch' target='_blank'>сократить разрыв</a> между объектной моделью и моделью данных. Некоторые реляционные базы данных, такие как PostgreSQL, теперь тоже поддерживают документно-ориентированное хранилище, но в большинстве реляционных баз данных эта возможность всё еще отсутствует.
<h3>Базы данных типа "ключ/значение"</h3>Базы данных типа "ключ/значение" обычно реализуют простейшую NoSQL-модель. По существу, они предоставляют вам распределенную <a href='https://en.wikipedia.org/wiki/Hash_table' target='_blank'>хэш-таблицу</a>, позволяющую записывать данные по заданному ключу и читать их обратно с его помощью.

Базы данных типа "ключ/значение" легко масштабируются и отличаются от других баз данных значительно более низкой задержкой.
<h3>Графовые базы данных</h3>Многие предметные области, например, социальные сети или информацию о фильмах и актёрах, можно представить в виде графов. Хотя граф можно представить и с помощью реляционной базы данных, это сложно и неудобно. Если вам нужны графовые данные, лучше воспользоваться специализированной графовой базой данных, которая может хранить информацию о графе в распределенном кластере и дает возможность эффективной реализации алгоритмов на графах.
<h3>Столбцовые базы данных</h3>Основное различие между столбцовыми и другими типами баз данных заключается в способе хранения данных на диске. Реляционные базы данных создают по файлу для каждой таблицы и хранят значения для всех строк последовательно. Столбцовые базы данных создают по файлу для каждого столбца ваших таблиц.

Такая структура позволяет агрегировать данные и выполнять определенные запросы эффективнее, однако необходимо убедиться, что данные соответствуют ограничениям таких баз данных.
<h3>Какую базу данных выбрать?</h3>Выбор базы данных – обычно мучительная проблема, и при таком количестве возможных вариантов может показаться невыполнимой задачей. Хорошая новость состоит в том, что нет нужды выбирать только одну.

Вместо создания единого монолитного приложения, реализующего все возможности и имеющего доступ ко всем данным системы, можно воспользоваться еще одним современным паттерном под названием "<a href='https://martinfowler.com/articles/microservices.html' target='_blank'>микросервисы</a>": разбить приложение на набор независимых сервисов. Каждый сервис решает свою узкую задачу, и использует только свою базу данных, которая максимально подходит для решения этой задачи.
<h2>Как прикажете всё это выучить?</h2>При <a href='https://db-engines.com/en/ranking' target='_blank'>таком количестве баз данных</a>, выучить их все может показаться невыполнимой задачей. Хорошая новость: этого делать и не надо. Существует лишь несколько основных типов NoSQL баз данных, и, если разобраться в принципах их работы, разобраться с другими будет намного проще. Также, некоторые NoSQL базы данных используются намного чаще других, так что лучше сосредоточить усилия на наиболее популярных решениях.

Вот список чаще всего используемых NoSQL баз данных, на которые, как мне кажется, вам стоит взглянуть:
<ol>
<li><em><strong>MongoDB</strong></em>. Вероятно, самая популярная NoSQL база данных на рынке. Если компания не использует в качестве основного хранилища данных реляционную базу данных, то, вероятно, она использует MongoDB. Это гибкое хранилище документов с хорошим набором инструментария. В начале своей "карьеры" у MongoDB была не лучшая репутация, потому что <a href='https://aphyr.com/posts/284-call-me-maybe-mongodb' target='_blank'>данные в ней в некоторых случаях терялись</a>, но с тех пор её стабильность и надежность намного повысились. Взгляните на этот <a href='http://shrsl.com/kzpn' target='_blank'>посвященный MongoDB курс</a>, если хотите узнать больше.</li><br>
<li><em><strong>DynamoDB</strong></em>. Если вы используете веб-сервисы Amazon (AWS), вам лучше узнать больше о DynamoDB. Это исключительно надежная, масштабируемая база данных с низкой задержкой, богатым набором возможностей и интеграцией с множеством других сервисов AWS. А самое приятное то, что её не нужно развертывать самостоятельно. Настроить масштабируемый кластер DynamoDB, способный обрабатывать тысячи запросов, можно всего за несколько щелчков мышью. Если это вас заинтересовало, можете взглянуть на <a href='http://shrsl.com/kzpt' target='_blank'>вот этот курс</a>.</li><br>
<li><em><strong>Neo4j</strong></em>. Самая распространенная графовая база данных. Это масштабируемое и стабильное решение, подходящее для желающих воспользоваться графовой моделью данных. Если хотите узнать больше – начните <a href='http://shrsl.com/kzsy' target='_blank'>с этого курса</a>.</li><br>
<li><em><strong>Redis</strong></em>. В то время как остальные описанные тут базы данных используются для хранения основных данных приложения, Redis применяется в основном для реализации кэша и хранения вспомогательных данных. Во многих случаях, используется одна из вышеупомянутых баз данных в тандеме с Redis. Чтобы узнать больше, загляните в этот <a href='http://shrsl.com/kzt5' target='_blank'>курс.</a></li>
</ol><h2>В 2018-м с NoSQL</h2>NoSQL базы данных – обширная и быстро развивающаяся область. Они позволяют хранить и обрабатывать неслыханные до сих пор объемы данных, но за это приходится платить.

В этих базах данных нет многих привычных по реляционным базам данных возможностей, и настроить себя на их использование может оказаться непросто. Но когда вы с ними разберетесь, то сможете создавать масштабируемые распределенные базы данных, способные обрабатывать поразительные объемы запросов на чтение и запись, что может иметь исключительное значение по мере генерации всё больших и больших объемов данных.

<em><strong>Оригинал: </strong></em><a href='https://simpleprogrammer.com/guide-nosql-software-developers/ ' target='_blank'>https://simpleprogrammer.com/guide-nosql-software-developers/ </a>
<table>
<tr><th>Что еще почитать?</th>
</tr>
<tr>
<td>
<p><a href='https://javarush.com/groups/posts/292-kljevihe-optimizacii-sql-ne-zavisjajshie-ot-stoimostnoy-modeli' target='_blank'>Клёвые оптимизации SQL, не зависящие от стоимостной модели. Часть 1</a></p>
<p><a href='https://javarush.com/groups/posts/72-kak-praviljhno-nachatjh-razrabotku-pod-subd-oracle' target='_blank'>Как правильно начать разработку под СУБД Oracle</a></p>
</td>
</tr>
</table>