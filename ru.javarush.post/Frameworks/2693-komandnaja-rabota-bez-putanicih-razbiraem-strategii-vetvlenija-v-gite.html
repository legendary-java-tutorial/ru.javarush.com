Командная работа без путаницы: разбираем стратегии ветвления в Гите
<p>----------------------------------------</p>
Гит стал де-факто промышленным стандартом для системы контроля версий в создании программного обеспечения. О том, что такое гит и как начать, почитайте вначале мою статью об этом. Прочитали? Отлично...
<p>----------------------------------------</p>
<h2>Вступление</h2>Гит стал де-факто промышленным стандартом для системы контроля версий в создании программного обеспечения.

О том, что такое гит и как начать, почитайте <a href="https://javarush.com/groups/posts/2683-nachalo-rabotih-s-git-podrobnihy-gayd-dlja-novichkov" target="_blank">вначале</a> мою статью об этом. 

Прочитали? Отлично, поехали дальше!
<img data-max-width="800" data-id="0a6eb9f6-1e54-4eb7-a031-a5876a09fcae" src="/images/article/0a6eb9f6-1e54-4eb7-a031-a5876a09fcae/800.jpeg" class="img-fluid" alt="Командная работа без путаницы: разбираем стратегии ветвления в Гите - 1">Нравится нам или нет, но инструмент, который Линус Товальдс создал, не собирается уходить на пенсию. Поэтому имеет смысл поговорить о том, как работать распределенным командам в гите и какую стратегию ветвления для этого выбрать. 

И это вопрос вовсе не праздный. Часто в ситуации, когда собирают новую команду разработчиков, которые не сотрудничали друг с другом, стратегия ветвления — это одно из первых, что нужно решить. 

И будут люди, которые будут с пеной у рта доказывать, что одна стратегия лучше другой. Поэтому я хочу донести до вас информацию о том, какими вообще они бывают.
<h3>А нужны ли стратегии ветвления?</h3>А вот нужны, и еще как нужны. Потому что если не договориться о чем-то в команде, получится, что каждый будет делать, что хочет:
<ul>
<li>работать в той ветке, в которой он хочет;</li>
<li>смердживать в другие ветки, в которые он хочет;</li>
<li>удалять какие-то ветки;</li>
<li>создавать новые; </li>
<li>и так —каждый из членов команды в неуправляемом потоке.</li>
</ul>Поэтому ниже приведу три стратегии. Поехали!
<h3>GitHub Flow стратегия</h3><img data-max-width="800" data-id="40ca42c4-6492-4586-818b-05ed07b8bfd9" src="/images/article/40ca42c4-6492-4586-818b-05ed07b8bfd9/800.jpeg" class="img-fluid" alt="Командная работа без путаницы: разбираем стратегии ветвления в Гите - 2">Стратегия ветвления, как бы это ни было странно, предпочитаемая в GitHub :) К ней прилагается <a href="https://githubflow.github.io/" rel="nofollow" target="_blank">набор правил</a>, которым нужно следовать:
<ol>
<li>Код в master ветке должен быть не поломанным и готовым к развертыванию в любое время (то есть нельзя туда положить код, который помешает собрать проект и развернуть его на сервере).</li>
<li>Когда планируется работа над новой функциональностью, необходимо создать новую ветку (feature ветку) на основе master ветки и дать ей понятное имя.
Коммитить свой код локально и регулярно пушить свои изменения на эту же ветку в удаленный репозиторий.</li>
<li>Открыть Pull-Request (что такое pull-request, можно почитать <a href="https://habr.com/ru/post/125999/" rel="nofollow" target="_blank">здесь</a>), когда есть четкое ощущение, что работа готова и может быть смерджена в master ветку (или если уверенности нет, но хочется получить отзывы о проделанной работе).</li>
<li>После того, как новую фичу в пул-реквесте заапрувили, ее можно смерджить в master ветку.</li>
<li>Когда изменения смерджены в master ветку, их нужно развернуть на сервере немедленно.</li>
</ol>По GitHub Flow получается, что прежде чем начать работу над чем-то новым, будь то исправление или новая фича, нужно создать новую ветку на основе master’а и дать ей подходящее имя.

Далее, начинается работа над реализацией. Нужно постоянно отправлять коммиты на удаленный сервер с тем же именем. Когда приходит понимание, что все готово, нужно создать пул-реквест в master ветку. Потом хотя бы один, а лучше — два человека должны посмотреть этот код и нажать Approve. Обычно обязательно должен посмотреть тимлид проекта и кто-то еще, и тогда уже можно завершать пул-реквест.

GitHub Flow еще известен тем, что драйвит <a href="https://rollout.io/blog/continuous-integration-continuous-delivery-continuous-deployment/" rel="nofollow" target="_blank">Continuous Delivery(CD)</a> на проекте. Потому что когда изменения заходят в master ветку, они должны сразу же быть развернуты на сервере.
<h3>GitFlow стратегия</h3><img data-max-width="512" data-id="5a14b4b7-158a-48fd-bebe-fe197309bf81" src="/images/article/5a14b4b7-158a-48fd-bebe-fe197309bf81/512.jpeg" class="img-fluid" alt="Командная работа без путаницы: разбираем стратегии ветвления в Гите - 3">Предыдущая стратегия (GitHub Flow) была по сути не очень сложной. Есть два типа веток: master и фиче ветки.

А вот GitFlow уже серьёзнее. Как минимум из картинки выше вы это можете понять)

Итак, как работает эта стратегия? 


В целом GitFlow состоит из двух постоянных веток и нескольких типов временных веток (В контексте GitHub Flow, master ветка — постоянная, а другие — временные).

<span class="text-bold">Постоянные ветки:</span>
<ul>
<li>master: эту ветку просто так никто не должен трогать/ничего не пушить туда. В этой стратегии master отображает последнюю стабильную версию, которую используют в продакшене (то есть на реальном сервере);</li>
<li>development — это ветка для разработки. Потенциально она может быть нестабильная.</li></ul>Разработка ведется при помощи трех <span class="text-bold">вспомогательных временных веток</span>:
<ol>
<li>Фиче ветки (feature branches) — для разработки новой функциональности.</li>
<li>Релизные ветки (release branches) — для подготовки выпуска новой версии проекта.</li>
<li>Хотфикс ветки (hotfix branches) — быстрое решение дефекта, который нашли уже реальные пользователи на реальном сервере.</li>
</ol><h4>Фиче ветки (feature branches)</h4>Фиче ветки создаются разработчиками для нового функционала. Они всегда должны создаваться на основе development ветки. 

После завершения работы над новой функциональностью, нужно создать пул-реквест в development ветку.

Понятно, что в больших командах одновременно может быть больше одной фиче ветки. Еще раз обратите внимание на картинку в начале описания стратегии GitFlow.
<h4>Релизные ветки (release branches)</h4>Когда необходимое количество новых фич подготовлено в development ветке, можно подготовиться к выпуску новой версии продукта. В этом нам поможет релизная ветка. которая создается на основе development ветки.

В ходе работы с релизной веткой нужно найти и починить все дефекты. 

Все новые изменения, которые требуются для стабилизации релизной ветки, нужно также смерджить обратно в development. Делается это для того, чтобы стабилизировать и development ветку.

Когда тестировщики скажут, что ветка достаточно стабильная для нового релиза, ее смердживают в master ветку. 

Далее на этом коммите создается метка (tag: подробнее можно почитать об этом <a href="https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8" rel="nofollow" target="_blank">здесь</a>), которой присваивается номер версии. 

Как пример, можно посмотреть на картинку в начале стратегии. Так вот, там <span class="text-bold">Tag 1.0</span>  — это как раз метка, которая указывает на версию 1.0 проекта.

И последнее — это хотфикс ветки.
<h4>Хотфикс ветки (Hotfix branches)</h4>Хотфикс ветки также предназначены для релиза новой версии в master. Только разница в том, что этот релиз не планируется. 

Бывают ситуации, когда дефекты доходят до релиза и уже обнаруживаются в работе. Например, iOS: как только выпустят новую версию, так сразу тебе куча обновлений с фиксами дефектов, которые обнаруживаются после релиза. В связи с этим нужно быстро пофиксить этот дефект и выпустить новую версию. 

На нашей картинке это соответствует версии 1.0.1.

Идея заключается в том, что работа над новыми функциональностями может не останавливаться в моменты, когда нужно починить дефект на реальном сервере (как у нас говорят, “на проде”: опять калька с английского слова production).

Хотфикс ветка должна создаваться от master ветки, так как она отображает состояние, которое работает в проде. Как только решение дефекта готово, смердживается в master, создается новая метка.

Так же, как и подготовка релизной ветки, хотфикс ветка должна смерджить свое решение в development ветку.
<h3>The Forking Workflow стратегия</h3><img data-max-width="800" data-id="9caec5c2-7969-4cca-94ad-318ad3aca782" src="/images/article/9caec5c2-7969-4cca-94ad-318ad3aca782/800.jpeg" class="img-fluid" alt="Командная работа без путаницы: разбираем стратегии ветвления в Гите - 4">В рамках Forking Workflow стратегии разработка ведется так, что есть два репозитория:
<ol>
<li>Оригинальный репозиторий, в который будут смердживаться все изменения.</li>
<li>Форк репозиторий (это копия оригинального репозитория во владении другого разработчика, который хочет внести изменения в оригинальный).</li></ol>Пока звучит как-то странно, да?

Тем, кто уже сталкивался с open-source разработкой, этот подход уже знаком.
Такая стратегия дает следующее премущество: разработка может вестись в форк-репозитории и без предоставления прав на совместную разработку в оригинальном.

Разумеется, что владелец оригинального репозитория вправе отклонить предлагаемые изменения. Или согласиться и смерджить их.

Это удобно и владельцу оригинального репозитория, и разработчику, который хочет поучаствовать в создании какого-то продукта. 

Например можно предложить изменения в <a href="https://github.com/torvalds/linux" rel="nofollow" target="_blank">ядро линукса</a>. Если Линус решит, что они имеют смысл, изменения будут добавлены (!!!).
<h3>Пример The Forking Workflow</h3>The Forking Flow применяется на GitHub’e в момент, когда есть какая-то библиотека, которую хочется использовать. В ней есть дефект, который мешает использовать ее полноценно. 

Допустим, вы погрузились достаточно в проблему и знаете решение. При помощи The Forking Workflow стратегии можно решить эту задачу без предоставления прав для работы в оригинальном репозитории библиотеки.

Чтобы начать работу, нужно выбрать какой-то репозиторий, например, <a href="https://github.com/spring-projects/spring-framework" rel="nofollow" target="_blank">ядро Spring Framework</a>, Находим в верхнем правом углу кнопку Fork и нажимаем ее:
<img data-max-width="1024" data-id="0eba6191-9a64-4614-b4c9-020b1cd81c9d" src="/images/article/0eba6191-9a64-4614-b4c9-020b1cd81c9d/1024.jpeg" class="img-fluid" alt="Командная работа без путаницы: разбираем стратегии ветвления в Гите - 5">Это займет некоторое время, после чего появится копия этого оригинального репозитория в личном аккаунте, в котором будет указано, что она является форком:
<img data-max-width="800" data-id="248f8d47-290b-4ff9-9f4b-0b0ab0ead019" src="/images/article/248f8d47-290b-4ff9-9f4b-0b0ab0ead019/800.jpeg" class="img-fluid" alt="Командная работа без путаницы: разбираем стратегии ветвления в Гите - 6">Далее вы можете работать с этим репозиторием в обычном режиме, добавлять изменения в master ветку и когда все будет готово — создать Pull-Request в оригинальный репозиторий.

Для этого нужно нажать кнопку <span class="text-bold">New Pull request</span>:
<img data-max-width="800" data-id="2ec57367-e6a2-4203-8f06-c6004a01636e" src="/images/article/2ec57367-e6a2-4203-8f06-c6004a01636e/800.jpeg" class="img-fluid" alt="Командная работа без путаницы: разбираем стратегии ветвления в Гите - 7"><h3>Какую стратегию выбрать</h3>Гит — это гибкий и мощный инструмент, который позволяет работать, используя широкий спектр процессов и стратегий. Но чем больше выбор, тем сложнее решить, какую именно стратегию сейчас выбрать.

Ясно, что нет однозначного ответа для всех. Все зависит от ситуации. Тем не менее, есть несколько рекомендаций, которые могут помочь в этом:
<ol>
<li>Сперва лучше выбирать самую простую стратегию. Переходить к более сложным стратегиям только тогда, когда это нужно.</li>
<li>Рассматривать стратегии, в которых как можно меньше типов веток для разработчиков.</li>
<li>Посмотреть на плюсы и минусы разных стратегий и, в соответствии с проектом, выбрать нужную.</li>
</ol>Это все, что я хотел рассказать по поводу стратегии ветвления в гите. Спасибо за внимание :)

<span class="text-bold">Подписывайтесь на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мой гитхаб аккаунт</a></span>, я там часто выкладываю свои наработки в разных технологиях и инструментах, которые использую в работе
<h2>Полезные ссылки</h2><ul>
<li><a href="https://githubflow.github.io/" rel="nofollow" target="_blank">GitHub flow:</a>  the best way to use Git and GitHub</li>
<li><a href="https://habr.com/ru/post/125999/" rel="nofollow" target="_blank">Pull request'ы на GitHub или Как мне внести изменения в чужой проект</a></li>
<li>GitHub: <a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests" rel="nofollow" target="_blank">About Pull-Requests</a></li>
<li><a href="https://rollout.io/blog/continuous-integration-continuous-delivery-continuous-deployment/" rel="nofollow" target="_blank">Continuous Integration, Delivery, and Deployment Differentiated</a></li>
<li>Основы Гит: <a href="https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8" rel="nofollow" target="_blank">работа с метками</a></li>
<li>Хабр: <a href="https://habr.com/ru/post/106912/" rel="nofollow" target="_blank">Удачная модель ветвления для Git</a></li>
</ul>