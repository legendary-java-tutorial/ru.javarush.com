Реализуем развертывание приложения - "Java-проект от А до Я"
<p>----------------------------------------</p>
Всем привет. Продолжаем цикл статей по написанию своего проекта. Из важного, чтобы не потеряться в ветках и их порядке в репозитории, я решил их переименовать, добавив приставку STEP_{number}. Например, у нас есть три ветки...
<p>----------------------------------------</p>
Всем привет. Продолжаем цикл статей по написанию своего проекта.

<img data-max-width="800" data-id="b90d4b3b-cbf0-4c7e-a6df-945302d7f20a" src="https://cdn.javarush.com/images/article/b90d4b3b-cbf0-4c7e-a6df-945302d7f20a/800.jpeg" alt="“Java-проект от А до Я”: Реализуем развертывание приложения - 1"><h2>Сортируем ветки</h2>Из важного, чтобы не потеряться в ветках и их порядке в репозитории, я решил их переименовать, добавив приставку <span class="text-bold">STEP_{number}</span>. Например, у нас есть три ветки помимо главной:<ul>
<li>JRTB-0</li>
<li>JRTB-2</li>
<li>JRTB-3</li>

</ul>Сразу не поймешь, какая за какой должна идти. Поэтому я их переименую следующим образом:<ul>
<li>STEP_1_JRTB-0 — первый шаг</li>
<li>STEP_2_JRTB-2 — второй шаг</li>
<li>STEP_3_JRTB-3 — третий шаг</li>

</ul>И так далее для следующих статей.

Чтобы переименовать ветки, заходим на <a href="https://github.com/javarushcommunity/javarush-telegrambot" rel="nofollow" target="_blank">страницу репозитория</a>, находим плашку <span class="text-bold">branches</span>, переходим по ней:<img data-max-width="1080" data-id="12e7cd1d-e782-4c9e-996f-07fd1469d62b" src="https://cdn.javarush.com/images/article/12e7cd1d-e782-4c9e-996f-07fd1469d62b/1080.jpeg" alt="“Java-проект от А до Я”: Реализуем развертывание приложения - 2">Под каждой веткой нажимаем на карандашик и переименовываем ветку:<img data-max-width="512" data-id="2083743b-d4d8-4f7e-94b2-1d736d6ebf22" src="https://cdn.javarush.com/images/article/2083743b-d4d8-4f7e-94b2-1d736d6ebf22/512.jpeg" alt="“Java-проект от А до Я”: Реализуем развертывание приложения - 3">И в результате получим:<img data-max-width="1080" data-id="facd6ae3-25f3-4b7a-bc7c-d30973d5a772" src="https://cdn.javarush.com/images/article/facd6ae3-25f3-4b7a-bc7c-d30973d5a772/1080.jpeg" alt="“Java-проект от А до Я”: Реализуем развертывание приложения - 4">Кстати, все, кто подписан на <a href="https://t.me/romankh3" rel="nofollow" target="_blank">мой телеграм-канал</a>, узнали сразу же, что я переименовал ветки.<h2>Немного о докере</h2>Что такое Docker? Вкратце — это инструмент, с помощью которого можно быстро и безопасно развертывать (деплоить) приложения, создавая для них закрытую инфраструктуру, необходимую только для них.

Пока что сложно, я понимаю. В общем и целом докер можно понимать как платформу для разработки, где можно быстро и эффективно работать. 

Докер можно понимать как программу, которая работает на сервере. Эта программа имеет возможность хранить контейнеры с приложениями.

Что такое контейнер? Это отдельная инфраструктура, в которую можно добавить все, что нужно. Например для Java-приложения нам нужна JRE, чтобы запустить приложение, вот контейнер будет иметь это, нужно будет еще какое-то программное обеспечение — можно добавить это.

А может быть, нам нужен Линукс и Tomcat сервлет контейнер. Такое тоже можно будет сделать. 

Контейнеры создаются на основе image (образа): то есть, это определенный шаблон в котором написано все необходимое для создания докер контейнера.

Как создать этот образ? В нашем случае нам нужно будет создать файл  Dockerfile в корне проекта с описанием того, что должно быть в контейнере. Так как мы не хотим где-то показывать токен бота, придется извернуться и передавать его каждый раз, когда мы захотим развертывать приложение.

Более детально об этой теме почитать можно <a href="https://habr.com/ru/post/253877/" rel="nofollow" target="_blank">здесь</a> и <a href="https://habr.com/ru/post/309556/" rel="nofollow" target="_blank">здесь</a>.<h2>Пишем JRTB-13</h2>Нужно настроить быстрый и легкий процесс развертывания (деплоя) нашего приложения на сервер. То есть на машину, которая работает 24/7. За основу возьмем докер. Но задачи в нашем списке, которая бы отвечала за добавление этой функциональности, нет. Как-то я его пропустил при создании. Ничего страшного, сейчас создадим.

Заходим на вкладку <a href="https://github.com/javarushcommunity/javarush-telegrambot/issues/new/choose" rel="nofollow" target="_blank">создания issue</a> на гитхаб и выбираем Feature Request:<img data-max-width="1080" data-id="5013c175-6776-4d30-860e-55a733150703" src="https://cdn.javarush.com/images/article/5013c175-6776-4d30-860e-55a733150703/1080.jpeg" alt="“Java-проект от А до Я”: Реализуем развертывание приложения - 5">Добавляем описание задачи, критерии его приемки, устанавливаем, к какому проекту этот issue относится и можно создавать новое issue:<img data-max-width="1080" data-id="47809c3f-cd45-41c7-9726-ee2e07e38b57" src="https://cdn.javarush.com/images/article/47809c3f-cd45-41c7-9726-ee2e07e38b57/1080.jpeg" alt="“Java-проект от А до Я”: Реализуем развертывание приложения - 6">Теперь чтобы показать, что <a href="https://github.com/javarushcommunity/javarush-telegrambot/issues/18" rel="nofollow" target="_blank">задача</a> взята в работу, сменим статус задачи с To do на In Progress:<img data-max-width="1080" data-id="ff6e6f4d-75a2-4c4b-b5be-b01b2473b6ba" src="https://cdn.javarush.com/images/article/ff6e6f4d-75a2-4c4b-b5be-b01b2473b6ba/1080.jpeg" alt="“Java-проект от А до Я”: Реализуем развертывание приложения - 7">Это будет сложная статья. Если будут проблемы — пишите в комментариях: я буду следить и отвечать на них в меру сил. Такой будет небольшой Customer Support :D<h2>Создаем Dockerfile</h2>Что такое докерфайл? Для докера это скрипт (пошаговая инструкция), как создавать образ для докер контейнера. 

Для работы нашего приложения нужна JDK, причем 11-й версии. То есть, нам нужно найти докер-образ JDK 11 и добавить его в наш образ. Это что-то сродни с тем, как мы добавляем зависимость в помник. Для этого дела у докера есть <a href="https://hub.docker.com/" rel="nofollow" target="_blank">DockerHub</a>. Чтобы локально загружать образы, нужно там зарегистрироваться. После регистрации идем искать нам JDK11. Из того, что получилось найти — вот этот контейнер: <a href="https://hub.docker.com/r/adoptopenjdk/openjdk11/" rel="nofollow" target="_blank">adoptopenjdk/openjdk11</a>. В описании этого контейнера есть то, что нужно для докерфайла:

<pre class="language-java line-numbers"><code>
FROM adoptopenjdk/openjdk11:ubi
RUN mkdir /opt/app
COPY japp.jar /opt/app
CMD ["java", "-jar", "/opt/app/japp.jar"]
</code></pre>
Поправим папку, из которой мы берем jar файл. У нас он находится в target папке после того, как мы запускаем mvn package задачу мавена.

Перед тем, как все это делать, на основе обновленной main ветки создаем новую, для нашей задачи: <span class="text-bold">STEP_4_JRTB-13</span>.

Теперь можно работать. В корне проекта создаем файл без расширения <span class="text-bold">Dockerfile</span> и добавим внутрь следующее:

<pre class="language-java line-numbers"><code>
FROM adoptopenjdk/openjdk11:ubi
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
</code></pre>
Первая строка — на основе чего будет состоять образ — adoptopenjdk/openjdk11.

Вторая строчка — добавляем аргумент в образ с именем JAR_FILE, который находится в папке target. Причем нынешняя папка определяется по месту Dockerfile.

Третья строка — копируем в докер-образ jar нашего проекта.

Последняя строка по сути содержит массив, созданный из команды в терминале, которую разделили по пробелу. 

То есть, в итоге будет выполнено следующее:
“java -jar /app.jar”

Чтобы держать в тайне токен бота, при запуске контейнера нам нужно будет передавать две переменные — имя бота и его токен.

Для этого напишем запрос, который должен запустить наш проект с переменными. А как это сделать? Нужно загуглить: вот <a href="https://stackoverflow.com/questions/55440726/how-to-make-environment-variables-work-in-a-jar-file" rel="nofollow" target="_blank">первая ссылка</a> с нормальным описанием.

А что мы хотим сделать? 

У нас в application.properties файле есть две переменные, которые мы там определяем:<ul>
<li>bot.username</li>
<li>bot.token</li>

</ul>Я хочу запускать докер контейнер и каждый раз передавать туда свое значение, чтобы никто не видел эти значения.

Я знаю, что в SpringBoot переменные окружения, которые задаются в момент запуска jar проекта, будут более приоритетнее чем те, которые находятся в файле application.properties.

Чтобы передать переменную в запросе, нужно добавить следующую конструкцию: <span class="text-bold">-D{имя переменной}=”{значение переменной}”</span>. Фигурные скобки не дописываем ;) 

Получим запрос, при котором будет запущено наше приложение с предопределенными значениями — имя и токена бота:

<span class="text-bold">java -jar -Dbot.username=”test.javarush.community_bot” -Dbot.token=”dfgkdjfglkdjfglkdjfgk” *.jar</span>

Теперь нужно передать эти переменные внутрь докер контейнера. Это environment variable.

Чтобы в будущем у нас база данных работала четко и без проблем с нашим приложением, будем использовать docker-compose. Это отдельный инструмент, в котором можно упорядочить работу, запуск и зависимости между контейнерами. Иными словами, это надстройка над докером, чтобы управлять контейнерами одной инфраструктуры.

Плюс перед тем, как запустить docker-compose, нужно быть уверенным, что мы стянули все изменения кода с сервера, собрали приложение и остановили старую версию. Для этого будем использовать баш скрипт.

Ух… Звучит все непросто, согласен. Но работа с настройкой развертывания приложений — это всегда муторный и сложный процесс.

Поэтому у нас вырисовывается нехилая схема:<ol>

<li>Запускаем баш скрипт.</li>
<li>Баш скрипт запускает docker-compose.</li>
<li>Docker-compose запускает docker контейнер с нашим приложением.</li>
<li>Docker контейнер запускает наше приложение.</li>

</ol>И вот нужно сделать так, чтобы две переменные — имя бота и его токен — прошли из 1 пункта в 4. Причем так, чтобы эти две переменные использовались при запуске нашего java-приложения. 

Пойдем с конца в начало. Мы уже знаем, какую команду нужно выполнить, чтобы запустить джарник.

Поэтому будем настраивать Dockerfile, чтобы он научился принимать две переменные и передавать их в запрос.

Для этого приведем Dockerfile к следующему виду:

<pre class="language-java line-numbers"><code>
FROM adoptopenjdk/openjdk11:ubi
ARG JAR_FILE=target/*.jar
ENV BOT_NAME=test.javarush_community_bot
ENV BOT_TOKEN=1375780501:AAE4A6Rz0BSnIGzeu896OjQnjzsMEG6_uso
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java", "-Dbot.username=${BOT_NAME}", "-Dbot.token=${BOT_TOKEN}", "-jar", "/app.jar"]
</code></pre>
Видно, что мы добавили две строки и обновил ENTRYPOINT.

Строки:

<pre class="language-java line-numbers"><code>
ENV BOT_NAME=test.javarush_community_bot
ENV BOT_TOKEN=1375780501:AAE4A6Rz0BSnIGzeu896OjQnjzsMEG6_uso
</code></pre>
объявляют переменные внутри кодер файла. По умолчанию у них значение указано. Если при создании образа из этого докерфайла будут переданы переменные окружения с такими именами, значения будут другие. 

А в ENTRYPOINT мы добавили еще несколько элементов, которые будут считывать эти переменные среды:

<pre class="language-java line-numbers"><code>
"-Dbot.username=${BOT_NAME}", "-Dbot.token=${BOT_TOKEN}"
</code></pre>
Здесь видно, что внутри строки при помощи ${} конструкции будут переданы значения BOT_NAME и BOT_TOKEN.

Далее нам нужно научить получать и передавать эти переменные в docker-compose.<h2>Создаем docker-compose.yml</h2>Хорошо бы вам про YAML формат почитать отдельно, а то статья и так уже растет, как на дрожжах.

Для нас это просто еще одно описание переменных по типу .properties. Только в пропертях записывается через точку, а в YAML это делается немного красивее. Например, так. 

Две переменные в .properties:

javarush.telegram.bot.name=ivan
javarush.telegram.bot.token=pupkin

А вот в .yaml (тоже самое что и .yml) будет это так:

<pre class="language-java line-numbers"><code>
javarush:
	telegram:
		bot:
		  name: ivan
		  token: pupkin
</code></pre>
Второй вариант более красивый и понятный. Пробелы должны быть именно такие, как указаны выше. Как-нибудь переведем наши application.properties и application.yml.

Для начала нужно его создать. В корне проекта создаем файл <span class="text-bold">docker-compose.yml</span> и записываем туда следующее:

<pre class="language-java line-numbers"><code>
version: '3.1'

services:
 jrtb:
   build:
     context: .
   environment:
     - BOT_NAME=${BOT_NAME}
     - BOT_TOKEN=${BOT_TOKEN}
   restart: always
</code></pre>
Первая строка — это версия docker-compose.

<span class="text-bold">services:</span> говорит о том, что все следующие строки после этого (будут сдвинуты) — относятся к сервисам, которые мы настраиваем. 

У нас такой пока только один — java-приложение под названием <span class="text-bold">jrtb</span>. И уже под ним будут все его настройки. Например, <span class="text-bold">build: context: .</span> говорит о том, что мы будем искать Dockerfile в той же директории, что и docker-compose.yml. 

А вот секция <span class="text-bold">environment:</span> будет отвечать за то, чтобы мы передали в Dockerfile необходимые переменные среды (environment variables). Как раз то, что нам и нужно. Поэтому ниже мы переменные и передаем. Их docker-compose будет искать в переменных операционной среды сервера. Добавим их в баш скрипте.<h2>Создаем баш скрипты</h2>И последний шаг — создать баш скрипт.

Создаем в корне проекта файл с именем start.sh и пишем туда следующее:

<pre class="language-java line-numbers"><code>
#!/bin/bash

# Pull new changes
git pull

# Prepare Jar
mvn clean
mvn package

# Ensure, that docker-compose stopped
docker-compose stop

# Add environment variables
export BOT_NAME=$1
export BOT_TOKEN=$2

# Start new deployment
docker-compose up --build -d
</code></pre>
Первая строка нужна для всех баш скриптов: без нее работать не будет. А далее — просто набор команд в терминале, которые нужно выполнить.

Я добавил комментарии в каждой команде, поэтому должно быть понятно. Единственное, что хочется объяснить — это то, что значит $1 и $2. Это две переменные, которые будут переданы в запуске баш скрипта.

При помощи команды export они будут добавлены в переменные сервера и считаны уже в docker-compose. Это работает для убунты, для виндоуса, наверно, нет, но я не уверен. 

Теперь нужно добавить скрипт stop.sh, который будет останавливать работу. В нем будет несколько строк:

<pre class="language-java line-numbers"><code>
#!/bin/bash

# Ensure, that docker-compose stopped
docker-compose stop

# Ensure, that the old application won't be deployed again.
mvn clean
</code></pre>
Здесь мы останавливаем docker-compose и зачищаем джарник проекта, который лежит еще с прошлой сборки. Делаем мы это для того, чтобы наш проект точно пересобирался. Были прецеденты, поэтому и добавляю)

В итоге у на получается 4 новых файла:<ul>

<li>Dockerfile — файл для создания образа нашего приложения;</li>
<li>docker-compose.yml — файл с настройкой того, как мы будем запускать наши контейнеры;</li>
<li>start.sh — баш скрипт для развертывания нашего приложения;</li>
<li>stop.sh — баш скрипт для остановки нашего приложения.</li>

</ul>Также обновим версию нашего приложения с 0.2.0-SNAPSHOT на 0.3.0-SNAPSHOT.

Добавим в RELEASE_NOTES описание к новой версии и немного отрефакторим то, что было:

<div class="terminal"># Release Notes

## 0.3.0-SNAPSHOT

*   JRTB-13: added deployment process to the project

## 0.2.0-SNAPSHOT

*   JRTB-3: implemented Command pattern for handling Telegram Bot commands

## 0.1.0-SNAPSHOT

*   JRTB-2: added stub telegram bot
*   JRTB-0: added SpringBoot skeleton project</div>
И в README  добавим новый параграф с описанием того, как деплоить наше приложение:

<div class="terminal">## Deployment
Deployment process as easy as possible:
Required software:
- terminal for running bash scripts
- docker
- docker-compose

to deploy application, switch to needed branch and run bash script:

$ bash start.sh ${bot_username} ${bot_token}

That's all.</div>
Разумеется, все пишет на английском.

Уже как обычно, в нашей новосозданной ветке STEP_4_JRTB-13 создаем новый коммит с именем: <span class="text-bold">JRTB-13: implement deployment process via docker</span> и делаем пуш.

Я перестаю подробно останавливаться на вещах, которые я уже описывал в прошлых статьях. Не вижу смысла повторять одно и тоже. К тому же, кто разобрался и сделал у себя, у того вопросов не возникнет. Это я о том, как создать новую ветку, как создать коммит, как запушить коммит в репозиторий.<h2>Итог</h2>За сегодня я показал тьму новой информации, которую нужно хорошо обдумать и расширить дополнительным чтением. 

Самое главное: при помощи ОДНОЙ(!!!) команды все необходимое для развертывания нашего приложения будет сделано. Это настолько классно, что я даже передать не могу вам.

Да, пришлось потратить приличное количество времени в документации докера, чтобы понять, как правильно пробрасывать переменные. С этого момента телеграм-бот всегда будет работать на последней версии <span class="text-bold">main</span> ветки. 

<a href="https://t.me/test_javarush_community_bot" rel="nofollow" target="_blank">Ссылка на телеграм-бота.</a>

Сегодня не будут ссылок на материалы, которые хорошо бы прочесть: ответственность лежит на вас. Нужно учиться искать информацию. Все, кто подписан на мой телеграм-канал, узнали о деплое бота почти сразу же.

Друзья, нравится проект? Ставьте ему <a href="https://github.com/javarushcommunity/javarush-telegrambot/stargazers" rel="nofollow" target="_blank">звезду</a>! Так он станет более популярным и больше людей смогут узнать о нем и поучиться.

<em>Традиционно предлагаю зарегистрироваться на GitHub и подписаться на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мой аккаунт</a>, чтобы следить за этой серией и другими моими проектами, которые я веду там. </em>

Теперь мы готовы подключать базу данных. Следующая статья будет бооольшая и в ней мы сделаем все необходимое для работы с БД. Все описание — в <a href="https://github.com/javarushcommunity/javarush-telegrambot/issues/1" rel="nofollow" target="_blank">JRTB-1</a>.

<h4><a href="https://javarush.com/groups/posts/2935-java-proekt-ot-a-do-ja-pishem-realjhnihy-proekt-dlja-portfolio#articles" target="_blank">Список всех материалов серии в начале этой статьи.</a></h4>