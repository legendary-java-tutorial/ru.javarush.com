Часть 2. Структура СУБД, таблицы и типы данных
<p>----------------------------------------</p>
Мы  продолжаем создавать наш простенький эмулятор биржи. Вот что мы сделаем: cоздадим схему организации базы данных, распишем что, как и где хранится, узнаем, как данные связаны друг с другом, начнём изучать основы SQL на примере команды создания таблицы SQL ...
<p>----------------------------------------</p>
<em><strong><a href='https://javarush.com/groups/posts/1952-vvedenie-v-sql' target='_blank'>Первая часть</a></strong></em>
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="d116f10d-8657-474a-87f7-abf56ed59e70" data-max-width="710" alt="Часть 2. Структура СУБД, таблицы и типы данных - 1" src="https://cdn.javarush.com/images/article/d116f10d-8657-474a-87f7-abf56ed59e70/1024.jpeg"></div></div>Мы  продолжаем создавать наш простенький эмулятор биржи. Вот что мы сделаем: 

<ul>
<li>Создадим  схему организации базы данных.</li>
<li>Распишем что, как и где хранится.</li>
<li>Узнаем, как данные связаны друг с другом.</li>
<li>Начнём изучать основы SQL на примере команды создания таблицы SQL  <strong>CREATE TABLE</strong>,  Data Definition Language (<strong>DDL</strong>) языка SQL.</li>
<li>Продолжим писать Java-программу. Основные функции СУБД в части java.sql по созданию нашей базы данных реализуем программно, используя JDBC и трехзвенную (3-tier) архитектуру.</li>
</ul>
Эти две части вышли более объёмными, поскольку нам необходимо ознакомиться с основами SQL и организацией СУБД изнутри, и привести аналогии с Java. Чтобы не утомлять листингами кода, в конце приведены ссылки на соответствующий commit github-репозитория с программой. 

<h2>Дизайн СУБД</h2><h3>Описание приложения</h3>Вы уже слышали о том, что организация хранения данных – неотъемлемая часть программирования. Напомню, цель нашего приложения – простейшая эмуляция биржи: 

<ul>
<li>Существуют акции, стоимость которых может меняться в течение торгового дня по заданным правилам;</li>
<li>есть трейдеры с начальным капиталом;</li>
<li>трейдеры могут покупать и продавать акции, согласно своему алгоритму.</li>
</ul>
Биржа работает <strong>тиками</strong> – фиксированными периодами времени (в нашем случае — 1 мин). В течение тика может поменяться курс акции, далее совершиться покупка или продажа акций трейдером. 

<h3>Структура данных эмуляции биржи</h3>Назовем отдельные сущности биржи моделями. Чтобы избежать ошибок округления, с финансовыми суммами будем работать через класс <code><strong>BigDecimal</strong></code> (подробности можно узнать по ссылке в конце статьи). Распишем структуру каждой модели подробнее:

<strong>Акция:</strong>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Тип</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td><em>Srting</em></td>
<td>Наименование</td>
</tr>
<tr>
<td><code>changeProbability</code></td>
<td><em>int</em></td>
<td>Вероятность смены курса в процентах на каждом тике</td>
</tr>
<tr>
<td><code>startPrice</code></td>
<td><em>BigDecimal</em></td>
<td>Начальная стоимость</td>
</tr>
<tr>
<td><code>delta</code></td>
<td><em>int</em></td>
<td>Максимальная величина в процентах, на которую может смениться текущая стоимость</td>
</tr>
</tbody>
</table>
<strong>Курс акции:</strong>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Тип</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operDate</code></td>
<td><em>LocalDateTime</em></td>
<td>Время (тик) выставления курса</td>
</tr>
<tr>
<td><code>share</code></td>
<td><em>Акция</em></td>
<td>Ссылка на акцию</td>
</tr>
<tr>
<td><code>rate</code></td>
<td><em>BigDecimal</em></td>
<td>Курс акции</td>
</tr>
</tbody>
</table>
<strong>Трейдер:</strong>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Тип</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td><em>String</em></td>
<td>Время (тик) выставления курса</td>
</tr>
<tr>
<td><code>sfreqTick</code></td>
<td><em>int</em></td>
<td>Частота совершения операций. Задана периодом, в тиках, спустя который трейдер совершает операции</td>
</tr>
<tr>
<td><code>cash</code></td>
<td><em>BigDecimal</em></td>
<td>Сумма денег, помимо акций</td>
</tr>
<tr>
<td><code>traidingMethod</code></td>
<td><em>int</em></td>
<td>Используемый трейдером алгоритм. Зададим его числом-константой, реализация алгоритма будет (в следующих частях) в Java-коде</td>
</tr>
<tr>
<td><code>changeProbability</code></td>
<td><em>int</em></td>
<td>Вероятность выполнения операции, в процентах</td>
</tr>
<tr>
<td><code>about</code></td>
<td><em>String</em></td>
<td>Вероятность смены курса, в процентах, на каждом тике</td>
</tr>
</tbody>
</table>
<strong>Действия трейдеров:</strong>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Тип</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operation</code></td>
<td><em>int</em></td>
<td>Тип операции (покупка или продажа)</td>
</tr>
<tr>
<td><code>traider</code></td>
<td><em>Трейдер</em></td>
<td>Ссылка на трейдера</td>
</tr>
<tr>
<td><code>shareRate</code></td>
<td><em>Курс акции</em></td>
<td>Ссылка на курс акции (соответственно на саму акцию, её курс и время его выставление)</td>
</tr>
<tr>
<td><code>amount</code></td>
<td><em>Long</em></td>
<td>Количество акций, участвующих в операции</td>
</tr>
</tbody>
</table>
Для обеспечения уникальности каждой модели, добавим атрибут <code>id</code> типа <strong>long</strong>.  Данный атрибут будет <em><strong>уникальным</strong></em> в пределах экземпляров модели и будет однозначно его определять. Атрибуты, ссылающиеся на другие модели (трейдер, акция, курс акции), могут использовать этот <code>id</code> для однозначного определения соответствующей модели.

Сразу приходит мысль, что мы могли бы использовать <code>Map&lt;Long, Object&gt;</code>  для хранения подобных данных, где <code>Object</code> – соответствующая модель. Однако попробуйте реализовать это в коде при следующих условиях:

<ul>
<li>размер данных существенно превышает объем доступной оперативной памяти;</li>
<li>доступ к данным предполагается с десятка разных мест;</li>
<li>необходима возможность одновременного модифицирования и чтения данных;</li>
<li>нужно обеспечить правила формирования и целостности данных;</li>
</ul>
…и вы столкнётесь с задачами, требующими должной квалификации и времени на реализацию. Не стоит «изобретать велосипед». Многое уже продумано и написано за нас. Так что мы будем использовать то, что уже проверено годами.

<h3>Хранение данных в Java</h3>Рассмотрим акцию. В Java мы создали для этой модели определенный класс <code>Share</code> c полями <code>name</code>, <code>changeProbability</code>, <code>startPrice</code>, <code>delta</code>.  А множество акций хранили как <code><strong>Map&lt;Long, Share&gt;</strong></code>, где ключом служит уникальный идентификатор для каждой акции. 

<pre class='lang-java line-numbers'><code>
public class Share {
    private String name;
    private BigDecimal startPrice;
    private int changeProbability; 
    private int delta;   
}
Map&lt;Long, Share&gt; shares = new HashMap&lt;&gt;();
shares.put(1L, new Share("ibm", BigDecimal.valueOf(20.0), 15, 10));
shares.put(2L, new Share("apple", BigDecimal.valueOf(14.0), 25, 15));
shares.put(3L, new Share("google", BigDecimal.valueOf(12.0), 20, 8));
...
shares.put(50L, new Share("microsoft", BigDecimal.valueOf(17.5), 10,4 ));
</code></pre>
Для доступа к нужной акции по идентификатору применяем метод <code>shares.get(id)</code>. Для задачи нахождения по имени акции или цене, мы бы перебирали в цикле все записи в поисках нужной и так далее. Но мы пойдём другим путём, и будем хранить значения в СУБД. 

<h3>Хранения данных в СУБД</h3>Сформулируем начальный свод правил хранения данных для СУБД:

<ul>
<li>Данные в СУБД организованы в таблицы (<strong>TABLE</strong>), представляющие собой набор записей. </li>
<li>Все записи имеют одинаковые наборы полей. Они задаются при создании таблицы. </li>
<li>Для поля можно выставить значение по умолчанию (<strong>DEFAULT</strong>).</li>
<li>Для таблицы можно выставить ограничения (<strong>CONSTRAINT</strong>), описывающие требования к её данным чтобы обеспечить их целостность. Это можно сделать на этапе создания таблицы (<strong>CREATE TABLE</strong>) или добавить позже (<strong>ALTER TABLE … ADD CONSTRAINT</strong>).</li>
<li>Наиболее распространённые <strong>CONSTRAINT</strong>:
<ul>
<li>Первичный ключ PRIMARY (Id в нашем случае).</li>
<li>Уникальное значение поле <strong>UNIQUE</strong> (VIN для таблицы автотранспорта).</li>
<li>Проверка поля <strong>CHECK</strong> (значение процентов не может быть больше 100). Одно из частных ограничений на поле – <strong>NOT NULL</strong> или <strong>NULL</strong>, запрещающее/разрешающее хранить NULL в поле таблицы.</li>
<li>Ссылка на стороннюю таблицу <strong>FOREIGN KEY</strong> (ссылка на акцию в таблице курсов акций).</li>
<li>Индекс <strong>INDEX</strong> (индексирование поля для ускорения поиска значений по нему).</li>
<li>Выполнение модификации записи (<strong>INSERT</strong>, <strong>UPDATE</strong>) не произойдёт, если значение её полей противоречат ограничениям (CONSTRAINT).</li></ul></li>
<li>Каждая таблица может иметь ключевое поле (или несколько), по которой можно однозначно определить запись. Такое поле (или поля, если они формируют составной ключ) образует первичный ключ таблицы — <strong>PRIMARY KEY</strong>.
<ul>
<li> Первичный ключ обеспечивает уникальность записи в таблице, по нему создается индекс, что дает быстрый доступ по значению ключа ко всей записи. </li>
<li>Наличие первичного ключа существенно облегчает создание ссылок между таблицами. Далее мы будем использовать искусственный первичный ключ: для первой записи <code>id = 1</code>, каждая следующая запись будет вставляться в таблицу с увеличенным на единицу значением id. Такой ключ часто называют <em>AutoIncrement </em>или <em>AutoIdentity</em>.</li></ul></li></ul>
Собственно, таблица акций:
<img data-id="ac0a412f-89bb-452d-83f7-cf347519f086" data-max-width="850" alt="Часть 2. Структура СУБД, таблицы и типы данных - 2" src="https://cdn.javarush.com/images/article/ac0a412f-89bb-452d-83f7-cf347519f086/1024.jpeg">
Можно ли в таком случае использовать в качестве ключа имя акции? По большому счёту — да, только вот есть вероятность, что какая-то компания выпускает разные акции и именует их только собственным названием. В таком случае уникальности уже не будет. 

На практике искусственный первичный ключ используют довольно часто. Согласитесь, использование ФИО в качестве уникального ключа в таблице, содержащей записи по людям, не обеспечит уникальности. Как и использование комбинации ФИО и даты рождения. 

<h2>Типы данных в СУБД</h2>Как и в любом другом языке программирования в SQL существует типизация данных. Приведём наиболее распространённые типы данных SQL: 


<strong>Целые типы</strong><table>
<thead>
<tr>
<th>SQL-тип
</th>
<th>SQL-синонимы
</th>
<th>Соответствие в Java
</th>
<th>Описание
</th>
</tr>
</thead>
<tboby>
<tr>
<td>INT
</td>
<td>INT4,INTEGER
</td>
<td>java.lang.Integer
</td>
<td>4-байтовое целое, -2147483648 … 2147483647 
</td>
</tr>
<tr>
<td>BOOLEAN
</td>
<td>BOOL, BIT
</td>
<td>java.lang.Boolean
</td>
<td>True, False
</td>
</tr>
<tr>
<td>TINYINT
</td>
<td>
</td>
<td>java.lang.Byte
</td>
<td>1-байтовое целое, -128 … 127
</td>
</tr>
<tr>
<td>SMALLINT 
</td>
<td>INT2
</td>
<td>java.lang.Short
</td>
<td>2-байтовое целое, -32768 … 32767
</td>
</tr>
<tr>
<td>BIGINT
</td>
<td>INT8
</td>
<td>java.lang.Long
</td>
<td>8-байтовое целое, -9223372036854775808 … 9223372036854775807
</td>
</tr>
<tr>
<td>AUTO_INCREMENT
</td>
<td>INCREMENT
</td>
<td>java.lang.Long
</td>
<td>Инкрементальный счётчик, уникальный для таблицы. Если в неё вставляют новое значение, он увеличивается на единицу Сгенерированные значения никогда не повторяются. 
</td>
</tr>
</tbody>
</table>
<strong>Вещественные</strong>
<table>
<thead>
<tr>
<th>SQL-тип
</th>
<th>SQL-синонимы
</th>
<th>Соответствие в Java
</th>
<th>Описание
</th>
</tr>
</thead>
<tbody>
<tr>
<td>DECIMAL(N,M)
</td>
<td>DEC, NUMBER
</td>
<td>java.math.BigDecimal
</td>
<td>Десятичная дробь с фиксированной точностью (N цифр целой части и M — дробной). В основном предназначены для работы с финансовыми данными.
</td>
</tr>
<tr>
<td>DOUBLE
</td>
<td>FLOAT8
</td>
<td>java.lang.Double
</td>
<td>Вещественное число двойной точности (8 байт).
</td>
</tr>
<tr>
<td>REAL
</td>
<td>FLOAT4
</td>
<td>java.lang.Real
</td>
<td>Вещественное число одинарной точности (4 байта).
</td>
</tr>
</tbody>
</table>
<strong>Строковые</strong>
<table>
<thead>
<tr>
<th>SQL-тип
</th>
<th>SQL-синонимы
</th>
<th>Соответствие в Java
</th>
<th>Описание
</th>
</tr>
</thead>
<tbody>
<tr>
<td>VARCHAR(N)
</td>
<td>NVARCHAR
</td>
<td>java.lang.String
</td>
<td>Строка в формате UNICODE длины N. Длина ограничена значением 2147483647 Полностью загружает содержимое строки в память.
</td>
</tr>
</tbody>
</table>
<strong>Дата и время</strong>
<table>
<thead>
<tr>
<th>SQL-тип
</th>
<th>SQL-синонимы
</th>
<th>Соответствие в Java
</th>
<th>Описание
</th>
</tr>
</thead>
<tbody>
<tr>
<td>TIME
</td>
<td>
</td>
<td>java.time.LocalTime,
 java.sql.Time
</td>
<td>Хранение времени (до наносекунд), при конвертации в DATETIME, в качестве даты   выставляется  1 янв 1970.
</td>
</tr>
<tr>
<td>DATE
</td>
<td>
</td>
<td>java.time.LocalDate,
java.sql.Timestamp
</td>
<td>Хранение дат в формате yyyy-mm-dd, время выставляется как 00:00
</td>
</tr>
<tr>
<td>DATETIME
</td>
<td>TIMESTAMP
</td>
<td>java.time.LocalDateTime, java.sql.Timestamp
</td>
<td>Хранение даты + времени 
(без учёта временных зон).
</td>
</tr>
</tbody>
</table>
<strong>Хранение больших объемов данных</strong>
<table>
<thead>
<tr>
<th>SQL-тип
</th>
<th>Соответствие в Java
</th>
<th>Описание
</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLOB
</td>
<td>java.io.InputStream, java.sql.Blob
</td>
<td>Хранение двоичных данных (картинок, файлов...).
</td>
</tr>
<tr>
<td>CLOB
</td>
<td>java.io.Reader, java.sql.Clob
</td>
<td>Хранение больших текстовых данных (книг, статей...), 
в отличии от VARCHAR загружает данные в память порциями.
</td>
</tr>
</tbody>
</table>
<h3>Стиль написания кода в SQL</h3>Для многих языков существуют рекомендации по оформлению кода. Обычно такие документы содержат правила именования переменных, констант, методов и иных языковых структур. Так, для Python существует PEP8, для <em>Java — Oracle Code Conventions for Java</em>. Для SQL создано несколько разных сводов, которые несколько отличаются друг от друга. Невзирая на это, следует выработать привычку придерживаться правил при оформлении кода, особенно если вы работаете в команде. Правила могут быть, например, следующими (разумеется, вы можете разработать для себя другой набор правил, главное придерживайтесь их в дальнейшем):

<ul>
<li>Ключевые и зарезервированные слова, в том числе команды и операторы, нужно писать прописными буквами: CREATE TABLE, CONSTRAINT…</li>
<li>Имена таблиц, полей и прочих объектов не должны совпадать с ключевыми словами языка SQL (см. ссылку в конце статьи), но могут содержать их в себе.</li>
<li>Имена таблиц должны отражать их назначение. Они записываются строчными буквами. Слова в наименовании отделены друг от друга подчёркиваниями.  Слово в конце должно быть во <strong>множественном</strong> числе: traiders (трейдеры), share_rates (курс акций).</li>
<li>Имена полей таблиц должны отражать их назначение. Их нужно записывать строчными буквами, слова в наименовании нужно оформлять в стиле <em>Camel Case</em>, а слово в конце нужно использовать в <strong>единственном</strong> числе: name (наименование), share_rates (курс акций).</li>
<li>Поля искусственных ключей должны содержать слово id.</li>
<li>Имена CONSTRAINT должны удовлетворять правилам именования таблиц. Также они должны включать участвующие в них поля и таблицы, начинаться со смыслового префикса: check_ (проверка значения поля), pk_ (первичный ключ), fk_ (внешний ключ), uniq_ (уникальность поля), idx_ (индекс).  Пример: pk_traider_share_actions_id (первичный ключ по полю id для таблицы traider_share_actions).</li>
<li>И так далее, по мере изучения SQL список правил будет пополняться/изменяться.</li>
</ul>
<h3>Проектирование СУБД</h3>Непосредственно перед созданием СУБД её нужно спроектировать. Конечная схема содержит таблицы, набор полей, CONSTRAINT, ключи, условия по умолчанию для полей, связи между таблицами и прочие сущности БД. В интернете можно найти множество бесплатных online/offline дизайнеров для проектирования небольших СУБД. Попробуйте вбить в поисковик что-то вроде “Database designer free”.  Такие приложения обладают полезными дополнительными свойствами:

<ul>
<li>Умеют генерировать SQL-команды для создания СУБД.</li>
<li>Визуально отображают настройки на диаграмме.</li>
<li>Позволяют перемещать таблицы для лучшей визуализации.</li>
<li>Показывают на диаграмме ключи, индексы, связи, значения по умолчанию и тому подобное.</li>
<li>Могут удалённо хранить схему СУБД.</li>
</ul>
Например, <a href='https://dbdiffo.com/' rel='nofollow' target='_blank'>dbdiffo.com</a> выделяет ключи, показывает меткой NN непустые поля и AI(AutoIncrement) – счётчики:
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="0cc9f541-5e0b-41e6-8ff4-0041c338631d" data-max-width="600" alt="Часть 2. Структура СУБД, таблицы и типы данных - 3" src="https://cdn.javarush.com/images/article/0cc9f541-5e0b-41e6-8ff4-0041c338631d/1024.jpeg"></div></div><h3>Создание таблиц в СУБД</h3>Итак, у нас есть схема. Теперь перейдём непосредственно к созданию таблиц (CREATE TABLE). Для этого нам желательно иметь предварительные данные: 

<ul>
<li>имя таблицы</li>
<li>имена и тип полей</li>
<li>ограничения (CONSTRAINTS) на поля</li>
<li>значения по умолчанию для полей (при наличии)</li>
<li>первичный ключ (PRIMARY KEY) при наличии</li>
<li>связи между таблицами (FOREIGN KEY)</li>
</ul>
Не будем изучать досконально все опции команды CREATE TABLE, рассмотрим основы SQL на примере создания таблицы для трейдеров:

<pre class='lang-java line-numbers'><code>
CREATE TABLE traiders( 
	id BIGINT AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(255) NOT NULL,
	freqTiсk INTEGER NOT NULL,
	cash  DECIMAL(15,2) NOT NULL DEFAULT 1000,
	tradingMethod INTEGER NOT NULL,
	changeProbability INTEGER NOT NULL DEFAULT 50,
	about VARCHAR(255) NULL
);
ALTER TABLE traiders ADD CONSTRAINT check_traiders_tradingMethod 
	CHECK(tradingMethod IN (1,2,3));
ALTER TABLE traiders ADD CONSTRAINT check_traiders_changeProbability 
	CHECK(changeProbability <= 100 AND changeProbability > 0)
</code></pre>
Разберём подробнее:

<ul>
<li><code><strong>CREATE TABLE traiders</strong></code> (описание полей) — создание таблицы с указанным именем, в описании поля разделяются запятой. Любая команда завершается точкой с запятой.</li>
<li>Описание поля начинается с его имени, далее следует тип, CONSTRAINT и значение по умолчанию.</li>
<li><code><strong>id BIGINT AUTO_INCREMENT PRIMARY KEY</strong></code> – поле id целого типа — это первичный ключ и инкрементный счётчик (для каждой новой записи для поля id будет генерироваться значение на единицу больше ранее созданного для этой таблицы).</li>
<li><code><strong>cash  DECIMAL(15,2) NOT NULL DEFAULT 1000</strong></code> – поле cash, десятичная дробь, 15 цифрами до запятой и две после (финансовые данные, например, доллары и центы). Не может принимать NULL-значений. Если значение не задано, оно получит значение 1000.</li>
<li><code><strong>about VARCHAR(255) NULL</strong></code> – поле about, строка до 255 символов длиной, может принимать пустые значения.</li>
</ul>
Заметим, что часть <strong>CONSTRAINT</strong>-условий мы можем задать после создания таблицы. Рассмотрим конструкцию, для модификации структуры таблицы и её полей:

<strong>ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения CHECK(условие)</strong> на примерах:

<ul>
<li><code><strong>CHECK(tradingMethod IN (1,2,3))</strong></code> – поле tradingMethod  может принимать только значения 1,2,3</li>
<li><code><strong>CHECK(changeProbability <= 100 AND changeProbability > 0)</strong></code> – поле changeProbability может принимать целые значения в диапазоне от 1 до 100</li>
</ul>
<h3>Связи между таблицами</h3>Для разбора описания связей между таблицами посмотрим создание share_rates:

<pre class='lang-java line-numbers'><code>
CREATE TABLE share_rates(
	id BIGINT AUTO_INCREMENT PRIMARY KEY,
	operDate datetime NOT NULL,
	share BIGINT NOT NULL,
	rate DECIMAL(15,2) NOT NULL
);
ALTER TABLE share_rates ADD FOREIGN KEY (share) REFERENCES shares(id)
</code></pre>
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="bfc4b676-1342-4cc0-af1d-efa2ddf57354" data-max-width="600" alt="Часть 2. Структура СУБД, таблицы и типы данных - 4" src="https://cdn.javarush.com/images/article/bfc4b676-1342-4cc0-af1d-efa2ddf57354/1024.jpeg"></div></div>
Ссылку на значения другой таблицы можно задать следующим образом:

<code><strong>ALTER TABLE</strong></code> таблица_из_которой_ссылаемся <code><strong>ADD FOREIGN KEY</strong></code> (поле_которое_ссылается) 

<code><strong>REFERENCES</strong></code> таблица_на_которую_ссылаемся(поле_на_которое_ссылаемся)

Пусть в <strong>shares</strong> мы имеем записи по акциям, например,  для id=50 храним  акции Microsoft с начальной ценой 17.5, дельтой 20 и шансом изменения 4%. Для таблицы <strong>share_rates</strong> мы получаем три основных свойства: 

<ul>
<li>Нам достаточно хранить в поле share только значение ключа id из таблицы shares, чтобы по нему получить оставшуюся информацию (название и так далее) из таблицы акций.</li>
<li>Мы не можем создать курс для несуществующей акции. Вставить в поле share несуществующее значение (для которого нет записи в таблице shares с этим id) нельзя, так как не будет соответствия между таблицами.</li>
<li>Мы не можем удалить в shares запись акции, для которой заданы курсы в share_rates.</li></ul>Последние два пункта служат для обеспечения целостности хранимых данных.

Создание таблиц SQL нашей эмуляции и примеры SQL запросов вы можете посмотреть в реализации Java методов соответствующих классов по ссылке на github-репозиторий в конце статьи.

<em><strong><a href='https://javarush.com/groups/posts/1971-chastjh-3-sozdaem-skelet-nashey-bazih-pervihe-sql-komandih-na-primerakh-javasql' target='_blank'>Третья часть</a></strong></em>