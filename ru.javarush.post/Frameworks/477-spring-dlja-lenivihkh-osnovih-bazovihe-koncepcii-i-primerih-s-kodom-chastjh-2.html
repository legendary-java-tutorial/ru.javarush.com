Spring для ленивых. Основы, базовые концепции и примеры с кодом. Часть 2
<p>----------------------------------------</p>
В прошлой статье я в двух словах объяснил что такое спринг, что такое бины и контекст. Теперь пришло время попробовать как это все работает. Я у себя буду делать в Intellij Idea Enterprise Edition.
<p>----------------------------------------</p>
<a href="https://javarush.com/groups/posts/476-spring-dlja-lenivihkh-osnovih-bazovihe-koncepcii-i-primerih-s-kodom-chastjh-1" target="_blank" rel="nofollow">В прошлой статье</a> я в двух словах объяснил что такое спринг, что такое бины и контекст. Теперь пришло время попробовать как это все работает.
<img data-max-width="850" alt="Spring для ленивых. Основы, базовые концепции и примеры с кодом. Часть 2 - 1" src="https://cdn.javarush.com/images/article/5c7f95e8-7e61-4cfb-a114-e7aecc9dd4e1/1024.jpeg">Я у себя буду делать в Intellij Idea Enterprise Edition. Но все мои примеры должны так же работать и в бесплатной Intellij Idea Community Edition. Просто если увидите на скриншотах, что у меня есть какое-то окно, которого нет у вас — не переживайте, для данного проекта это не критично :)

Для начала создаем пустой мавен проект. Я показывал как это сделать <a href="https://javarush.com/groups/posts/305-sozdanie-prosteyshego-web-proekta-v-intellij-idea-enterprise-edition-poshagovo-s-kartinkami" target="_blank" rel="nofollow">в статье</a> (читать до слов "<em>Пришло время наш мавен-проект превратить в web-проект.</em>", после этого там уже показывается как сделать веб-проект, а этого нам сейчас не нужно)

Создадим в папке <strong>src/main/java</strong> какой-нибудь пакет (в моем случае я его назвал "<code>ru.javarush.info.fatfaggy.animals</code>", вы можете назвать как хотите, просто в нужных местах не забудьте на свое название заменять). И создадим класс <code>Main</code> в котором сделаем метод

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
    ...
}
</code></pre>
После чего откроем файл pom.xml и добавим там раздел <code>dependencies</code>. Теперь идем в <a href="https://mvnrepository.com" target="_blank" rel="nofollow">мавеновский репозиторий</a> и ищем там <em>spring context</em> последней стабильной версии, и вставляем то, что получили внутрь раздела <code>dependencies</code>. Чуть более подробно я описал этот процесс <a href="https://javarush.com/groups/posts/328-sozdanie-prostogo-veb-prilozhenija-na-servletakh-i-jsp-chastjh-1" target="_blank" rel="nofollow">в этой статье</a> (см. раздел "<em>Подключение зависимостей в мавене</em>").

Тогда мавен сам найдет и скачает нужные зависимости, и в итоге у вас должно получиться что-то типа такого:
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="eeb4aff7-a1b9-4f57-85ed-fb9344c2ada1" data-max-width="740" alt="Spring для ленивых. Основы, базовые концепции и примеры с кодом. Часть 2 - 2" src="https://cdn.javarush.com/images/article/eeb4aff7-a1b9-4f57-85ed-fb9344c2ada1/1024.jpeg"></div></div>В левом окошке видно структуру проекта с пакетом и классом <code>Main</code>.
В среднем окне показано как у меня выглядит pom.xml. Я еще добавил туда раздел <em>properties</em>, в котором указал мавену какая у меня версия джавы используется в исходниках и в какую версию компилировать. Это просто чтобы идея предупреждения мне не кидала при запуске, что используется старая версия джавы. Можете делать, можете нет)

В правом же окошке — видно что хоть мы и подключили только spring context — он автоматически за собой подтянул еще и core, beans, aop и expression. Можно было подключать отдельно каждый модуль, прописывая в помнике для каждого зависимость с явным указанием версии, но нас пока устраивает и такой вариант, как есть сейчас.

Теперь создадим пакет <code>entities</code> (сущности) и в нем создадим 3 класса: <code>Cat</code>, <code>Dog</code>, <code>Parrot</code>. Пусть у каждого животного будет имя (<code>private String name</code>, можете захардкодить туда какие-то значения), и геттеры/сеттеры публичные.

Теперь переходим в класс <code>Main</code> и в методе <code>main()</code> пишем что-то типа такого:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
	// создаем пустой спринговый контекст, который будет искать свои бины по аннотациям в указанном пакете
	ApplicationContext context = 
		new AnnotationConfigApplicationContext("ru.javarush.info.fatfaggy.animals.entities");

	Cat cat = context.getBean(Cat.class);
	Dog dog = (Dog) context.getBean("dog");
	Parrot parrot = context.getBean("parrot-kesha", Parrot.class);

	System.out.println(cat.getName());
	System.out.println(dog.getName());
	System.out.println(parrot.getName());
}
</code></pre>
Сначала мы создаем объект контекста, и в конструкторе указываем ему имя пакета, которое надо сканировать на наличие в нем бинов. То-есть, спринг пройдется по этому пакету и попробует найти такие классы, которые отмечены специальными аннотациями, дающими спрингу понять, что это — бин. После чего он создает объекты этих классов и помещает их себе в контекст.

После чего мы получаем из этого контекста котика. Обращаясь к объекту контекста — мы просим его дать нам бин (объект), и указываем, какого класса объект нам нужен (тут, кстати, можно указывать не только классы, но и интерфейсы). После чего нам спринг возвращает объект этого класса, который мы уже и сохраняем в переменную.

Далее мы просим спринг достать нам бин, который называется "dog". Когда спринг будет создавать объект класса <code>Dog</code> — то он даст ему стандартное имя (если явно не указано имя создаваемого бина), которое является названием класса объекта, только с маленькой буквы. Поэтому, поскольку класс у нас называется <code>Dog</code>, то имя такого бина будет "dog". Если бы у нас там был объект <code>BufferedReader</code> — то ему спринг дал бы имя по умолчанию "bufferedReader". И поскольку в данном случае (у джавы) нет точной уверенности какого именно класса будет такой объект — то возвращается просто некий <code>Object</code>, который мы уже потом ручками кастим к нужному нам типу <code>Dog</code>. Вариант с явным указанием класса удобнее.

Ну и в третьем случае мы получаем бин по классу и по имени. Просто может быть такая ситуация, что в контексте окажется несколько бинов какого-то одного класса, и для того, чтобы указать какой именно бин нам нужен — указываем его имя. Поскольку мы тут тоже явно указали класс — то и кастить нам уже не приходится.

<mark>Важно!</mark> Если окажется так, что спринг найдет несколько бинов по тем требованиям, что мы ему указали — он не сможет определить какой именно бин нам дать и кинет исключение. Поэтому старайтесь указывать ему максимально точно какой бин вам нужен, чтоб не возникло таких ситуаций.
Если спринг не найдет у себя в контексте вообще ни одного бина по вашим условиям — он тоже кинет исключение.

Ну и далее мы просто выводим имена наших животных на экран чтобы убедиться, что это реально именно те объекты, которые нам нужны.

Но если мы запустим программу сейчас — то увидим, что спринг ругается, что не может найти у себя в контексте нужных нам животных. Так случилось потому, что он не создал эти бины. Как я уже говорил, когда спринг сканирует классы — он ищет "свои" спринговые аннотации там. И если не находит — то и не воспринимает такие классы как те, бины которых ему надо создать.

Чтобы пофиксить это — достаточно просто в классах наших животных добавить аннотацию <code>@Component</code> перед классом.

<pre class="lang-java line-numbers"><code>
@Component
public class Cat {
	private String name = "Барсик";
	...
}
</code></pre>
Но и это не все. Если нам надо явно указать спрингу что бин для этого класса должен иметь какое-то определенное имя — это имя можно указать в скобках после аннотации. Например, чтобы спринг дал нужное нам имя "<code>parrot-kesha</code>" бину попугайчика, по которому мы в <code>main</code>-е потом этого попугайчика будем получать — надо сделать примерно так:

<pre class="lang-java line-numbers"><code>
@Component("parrot-kesha")
public class Parrot {
	private String name = "Кеша";
	...
}
</code></pre>
В этом вся суть <strong>автоматической конфигурации</strong>. Вы пишете ваши классы, отмечаете их нужными аннотациями, и указываете спрингу пакет с вашими классами, по которому он идет, ищет аннотации и создает объекты таких классов.

Кстати, спринг будет искать не только аннотации <code>@Component</code>, но и все остальные аннотации, которые наследуются от этой. Например, <code>@Controller</code>, <code>@RestController</code>, <code>@Service</code>, <code>@Repository</code> и другие, с которыми мы познакомимся в дальнейших статьях.

Теперь попробуем сделать то же, но <strong>используя java-конфигурацию</strong>.

Для начала — удалим аннотации <code>@Component</code> из наших классов. Для усложнения задачи, представим, что это не наши самописные классы, которые мы можем легко модифицировать, добавлять что-то, в том числе и аннотации. А будто эти классы лежат запакованными в какой-то библиотеке. В таком случае мы не можем никак эти классы править чтобы они были восприняты спрингом. Но объекты этих классов нам нужны!

Тут нам пригодится java-конфигурация для создания таких объектов.

Для начала, создадим пакет например <code>configs</code>, а в нем — обычный джава класс например <code>MyConfig</code> и пометим его аннотацией <code>@Configuration</code>

<pre class="lang-java line-numbers"><code>
@Configuration
public class MyConfig {
}
</code></pre>
Теперь нам нужно немножко подправить в методе <code>main()</code> то, как мы создаем контекст. Мы можем либо напрямую указать там наш класс с конфигурацией:

<pre class="lang-java line-numbers"><code>
ApplicationContext context =
	new AnnotationConfigApplicationContext(MyConfig.class);
</code></pre>
Если у нас несколько разных классов, где мы производим создание бинов и мы хотим подключить сразу несколько из них — просто указываем их там через запятую:

<pre class="lang-java line-numbers"><code>
ApplicationContext context =
	new AnnotationConfigApplicationContext(MyConfig.class, MyAnotherConfig.class);
</code></pre>
Ну и если у нас их слишком много, и мы хотим их подключить сразу все — просто указываем здесь название пакета, в котором они у нас лежат:

<pre class="lang-java line-numbers"><code>
ApplicationContext context =
	new AnnotationConfigApplicationContext("ru.javarush.info.fatfaggy.animals.configs");
</code></pre>
В таком случае спринг пройдется по этому пакету и найдет все классы, которые отмечены аннотацией <code>@Configuration</code>.

Ну и на случай, если у нас реально большая программа, где конфиги разбиты по разным пакетам — просто указываем название пакетов с конфигами через запятую:

<pre class="lang-java line-numbers"><code>
ApplicationContext context =
	new AnnotationConfigApplicationContext("ru.javarush.info.fatfaggy.animals.database.configs",
		"ru.javarush.info.fatfaggy.animals.root.configs",
		"ru.javarush.info.fatfaggy.animals.web.configs");
</code></pre>
Ну или название более общего для всех них пакета:

<pre class="lang-java line-numbers"><code>
ApplicationContext context =
	new AnnotationConfigApplicationContext("ru.javarush.info.fatfaggy.animals");
</code></pre>
Можете у себя сделать как хотите, но мне кажется, самый первый вариант, где указывается просто класс с конфигами, подойдет нашей программе лучше всего.

При создании контекста спринг будет искать те классы, которые помечены аннотацией <code>@Configuration</code>, и создаст объекты этих классов у себя. После чего он попытается вызывать методы в этих классах, которые помечены аннотацией <code>@Bean</code>, что значит, что такие методы будут возвращать бины (объекты), которые он уже поместит себе в контекст.

Ну что ж, теперь создадим бины котика, собачки и попугайчика в нашем классе с java-конфигурацией. Делается это довольно просто:

<pre class="lang-java line-numbers"><code>
@Bean
public Cat getCat() {
	return new Cat();
}
</code></pre>
Получается, что мы тут сами вручную создали нашего котика и дали спрингу, а он уже поместил этот наш объект к себе в контекст. Поскольку мы явно не указывали имя нашего бина — то спринг даст бину такое же имя, как и название метода. В нашем случает, бин кота будет иметь имя "<code>getCat</code>". Но так как в <code>main</code>-е мы все-равно получаем кота не по имени,  а по классу — то в данном случае нам имя этого бина не важно.

Аналогично сделайте и бин с собачкой, но учтите, что спринг назовет такой бин по названию метода.

Чтобы явно задать имя нашему бину с попугайчиком просто указываем его имя в скобках после аннотации <code>@Bean</code>:

<pre class="lang-java line-numbers"><code>
@Bean("parrot-kesha")
public Object weNeedMoreParrots() {
	return new Parrot();
}
</code></pre>
Как видно, тут я указал тип возвращаемого значения <code>Object</code>, а метод назвал вообще как угодно. На название бина это никак не влияет потому что мы его явно тут задаем. Но лучше все-таки тип возвращаемого значения и имя метода указывать не "с потолка", а более-менее понятно. Просто даже для самих себя, когда через год откроете этот проект. :)

Тепер рассмотрим ситуацию, когда <strong>для создания одного бина нам нужно использовать другой бин</strong>.

Например, мы хотим чтобы имя кота в бине кота состояло из имени попугайчика и строки "-killer". Без проблем!

<pre class="lang-java line-numbers"><code>
@Bean
public Cat getCat(Parrot parrot) {
	Cat cat = new Cat();
	cat.setName(parrot.getName() + "-killer");
	return cat;
}
</code></pre>
Тут спринг увидит, что перед тем, как создавать этот бин — ему понадобится сюда передать уже созданный бин попугайчика. Поэтому он выстроит цепочку вызовов наших методов так, чтобы сначала вызвался метод по созданию попугайчика, а потом уже передаст этого попугайчика в метод по созданию кота. Тут сработала та штука, которая называется <strong>dependency injection</strong>: спринг сам передал нужный бин попугайчика в наш метод. Если идея будет ругаться на переменную <code>parrot</code> – не забудьте изменить тип возвращаемого значения в методе по созданию попугайчика с <code>Object</code> на <code>Parrot</code>.

Кроме того, джава-конфигурирование позволяет выполнять <strong>абсолютно любой джава-код</strong> в методах по созданию бинов. Можно делать реально что угодно: создавать другие вспомогательные объекты, вызывать любые другие методы, даже не помеченные спринговыми анотациями, делать циклы, условия - что только в голову придет! 

Этого всего при помощи автоматической конфигурации, и уж тем-более использованием xml-конфигов — не добиться.

<div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div>

<strong>Теперь рассмотрим задачку повеселее. С полиморфизмом и интерфейсами :)</strong>

Создадим интерфейс <code>WeekDay</code>, и создадим 7 классов, которые бы имплементили этот интерфейс: <code>Monday</code>, <code>Tuesday</code>, <code>Wednesday</code>, <code>Thursday</code>, <code>Friday</code>, <code>Saturday</code>, <code>Sunday</code>.

Создадим в интерфейсе метод <code>String getWeekDayName()</code>, который возвращал бы название дня недели соответствующего класса. То-есть, класс <code>Monday</code> возвращал бы "<code>monday</code>", итд.

Допустим, стоит задача при запуске нашего приложения поместить в контекст такой бин, который бы соответствовал текущему дню недели. Не все бины всех классов, которые имплементят <code>WeekDay</code> интерфейс, а только нужный нам. Это можно сделать примерно так:

<pre class="lang-java line-numbers"><code>
@Bean
public WeekDay getDay() {
	DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
	switch (dayOfWeek) {
		case MONDAY: return new Monday();
		case TUESDAY: return new Tuesday();
		case WEDNESDAY: return new Wednesday();
		case THURSDAY: return new Thursday();
		case FRIDAY: return new Friday();
		case SATURDAY: return new Saturday();
		default: return new Sunday();
	}
}
</code></pre>
Тут тип возвращаемого значения — это наш интерфейс, а возвращаются методом реальные объекты класов-реализаций интерфейса в зависимости от текущего дня недели.

Теперь в методе <code>main()</code> мы можем сделать так:

<pre class="lang-java line-numbers"><code>
WeekDay weekDay = context.getBean(WeekDay.class);
System.out.println("It's " + weekDay.getWeekDayName() + " today!");
</code></pre>
Мне выдало, что сегодня воскресенье :) Уверен, что если я запущу программу завтра — в контексте окажется совсем другой объект.

Обратите внимание, тут мы получаем бин просто по интерфейсу: <code>context.getBean(WeekDay.class)</code>. Спринг посмотрит в своем контексте какой из бинов у него там имплементит такой интерфейс — его и вернет. Ну а дальше уже получается, что в переменной типа <code>WeekDay</code> оказался объект типа <code>Sunday</code>, и начинается уже знакомый всем нам полиморфизм, при работе с этой переменной. :)

И пару слов про <strong>комбинированный подход</strong>, где часть бинов создается спрингом самостоятельно, используя сканирование пакетов на наличие классов с аннотацией <code>@Component</code>, а некоторые другие бины — создаются уже используя java-конфиг.

Для этого вернемся к первоначальному варианту, когда классы <code>Cat</code>, <code>Dog</code> и <code>Parrot</code> были отмечены аннотацией <code>@Component</code>.

Допустим, мы хотим создать бины наших животных при помощи <strong>автоматического сканирования</strong> пакета <code>entities</code> спрингом, а вот бин с днем недели создавать так, как мы только-что сделали.

Все что надо сделать — это добавить на уровне класса <code>MyConfig</code>, который мы указываем при создании контекста в <code>main</code>-е аннотацию <code>@ComponentScan</code>, и указать в скобочках пакет, который надо просканировать и создать бины нужных классов  автоматически:

<pre class="lang-java line-numbers"><code>
@Configuration
@ComponentScan("ru.javarush.info.fatfaggy.animals.entities")
public class MyConfig {
	@Bean
	public WeekDay getDay() {
		DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
		switch (dayOfWeek) {
			case MONDAY: return new Monday();
			case TUESDAY: return new Tuesday();
			case WEDNESDAY: return new Wednesday();
			case THURSDAY: return new Thursday();
			case FRIDAY: return new Friday();
			case SATURDAY: return new Saturday();
			default: return new Sunday();
		}
	}
}
</code></pre>
Получается, что при создании контекста спринг видит, что ему нужно обработать класс <code>MyConfig</code>. Заходит в него и видит, что нужно просканировать пакет "<code>ru.javarush.info.fatfaggy.animals.entities</code>" и создать бины тех класов, после чего выполняет метод <code>getDay()</code> из класса <code>MyConfig</code> и добавляет бин типа <code>WeekDay</code> себе в контекст. В методе <code>main()</code> мы теперь имеем доступ ко всем нужным нам бинам: и к объектам животных, и к бину с днем недели.

Как сделать так, чтобы спринг подхватил еще и какие-то xml-конфиги - нагуглите в интернете самостоятельно уже если понадобится :)

<strong>Резюме:</strong>
<ul>
<li>стараться использовать автоматическую конфигурацию;</li>
<li>при автоматической конфигурации указываем имя пакета, где лежат классы, бины которых надо создать;</li>
<li>такие классы помечаются аннотацией <code>@Component;</code></li>
<li>спринг проходит по всем таким классам и создает их объекты и помещает себе в контекст;</li>
<li>если автоматическая конфиграция нам по каким-то причинам не подходит — используем java-конфигурирование;</li>
<li>в таком случае создаем обычный джава класс, методы которого будут возвращать нужные нам объекты, и помечаем такой класс аннотацией <code>@Configuration</code> на случай, если будем сканировать весь пакет целиком, а не указывать конкретный класс с конфигурацией при создании контекста;</li>
<li>методы этого класса, которые возвращают бины — помечаем аннотацией <code>@Bean</code>;</li>
<il>если хотим подключить возможность автоматического сканирования при использовании java-конфигурации — используем аннотацию <code>@ComponentScan</code>.
</il></ul>Если ничего не понятно — то попробуйте прочитать эту статью через пару дней. Ну или если вы на ранних уровнях джавараша, то возможно, что спринг для вас пока немного рановато изучать. Вы всегда сможете вернуться к этой статье чуть позже, когда будете чувствовать себя уже более уверенней в программировании на java.

Если все понятно — можете попробовать перевести какой-нибудь свой pet-проект на спринг :)

Если что-то понятно, а что-то не очень - прошу в комменты :) Туда же и предложения и замечания, если я где-то ступил или написал какую-то глупость)

В следующей статье мы резко нырнем в <em>spring-web-mvc</em> и сделаем простенькое веб-приложение, используя спринг.