Начало работы с Git: подробный гайд для новичков
<p>----------------------------------------</p>
Привет тебе, будущий Senior Software Engineer. Сегодня поговорим о системе контроля версий, а именно о Git (читается как ГИТ, а не ДЖИТ, как могло бы показаться из грамматики английского языка). Да-да, я знаю что есть еще и Mercurial, SVN… Но будем откровенны: их время уже ушло...
<p>----------------------------------------</p>
<h2>Вместо вступления</h2>Привет тебе, будущий Senior Software Engineer.
<img data-max-width="800" data-id="a1d39060-a02e-4a92-9e18-1fe27245ef4f" src="/images/article/a1d39060-a02e-4a92-9e18-1fe27245ef4f/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 1">Сегодня поговорим о системе контроля версий, а именно о Git (читается как ГИТ, а не ДЖИТ, как могло бы показаться из грамматики английского языка). 

Да-да, я знаю что есть еще и Mercurial, SVN… Но будем откровенны: их время уже ушло, и тратить ваше драгоценное время на них не собираюсь.

Чтобы вы понимали важность знания гита в наше время, скажу так: без знания/понимания этого вам делать в программировании нечего. Но прелесть в том, что для постоянной работы не нужно держать в голове все команды и возможности. Нужно знать набор команд, которые помогут понимать всё, что происходит.
<h2>Основы Git</h2>Git — это распределенная система контроля версий нашего кода. Зачем она нам? Для распределенных команд нужна какая-то система управления работы. Нужна, чтобы отслеживать изменения, которые происходят со временем. 

То есть шаг за шагом мы видим, какие файлы изменились и как. Особенно это важно, когда анализируешь, что было проделано в рамках одной задачи: это дает возможность возвращаться назад.

Представим себе ситуацию: был работающий код, всё в нем было хорошо, но мы решили что-то улучшить, там подправить, сям подправить. Все ничего, но такое улучшение поломало половину функционала, сделало невозможным работу. И что дальше? Без Гита нужно было бы часами сидеть и вспоминать, как же все было изначально. А так мы просто откатываемся на коммит назад — и все. 

Или что делать, если есть два разработчика, которые делают одновременно свои изменения в коде? Без Гита это выглядит так: они скопировали код из оригинала, сделали что нужно. Наступает момент, и оба хотят добавить свои изменения в главную папку. И что делать в этой ситуации?.. Я даже не берусь оценить время, чтоб проделать эту работу.

Таких проблем не будет вовсе, если пользоваться Гитом. 
<h2>Установка Git</h2>Установим гит на компьютер. Я понимаю, что у всех разные OS, поэтому постараюсь описать для нескольких случаев.
<h3>Установка для Windows</h3>Как обычно, нужно скачать exe файл и запустить его. Здесь все просто: жмем на <a href="https://git-scm.com/downloads" rel="nofollow" target="_blank">первую ссылку гугла</a>, устанавливаем и всё. Для работы будем использовать bash консоль, которую они предоставляют.

Чтобы работать в виндоусе, нужно запустить Git Bash. Вот как он выглядит в меню пуск:
<img data-max-width="800" data-id="7f9c3203-5ae5-46fd-b500-42b3979c2eaf" src="/images/article/7f9c3203-5ae5-46fd-b500-42b3979c2eaf/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 2">И это уже консоль, в которой можно работать.

Чтобы не переходить каждый раз в папку с проектом, чтобы там открыть гит, можно в папке правой кнопкой мыши открыть консоль с нужным нам путем:
<img data-max-width="1024" data-id="52ad1966-4e34-4e47-ba78-8ce1ff395d18" src="/images/article/52ad1966-4e34-4e47-ba78-8ce1ff395d18/1024.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 3"><h3>Установка для Linux</h3>Обычно git уже установлен и есть в дистрибутивах линукса, так как это инструмент, первоначально написанный для разработки ядра линукса. Но бывают ситуации, когда его нет. Чтобы проверить это, нужно открыть терминал и прописать: git --version. Если будет вразумительный ответ, ничего устанавливать не нужно.

Открываем терминал и устанавливаем. Я работаю на Ubuntu, поэтому могу сказать, что писать для нее: sudo apt-get install git. И все: теперь в любом терминале можно пользоваться гитом.
<h3>Установка на macOS</h3>Здесь также для начала нужно проверить, есть ли уже гит (смотри выше, как на линуксе).

Если все же нет, самый простой путь — это скачать <a href="https://sourceforge.net/projects/git-osx-installer/files/" rel="nofollow" target="_blank">отседова</a> последнюю версию. Если установлен XCode, то гит уже точно будет автоматически установлен.
<h3>Настройка гита</h3>У гита есть настройка пользователя, от которого будет идти работа. Это разумная и необходимая вещь, так как когда создается коммит, гит берет именно эту информацию для поля Author.

Чтобы настроить имя пользователя и пароль для всех проектов, нужно прописать следующие команды:

<pre><code>
git config --global user.name ”Ivan Ivanov”
git config --global user.email ivan.ivanov@gmail.com
</code></pre>
Если есть необходимость для конкретного проекта поменять автора (для личного проекта, например), можно убрать --global, и так получится:

<pre><code>
git config user.name ”Ivan Ivanov”
git config user.email ivan.ivanov@gmail.com
</code></pre><h3>Немного теории…</h3>Чтобы быть в теме, желательно добавить в свое обращение несколько новых слов и действий… А то говорить будет не о чем. Конечно это некий жаргон и калька с английского, поэтому я буду добавлять значения на английском.

Какие слова и действия?
<ul>
<li>гит репозиторий (git repository);</li>
<li>коммит (commit);</li>
<li>ветка (branch);</li>
<li>смерджить (merge);</li>
<li>конфликты (conflicts);</li>
<li>спулить (pull);</li>
<li>запушить (push);</li>
<li>как игнорировать какие-то файлы (.gitignore).</li>
</ul>И так далее.
<h3>Состояния в Гит</h3>У Гита есть несколько состояний, которые нужно понять и запомнить:
<ul>
<li>неотслеживаемое (untracked);</li>
<li>измененное (modified);</li>
<li>подготовленное (staged);</li>
<li>закомиченное (committed).</li>
</ul><h4>Как это понимать?</h4>Это состояния, в которых находятся файлы из нашего кода. То есть, их жизненный путь обычно выглядит так:
<ol>
<li>Файл, который создан и не добавлен в репозиторий, будет в состоянии untracked.</li>
<li>Делаем изменения в файлах, которые уже добавлены в гит репозиторий — находятся в состоянии modified. </li>
<li>Из тех файлов, которые мы изменили, выбираем только те (или все), которые нужны нам (например, скомпилированные классы нам не нужны), и эти классы с изменениями попадают в состояние staged.</li>
<li>Из заготовленных файлов из состояния staged создается коммит и переходит уже в гит репозиторий. После этого staged состояние — пустое. А вот modified еще может что-то содержать.</li>
</ol>Выглядит это так (картиночка из официальной доки, так что можно верить)):
<img data-max-width="800" data-id="6136c12e-46b4-4fda-820c-3287237c48ab" src="/images/article/6136c12e-46b4-4fda-820c-3287237c48ab/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 4"><h3>Что такое коммит</h3>Коммит — это основной объект в управлении контроля версий. Он содержит все изменения за время этого коммита. Коммиты связаны между с собой как односвязный список. 

А именно: Есть первый коммит. Когда создается второй коммит, то он (второй) знает, что идет после первого. И таким образом можно отследить информацию. 

Также у коммита есть еще своя информация, так называемые метаданные:
<ul>
<li>уникальный идентификатор коммита, по которому можно его найти;</li>
<li>имя автора коммита, который создал его;</li>
<li>дата создания коммита;</li>
<li>комментарий, который описывает, что было сделано во время этого коммита.</li></ul>Вот как это выглядит:
<img data-max-width="512" data-id="f0a1025b-2f0c-4e65-b9bc-641db79a7704" src="/images/article/f0a1025b-2f0c-4e65-b9bc-641db79a7704/512.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 5"><h2>Что такое ветка</h2><img data-max-width="512" data-id="29945159-3a11-47a9-ae00-c762a4f5d6fb" src="/images/article/29945159-3a11-47a9-ae00-c762a4f5d6fb/512.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 6">Ветка — это указатель какого-то коммита. Так как коммит знает, какой коммит был до него, когда ветка указывает на какой-то коммит, к ней относятся и все те предыдущие. 

Исходя из этого можно сказать, что веток, указывающих на один и тот же коммит, может быть сколько угодно много.

Работа происходит в ветках, поэтому когда создается новый коммит, ветка переносит свой указатель на более новый коммит.
<h2>Начало работы с Гитом</h2>Можно работать и только с локальный репозиторием, и с удаленным.

Для отработки нужных команд можно воспользоваться только локальным репозиторием. Он хранит всю информацию только локально в проекте в папке .git.

Если говорить об удаленном, то вся информация хранится где-то на удаленном сервере: локально хранится только копия проекта, изменения которой можно запушить (git push) в удаленный репозиторий.

Здесь и далее будем обсуждать работу с гитом в консоли. Конечно, можно пользоваться какими-то графическими решениями (например, в Intellij IDEA), но сперва нужно разобраться, какие команды происходят и что они значат.

<div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><h3>Работа с гитом в локальном репозитории</h3>Далее я предлагаю вам проделать все те шаги, которые проделал я, в то время как будете читать статью. Это улучшит ваше понимание и усвоение материала. Так что приятного аппетита :)

Чтобы создать локальный репозиторий, нужно написать:

<pre><code>
git init
</code></pre><img data-max-width="800" data-id="5dbf6234-0ea6-40a8-9d37-ce14609d53b4" src="/images/article/5dbf6234-0ea6-40a8-9d37-ce14609d53b4/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 7">После этого будет создана папка .git в том месте, где находится консоль.

.git — это папка, которая хранит всю информацию о гит репозитории. Ее удалять не нужно ;)

Далее, добавляются файлы в этот проект, и их состояние становится Untracked. Чтобы посмотреть, какой статус работы на данный момент, пишем:

<pre><code>
git status
</code></pre><img data-max-width="800" data-id="348071fa-ccab-4a0c-ae94-6f9f0e6fa671" src="/images/article/348071fa-ccab-4a0c-ae94-6f9f0e6fa671/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 8">Мы находимся в master ветке, и пока мы не перейдем в другую, 
так все и останется.

Таким образом видно, какие файлы изменены, но еще не добавлены в состояние staged. Чтобы добавить их в состояние staged, нужно написать git add. Здесь может быть несколько вариантов, например:
<ul>
<li>git add -A — добавить все файлы из состояния в staged;</li>
<li>git add . — добавить все файлы из этой папки и все внутренних. По сути тоже самое, что и предыдущее;</li>
<li>git add &lt;имя файла&gt; — добавляет только конкретный файл. Здесь можно пользоваться регулярными выражениями, чтобы добавлять по какому-то шаблону. Например, git add *.java: это значит, что нужно добавить только файлы с расширением java.</li></ul>Ясно, что первые два варианта простые, а вот с добавлением будет интереснее, поэтому пишем:

<pre><code>
git add *.txt
</code></pre>
Чтобы проверить статус, используем уже известную нам команду:

<pre><code>
git status
</code></pre><img data-max-width="800" data-id="948c12dc-8227-48d0-8bd3-2ac9ed8be271" src="/images/article/948c12dc-8227-48d0-8bd3-2ac9ed8be271/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 9">Отсюда видно, что регулярное выражение отработало верно, и теперь test_resource.txt находится в staged состоянии.

И, наконец, последний этап (при локальном репозитории, с удаленным будет еще один ;)) — закоммитить и создать новый коммит:

<pre><code>
git commit -m “all txt files were added to the project”
</code></pre><img data-max-width="800" data-id="5159fcca-3b1c-4308-b1e4-854c1d480385" src="/images/article/5159fcca-3b1c-4308-b1e4-854c1d480385/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 10">Далее есть отличная команда, чтобы посмотреть на историю коммитов в ветке. Воспользуемся ею:

<pre><code>
git log
</code></pre><img data-max-width="800" data-id="b869b551-e804-4ac1-b199-6f16684be943" src="/images/article/b869b551-e804-4ac1-b199-6f16684be943/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 11">Здесь уже видно, что появился наш первый коммит с текстом, который мы передали. Очень важно понять, что текст, который мы передаем, должен максимально точно определять то, что было проделано за этот коммит. Это в будущем будет помогать множество раз.

Пытливый читатель, который еще не уснул, может сказать: а что случилось с файлом GitTest.java? Сейчас узнаем, используем для этого:

<pre><code>
git status
</code></pre><img data-max-width="800" data-id="00e768e8-6568-42d8-9d03-437c71028b50" src="/images/article/00e768e8-6568-42d8-9d03-437c71028b50/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 12">Как видим, он так и остался в состоянии untracked и ждет своего часа. А может мы вовсе не хотим его добавлять в проект? Бывает и такое. 

Далее, чтобы стало интереснее, попробуем изменить наш текстовый файл test_resource.txt. Добавим туда какой-то текст и проверим состояние:

<pre><code>
git status
</code></pre><img data-max-width="800" data-id="3abb8e35-ebfd-4480-b26e-fc8f19322b36" src="/images/article/3abb8e35-ebfd-4480-b26e-fc8f19322b36/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 13">Здесь хорошо видна разница между двумя состояниями — untracked и modified. 

GitTest.java находится в состоянии untracked, а test_resource.txt находится в modified.

Теперь, когда уже есть файлы в состоянии modified, мы можем посмотреть на изменения, которые были произведены над ними. Сделать это можно при помощи команды: 

<pre><code>
git diff
</code></pre><img data-max-width="800" data-id="1f3506ae-1746-4ee9-b346-c992be73bb63" src="/images/article/1f3506ae-1746-4ee9-b346-c992be73bb63/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 14">То есть здесь хорошо видно, что я добавил в наш текстовый файл hello world!

Добавляем изменения в текстовом файле и коммитим:

<pre><code>
git add test_resource.txt
git commit -m “added hello word! to test_resource.txt”
</code></pre>
Чтобы посмотреть на все коммиты, пишем:

<pre><code>
git log
</code></pre><img data-max-width="800" data-id="12d64adf-c2ae-4d62-ab36-df174fdab5b8" src="/images/article/12d64adf-c2ae-4d62-ab36-df174fdab5b8/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 15">Как видим, уже есть два коммита.

Таким же образом добавляем и GitTest.java. Теперь без комментариев, просто команды:

<pre><code>
git add GitTest.java
git commit -m “added GitTest.java”
git status
</code></pre><img data-max-width="800" data-id="e5e89bbd-baa2-43cc-bace-cbb24e030c7a" src="/images/article/e5e89bbd-baa2-43cc-bace-cbb24e030c7a/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 16"><h3>Работа с .gitignore</h3>Ясно, что мы хотим хранить только исходный код и ничего другого в репозитории. А что может быть еще? Как минимум, скомпилированные классы и/или файлы, которые создают среды разработки. 

Чтобы гит их игнорировал, есть специальный файл, который нужно создать. Делаем это: создаем файл в корне проекта с названием .gitignore, и в этом файле каждая строка будет шаблоном для игнорирования.

В этом примере гит игнор будет выглядеть так:

<pre><code>
```
*.class
target/
*.iml
.idea/
```
</code></pre>
Смотрим теперь:
<ul>
<li>первая строка — это игнорирование всех файлов с расширением .class;</li>
<li>вторая строка — это игнорирование папки target и всего, что она содержит;</li>
<li>третья строка — это игнорирование всех файлов с расширением .iml;</li>
<li>четвертая строка — это игнорирование папки .idea.</li>
</ul>Попробуем на примере. Чтобы посмотреть как это работает, добавим скомпилированный класс GitTest.class в проект и посмотрим статус проекта:

<pre><code>
git status
</code></pre><img data-max-width="800" data-id="78f2e2ef-72df-41ed-9f16-6aeb16be9c92" src="/images/article/78f2e2ef-72df-41ed-9f16-6aeb16be9c92/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 17">Ясно, что мы не хотим как-то случайно (если использовать git add -A) добавить скомпилированный класс в проект. Для этого создаем .gitignore файл и добавляем все, что описывалось ранее:
<img data-max-width="1024" data-id="cb845a33-8843-4ee9-8842-545e11a8436b" src="/images/article/cb845a33-8843-4ee9-8842-545e11a8436b/1024.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 18">Теперь добавим новым коммитом гит игнор в проект:

<pre><code>
git add .gitignore
git commit -m “added .gitignore file”
</code></pre>
И теперь момент истины: у нас есть в untracked состоянии скомпилированный класс GitTest.class, который мы не хотели добавлять в гит репозиторий. 

Вот здесь-то и должен заработать гит игнор:

<pre><code>
git status
</code></pre><img data-max-width="800" data-id="d094337b-01dc-43a6-8326-c0ba309d0df7" src="/images/article/d094337b-01dc-43a6-8326-c0ba309d0df7/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 19">Все чисто) Гит игнору +1)
<h3>Работа с ветками и иже с ним</h3>Разумеется, работать в одной ветке неудобно одному и невозможно, когда в команде больше одного человека. Для этого существует ветвление.

Как я уже говорил, ветка — это просто подвижный указатель на коммиты.

В этой части рассмотрим работу в разных ветках: как смерджить изменения одной ветки в другую, какие могут возникнуть конфликты и многое другое.

Чтобы посмотреть список всех веток в репозитории и понять, на какой находишься, нужно написать:

<pre><code>
git branch -a
</code></pre><img data-max-width="800" data-id="3a5ccec8-3fe1-4b6c-b19f-2e66280f4fc6" src="/images/article/3a5ccec8-3fe1-4b6c-b19f-2e66280f4fc6/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 20">Видно, что у нас только одна ветка master, и звездочка перед ней говорит, что мы находимся на ней. К слову, чтобы узнать, на какой ветке мы находимся, можно воспользоваться и проверкой статуса (git status).

Далее есть несколько вариантов создания веток (может их и больше, я использую эти):
<ul>
<li>создать новую ветку на основе той, на которой находимся (99% случаев);</li>
<li>создать ветку на основе конкретного коммита (1%).</li>
</ul><h4>Создаем ветку на основе конкретного коммита</h4>Опираться будем на уникальный идентификатор коммита. Чтобы найти его, напишем:

<pre><code>
git log
</code></pre><img data-max-width="800" data-id="6f312f65-a820-4faf-a218-686182020e32" src="/images/article/6f312f65-a820-4faf-a218-686182020e32/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 21">Я выделил коммит с комментарием “added hello world…”. У него уникальный идентификатор — “6c44e53d06228f888f2f454d3cb8c1c976dd73f8”. Я хочу создать ветку development начиная с этого коммита. Для этого напишу:

<pre><code>
git checkout -b development 6c44e53d06228f888f2f454d3cb8c1c976dd73f8
</code></pre>
Создается ветка, в которой будут только первые два коммита из ветки master. Чтобы проверить это, мы сперва убедимся, что перешли в другую ветку и посмотрим на количество коммитов ней:

<pre><code>
git status
git log
</code></pre><img data-max-width="800" data-id="32e2010a-16e6-4342-a082-c5181a876dfd" src="/images/article/32e2010a-16e6-4342-a082-c5181a876dfd/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 22">И правда: получилось, что у нас два коммита. Кстати, интересный момент: в этой ветке еще нет файла .gitignore, поэтому наш скомпилированный файл (GitTest.class) теперь подсвечивается в untracked состоянии.

Теперь можем провести еще раз ревизию наших веток, написав:

<pre><code>
git branch -a
</code></pre><img data-max-width="800" data-id="b0fa2136-26d5-4c09-867a-9faebdc3be8e" src="/images/article/b0fa2136-26d5-4c09-867a-9faebdc3be8e/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 23">Видно, что есть две ветки — master и development  — и сейчас стоим на development.
<h4>Создаем ветку на основе текущей</h4>Второй способ создания ветки — создание на основе другой. Я хочу создать ветку на основе master ветки, поэтому нужно сперва перейти на нее, а уже следующим шагом — создать новую. Смотрим:
<ul>
<li>git checkout master — переходим на ветку master;</li>
<li>git status — проверяем, точно ли на мастере.</li>
</ul><img data-max-width="800" data-id="fc59d1e4-d887-4b07-add7-0a1ed53ede8b" src="/images/article/fc59d1e4-d887-4b07-add7-0a1ed53ede8b/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 24">Вот здесь видно, что мы перешли на master ветку, здесь уже работает гит игнор, и скомпилированный класс уже не светится как untracked.

Теперь создаем новую ветку на основе master ветки:

<pre><code>
git checkout -b feature/update-txt-files
</code></pre><img data-max-width="800" data-id="19d396fc-af1c-4d3f-8deb-2dbba09dfaf2" src="/images/article/19d396fc-af1c-4d3f-8deb-2dbba09dfaf2/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 25">Если есть сомнения, что эта ветка будет не такой же, как и master, можно это легко проверить, написав git log и посмотреть на все коммиты. Там их должно быть четыре.
<h3>Резолвим конфликты</h3>Прежде чем разобраться с тем, что такое конфликт, нужно поговорить о слиянии (смердживании) одной ветки в другую. 

Вот такой картинкой можно показать процесс, когда одну ветку мерджат в другую:
<img data-max-width="512" data-id="5be87984-024c-43ab-be88-a3cdf3331692" src="/images/article/5be87984-024c-43ab-be88-a3cdf3331692/512.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 26">То есть, есть главная ветка. От нее в какой-то момент создают второстепенную, в которой происходят изменения. Как только работа сделана, нужно слить одну ветку в другую.

Я не буду описывать разные особенности: я хочу донести в рамках этой статьи только понимание, а уже детали узнаете сами, если будет нужно.

Так вот, на нашем примере, мы создали ветку feature/update-txt-files. Как написано в имени ветки — обновим текст.
<img data-max-width="800" data-id="47a002ed-bea0-4be5-b60c-f9c822c5c834" src="/images/article/47a002ed-bea0-4be5-b60c-f9c822c5c834/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 27">Теперь нужно создать под это дело новый коммит:

<pre><code>
git add *.txt 
git commit -m “updated txt files”
git log
</code></pre><img data-max-width="800" data-id="99af1950-f2b6-4792-8fe7-4ad7442dd8fc" src="/images/article/99af1950-f2b6-4792-8fe7-4ad7442dd8fc/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 28">Теперь, если мы хотим смерджить feature/update-txt-files ветку в master, нужно перейти в master и написать git merge feature/update-txt-files:

<pre><code>
git checkout master
git merge feature/update-txt-files
git log
</code></pre><img data-max-width="800" data-id="96f5d6f1-3d22-4597-b85b-b8af900b2e35" src="/images/article/96f5d6f1-3d22-4597-b85b-b8af900b2e35/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 29">Как результат — теперь и в мастер ветке есть коммит, который был добавлен в feature/update-txt-files.

Эта функциональность добавлена, поэтому можно удалить фиче (feature) ветку. Для этого напишем:

<pre><code>
git branch -D feature/update-txt-files
</code></pre>
Пока понятно, да?

Усложняем ситуацию: теперь допустим, что опять нужно изменить txt файл. Но теперь еще и в мастере этот файл будет изменен также. То есть он будет параллельно изменяться, и гит не сможет понять что нужно делать в ситуации, когда мы захотим смерджить в master ветку новый код.

Поехали!

Создаем новую ветку на основе master, делаем изменения в text_resource.txt и создаем коммит под это дело:

<pre><code>
git checkout -b feature/add-header
... делаем изменения в файле
</code></pre><img data-max-width="800" data-id="0a9176d6-8054-4655-b90a-315e215aa56f" src="/images/article/0a9176d6-8054-4655-b90a-315e215aa56f/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 30">
<pre><code>
git add *.txt
git commit -m “added header to txt”
</code></pre><img data-max-width="800" data-id="2635b663-7fd8-4d22-947b-df8c50777840" src="/images/article/2635b663-7fd8-4d22-947b-df8c50777840/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 31">Переходим на master ветку и также обновляем этот текстовый файл в той же строке, что и фиче ветка:

<pre><code>
git checkout master
… обновили test_resource.txt
</code></pre><img data-max-width="800" data-id="ac84fa61-0381-48e0-bf5c-1dcf633b779f" src="/images/article/ac84fa61-0381-48e0-bf5c-1dcf633b779f/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 32"><pre><code>
git add test_resource.txt
git commit -m “added master header to txt”
</code></pre>
И теперь самый интересный момент: нужно смерджить изменения из feature/add-header ветки в master. Мы находимся в мастер ветке, поэтому нужно только написать:

<pre><code>
git merge feature/add-header
</code></pre>
Но мы получим результат с конфликтом в файле test_resource.txt:
<img data-max-width="800" data-id="233f6738-b599-4f22-8552-2d39813d6dd8" src="/images/article/233f6738-b599-4f22-8552-2d39813d6dd8/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 33">И здесь мы можем видеть, что гит не смог самостоятельно решить, как смерджить этот код и говорит, что нужно вначале разрезолвить конфликт, а уже потом сделать коммит.

Ок, открываем в текстовом редакторе файл, в котором конфликт, и видим:<img data-max-width="800" data-id="efa04c3b-e279-4f6f-8f05-c3d2318d8ff2" src="/images/article/efa04c3b-e279-4f6f-8f05-c3d2318d8ff2/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 34">Чтобы понять, что здесь сделал гит, нужно вспомнить, что мы где писали, и сравнить:
<ol>
<li>между “&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD” и “=======” находятся изменения мастер, которые были в этой строке в мастер ветке.</li>
<li>между “=======” и “&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/add-header” находятся изменения, которые были в feature/add-header ветке.</li>
</ol>Таким образом гит показывает, что в этом месте он не смог понять, как слить воедино этот файл, разделил этот участок на две части из разных веток и предложил решить нам самим.

Хорошо, твердою волей решаю убрать все, оставить только слово header:
<img data-max-width="800" data-id="c167e2b2-1cb1-4d19-862e-80ee06a7b6b4" src="/images/article/c167e2b2-1cb1-4d19-862e-80ee06a7b6b4/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 35">Посмотрим на статус изменений, описание будет несколько другим. Будет не modified состояние, а Unmerged. Так что смело можно было добавить пятое состояние… Но я думаю, что это излишне, посмотрим:

<pre><code>
git status
</code></pre><img data-max-width="800" data-id="4416b14b-0e87-4877-b098-702624219f04" src="/images/article/4416b14b-0e87-4877-b098-702624219f04/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 36">Убедились, что это другой случай, необычный. Продолжаем:

<pre><code>
git add *.txt
</code></pre><img data-max-width="800" data-id="99a41e85-fb52-429a-86c3-65ad32dd54aa" src="/images/article/99a41e85-fb52-429a-86c3-65ad32dd54aa/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 37">В описании можно заметить, что предлагают написать только git commit. Слушаем и пишем:

<pre><code>
git commit
</code></pre><img data-max-width="800" data-id="c07c9f20-993a-42ed-91d6-91fbf8f37646" src="/images/article/c07c9f20-993a-42ed-91d6-91fbf8f37646/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 38">И все: таким образом мы сделали это — разрезолвили конфликт в консоли.

Конечно, в средах разработки можно это сделать немного проще, например, в Intellij IDEA все настроено так хорошо, что можно выполнять все необходимые действия в ней. Но среда разработки делает много чего “под капотом”, и мы зачастую не понимаем, что именно там произошло. А когда нет понимания, тогда могут возникнуть и проблемы.
<h2>Работа с удаленными репозиториями</h2>Последний шаг — разобраться еще с несколькими командами, которые нужны для работы с удаленным репозиторием. 

Как я уже говорил, удаленный репозиторий — это какое-то место, где хранится репозиторий и откуда можно его клонировать.

Какие бывают удаленные репозитории? Примеров тьма:
<ul>
<li><p><a href="https://github.com/" rel="nofollow" target="_blank">GitHub</a> — это крупнейшее хранилище для репозиториев и совместной разработки. Я уже описывал его в предыдущих статьях.<br>
Подписывайтесь на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мой гитхаб аккаунт</a>. Я часто выставляю там свои наработки в тех сферах, которые изучаю во время работы.</p></li>
<li><p><a href="https://about.gitlab.com/" rel="nofollow" target="_blank">GitLab</a> — веб-инструмент жизненного цикла <a href="https://ru.wikipedia.org/wiki/DevOps" rel="nofollow" target="_blank">DevOps</a> с <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D0%B5_%D0%9F%D0%9E" rel="nofollow" target="_blank">открытым исходным кодом</a>, представляющий систему управления <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9" rel="nofollow" target="_blank">репозиториями</a> кода для <a href="https://ru.wikipedia.org/wiki/Git" rel="nofollow" target="_blank">Git</a> с собственной вики, <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BE%D1%82%D1%81%D0%BB%D0%B5%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA" rel="nofollow" target="_blank">системой отслеживания ошибок</a>, CI/CD пайплайн и другими функциями.<br>
После новости о том, что Microsoft купила GitHub, некоторые разработчики продублировали свои наработки в GitLab.</p></li>
<li><p>BitBucket — веб-сервис для хостинга проектов и их совместной разработки, основанный на системе контроля версий Mercurial и Git. Одно время имел большое преимущество перед GitHub в том, что у него были бесплатные приватные репозитории. В прошлом году GitHub также открыл эту возможность для всех бесплатно.</p></li>
<li><p>И так далее…</p></li>
</ul>Первое, что нужно сделать в работе с удаленным репозиторием — клонировать проект себе в локальный. 

Для этого дела я экспортировал проект, который мы делали локально, и теперь каждый его может себе клонировать, написав:

<pre><code>
git clone <a href="https://github.com/romankh3/git-demo" rel="nofollow" target="_blank">https://github.com/romankh3/git-demo</a>
</code></pre> 
Теперь локально есть полная копия проекта. Чтобы быть уверенным, что локально находится последняя копия проекта, нужно, как говорится, спулить данные, написав:

<pre><code>
git pull
</code></pre><img data-max-width="800" data-id="782b84b1-e001-4849-be0b-c319133afca0" src="/images/article/782b84b1-e001-4849-be0b-c319133afca0/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 39">В нашем случае сейчас ничего не изменилось удаленно, поэтому и ответ: Already up to date.

Но если я внесу какие-то изменения в удаленном репозитории, локальный обновится после того, как мы их спулим.

И, наконец, последняя команда — запушить данные на удаленный репозиторий. Когда мы локально что-то сделали и хотим это передать на удаленный репозиторий, нужно сперва создать новый коммит локально. Для этого добавим в наш текстовый файл еще что-нибудь:
<img data-max-width="800" data-id="5598fa4d-3058-4994-b17d-63c6b5710076" src="/images/article/5598fa4d-3058-4994-b17d-63c6b5710076/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 40">Теперь уже обыденная для нас вещь — создаем коммит под это дело:

<pre><code>
git add test_resource.txt
git commit -m “prepated txt for pushing”
</code></pre>
И теперь команда, чтобы отправить это на удаленный репозиторий:

<pre><code>
git push
</code></pre><img data-max-width="800" data-id="46c49cfa-afb0-4b3a-b95f-7506a199a189" src="/images/article/46c49cfa-afb0-4b3a-b95f-7506a199a189/800.jpeg" class="img-fluid" alt="Начало работы с Git: подробный гайд для новичков - 41">Вот и все, что я хотел рассказать. Спасибо за внимание.

Подписывайтесь на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мой аккаунт на GitHub</a>, в котором я выкладываю разные прикольные проекты-примеры из того, что я изучаю и использую на работе.
<h2>Полезные ссылки</h2><ul><li>Официальная <a href="https://bit.ly/3eUqoaa" rel="nofollow" target="_blank">дока на гит, есть на русском</a>. Рекомендую как справочное пособие.</li>
<li><a href="https://bit.ly/2SfBCMY" rel="nofollow" target="_blank">Git 