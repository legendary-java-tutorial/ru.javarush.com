Проблемы с производительностью SQL, возникающие из-за "ненужной, но обязательной работы"
<p>----------------------------------------</p>
Уровень необходимых знаний для понимания стати: общее представление о базах данных и SQL, небольшой практический опыт работы с СУБД. Вероятно, самое важное, чему только можно научиться для написания ...
<p>----------------------------------------</p>
<em>Уровень необходимых знаний для понимания стати:</em> общее представление о базах данных и SQL, небольшой практический опыт работы с СУБД. 

<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="27633b8c-93c9-4dc9-9304-24013bc9feb4" data-max-width="600" alt="Проблемы с производительностью SQL, возникающие из-за " src="https://cdn.javarush.com/images/article/27633b8c-93c9-4dc9-9304-24013bc9feb4/1024.jpeg"></div></div>
Вероятно, самое важное, чему только можно научиться для написания эффективных SQL-запросов, – это индексация. Однако на втором месте, с очень небольшим отставанием, идет знание о том, что множество SQL-клиентов требуют от базы данных выполнения массы <strong>"ненужной, но обязательной работы"</strong>.

Повторяйте за мной:
<table>
<tr>
<td align="center">Ненужная, но обязательная работа
</td>
</tr>
</table>Что же такое "ненужная, но обязательная работа"? Как подсказывает нам, Капитан Очевидность, она:
<h3>Ненужная</h3>Пусть нашему клиентскому приложению необходимы следующие данные:
 <div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="788c09f3-a7d0-4cfa-b74d-9e9067f9a226" data-max-width="450" alt="Проблемы с производительностью SQL, возникающие из-за " src="https://cdn.javarush.com/images/article/788c09f3-a7d0-4cfa-b74d-9e9067f9a226/1024.jpeg"></div></div>Ничего необычного. Мы работаем с базой данных фильмов (например, <a href='https://www.jooq.org/sakila' target='_blank'>базой данных Sakila</a>) и хотим отображать пользователям название и рейтинг всех фильмов.

Нужный нам результат может дать следующий запрос:

<pre class='lang-java line-numbers'><code>
SELECT title, rating
FROM film
</code></pre>
Однако наше приложение (или наш ORM), вместо этого, выполняет вот такой запрос:

<pre class='lang-java line-numbers'><code>
SELECT *
FROM film
</code></pre>
Что же мы получаем в результате? Угадайте. Мы получаем массу бесполезной информации:
<center><img data-id="361ac3dd-0a6f-44f6-8fb5-afde7d960560" data-max-width="1000" alt="Проблемы с производительностью SQL, возникающие из-за " src="https://cdn.javarush.com/images/article/361ac3dd-0a6f-44f6-8fb5-afde7d960560/1024.jpeg"></center>Справа тут даже виднеется какой-то сложный JSON, загружаемый:
<ul>
<li>c диска</li>
<li>в кэш</li>
<li>по проводам</li>
<li>в память клиента</li>
<li>и, наконец, выбрасывается [за ненадобностью]</li>
</ul>Да, мы выбрасываем большую часть этой информации. Все выполненные для извлечения этой информации действия оказались совершенно бесполезными. Правда? Правда.
<h3>Обязательная</h3>А теперь – самое плохое. Хотя оптимизаторы сейчас умеют немало, эти действия обязательны для базы данных. База данных никак не может узнать, что клиентскому приложению 95% этих данных совершенно не нужно. И это лишь простейший пример. Представьте себе соединение нескольких таблиц...

Ну и что, – скажете вы, – базы данных же быстрые? Позвольте просветить вас о некоторых вещах, о которых вы, наверное, не задумывались.

Конечно, время выполнения отдельного запроса ни на что особо не влияет. Ладно, он выполнился в полтора раза медленнее, но мы же это переживём, правда? Ради удобства? Иногда это так. Но если жертвовать производительностью ради удобства <em>всегда</em>, эти мелочи начнут накапливаться. Речь пойдёт уже не о производительности (скорости выполнения отдельных запросов), а о пропускной способности (времени отклика системы) и тогда-то начнутся нешуточные проблемы, решить которые не так уж просто. Тогда-то вы и утратите масштабируемость.

Взглянем на планы выполнения, в данном случае, СУБД Oracle:

<pre class='lang-java line-numbers'><code>

--------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes |
--------------------------------------------------
|   0 | SELECT STATEMENT  |      |  1000 |   166K|
|   1 |  TABLE ACCESS FULL| FILM |  1000 |   166K|
--------------------------------------------------
</code></pre>
по сравнению с:

<pre class='lang-java line-numbers'><code>

--------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes |
--------------------------------------------------
|   0 | SELECT STATEMENT  |      |  1000 | 20000 |
|   1 |  TABLE ACCESS FULL| FILM |  1000 | 20000 |
--------------------------------------------------
</code></pre>
При выполнении запроса SELECT * вместо SELECT title, rating используется в 8 раз больше памяти в базе данных. Ничего неожиданного, правда? Мы знали, что так и будет. Но все равно мы соглашаемся с этим для многих наших запросов, в которых все эти данные нам просто не нужны. Мы создаем для базы данных <strong>ненужную, но обязательную работу</strong>, которая все накапливается и накапливается. Мы используем в 8 раз больше памяти, чем нужно (множитель будет меняться, конечно).

А между тем, на всех остальных этапах (дисковый ввод/вывод, передача данных по сети, потребление памяти клиентом) проблемы точно те же, но я их пропущу, а взгляну, вместо этого, на...
<h3>Использование индексов</h3>Большинство баз данных, на сегодня, уже оценили по достоинству концепцию <a href='https://blog.jooq.org/2015/04/28/do-not-think-that-one-second-is-fast-for-query-execution/' target='_blank'>покрывающих индексов</a> (covering indexes). Покрывающий индекс – сам по себе не является каким-то особым видом индекса. Но он может оказаться "особым индексом" для конкретного запроса, или "случайно", или потому, что так было задумано.

Рассмотрим следующий запрос:

<pre class='lang-java line-numbers'><code>
SELECT * 
FROM actor
WHERE last_name LIKE 'A%'
</code></pre>
Ничего неожиданного в плане его выполнения не видно. Это простой запрос. Просмотр диапазона по индексу, доступ к таблице – и готово:

<pre class='lang-java line-numbers'><code>
-------------------------------------------------------------------
| Id  | Operation                   | Name                | Rows  |
-------------------------------------------------------------------
|   0 | SELECT STATEMENT            |                     |     8 |
|   1 |  TABLE ACCESS BY INDEX ROWID| ACTOR               |     8 |
|*  2 |   INDEX RANGE SCAN          | IDX_ACTOR_LAST_NAME |     8 |
-------------------------------------------------------------------
</code></pre>
Хороший план, не правда ли? Ну, если нам правда было нужно вот это, то нет:
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="419549b7-2353-4838-bfde-6d82c9fd9551" data-max-width="300" alt="Проблемы с производительностью SQL, возникающие из-за " src="https://cdn.javarush.com/images/article/419549b7-2353-4838-bfde-6d82c9fd9551/1024.jpeg"></div></div>Очевидно, что мы зря расходуем память и т. п. Давайте рассмотрим вот такой запрос в качестве альтернативного варианта:

<pre class='lang-java line-numbers'><code>
SELECT first_name, last_name 
FROM actor
WHERE last_name LIKE 'A%'
</code></pre>
Его план таков:

<pre class='lang-java line-numbers'><code>
----------------------------------------------------
| Id  | Operation        | Name            | Rows  |
----------------------------------------------------
|   0 | SELECT STATEMENT |                 |     8 |
|*  1 |  INDEX RANGE SCAN| IDX_ACTOR_NAMES |     8 |
----------------------------------------------------
</code></pre>
Нам удалось полностью исключить доступ к таблице, благодаря наличию удовлетворяющего все потребности нашего запроса индекса... покрывающего индекса. Важно ли это? Еще как! Это подход позволяет ускорить некоторые запросы на порядок (или замедлить их на порядок, когда индекс перестает быть покрывающим после каких-либо изменений).

Покрывающими индексами можно воспользоваться не всегда. За индексы приходится платить и добавлять слишком много их не следует. Но в данном случае, всё очевидно. Давайте оценим производительность:

<pre class='lang-java line-numbers'><code>
SET SERVEROUTPUT ON
DECLARE
  v_ts TIMESTAMP;
  v_repeat CONSTANT NUMBER := 100000;
BEGIN
  v_ts := SYSTIMESTAMP;
    
  FOR i IN 1..v_repeat LOOP
    FOR rec IN (
      -- Наихудший вариант запроса: перерасход памяти ПЛЮС доступ к таблице 
      SELECT *
      FROM actor
      WHERE last_name LIKE 'A%'
    ) LOOP
      NULL;
    END LOOP;
  END LOOP;
    
  dbms_output.put_line('Оператор 1 : ' || (SYSTIMESTAMP - v_ts));
  v_ts := SYSTIMESTAMP;
    
  FOR i IN 1..v_repeat LOOP
    FOR rec IN (
      -- Улучшенный запрос, но все равно с доступом к таблице
      SELECT /*+INDEX(actor(last_name))*/ 
        first_name, last_name
      FROM actor
      WHERE last_name LIKE 'A%'
    ) LOOP
      NULL;
    END LOOP;
  END LOOP;
    
  dbms_output.put_line('Оператор 2 : ' || (SYSTIMESTAMP - v_ts));
  v_ts := SYSTIMESTAMP;
    
  FOR i IN 1..v_repeat LOOP
    FOR rec IN (
      -- Оптимальный запрос: покрывающий индекс
      SELECT /*+INDEX(actor(last_name, first_name))*/ 
        first_name, last_name
      FROM actor
      WHERE last_name LIKE 'A%'
    ) LOOP
      NULL;
    END LOOP;
  END LOOP;
    
  dbms_output.put_line('Оператор 3 : ' || (SYSTIMESTAMP - v_ts));
END;
/
</code></pre>
<table>
<tr><td>
<p>В результате получаем:</p><br>
<p>Оператор 1 : +000000000 00:00:02.479000000</p>
<p>Оператор 2 : +000000000 00:00:02.261000000</p>
<p>Оператор 3 : +000000000 00:00:01.857000000</p>
</td></tr>
</table>Обратите внимание, что в таблице actor всего 4 столбца, так что разница в производительности между операторами 1 и 2 не так уж велика, но все же значительна. Замечу также, что я воспользовался подсказками оптимизатора Oracle, чтобы оптимизатор выбирал тот или иной конкретный индекс для запроса. Оператор 3 – безусловный победитель нашего забега. Его производительность намного лучше, а ведь речь идет об исключительно простом запросе.

Опять же, когда мы пишем SELECT *, то создаем для базы данных <strong>ненужную, но обязательную работу</strong>, которую она не может оптимизировать. Она не выберет покрывающий индекс, потому что у него немного выше накладные расходы, чем у выбранного ей индекса LAST_NAME, и, помимо прочего, ей приходится все равно обращаться к таблице для извлечения никому не нужного столбца LAST_UPDATE, например.

Но чем глубже мы анализируем SELECT *, тем хуже оказываются дела. Поговорим про...
<h3>SQL-преобразования</h3>Оптимизаторы демонстрируют столь хорошие результаты потому, что преобразовывают SQL-запросы (<a href='https://www.youtube.com/watch?v=wTPGW1PNy_Y' target='_blank'>в своем недавнем выступлении на конференции Voxxed Days в Цюрихе я рассказывал, как это работает</a>). Например, существует чрезвычайно мощное преобразование "исключение JOIN". Рассмотрим следующее вспомогательное представление, которое нам пришлось создать, чтобы не соединять все эти таблицы каждый раз вручную:

<pre class='lang-java line-numbers'><code>
CREATE VIEW v_customer AS
SELECT 
  c.first_name, c.last_name, 
  a.address, ci.city, co.country
FROM customer c
JOIN address a USING (address_id)
JOIN city ci USING (city_id)
JOIN country co USING (country_id)
</code></pre>
Это представление просто выполняет все "...-к-одному" соединения между таблицей покупателей CUSTOMER и различными таблицами для частей их адреса. Спасибо тебе, нормализация.

Представьте, что, поработав немного с этим представлением, мы к нему привыкли и забыли про лежащие в его основе таблицы. И теперь мы выполняем следующий запрос:

<pre class='lang-java line-numbers'><code>
SELECT *
FROM v_customer
</code></pre>
Мы получаем в его результате весьма внушительный план:

<pre class='lang-java line-numbers'><code>
----------------------------------------------------------------
| Id  | Operation            | Name     | Rows  | Bytes | Cost |
----------------------------------------------------------------
|   0 | SELECT STATEMENT     |          |   599 | 47920 |   14 |
|*  1 |  HASH JOIN           |          |   599 | 47920 |   14 |
|   2 |   TABLE ACCESS FULL  | COUNTRY  |   109 |  1526 |    2 |
|*  3 |   HASH JOIN          |          |   599 | 39534 |   11 |
|   4 |    TABLE ACCESS FULL | CITY     |   600 | 10800 |    3 |
|*  5 |    HASH JOIN         |          |   599 | 28752 |    8 |
|   6 |     TABLE ACCESS FULL| CUSTOMER |   599 | 11381 |    4 |
|   7 |     TABLE ACCESS FULL| ADDRESS  |   603 | 17487 |    3 |
----------------------------------------------------------------
</code></pre>
Ну, конечно. База данных выполняет все эти соединения и полные просмотры таблиц, поскольку именно это мы и приказали ей сделать – извлечь все эти данные.

Теперь, опять же, представьте себе, что на самом деле всё, что нам было нужно – вот это:
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-max-width="250" alt="Проблемы с производительностью SQL, возникающие из-за " src="https://cdn.javarush.com/images/article/41f8d8a0-a2f1-4a1c-a979-f4d8eb5684c5/original.jpeg"></div></div> Что, серьёзно, да? Теперь вы начинаете понимать, о чём я говорю. Но представьте, что мы кое-чему научились на прошлых ошибках, и выполняем вот такой, более оптимальный запрос:

<pre class='lang-java line-numbers'><code>
SELECT first_name, last_name
FROM v_customer
</code></pre>
Теперь проверим, что получилось!

<pre class='lang-java line-numbers'><code>
------------------------------------------------------------------
| Id  | Operation          | Name        | Rows  | Bytes | Cost  |
------------------------------------------------------------------
|   0 | SELECT STATEMENT   |             |   599 | 16173 |     4 |
|   1 |  NESTED LOOPS      |             |   599 | 16173 |     4 |
|   2 |   TABLE ACCESS FULL| CUSTOMER    |   599 | 11381 |     4 |
|*  3 |   INDEX UNIQUE SCAN| SYS_C007120 |     1 |     8 |     0 |
------------------------------------------------------------------
</code></pre>
<em>Разительные</em> изменения к лучшему в плане выполнения. Соединения были исключены, поскольку оптимизатор теперь может убедиться в их <strong>бесполезности</strong>, а если он способен в этом убедиться (а вы не сделали эту работу обязательной путем выбора *), то может и просто не делать всю эту работу. Почему это так в данном случае?

Внешний ключ CUSTOMER.ADDRESS_ID к первичному ключу ADDRESS.ADDRESS_ID гарантирует ровно одно значение последнего, а значит и то, что операция JOIN будет соединением типа "...-к-одному", которое не увеличивает и не уменьшает количество строк. А раз каких-то строк мы вообще не выбираем и не запрашиваем, то никакого смысла вообще их загружать нет. Удаление JOIN, вероятно, вообще не повлияет на результат запроса.

Базы данных делают подобное постоянно. Можно выполнить следующий запрос на почти любой базе данных:

<pre class='lang-java line-numbers'><code>
-- Oracle
SELECT CASE WHEN EXISTS (
  SELECT 1 / 0 FROM dual
) THEN 1 ELSE 0 END
FROM dual

-- Более адекватные диалекты SQL, например, PostgreSQL
SELECT EXISTS (SELECT 1 / 0)
</code></pre>
В данном случае вы могли бы ожидать генерации арифметического исключения, как при выполнении следующего запроса:

<pre class='lang-java line-numbers'><code>SELECT 1 / 0 FROM dual</code></pre>
<table>
<tr><td>
<p>Получилось:</p><br>
<p>ORA-01476: divisor is equal to zero</p>
</td></tr>
</table>Но этого не происходит. Оптимизатор (или даже синтаксический анализатор) может убедиться, что никакие элементы списка выборки в предикате EXISTS (SELECT ..) не изменят результат запроса, так что необходимости выполнять его нет. Вот так!
<h3>Тем временем...</h3>Одна из самых неприятных проблем ORM заключается в том, что в них так удобно писать запросы SELECT *. Собственно, например, в HQL / JPQL они вообще используются по умолчанию. Можно вообще опустить предложение SELECT, ведь мы же собираемся извлекать всю сущность целиком, правда?

Например:

<pre class='lang-java line-numbers'><code>
FROM v_customer
</code></pre>
Например, <a href='https://vladmihalcea.com/2016/09/13/the-best-way-to-handle-the-lazyinitializationexception/' target='_blank'>Влад Михалче (Vlad Mihalcea), эксперт и сторонник разработки при помощи библиотеки Hibernate</a>, рекомендует использовать [уточненные] запросы практически всегда, когда вы уверены, что не хотите сохранить какие-либо изменения после извлечения.

ORM сильно облегчают решение задачи сохраняемости графов объектов. Примечание: Сохраняемости. Задачи собственно модификации графов объектов и сохранения изменений неразрывно связаны.

Но если делать этого вы не собираетесь, то зачем утруждать себя извлечением сущности? Почему не написать [уточненный] запрос? Давайте четко разберемся: с точки зрения производительности, написание запроса, специально подогнанного под ваш конкретный сценарий использования, заведомо лучше любого другого варианта. Возможно, вам все равно, поскольку ваш набор данных невелик и это не имеет значения. Отлично. Но когда, в конце концов, вам потребуется масштабируемость, то перепроектировать свои приложения под использование запросов вместо императивного обхода графа сущностей окажется весьма непросто. А у вас будет, чем заняться и без этого.
<h3>Подсчет строк для выяснения наличия чего-либо</h3>Один из случаев самого ужасного разбазаривания ресурсов – выполнение запросов COUNT(*) просто, чтобы узнать, имеется ли что-то в базе данных. Например, нам нужно узнать, есть ли у данного пользователя вообще заказы. И мы выполняем запрос:

<pre class='lang-java line-numbers'><code>
SELECT count(*)
FROM orders
WHERE user_id = :user_id
</code></pre>
Элементарно. Если COUNT = 0, то заказов нет. В противном случае – есть.

Производительность окажется не такой уж плохой, ведь у нас, наверное, есть индекс по столбцу ORDERS.USER_ID. Но как вы думаете, какая будет производительность вышеприведенного запроса по сравнению со следующим вариантом:

<pre class='lang-java line-numbers'><code>
-- Oracle
SELECT CASE WHEN EXISTS (
  SELECT *
  FROM orders
  WHERE user_id = :user_id
) THEN 1 ELSE 0 END
FROM dual

-- Более адекватные диалекты SQL, например, PostgreSQL
SELECT EXISTS (
  SELECT *
  FROM orders
  WHERE user_id = :user_id
)
</code></pre>
Не нужно быть семи пядей во лбу, чтобы понять, что настоящий предикат существования прекратит поиск дополнительных строк сразу после обнаружения <em>первой же</em>. Так что если результат окажется "заказов нет", то скорость будет сравнимой. Если же, однако, результат будет "да, заказы есть", то в случае, когда не надо считать точное количество, ответ будет получен <em>намного</em> быстрее.

Ведь точное количество нас и не интересует. Тем не менее, мы приказали базе данных вычислить его (<strong>ненужная работа</strong>), а база данных не знает, что мы игнорируем все результаты больше 1 (<strong>обязательная работа</strong>).

Конечно, было бы намного хуже, если бы для достижения тех же результатов мы вызывали list.size() для поддерживаемой JPA коллекции.
<a href='https://blog.jooq.org/2016/09/14/avoid-using-count-in-sql-when-you-could-use-exists/' target='_blank'>
Я уже писал об этом в своём блоге ранее, и проводил сравнительное тестирование обоих вариантов на р...</a>
<h2>Заключение</h2>Эта статья излагает очевидные вещи. Не заставляйте базу данных выполнять <strong>ненужную, но обязательную работу</strong>.

Она <strong>ненужная</strong>, поскольку, в соответствии с имеющимися требованиями, вы знаете, что некоторую конкретную часть работы выполнять не нужно. Тем не менее, вы говорите базе данных сделать её.

Она обязательная, поскольку база данных никак не может убедиться, что эта работа <strong>ненужная</strong>. Эта информация есть только у клиента и недоступна серверу. Так что базе данных приходится её выполнять.

Статья была посвящена SELECT *, в основном потому, что это такой удобный объект для рассмотрения. Но это касается не только баз данных. Это касается всех распределенных алгоритмов, в которых клиент указывает серверу выполнять <strong>ненужную, но обязательную работу</strong>. Сколько <strong>N+1</strong> задач встречается в вашем среднестатистическом AngularJS-приложении, в которых UI организовывает цикл по полученному от сервиса результату A, вызывая сервис B несколько раз, вместо того, чтобы упаковать все обращения к B в единый вызов? Это очень часто встречающееся явление.

Решение всегда одно и то же. Чем больше информации вы предоставляете выполняющей ваши команды сущности, тем быстрее она (теоретически) эти команды выполняет. Пишите оптимальные запросы. Всегда. Вся ваша система будет благодарна вам за это.

<em><a href='https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/' target='_blank'>Оригинал статьи</a></em>
<table>
<tr>
<th>Что ещё почитать?</th>
</tr>
<td>
<p><a href='https://javarush.com/groups/posts/244-vopros-otvet-kak-v-java-praviljhno-konvertirovatjh-string-v-int--' target='_blank'>Вопрос-ответ: как в Java правильно конвертировать String в int?</a></p>
<p><a href='https://javarush.com/groups/posts/234-luchshie-knigi-dlja-podgotovki-k-ehkzamenu-ocajp8-1z0-808-po-java-8' target='_blank'>Лучшие книги для подготовки к экзамену OCAJP8 (1Z0-808) по Java 8</a></p>
<p><a href='https://javarush.com/groups/posts/72-kak-praviljhno-nachatjh-razrabotku-pod-subd-oracle' target='_blank'>Как правильно начать разработку под СУБД Oracle</a></p>
</td>
</tr>
</table>