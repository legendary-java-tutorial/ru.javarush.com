Часть 1. Что нужно знать перед изучением Spring и JavaEE
<p>----------------------------------------</p>
Если ты уже закончил изучение Java SE или близок к этому, пришло время задуматься о дальнейших шагах в покорении профессии Java-девелопера. С одной стороны, ты уже неплохо разбираешься в Java: знаешь, как работать с IDE, писать программы и многое другое. Но что с ними...
<p>----------------------------------------</p>
Если ты уже закончил изучение Java SE или близок к этому, пришло время задуматься о дальнейших шагах в покорении профессии Java-девелопера.

<img data-max-width="850" alt="Часть 1. Что нужно знать перед изучением Spring и JavaEE - 1" src="https://cdn.javarush.com/images/article/0f024f83-d3b6-4727-b11c-f9abfb1c49bb/original.jpeg">С одной стороны, ты уже неплохо разбираешься в Java: знаешь, как работать с IDE, писать программы и многое другое. Но что с ними, программами, нужно делать дальше? Как сделать их круче и “выпустить в мир”? Становится очевидно, что пора браться за изучение Enterprise-технологий. И тут-то начинается самое интересное.

Неважно, с какого стека технологий ты решишь начать. Будь то JavaEE или Spring, ты наверняка столкнешься с массой вещей, которые пока что находятся за пределами твоего понимания. Между основами Java и продвинутыми технологиями есть еще промежуточная ступенька знаний, которые помогут тебе не растерять остатки самообладания и веры себя при чтении объемной документации.

<span class="text-bold">Поэтому цель данного цикла статей</span> — дать тебе минимум необходимых теоретических знаний для дальнейшего изучения JavaEE или Spring.
  
Весь материал разбит на 7 частей:
<ol>
<li>Поговорим немного о сети.</li>
<li>Рассмотрим устройство клиент-серверной и трехуровневой архитектуры.</li>
<li>Разберемся с HTTP/HTTPS протоколами.</li>
<li>Узнаем все, что нужно, о Maven.</li>
<li>Поговорим о сервлетах.</li>
<li>Контейнерах сервлетов.</li>
<li>И наконец — об MVC.</li>
</ol><h2>Часть 1. Поговорим немного о сети</h2>Начнем с самого главного и поговорим о том, на основе чего строятся все социальные сети, web-сервисы и приложения, мессенджеры и простенькие сайты — о сети (<em>в контексте этого цикла статей под термином “сеть” подразумевается Глобальная сеть Интернет</em>).

Сеть состоит из громадного количества компьютеров: они соединены между собой и способны коммуницировать. Важно понимать, как они это делают, потому что web-приложения как раз и занимаются передачей информации от одного компьютера другому.
<h3>Сетевая модель OSI</h3>Модель OSI (Open Systems Interconnection) создает уровневый подход к построению сети. Она четко показывает как и на каком уровне между собой могут взаимодействовать члены одной сети.

Всего данная модель содержит 7 уровней:
<table style="background:#eceff1; border: 2px solid black;">
<tbody><tr style="border: 2px solid black;">
<td style="border: 2px solid black;">7</td>
<td style="border: 2px solid black;">Прикладной</td>
</tr>
<tr style="border: 2px solid black;">
<td style="border: 2px solid black;">6</td>
<td style="border: 2px solid black;">Представления</td>
</tr>
<tr style="border: 2px solid black;">
<td style="border: 2px solid black;">5</td>
<td style="border: 2px solid black;">Сеансовый</td>
</tr>
<tr style="border: 2px solid black;">
<td style="border: 2px solid black;">4</td>
<td style="border: 2px solid black;">Транспортный</td>
</tr>
<tr style="border: 2px solid black;">
<td style="border: 2px solid black;">3</td>
<td style="border: 2px solid black;">Сетевой</td>
</tr>
<tr style="border: 2px solid black;">
<td style="border: 2px solid black;">2</td>
<td style="border: 2px solid black;">Канальный</td>
</tr>
<tr style="border: 2px solid black;">
<td style="border: 2px solid black;">1</td>
<td style="border: 2px solid black;">Физический
</td></tr></tbody></table>Разбивка на уровни абстракции позволяет специалистам, которые работают, например, над транспортным уровнем, не задумываться о деталях реализации сети на сетевом и сеансовых уровнях. Такой подход используется и в программировании.

<div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div>
<span class="text-bold">Рассмотрим все уровни модели OSI, и выясним, какие из них нам интересны:</span>
<ol>
<li><p><span class="text-bold">1. Физический уровень</span> — здесь свое дело делают законы физики, а задача человека — использовать и направлять это в своих целях. Например, создание кабелей и прокладывание их к членам сети.</p>
<p><em>Нам не интересен.</em></p></li>
<li><p><span class="text-bold">Канальный уровень</span> — отвечает за передачу данных сетевым узлам, создание каналов передачи данных на физических объектах.</p>
<p><em>Нам не интересен, если только нет желания писать прошивку для каналообразующей аппаратуры.</em></p></li>
<li><p><span class="text-bold">Сетевой уровень</span> — для определения адресов отдельных пользователей сети и маршрутов к ним. На этом уровне стоит остановиться подробнее, а именно — на адресе пользователя в сети.</p>
<p>Он определяется специальным протоколом: самый распространённый — IPv4 (Internet Protocol version 4). Именно его нужно использовать веб-программисту для обращения к другому абоненту сети.</p>
<p>IPv4 состоит из четырех байтовых значений, разделенных точкой, например: 192.0.2.235. Стоит помнить, что значения байтовые, а значит, они лежат в пределах 0..255.</p>
<p>IP-адреса, в свою очередь, делятся на классы, и просто так присвоить себе красивую комбинацию циферок не получится, но так сильно углубляться мы не станем. Достаточно понимать, что IP-адрес — это уникальный идентификатор абонента в сети, по которому мы сможем к нему обратиться.</p></li>
<li><p><span class="text-bold">Транспортный уровень</span> — занимается доставкой информации адресату. Для этого используются разные протоколы, которые нам пока не интересны. Гораздо больше нас интересует понятие, которое появляется на этом уровне, — <span class="text-bold">port</span>.</p> 
<p><span class="text-bold">Порты отвечают за идентификацию конкретного приложения на компьютере.</span> Например, ты написал чат на Java, установил на 2 компа и хочешь отправить своему собеседнику. Твое сообщение упаковывается, отправляется по конкретному IP-адресу, доставляется твоему собеседнику, но его ПК не знает, что делать с полученной информацией, так как не понимает, какое приложение должно обработать твое сообщение. Для этого и указываются порты при общении абонентов в сети.</p>
<p>Порт представляет собой число от 0 до 65535. Он добавляется к IP-адресу после двоеточия: <em>192.0.2.235:8080</em>. Но нельзя использовать все порты из указанного диапазона: часть из них зарезервирована под операционную систему, еще часть принято использовать с конкретно оговоренной целью. В предназначение разных портов углубляться не будем, пока достаточно понимать их роль в процессе общения в сети.</p></li>
<li><p><span class="text-bold">Сеансовый уровень</span> — создает и управляет сеансами связи приложений. На этом уровне становится возможным взаимодействие приложений, отправка запросов служебного уровня. Для нас важно знать, что на этом уровне между двумя абонентами открывается <span class="text-bold">сессия (session)</span>, с которой нам часто придется работать.</p>
<p><span class="text-bold">Сессия</span> — сущность, которая создается при установке связи между двумя пользователями. В ней можно сохранять нужную нам информацию о юзере, об истории их взаимодействия. Важной деталью является то, что при остановке обмена информацией сессия не пропадает, а сохраняет свое состояние на протяжении установленного промежутка времени, поэтому пользователи могут продолжить обмен информацией после перерыва.</p>
<p>Если приложение общается одновременно с несколькими пользователями, устанавливается соответствующее количество соединений, а значит и сессий. <span class="text-bold">У каждой сессии есть уникальный идентификатора (ID)</span>, что позволяет приложению различать пользователей, с которыми происходит общение.</p></li>
<li><p><span class="text-bold">Уровень представления</span> — отвечает за кодирование/декодирование данных. Очевидно, что если нам нужно передать другому пользователи строку “Hello web”, сначала она преобразуется (кодируется) в бинарный код, и только потом отправляется. Достигнув адресата, сообщение преобразуется обратно (декодируется), и адресат может увидеть исходную строку. Эти действие происходят на уровне представления.</p></li>
<li><p><span class="text-bold">Прикладной уровень</span> — самый интересный уровень для нас. Он обеспечивает взаимодействие приложений с сетью. На этом уровне мы будем принимать, отправлять сообщения, делать запросы к сервисам и удаленным базам данных.</p>
<p>Существует множество протоколов, которые используются на этом уровне: POP3, FTP, SMTP, XMPP, RDP, SIP, TELNET и, конечно же, HTTP/HTTPS. Протокол — это всеобщее соглашение, которого мы придерживаемся, составляя сообщения. О протоколах HTTP/HTTPS мы обязательно поговорим отдельно и подробнее.</p></li>
</ol><img data-max-width="850" alt="Часть 1. Что нужно знать перед изучением Spring и JavaEE - 2" src="https://cdn.javarush.com/images/article/fbd83468-8b60-4d0c-bfb5-f25673c06e45/original.jpeg">
Знать, как работает каждый уровень этой модели нам не обязательно. Главное — разбираться в принципах работы элементов, с которыми нам придется сталкиваться при написании веб-приложений, а именно:
<ul>
<li>IP-адрес — адрес абонента в сети;</li>
<li>Порт — адрес приложения конкретного абонента;</li>
<li>Сессия — сущность которая существует на протяжении всего общения двух абонентов;</li>
<li>Прикладные протоколы (HTTP/HTTPS) — правила, которыми мы будем руководствоваться при составлении и отправке сообщений.</li>
</ul>Когда мы переходим, скажем, в интернет-магазин, мы указываем его адрес нахождения и порт. При первом посещении создается сессия, в которую магазин может записывать информацию. Например, о товарах, которые мы оставили в корзине. Если мы закроем вкладку с интернет-магазином, а потом опять зайдем в него, наши товары останутся в корзине, потому что они сохранены в сессии. Ну и, естественно, всю информацию, которую мы получаем от магазина, мы получаем по протоколу HTTP/HTTPS, а наш браузер умеет его обрабатывать.

Ты можешь возразить и сказать, что никогда не вводил адрес и порт в браузере, и будешь отчасти прав, ведь ты вводил доменное имя, которое преобразовывалось на DNS-сервере. 

А вот здесь давай разберемся получше, что к чему.
<h3>DNS (Domain Name System)</h3>Как мы уже выяснили, у каждого абонента в сети есть уникальный адрес. Если речь идет о приложении, его уникальным адресом будет <span class="text-bold">IPv4:port</span>. Зная этот адрес, можно напрямую обратиться к приложению.

Представим, что мы написали веб-приложение, которое отображает среднюю температуру воздуха во всех странах в режиме реального времени. Мы развернули его на сервере с адресом 226.69.237.119 и на порту 8080. 

Чтобы пользователь смог получить от нас информацию, ему нужно ввести в браузере 5 чисел: 226.69.237.119:8080. Люди не очень любят запоминать наборы чисел: далеко не все из нас помнят больше двух телефонным номеров. 

Вот поэтому и была придумана <span class="text-bold">система доменных имен</span>. Мы можем создать “псевдоним” нашего адреса — например, world-temperature.com, и пользователь вместо того, чтобы искать нас по адресу из пяти сложных чисел, может ввести в адресной строке браузера наше доменное имя. 

Для сопоставления доменных имен и реальных адресов существуют <span class="text-bold">DNS-сервера</span>. Когда пользователь в браузере вводит, например, javarush.ru, его запрос отправляется на DNS-сервер, где он превращается в реальный адрес.
<img data-max-width="850" alt="Часть 1. Что нужно знать перед изучением Spring и JavaEE - 4" src="https://cdn.javarush.com/images/article/b3c41b90-bf86-49cd-bb61-6925463b2bc3/original.jpeg">Нам важно это понимать, потому что в наших приложениях мы будем вызывать удаленные сервисы как по доменном имени, так и по реальному адресу, и это будут одни и те же сервисы.

Вот и все! В этой статье мы рассмотрели основы устройства сети, которые пригодятся перед началом изучения веб-программирования. В следующий раз рассмотрим, что такое клиент-серверная архитектура и почему разбираться в ней так важно.

<a href="https://javarush.com/groups/posts/2519-chastjh-2-pogovorim-nemnogo-ob-arkhitekture-po" target="_blank">Часть 2. Поговорим немного об архитектуре ПО</a>
<a href="https://javarush.com/groups/posts/2521-chastjh-3-protokolih-httphttps" target="_blank">Часть 3. Протоколы HTTP/HTTPS</a>
<a href="https://javarush.com/groups/posts/2523-chastjh-4osnovih-maven" target="_blank">Часть 4.Основы Maven</a>
<a href="https://javarush.com/groups/posts/2529-chastjh-5-servletih-pishem-prostoe-veb-prilozhenie" target="_blank">Часть 5. Сервлеты. Пишем простое веб-приложение</a>
<a href="https://javarush.com/groups/posts/2533-chastjh-6-konteynerih-servletov" target="_blank">Часть 6. Контейнеры сервлетов</a>
<a href="https://javarush.com/groups/posts/2536-chastjh-7-znakomstvo-s-patternom-mvc-model-view-controller" target="_blank">Часть 7. Знакомство с паттерном MVC (Model-View-Controller)</a>
<a href="https://javarush.com/groups/posts/2537-chastjh-8-pishem-neboljhshoe-prilozhenie-na-spring-boot" target="_blank">Часть 8. Пишем небольшое приложение на spring-boot</a>