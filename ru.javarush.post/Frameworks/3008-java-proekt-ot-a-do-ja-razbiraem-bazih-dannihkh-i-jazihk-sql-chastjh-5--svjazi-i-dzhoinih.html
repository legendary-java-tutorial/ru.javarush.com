Разбираем базы данных и язык SQL. (Часть 5 — связи и джоины) - "Java-проект от А до Я"
<p>----------------------------------------</p>
Всем привет, будущие Сеньоры и Сеньориты программного обеспечения. Как я уже говорил в предыдущей части, сегодня будет новый материал. Для особо жаждущих я накопал интересное...
<p>----------------------------------------</p>
<em>Статья из серии о создании Java-проекта (ссылки на другие материалы — в конце). Ее цель — разбор ключевых технологий, итог — написание телеграм-бота.</em><ul><li><a href="#topic1">Типы связей в БД</a><ul>
<li><a href="#topic2">Один ко многим (one-to-many)</a></li>
<li><a href="#topic3">Один к одному (one-to-one)</a></li>
<li><a href="#topic4">Многие ко многим (many-to-many)</a></li></ul></li>
<li><a href="#topic5">Соединения (Джоины)</a><ul>
<li><a href="#topic6">INNER JOIN</a></li>
<li><a href="#topic7">LEFT JOIN</a></li>
<li><a href="#topic8">RIGHT JOIN</a></li>
<li><a href="#topic9">Закрепляем Джоины</a></li></ul></li>
<li><a href="#topic10">Домашнее задание</a></li>
</ul>Всем привет, будущие Сеньоры и Сеньориты программного обеспечения.

Как я уже говорил в предыдущей части (<a href="https://javarush.com/groups/posts/2989-java-proekt-ot-a-do-ja-razbiraem-bazih-dannihkh-i-jazihk-sql-chastjh-4--proverka-domashnego-zad" target="_blank">проверка домашнего задания</a>), сегодня будет новый материал.

Для особо жаждущих я накопал интересное домашнее задание, чтобы те, кто уже все знает и те, кто не знает, но хочет нагуглить, могли поупражняться и проверить свое умение.<img data-max-width="800" data-id="54e98b05-b363-4188-9aa7-fb433ae73cdd" src="/images/article/54e98b05-b363-4188-9aa7-fb433ae73cdd/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 1">Сегодня говорить будем о типах связей и джоинах.<h2 id="topic1">Типы связей в БД</h2><img data-max-width="512" data-id="a68750c2-9392-44d7-8458-59427e342c80" src="/images/article/a68750c2-9392-44d7-8458-59427e342c80/512.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 2">Чтобы понять, что такое связи, нужно вспомнить о том, что такое внешний ключ. Кто забыл — велкам в <a href="https://javarush.com/groups/posts/2946-java-proekt-ot-a-do-ja-razbiraem-bazih-dannihkh-i-jazihk-sql" target="_blank">начало серии</a>. <h3 id="topic2">Один ко многим (one-to-many)</h3>Вспомним наш пример со странами и городами. Ясно, что у города должна быть страна. А как привязать страну к городу? Нужно к каждому городу прикрепить уникальный идентификатор (ID) страны, к которой он принадлежит: мы уже это делали. Это и называется одним из типов связей — <span class="text-bold">один ко многим</span> (еще хорошо бы знать английскую версию —one-to-many).

Перефразируя, можно сказать: к одной стране может относиться несколько городов. Так и следует запоминать это: связь один ко многим. 

Пока что понятно, да? Если не очень, то вот первая картинка из интернетов:<img data-max-width="800" data-id="e3cfc7d7-4cc2-4f55-9461-af774bb9a90e" src="/images/article/e3cfc7d7-4cc2-4f55-9461-af774bb9a90e/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 3">Здесь показано, что есть заказчики и их заказы. Ведь разумно, что у одного заказчика может быть больше одного заказа. Налицо one-to-many :)

Или другой пример:<img data-max-width="800" data-id="10a8b2cb-6b9c-4c51-9338-d9678af7f8c8" src="/images/article/10a8b2cb-6b9c-4c51-9338-d9678af7f8c8/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 4">Есть три таблицы: издатель, автор и книга. У каждого издателя, который не хочет обанкротиться и жаждет быть успешным, есть больше одного автора, согласны? В свою очередь, у каждого автора может быть больше одной книги — тут тоже сомнений быть не может. А это значит, опять-таки, связь <span class="text-bold">один автор ко многим книгам, один издатель ко многим авторам</span>.

Примеров можно еще привести великое множество. Сложность в восприятии вначале может заключаться только в том, чтобы научиться абстрактно мыслить: смотреть со стороны на таблицы и их взаимодействие.<h3 id="topic3">Один к одному (one-to-one)</h3>Это, можно сказать, частный случай связи один-ко-многим. Ситуация, в которой одна запись в одной таблице связана только с одной записью в другой таблице. 

Какие могут быть примеры из жизни? 

Если исключить многоженство, то можно сказать, что есть связь один к одному между мужем и женой. Хотя если даже сказать, что многоженство разрешено, то все равно у каждой жены может быть только один муж. 

Точно так же можно сказать про родителей. У каждого человека может быть только один биологический отец и только одна биологическая мать. Явная связь один-к-одному. 

Пока писал это, пришла в голову мысль: а зачем тогда разделять связь один-к-одному на две записи в разных таблицах, если у них и так связь однозначная? Сам и ответ придумал. Эти записи могут быть еще связаны с другими записями в других связях.

О чем это я? 

Еще один пример из связей один-к-одному — это страна и президент. Можно же записать в таблице “страна” все данные о президенте? Да можно, SQL и слова не скажет. Вот только если подумать, что президент к тому же еще и человек... И еще у него может быть жена (еще одна связь один-к-одному) и дети (еще одна связь один-ко-многим) и тогда получается, что это уже нужно будет страну связывать с женой и детьми президента…. Звучит бредово, да? :D

Примеров других может быть множество и для этой связи. 

Причем в такой ситуации можно добавлять внешний ключ в обе таблицы, в отличие от связи one-to-many.<h3 id="topic4">Многие ко многим (many-to-many)</h3>Уже исходя из названия можно догадаться, о чем пойдет речь.

Зачастую в жизни, а мы программируем нашу жизнь, бывают ситуации, когда не хватает вышеперечисленных типов связей для описания нужных нам вещей. 

Мы уже говорили об издателях, книгах и авторах. Здесь просто так и прёт связями…

У каждого издания может быть несколько авторов — связь один ко многим. В тоже время у каждого автора может быть несколько издателей (почему нет, издавался писатель в одной месте, поругался из-за денег, ушел в другое издательство, например). И это опять связь один ко многим.

Или так: у каждого автора может быть несколько книг, но и у каждой книги может быть несколько авторов. Опять связь один ко многим между автором и книгой, книгой и автором. 

Из этого примера можно сделать более формализованный вывод:<table><tbody><tr><td><p>Если у нас есть две таблицы А и В.</p>

<p>А может относиться к В как один ко многим.</p>
<p>Но и В может относиться к А, как один ко многим.</p>

<p>А это значит, у них связь многие ко многим.</p></td></tr></tbody></table>Как задавать в SQL предыдущих типах связи было понятно: просто передаем ID-шник того, что один в те записи, которых много, да? Одна страна дает свой ID-шник как внешний ключ ко многим городам. 

А что делать со связью <span class="text-bold">многие ко многим</span>? Такой способ не подходит. Нужно добавить еще одну таблицу, которая связывала бы две таблицы.

Например, заходим в MySQL, создаем новую БД manytomany, создаем две таблицы, author и book в которых будут только имена и их ID-шники:

<span class="text-bold">CREATE DATABASE manytomany;
USE manytomany;

CREATE TABLE author(
id INT AUTO_INCREMENT,
name VARCHAR(100),
PRIMARY KEY (id)
);

CREATE TABLE book(
id INT AUTO_INCREMENT,
name VARCHAR(100),
PRIMARY KEY (id)
);</span><img data-max-width="800" data-id="94d80d86-92c3-48e7-a5b2-c74dfb1d4440" src="/images/article/94d80d86-92c3-48e7-a5b2-c74dfb1d4440/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 5">Теперь создадим третью таблицу, у которой будет два внешних ключа из наших таблиц author и book, и эта связка будет уникальной. То есть, нельзя будет добавить запись с одними и теми же ключами два раза:

<span class="text-bold">CREATE TABLE authors_x_books (
book_id INT NOT NULL,
author_id INT NOT NULL,
FOREIGN KEY (book_id) REFERENCES book(id),
FOREIGN KEY (author_id) REFERENCES author(id),
UNIQUE (book_id, author_id)
);</span><img data-max-width="800" data-id="6f1b13b7-48e3-4e4c-aec0-ae1afdcb07fe" src="/images/article/6f1b13b7-48e3-4e4c-aec0-ae1afdcb07fe/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 6">Здесь мы использовали несколько новых фишек, которые нужно прокомментировать отдельно:<ul>
<li>NOT NULL означает, что поле всегда должно быть заполнено, и если мы этого не сделаем, то SQL скажет нам об этом;</li>
<li>UNIQUE говорит о том, что поле или связка полей должны быть уникальна в таблице. Часто бывает так, что помимо уникального идентификатора уникальным для каждой записи должно быть еще одно поле. И UNIQUE отвечает как раз за это дело.</li>

</ul>Из моей практики: при переходе со старой системы на новую мы, как разработчики, должны хранить ID-шники старой системы для работы с ней и создать свои собственные. Почему свои создать, а не использовать старые? Они могут быть недостаточно уникальные, или такой подход в создании ID-шников уже не актуален и ограничен. Для этого мы и сделали и старый ID-шник тоже уникальным в таблице.

Чтобы это проверить, нужно добавить данные.

Добавим книгу и автора:

<span class="text-bold">NSERT INTO book (name) VALUES ("book1");
INSERT INTO author (name) VALUES ("author1");</span>

Мы уже знаем из предыдущих статей, что у них будут ID-шники 1 и 1. Поэтому можем сразу добавить запись в третью таблицу:

<span class="text-bold">INSERT INTO authors_x_books VALUES (1,1);</span>

И все будет хорошо до момента, пока мы не захотим повторить еще раз последнюю команду: то есть, записать еще раз одни и те же айдишники:<img data-max-width="800" data-id="ceb1b6f9-d36b-4776-ac1a-17fbb192cc2d" src="/images/article/ceb1b6f9-d36b-4776-ac1a-17fbb192cc2d/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 7">Результат будем закономерный — ошибка. Будет дубликат. Запись не будет записана. 

Вот так будет создана многие ко многим связь…

Все это очень круто и интересно, но напрашивается закономерный вопрос: а как эту информацию получить? Как соединить данные из разных таблиц воедино и получить один ответ? 

Вот об этом мы и поговорим в следующей части))<h2 id="topic5">Соединения (Джоины)</h2>В предыдущей части я готовил вас к тому, чтобы сразу было понятно, что такое джоины и где их использовать. Потому что я глубоко убежден, что как только придет понимание, сразу станет все очень просто, и все статьи о джоинах будут ясными, как очи младенца :D

Грубо и в общем, джоины — это получение результата из нескольких таблиц путем СОЕДИНЕНИЯ (джоина из английского join).

И все…) 

А чтобы соединить, нужно указать поле, по которому будут соединяться таблицы. Не так страшен черт, как его малюют, да?) Далее просто поговорим о том, какие бывают джоины и как их использовать.

Типов джоинов много, и все мы рассматривать не будем. Только те, которые нам реально нужны. Потому такие экзотические джоины как Cross и Natural нам не интересны. 

Совсем забыл, нам нужно запомнить еще один нюанс: у таблиц и полей могут быть <span class="text-bold">алиасы</span> — псевдонимы. Они удобно используются для джоинов. Например, можно сделать так:

<span class="text-bold">SELECT * FROM table1;</span>

если в запросе часто будет использоваться table1, то можно ему дать псевдоним:

<span class="text-bold">SELECT* FROM table1 as t1;</span>

или еще проще написать:

<span class="text-bold">SELECT * FROM table1 t1;</span>

и тогда дальше в запросе можно будет использовать <span class="text-bold">t1</span> как псевдоним для этой таблицы.<h3 id="topic6">INNER JOIN</h3>Самый распространенный и простой джоин. Он говорит о том, что когда у нас есть две таблицы и поле, по которому его можно соединить, будут выбраны все записи, связи которых существуют в двух таблицах. Сложно сказал как-то. Посмотрим на примере:

Добавим в нашу БД cities по одной записи. Одну запись в города и одну — в страны:

<span class="text-bold">$ INSERT INTO country VALUES(5, "Uzbekistan", 34036800);</span>

и

<span class="text-bold">$ INSERT INTO city (name, population) VALUES("Tbilisi", 1171100);</span>

Мы добавили страну, у которой нет города в нашей таблице, и город, который не привязан к стране в нашей таблице.

Так вот, INNER JOIN занимается тем, что выдает все записи на те соединения, которые есть в двух таблицах.

Вот как выглядит общий синтаксис, когда мы хотим соединить две таблицы table1 и table2:

SELECT * FROM table1 t1 <span class="text-bold">INNER JOIN table2 ON t1.id = t2.t1_id;</span>

и тогда будут выданы все записи, которые имеют связь в двух таблицах. Для нашего случая, когда мы хотим получить вместе с городами еще и информацию для стран, получится так:

<span class="text-bold">$ SELECT * FROM city ci INNER JOIN country co ON ci.country_id = co.id;</span><img data-max-width="800" data-id="e0579403-2573-4a69-9a4a-2588a4797fa5" src="/images/article/e0579403-2573-4a69-9a4a-2588a4797fa5/1024.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 8">Здесь хоть имена и совпадают, но можно отчетливо увидеть, что идут вначале поля городов, потом поля стран.

А тех двух записей, которые мы добавили выше, там нет. Потому что INNER JOIN именно так и работает.<h3 id="topic7">LEFT JOIN</h3>Бывают случаи, и довольно-таки часто, когда нас не устраивает потеря полей главной таблицы из-за того, что к ней нет записи в смежной таблице. Для этого дела и нужен LEFT JOIN.

Если мы в нашем предыдущем запросе укажем вместо INNER — LEFT, у нас в ответе добавится еще один город — Tbilisi:

<span class="text-bold">$ SELECT * FROM city ci LEFT JOIN country co ON ci.country_id = co.id;</span><img data-max-width="800" data-id="1350ff80-b185-48c0-b96b-1be9f199c8f2" src="/images/article/1350ff80-b185-48c0-b96b-1be9f199c8f2/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 9">Новая запись про Тбилиси есть и все, что относится к стране, там стоит в <span class="text-bold">null</span>.

Зачастую это так и используется.<h3 id="topic8">RIGHT JOIN</h3>Здесь будет отличие от LEFT JOIN в том, что выбираться все поля будут не слева, а справа в соединении. То есть, будут взяты не города, а все страны:

<span class="text-bold">$ SELECT * FROM city ci RIGHT JOIN country co ON ci.country_id = co.id;</span><img data-max-width="800" data-id="41941286-8506-4417-ae9e-4b81a385eb7e" src="/images/article/41941286-8506-4417-ae9e-4b81a385eb7e/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 10">Теперь видно, что в этом случае Тбилиси не будет, зато будет у нас Узбекистан. 

Вот как-то так…))

<div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><h3 id="topic9">Закрепляем Джоины</h3>Теперь я хочу показать вам типичную картинку, которую зубрят джуны перед собеседованием, чтобы убедить, что они понимают суть джоинов:<img data-max-width="512" data-id="b2c9292f-4d7d-4aba-9eb3-b0ec1507b770" src="/images/article/b2c9292f-4d7d-4aba-9eb3-b0ec1507b770/800.jpeg" alt="&quot;Java-проект от А до Я&quot;: разбираем базы данных и язык SQL. Часть 5 — связи и джоины - 11">Здесь все показано в виде множеств, каждый круг — это таблица. А те места, где закрашено — это те части, которые будут показаны в SELECT. 

Смотрим:<ul>
<li>INNER JOIN — это только пересечение множеств, то есть те записи, у которых есть связи на две таблицы — А и В;</li>
<li>LEFT JOIN — это все записи из таблицы A, включая все записи из таблицы В, которые имеют пересечение (связь) с А;</li>
<li>RIGHT JOIN — это с точностью до наоборот к LEFT JOIN — все записи в таблице В и записи из А, которые имеют связь.</li>

</ul>После всего этого эта картинка должна быть понятной))<h2 id="topic10">Домашнее задание</h2>На этот раз задания будут ооочень интересные и все те, кто успешно их решит, может не сомневаться, что готов к началу работы со стороны SQL! Задания не разжеванные и написаны были для мидлов, так что легко и скучно не будет вам :)

Я дам вам недельку на то, чтобы сделать задания самому, и потом выпущу отдельную статью с подробным разбором решения тех заданий, что я вам дал.<h3>Собственно задание:</h3><ol>
<li>Написать SQL script создания таблицы ‘Student’ с полями: id (primary key), name, last_name, e_mail (unique).</li>
<li>Написать SQL script создания таблицы ‘Book’ с полями: id, title (id + title = primary key).
Связать ‘Student’ и ‘Book’ связью ‘Student’ one-to-many ‘Book’.</li>
<li>Написать SQL script создания таблицы ‘Teacher’ с полями: id (primary key), name, last_name, e_mail (unique), subject.</li>
<li>Связать ‘Student’ и ‘Teacher’ связью ‘Student’ many-to-many Teacher’.</li>
<li>Выбрать ‘Student’ у которых в фамилии есть ‘oro’, например ‘Sid<span class="text-bold">oro</span>v’, ‘V<span class="text-bold">oro</span>novsky’.</li>
<li>Выбрать из таблицы ‘Student’ все фамилии (‘last_name’) и количество их повторений. Считать, что в базе есть однофамильцы. Отсортировать по количеству в порядке убывания. Выглядеть должно так:<table>
<tbody><tr><th>last_name</th>
<th>quantity</th></tr>
<tr><td>Petrov</td>
<td>15</td></tr>
<tr><td>Ivanov</td>
<td>12</td></tr>
<tr><td>Sidorov</td>
<td>3</td></tr></tbody></table></li>
<li>Выбрать из ‘Student’ топ 3 самых повторяющихся имен ‘name’. Отсортировать по количеству в порядке убывания. Выглядеть должно так:<table>
<tbody><tr><th>name</th>
<th>quantity</th></tr>
<tr><td>Alexander</td>
<td>27</td></tr>
<tr><td>Sergey</td>
<td>10</td></tr>
<tr><td>Peter</td>
<td>7</td></tr></tbody></table></li>
<li>Выбрать ‘Student’, у которых самое большое количество ‘Book’ и связанных с ним ‘Teacher’.Отсортировать по количеству в порядке убывания. Выглядеть должно так:<table>
<tbody><tr><th>Teacher’s last_name</th>
<th>Student’s  last_name</th>
<th>Book’s quantity</th></tr>
<tr><td>Petrov</td>
<td>Sidorov</td>
<td>7</td></tr>
<tr><td>Ivanov</td>
<td>Smith</td>
<td>5</td></tr>
<tr><td>Petrov</td>
<td>Kankava</td>
<td>2&gt;</td></tr></tbody></table></li>
<li>Выбрать ‘Teacher’, у которых самое большое количество ‘Book’ у всех его ‘Student’. Отсортировать по количеству в порядке убывания. Выглядеть должно так:<table>
<tbody><tr><th>Teacher’s last_name</th>
<th>Book’s quantity</th></tr>
<tr><td>Petrov</td>
<td>9</td></tr>
<tr><td>Ivanov</td>
<td>5</td></tr></tbody></table>
</li><li>Выбрать ‘Teacher’ у которых количество ‘Book’ у всех его ‘Student’ находится между 7-ю и 11-и. Отсортировать по количеству в порядке убывания. Выглядеть должно так:<table>
<tbody><tr><th>Teacher’s last_name</th>
<th>Book’s quantity</th></tr>
<tr><td>Petrov</td>
<td>11</td></tr>
<tr><td>Sidorov</td>
<td>9</td></tr>
<tr><td>Ivanov</td>
<td>7</td></tr></tbody></table></li>
<li>Вывести всех ‘last_name’ и ‘name’ всех ‘Teacher’ и ‘Student’ с полем ‘type‘ (student или teacher). Отсортировать в алфавитном порядке по ‘last_name’. Выглядеть должно так:<table>
<tbody><tr><th>last_name</th>
<th>type</th></tr>
<tr><td>Ivanov</td>
<td>student</td></tr>
<tr><td>Kankava</td>
<td>teacher</td></tr>
<tr><td>Smith</td>
<td>student</td></tr>
<tr><td>Sidorov</td>
<td>teacher</td></tr>
<tr><td>Petrov</td>
<td>teacher</td></tr></tbody></table></li>
<li>Добавить к существующей таблице ‘Student’ колонку ‘rate’, в которой будет храниться курс, на котором студент сейчас находится (числовое значение от 1 до 6).</li>
<li>Этот пункт не обязателен к выполнению, но будет плюсом. Написать функцию, которая пройдется по всем ‘Book’, и выведет через запятую все ‘title’.</li></ol><h2>Вывод</h2>Несколько затянулась серия про БД. Согласен. Тем не менее, мы проделали большой путь и в результате выходим со знанием дела!

Всем спасибо за прочтение, напоминаю, что все кто хочет идти дальше и следить за проектом, нужно создать аккаунт на <a href="https://github.com" rel="nofollow" target="_blank">GitHub</a> и подписаться на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мой аккаунт</a> :)

Дальше больше — поговорим о мавене и докере. 

Всем спасибо за прочтение. 

Повторю еще раз: <span class="text-bold">дорогу осилит идущий ;)</span>

<h4><a href="https://javarush.com/groups/posts/2935-java-proekt-ot-a-do-ja-pishem-realjhnihy-proekt-dlja-portfolio#articles" target="_blank">Список всех материалов серии в начале этой статьи.</a></h4>