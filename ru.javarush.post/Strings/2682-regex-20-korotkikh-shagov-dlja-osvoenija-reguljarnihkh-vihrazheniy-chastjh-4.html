RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4
<p>----------------------------------------</p>
Эта, заключительная часть, в ее середине мы коснемся таких вещей, которыми пользуются в основном мастера регулярных выражений. Но вам же легко дался материал из предыдущих частей, ведь правда...
<p>----------------------------------------</p>
<a href="https://javarush.com/groups/posts/2679-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-1" target="_blank" rel="nofollow">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1</a>
<a href="https://javarush.com/groups/posts/2680-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-2" target="_blank" rel="nofollow">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2</a>
<a href="https://javarush.com/groups/posts/2681-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-3" target="_blank" rel="nofollow">20 коротких шагов для освоения регулярных выражений. Часть 3</a>

Эта, заключительная часть, в ее середине коснется таких вещей, которыми пользуются в основном мастера регулярных выражений. Но вам же легко давался материал из предыдущих частей, ведь правда? Значит и с этим материалом вы справитесь с той же легкостью!

Оригинал <a href="https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc" target="_blank" rel="nofollow">здесь</a>
<img data-id="6c71dc23-6186-47c8-8c79-e3f4cdd4c63f" src="/images/article/6c71dc23-6186-47c8-8c79-e3f4cdd4c63f/800.jpeg" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4 - 1">
&lt;h2&gt;Шаг 16: группы без захвата <code>(?:)</code>&lt;/h2&gt;
<img data-id="b99d8e5c-d3b0-4bdc-b0ae-9f910d7476fb" src="/images/article/b99d8e5c-d3b0-4bdc-b0ae-9f910d7476fb/512.jpeg" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4 - 2">В двух примерах на предыдущем шаге мы захватывали текст, который в действительности нам не нужен. 

В задаче "Размеры файлов" мы захватили пробелы перед первой цифрой размеров файлов, а в задаче "CSV" мы захватили запятые между каждым токеном. Нам не нужно захватывать эти символы, но нам нужно использовать их для структурирования нашего регулярного выражения. Это идеальные варианты для использования группы без захвата, <code>(?:)</code>.

Группа без захвата делает именно то, на что это похоже по смыслу - она ​​позволяет группировать символы и использовать их в регулярных выражениях, но не захватывает их в пронумерованной группе:

<pre>pattern: <span>(?:")([^"]+)(?:")</span>
string:  I only want <span>"the text inside these quotes"</span>.
matches: <span>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
group:   <span>             1111111111111111111111111111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/87" target="_blank" rel="nofollow">Пример</a>)

Теперь регулярное выражение соответствовует тексту в кавычках, а также самим символам кавычек, но группа захвата захватила только текст в кавычках. Зачем нам так делать?

Дело в том, что большинство движков регулярных выражений позволяют вам восстанавливать текст из групп захвата, определенных в ваших регулярных выражениях. Если мы сможем обрезать лишние символы, которые нам не нужны, не включив их в наши группы захвата, то это упростит анализ и манипулирование текстом позже.

Вот как можно почистить парсер CSV из предыдущего шага:
<pre>pattern: <span>(?:^|,)\s*(?:\"([^",]*)\"|([^", ]*))</span>
string:  <span>a</span>, "<span>b</span>", "<span>c d</span>",<span>e</span>,<span>f</span>,   "<span>g h</span>", <span>dfgi</span>,, <span>k</span>, "", <span>l</span>
matches: <span>^   ^    ^^^  ^ ^     ^^^   ^^^^   ^      ^</span>
group:   <span>2   1    111  2 2     111   2222   2      2</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/115" target="_blank" rel="nofollow">Пример</a>)

Здесь есть несколько вещей, на которые стоит &lt;mark&gt;обратить внимание:&lt;/mark&gt;

Во-первых, мы больше не захватываем запятые, так как мы изменили группу захвата <code>(^|,)</code> на группу без захвата <code>(?:^|,)</code>. Во-вторых, мы вложили группу захвата в группу без захвата. Это полезно, когда, например, вам нужно, чтобы группа символов отображалась в определенном порядке, но вы заботитесь только о подмножестве этих символов.

В нашем случае нам нужно, чтобы символы <strong>не</strong> кавычек и <strong>не</strong> запятые <code>[^",]*</code> отображались в кавычках, но на самом деле нам не нужны сами символы кавычек, поэтому их не нужно было захватывать.

Наконец, &lt;mark&gt;обратите внимание&lt;/mark&gt;, что в приведенном выше примере также есть совпадение нулевой длины между символами <code>k</code> и <code>l</code>. Кавычки <code>""</code> являются искомой подстрокой, но между кавычками нет символов, поэтому соответствующая подстрока не содержит символов (имеет нулевую длину).
&lt;h3&gt;Закрепим знания? Вот две с половиной задачи, которые помогут нам в этом:&lt;/h3&gt;
Используя группы без захвата (и группы захвата, и классы символов, и т.д.), напишите регулярное выражение, которое захватывает только правильно отформатированные размеры файлов в строке ниже:

<pre>pattern: 
string:  <span>6.6KB</span> 1..3KB <span>12KB</span> 5G <span>3.3MB</span> KB .6.2TB <span>9MB</span>.
matches: <span>^^^^^       ^^^^^   ^^^^^^          ^^^^</span>
group:   <span>11111        1111    11111           111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/89" target="_blank" rel="nofollow">Решение</a>)

Открывающие HTML-теги начинаются с символа <code>&lt;</code> и заканчиваются символом <code>&gt;</code>. Закрывающие теги HTML начинаются с последовательности символов <code>&lt;/</code> и заканчиваются символом <code>&gt;</code>. Имя тега содержится между этими символами. Можете ли вы написать регулярное выражение, чтобы захватить только имена в следующих тегах? (Возможно, вам удастся решить эту проблему без использования групп без захвата. Попробуйте решить это двумя способами! Один раз с помощью групп и один раз без них.)

<pre>pattern: 
string:  <span>&lt;p&gt; &lt;/span&gt; &lt;div&gt; &lt;/kbd&gt; &lt;link&gt;</span>
matches: <span>^^^ ^^^^^^  ^^^^^ ^^^^^^ ^^^^^^</span>
group:   <span> 1    1111   111    111   1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/92" target="_blank" rel="nofollow">Решение с помощью групп без захвата</a>)
(<a href="https://regex101.com/r/Mf9L3O/91" target="_blank" rel="nofollow">Решение без помощи групп без захвата</a>)
&lt;h2&gt;Шаг 17: обратные ссылки <code>\N</code> и именованные группы захвата&lt;/h2&gt;
<img data-id="757fac4d-bb47-4066-adef-0d8876ba46fd" src="/images/article/757fac4d-bb47-4066-adef-0d8876ba46fd/512.jpeg" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4 - 3">Хоть я и предупреждал вас во введении, что попытка создать HTML-парсер при помощи регулярных выражений обычно приводит к душевным страданиям, последний пример - хороший переход к другой (иногда) полезной функции большинства регулярных выражений: обратным ссылкам (backreferences).

Обратные ссылки похожи на повторяющиеся группы, в которых вы можете попытаться захватить один и тот же текст дважды. Но они отличаются в одном важном аспекте - они будут захватывать только один и тот же текст, символ за символом.

В то время как повторяющаяся группа позволит нам захватить что-то вроде этого:

<pre>pattern: <span>(he(?:[a-z])+)</span>
string:  <span>heyabcdefg hey heyo heyellow heyyyyyyyyy</span>
matches: <span>^^^^^^^^^^ ^^^ ^^^^ ^^^^^^^^ ^^^^^^^^^^^</span>
group:   <span>1111111111 111 1111 11111111 11111111111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/93" target="_blank" rel="nofollow">Пример</a>)

... то обратная ссылка будет соответствовать только этому:

<pre>pattern: <span>(he([a-z])(\2+))</span>
string:  heyabcdefg hey heyo heyellow <span>heyyyyyyyyy</span>
matches: <span>                             ^^^^^^^^^^^</span>
group:   <span>                             11233333333</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/116" target="_blank" rel="nofollow">Пример</a>)

Повторяющиеся группы захвата полезны, когда вы хотите повторно сопоставить один и тот же шаблон, тогда как обратные ссылки хороши, когда вы хотите сопоставить один и тот же текст. Например, мы могли бы использовать обратную ссылку, чтобы попытаться найти подходящие открывающие и закрывающие HTML-теги:

<pre>pattern: <span>&lt;(\w+)[^&gt;]*&gt;[^&lt;]+&lt;\/\1&gt;</span>
string:  <span>&lt;span style="color: red"&gt;hey&lt;/span&gt;</span>
matches: <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
group:   <span> 1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/95" target="_blank" rel="nofollow">Пример</a>)

&lt;mark&gt;Обратите внимание&lt;/mark&gt;, что это чрезвычайно упрощенный пример, и я настоятельно рекомендую вам не пытаться писать анализатор HTML на основе регулярных выражений. Это очень сложный синтаксис, и вам, скорее всего, станет плохо.

<strong>Именованные группы захвата</strong> очень похожи на обратные ссылки, поэтому я кратко расскажу о них здесь. Единственная разница между обратными ссылками и именованной группой захвата состоит в том, что... именованная группа захвата имеет имя:

<pre>pattern: <span>&lt;(?&lt;tag&gt;\w+)[^&gt;]*&gt;[^&lt;]+&lt;\/(?P=tag)&gt;&lt;/tag&gt;</span>
string:  <span>&lt;span style="color: red"&gt;hey&lt;/span&gt;</span>
matches: <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
group:   <span> 1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/103" target="_blank" rel="nofollow">Пример</a>)

Вы можете создать именованную группу захвата с помощью (?&lt;name&gt;...) или (?'name'...) синтаксиса (.NET-совместимое регулярное выражение) или с таким синтаксисом (?P&lt;name&gt;...) или (?P'name'...) (Python-совместимое регулярное выражение). Поскольку мы используем PCRE (Perl-совместимое регулярное выражение), которое поддерживает обе версии, мы можем использовать любой из них здесь. <em>(Java 7 скопировала синтаксис .NET, но только вариант с угловыми скобками. прим. переводчика)</em>

Чтобы повторить именованную группу захвата позже в регулярном выражении, мы используем \&lt;kname&gt; или \k'name' (.NET) или (?P=name) (Python). Опять же, PCRE поддерживает все эти различные варианты. Вы можете прочитать больше об именованных группах захвата <a href="https://www.regular-expressions.info/named.html" target="_blank" rel="nofollow">здесь</a>, но это была большая часть того, что вам действительно нужно знать о них.
&lt;h3&gt;Задачка нам в помощь:&lt;/h3&gt;
Используйте обратные ссылки, чтобы помочь мне вспомнить ... эммм ... имя этого человека.

<pre>pattern: 
string:  "Hi my <span>name's Joe." [later] "What's that guy's name? Joe</span>?".
matches: <span>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
group:   <span>              111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/96" target="_blank" rel="nofollow">Решение</a>)
&lt;h2&gt;Шаг 18: взгляд вперед (lookahead) и взгляд назад (lookbehind)&lt;/h2&gt;
<img data-id="969316e1-3be0-4492-a61a-60da25f4309c" src="/images/article/969316e1-3be0-4492-a61a-60da25f4309c/512.jpeg" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4 - 4">Сейчас мы углубимся в некоторые расширенные функции регулярных выражений. Всё, вплоть до шага 16, я использую довольно часто. Но эти последние несколько шагов предназначены только для людей, которые очень серьезно используют regex для сопоставления очень сложных выражений. Другими словами, мастера регулярных выражений.

"Взгляд вперед" и "взгяд назад" могут показаться довольно сложными, но на самом деле они не слишком сложны. Они позволяют вам сделать что-то похожее на то, что мы делали с группами без захвата ранее - проверять, существует ли какой-либо текст непосредственно перед или сразу после фактического текста, который мы хотим сопоставить. Например, предположим, что мы хотим сопоставлять только названия вещей, которые люди любят, но только если они с энтузиазмом относятся к этому (только если они заканчивают свое предложение восклицательным знаком). Мы могли бы сделать что-то вроде:

<pre>pattern: <span>(\w+)(?=!)</span>
string:  I like desk. I appreciate stapler. I love <span>lamp</span>!
matches: <span>                                          ^^^^</span>
group:   <span>                                          1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/97" target="_blank" rel="nofollow">Пример</a>)

Вы можете видеть, как указанная выше группа захвата <code>(\w+)</code>, которая обычно соответствует любому из слов в отрывке, соответствует только слову lamp. Положительный "взгляд вперед" <code>(?=!)</code> означает, что мы можем сопоставлять только те последовательности, которые заканчиваются на <code>!</code> но, на самом деле, мы не сопоставляем сам символ восклицательного знака. Это важное различие, потому что с группами без захвата мы сопоставляем символ, но не захватываем его. С помощью lookaheads и lookbehinds мы используем символ для построения нашего регулярного выражения, но затем мы даже не сопоставляем его с ним самим. Мы можем сопоставить его позже в нашем регулярном выражении.

Всего существует четыре вида lookaheads и lookbehinds: положительный взгляд вперед (?=...), отрицательный взгляд вперед (?!...), положительный взгляд назад (?&lt;=...) и отрицательный взгляд назад (?&lt;!...). Они делают то, на что они похожи - положительные lookahead и lookbehind позволяют обработчику регулярных выражений продолжать сопоставление, только когда текст, содержащийся в lookahead / lookbehind, действительно совпадает. Отрицательные lookahead и lookbehind делают противоположное - они позволяют регулярному выражению совпадать только тогда, когда текст, содержащийся в lookahead / lookbehind, не совпадает.

Например, мы хотим сопоставить имена методов только в цепочке последовательностей методов, а не объект, над которым они работают. В этом случае каждому имени метода должен предшествовать символ <code>.</code> . Здесь может помочь регулярное выражение, использующее простой взгляд назад:

<pre>pattern: <span>(?&lt;=\.)(\w+)</span>
string:  myArray.<span>flatMap.aggregate.summarise.print</span>!
matches: <span>        ^^^^^^^ ^^^^^^^^^ ^^^^^^^^^ ^^^^^</span>
group:   <span>        1111111 111111111 111111111 11111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/98" target="_blank" rel="nofollow">Пример</a>)

В приведенном выше тексте мы сопоставляем любую последовательность символов слова <code>\w+</code>, но только в том случае, если им предшествует символ <code>.</code> . Мы могли бы достичь чего-то подобного, используя группы без захвата, но результат получится немного грязнее:

<pre>pattern: <span>(?:\.)(\w+)</span>
string:  myArray<span>.flatMap.aggregate.summarise.print</span>!
matches: <span>       ^^^^^^^^ ^^^^^^^^^ ^^^^^^^^^ ^^^^^</span>
group:   <span>        1111111 111111111 111111111 11111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/99" target="_blank" rel="nofollow">Пример</a>)

Несмотря на то, что он короче, он соответствует символам, которые нам не нужны. Хотя этот пример может показаться тривиальным, lookaheads и lookbehinds действительно могут помочь нам очистить наши регулярные выражения.
&lt;h3&gt;Осталось совсем немного до финиша! Следующие 2 задачи приблизят нас к нему еще на 1 шаг:&lt;/h3&gt;
Отрицательный lookbehind (?&lt;!...) позволяет движку регулярных выражений продолжать попытки найти совпадение, только если текст, содержащийся внутри отрицательного lookbehind, не отображается до оставшейся части текста, с которой нужно найти соответствие. 
Например, мы могли бы использовать регулярное выражение, чтобы найти соответствия только фамилиям женщин, посещающих конференцию. Для этого мы бы хотели убедиться, что фамилии человека не предшествует <code>Mr.</code> . 
Можете ли вы написать регулярное выражение для этого? (Можно предположить, что фамилии имеют длину не менее четырех символов.)

<pre>pattern: 
string:  Mr. Brown, Ms. <span>Smith</span>, Mrs. <span>Jones</span>, Miss <span>Daisy</span>, Mr. Green
matches: <span>               ^^^^^       ^^^^^       ^^^^^</span>
group:   <span>               11111       11111       11111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/100" target="_blank" rel="nofollow">Решение</a>)

Предположим, что мы очищаем базу данных и у нас есть столбец информации, который обозначает проценты. К сожалению, некоторые люди записали числа в виде десятичных значений в диапазоне [0,0, 1,0], в то время как другие написали проценты в диапазоне [0,0%, 100,0%], а третьи написали процентные значения, но забыли литерал знак процента <code>%</code>. Используя отрицательный взгляд вперед (?!...), можете-ли вы пометить только те значения, которые должны быть процентами, но в которых отсутствуют знаки <code>%</code>? Это должны быть значения, строго превышающие 1,00, но без конечного <code>%</code> . (Ни одно число не может содержать более двух цифр до или после десятичной точки.)

&lt;mark&gt;Обратите внимание&lt;/mark&gt;, что это решение <strong>чрезвычайно сложно</strong>. Если вы сможете решить эту проблему, не заглядывая в мой ответ, то у вас уже есть огромные навыки в регулярных выражениях!

<pre>pattern: 
string:  0.32 <span>100.00 5.6</span> 0.27 98% 12.2% <span>1.01</span> 0.99% 0.99 <span>13.13 1.10</span>
matches: <span>     ^^^^^^ ^^^                ^^^^            ^^^^^ ^^^^</span>
group:   <span>     111111 111                1111            11111 1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/101" target="_blank" rel="nofollow">Решение</a>)
&lt;h2&gt;Шаг 19: условия в регулярных выражениях&lt;/h2&gt;
<img data-id="f54bd4aa-a349-4200-a92b-825cbf5cd35d" src="/images/article/f54bd4aa-a349-4200-a92b-825cbf5cd35d/512.jpeg" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4 - 5">Сейчас перешли к тому этапу, когда большинство людей уже не станут использовать регулярные выражения.

Мы рассмотрели, вероятно, 95% сценариев использования простых регулярных выражений, и все, что делается на шагах 19 и 20, обычно выполняется более полнофункциональным языком манипулирования текстом, таким как awk или sed (или языком программирования общего назначения). Тем не менее, давайте продолжим, просто чтобы вы знали, на что действительно способно регулярное выражение.

Хотя <a href="https://stackoverflow.com/questions/7983115/are-perl-regexes-turing-complete" target="_blank" rel="nofollow">регулярные выражения не являются полными по Тьюрингу</a>, некоторые движки регулярных выражений предлагают функции, которые очень похожи на полный язык программирования. 
Одна из таких особенностей является "условием". Условные выражения Regex допускают операторы if-then-else, где выбранная ветвь определяется либо "взглядом вперед", либо "взглядом назад", о которых мы узнали на предыдущем шаге.

Например, вы можете захотеть сопоставить только действительные записи в списке дат:

<pre>pattern: <span>(?&lt;=Feb )([1-2][0-9])|(?&lt;=Mar )([1-2][0-9]|3[0-1])</span>
string:  Dates worked: Feb <span>28</span>, Feb <span>29</span>, Feb 30, Mar <span>30</span>, Mar <span>31</span> 
matches: <span>                  ^^      ^^              ^^      ^^</span>
group:   <span>                  11      11              22      22</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/104" target="_blank" rel="nofollow">Пример</a>)

&lt;mark&gt;Обратите внимание&lt;/mark&gt;, что указанные выше группы также индексируются по месяцам. Мы могли бы написать регулярное выражение для всех 12 месяцев и зафиксировать только действительные даты, которые затем были бы объединены в группы, проиндексированные по месяцу года.

Выше используется своего рода структура, подобная if, которая будет искать совпадения в первой группе, только если "Feb" предшествует числу (и аналогично для второй). Но что, если бы мы хотели использовать специальную обработку только для февраля? Что-то вроде "если числу предшествует "Feb ", сделайте это, иначе сделайте эту другую вещь". Вот как это делают условные выражения:

<pre>pattern: <span>(?(?&lt;=Feb )([1-2][0-9])|([1-2][0-9]|3[0-1]))</span>
string:  Dates worked: Feb <span>28</span>, Feb <span>29</span>, Feb 30, Mar <span>30</span>, Mar <span>31</span> 
matches: <span>                  ^^      ^^              ^^      ^^</span>
group:   <span>                  11      11              22      22</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/105" target="_blank" rel="nofollow">Пример</a>)

Структура if-then-else выглядит как (?(If)then|else), где (if) заменяется "взглядом вперед" или "взглядом назад". В приведенном выше примере (if) записан как <code>(?&lt;=Feb)</code>. Вы можете видеть, что мы сопоставляли даты больше 29, но только если они не следовали за "Feb ". Использование же lookbehinds ("взглядов назад") в условных выражениях полезно, если вы хотите убедиться, что совпадению предшествует какой-либо текст.

Положительные lookahead условные выражения могут сбивать с толку, потому что само условие не соответствует ни одному тексту. Поэтому, если вы хотите, чтобы условие if когда-либо имело значение, оно должно быть сопоставимым с lookahead, как показано ниже:

<pre>pattern: <span>(?(?=exact)exact|else)wo</span>
string:  exact else <span>exactwo elsewo</span> 
matches: <span>           ^^^^^^^ ^^^^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/106" target="_blank" rel="nofollow">Пример</a>)

Это означает, что положительные lookahead условные выражения бесполезны. Вы проверяете, находится ли этот текст впереди, и затем предоставляете шаблон соответствия, чтобы следовать ему, когда он есть. Условное выражение не помогает нам здесь вообще. Вы также можете просто заменить вышеприведенное на более простое регулярное выражение:

<pre>pattern: <span>(?:exact|else)wo</span>
string:  exact else <span>exactwo elsewo</span> 
matches: <span>           ^^^^^^^ ^^^^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/107" target="_blank" rel="nofollow">Пример</a>)

Итак, эмпирическое правило для выражений с условиями: тест, тест, и еще раз тест. Иначе решения, которые вы считаете очевидными, потерпят неудачу самыми захватывающими и неожиданными способами :)
&lt;h3&gt;Вот мы и подошли к последнему блоку задач, который отделяет нас от завершающего, 20-го шага:&lt;/h3&gt;
Напишите регулярное выражение, которое использует отрицательное lookahead условное выражение, чтобы проверить, начинается ли следующее слово с заглавной буквы.

Если это так, захватите только одну заглавную букву, а затем строчные буквы. Если это не так, захватите любые символы слова.

<pre>pattern: 
string:  <span>Jones Smith 9sfjn Hobbes 23r4tgr9h</span> CSV <span>Csv vVv</span>
matches: <span>^^^^^ ^^^^^ ^^^^^ ^^^^^^ ^^^^^^^^^     ^^^ ^^^</span>
group:   <span>22222 22222 11111 222222 111111111     222 111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/108" target="_blank" rel="nofollow">Решение</a>)

Напишите отрицательное lookbehind условное выражение, которое захватывает текст <code>owns</code> , только если ему не предшествует текст <code>cl</code> , и которое захватывает текст <code>ouds</code> , только когда ему предшествует текст <code>cl</code> . (Немного надуманный пример, но что поделаешь...)

<pre>pattern: 
string:  Those clowns <span>owns</span> some cl<span>ouds</span>. ouds.
matches: <span>             ^^^^        ^^^^</span>   
</pre>
(<a href="https://regex101.com/r/Mf9L3O/109" target="_blank" rel="nofollow">Решение</a>)
&lt;h2&gt;Шаг 20: рекурсия и дальнейшее обучение&lt;/h2&gt;
<img data-id="b2b3dc7c-5072-4cbe-9c6f-e24a1b39e207" src="/images/article/b2b3dc7c-5072-4cbe-9c6f-e24a1b39e207/512.jpeg" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4 - 6">На самом деле, есть очень много всего, что можно втиснуть в 20-шаговое введение в любую тему, и регулярные выражения не являются исключением.

Существует множество различных <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F#%D0%A0%D0%B0%D0%B7%D0%BD%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%80%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D1%85_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9" target="_blank" rel="nofollow">реализаций и стандартов для регулярных выражений</a>, которые можно найти в Интернете. Если вы хотите узнать больше, я предлагаю вам посетить замечательный сайт <a href="https://www.regular-expressions.info/" target="_blank" rel="nofollow">regularexpressions.info</a>, это фантастический справочник, и я, конечно, многое узнал от туда о регулярных выражениях. Я настоятельно рекомендую его, а также <a href="https://regex101.com/" target="_blank" rel="nofollow">regex101.com</a> для тестирования и публикации ваших творений.

На этом завершающем шаге я дам вам еще немного знаний о регулярных выражениях, а именно: как писать рекурсивные выражения.

Простые рекурсии довольно просты, но давайте подумаем, что это значит в контексте регулярного выражения. <a href="https://www.regular-expressions.info/" target="_blank" rel="nofollow">Синтаксис простой рекурсии</a> в регулярном выражении записывается так: <code>(?R)?</code> . Но, конечно, этот синтаксис должен появляться внутри самого выражения. То что мы сделаем, это вложим выражение в себя, произвольное количество раз. Например:

<pre>pattern: <span>(hey(?R)?oh)</span>
string:  <span>heyoh</span> heyyoh <span>heyheyohoh</span> hey oh heyhey hey<span>heyheyohoh</span> 
matches: <span>^^^^^        ^^^^^^^^^^                  ^^^^^^^^^^</span>
group:   <span>11111        1111111111                  1111111111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/110" target="_blank" rel="nofollow">Пример</a>)

Поскольку вложенное выражение является необязательным (<code>(?R)</code> сопровождается <code>?</code>), то самое простое совпадение - просто полностью игнорировать рекурсию. Итак, <code>hey</code>, а затем <code>oh</code> совпадает (<code>heyoh</code>). Чтобы сопоставить любое более сложное выражение, чем это, мы должны найти эту совпадающую подстроку, вложенную внутрь себя в той точке выражения, в которую мы вставили <code>(?R)</code> последовательность. Другими словами, мы могли бы найти heyheyohoh или heyheyheyohohoh, и так далее.

Одна из замечательных особенностей этих вложенных выражений заключается в том, что, в отличие от обратных ссылок и именованных групп захвата, они не ограничивают вас в соответствии с точным текстом, который вы сопоставляли ранее, символ за символом. Например:

<pre>pattern: <span>([Hh][Ee][Yy](?R)?oh)</span>
string:  <span>heyoh</span> heyyoh <span>hEyHeYohoh</span> hey oh heyhey <span>hEyHeYHEyohohoh</span> 
matches: <span>^^^^^        ^^^^^^^^^^               ^^^^^^^^^^^^^^^</span>
group:   <span>11111        1111111111               111111111111111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/111" target="_blank" rel="nofollow">Пример</a>)

Вы можете себе представить, что механизм регулярных выражений буквально копирует и вставляет ваше регулярное выражение в себя произвольное количество раз. Конечно, это означает, что иногда оно может делать не то, на что вы могли надеяться:

<pre>pattern: <span>((?:\(\*)[^*)]*(?R)?(?:\*\)))</span>
string:  (* comment <span>(* nested *)</span> not *) 
matches: <span>           ^^^^^^^^^^^^</span>
group:   <span>           111111111111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/113" target="_blank" rel="nofollow">Пример</a>)

Можете ли вы сказать, почему это регулярное выражение захватило только вложенный комментарий, а не внешний комментарий? Одно можно сказать наверняка: при написании сложных регулярных выражений всегда проверяйте их, чтобы убедиться, что они работают так, как вы думаете.

Вот и подошло к концу это скоростное ралли по дорогам регулярных выражений. Надеюсь, вам понравилось это путешествие. Ну, и напоследок, я оставлю здесь, как и обещал в начале, несколько полезных ссылок для более углубленного изучения материала:
<ul>
<li><a href="https://javarush.com/groups/posts/regulyarnye-vyrazheniya-v-java" target="_blank" rel="nofollow">Регулярные выражения в Java</a> (Статья от пользователя Alex)</li>
<li><a href="https://javarush.com/groups/posts/136-reguljarnihe-vihrazhenija-v-java-chastjh-1" target="_blank" rel="nofollow">Регулярные выражения в Java</a> (Перевод статьи Джеффа Фрисена от Эллеоноры Керри)</li>
<li><a href="https://hr-vector.com/java/regulyarnye-vyrazheniya-primery" target="_blank" rel="nofollow">Регулярные выражения java примеры</a> (с удобной таблицей по синтакису)</li>
<li><a href="https://learn.javascript.ru/regexp-greedy-and-lazy" target="_blank" rel="nofollow">Жадные и ленивые квантификаторы</a> (примеры на JavaScript)</li>
<li><a href="https://proglib.io/p/25-java-regex/" target="_blank" rel="nofollow">25 самых используемых регулярных выражений в Java</a></li>
<li><a href="https://regexone.com/" target="_blank" rel="nofollow">RegexOne</a> (Задачки с проверялкой)</li>
<li><a href="https://www.youtube.com/watch?v=_pLpx6btq6U" target="_blank" rel="nofollow">Не бойтесь регулярных выражений. Regex за 20 минут!</a> (для тех, кому больше нравятся видеоуроки)</li>
</ul>