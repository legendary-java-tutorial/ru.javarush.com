RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2
<p>----------------------------------------</p>
В прошлой части мы освоили простейшие регулярные выражения, и уже кое-чему научились. В этой части мы изучим чуть более сложные конструкции, но, поверьте, это будет не так трудно, как могло-бы...
<p>----------------------------------------</p>
<a href="https://javarush.com/groups/posts/2679-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-1" target="_blank">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1</a>

Оригинал <a href="https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc" target="_blank" rel="nofollow">здесь</a>

В прошлой части мы освоили простейшие регулярные выражения, и уже кое-чему научились. В этой части мы изучим чуть более сложные конструкции, но, поверьте, это будет не так трудно, как могло-бы показаться.
<img data-max-width="800" data-id="9075531f-6e76-466d-a04b-485c0da2b270" src="/images/article/9075531f-6e76-466d-a04b-485c0da2b270/800.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2 - 1">Итак, продолжим!
<h2>Шаг 8: звездочка <code>*</code> и знак "плюс" <code>+</code></h2><img data-max-width="512" data-id="7d74ba6f-5d7b-489f-b9fd-8b5f31d6ef27" src="/images/article/7d74ba6f-5d7b-489f-b9fd-8b5f31d6ef27/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2 - 2">До сих пор нам более или менее удавалось сопоставлять только строки заданной длины. Но в последних задачах мы приблизились к пределу того, что мы можем сделать с помощью обозначений, которые мы видели до сих пор.

Предположим, например, что мы не ограничены 3-символьными идентификаторами Java, а у нас могут быть идентификаторы любой длины. Решение, которое могло работать в предыдущем примере, не будет работать в следующем примере:

<pre>pattern: <span>[a-zA-Z_$]\w\w</span>
string:  <span>__e $12</span>3 3.2 fo <span>Bar</span>r <span>a23</span>mm ab x
matches: <span>^^^ ^^^         ^^^  ^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/48" target="_blank" rel="nofollow">Пример</a>)

<mark>Обратите внимание</mark>, что когда идентификатор действителен, но длиннее 3 символов, сопоставляются только первые три символа. 
И когда идентификатор действителен, но содержит менее 3 символов, то regex его вообще не находит!

Проблема в том, что выражения в квадратных скобках <code>[]</code> соответствуют ровно одному символу, как и классы символов, такие как <code>\w</code>. Это означает, что любые совпадения в приведенном выше регулярном выражении должны быть длиной ровно в три символа. Так что это не работает, как мы могли-бы надеяться.

Здесь могут помочь специальные символы <code>*</code> и <code>+</code>. Это модификаторы, которые могут быть добавлены справа от любого выражения, чтобы искать соответствия этому выражению более одного раза.

Звезда Клини (или "звездочка") <code>*</code> укажет, что нужно искать соответствия предыдущему токену любое количество раз, включая ноль раз. Знак "плюс" <code>+</code> укажет, что нужно искать один или несколько раз. Таким образом, выражение, которое предшествует <code>+</code>, является обязательным (по крайней мере, один раз), в то время как выражение, которое предшествует <code>*</code>, является необязательным, но когда оно появляется, оно может появляться любое количество раз.

Теперь, с этим знанием мы можем исправить приведенное выше регулярное выражение:

<pre>pattern: <span>[a-zA-Z_$]\w*</span>
string:  <span>__e $123</span> 3.2 <span>fo Barr a23mm ab x</span>
matches: <span>^^^ ^^^^     ^^ ^^^^ ^^^^^ ^^ ^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/49" target="_blank" rel="nofollow">Пример</a>)

Теперь мы сопоставляем действительные идентификаторы любой длины! Бинго! 

Но что-бы произошло, если бы мы в примере выше использовали <code>+</code> вместо <code>*</code>?

<pre>pattern: <span>[a-zA-Z_$]\w+</span>
string:  <span>__e $123</span> 3.2 <span>fo Barr a23mm ab</span> x
matches: <span>^^^ ^^^^     ^^ ^^^^ ^^^^^ ^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/50" target="_blank" rel="nofollow">Пример</a>)

Мы пропустили последнее совпадение, <code>х</code>. Это связано с тем, что для <code>+</code> требуется сопоставление хотя бы одного символа, но поскольку выражение в скобках <code>[]</code>, предшествующее <code>\w+</code>, уже 'съело' символ <code>x</code>, то доступных символов больше не осталось, поэтому сопоставление не удалось.

Когда мы можем использовать <code>+</code>? Когда нам нужно найти хотя бы одно совпадение, но не важно, сколько раз должно совпасть данное выражение. Например, если мы хотим найти любые числа, содержащие десятичную точку:

<pre>pattern: <span>\d*\.\d+</span>
string:  <span>0.011 .2</span> 42 <span>2.0 3.33 4.000</span> 5 6 <span>7.89012</span>
matches: <span>^^^^^ ^^    ^^^ ^^^^ ^^^^^     ^^^^^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/51" target="_blank" rel="nofollow">Пример</a>)

<mark>Обратите внимание</mark>, что сделав числа слева от десятичной точки необязательными, мы смогли найти как 0.011 так и .2. Для этого нам нужно было сопоставить ровно одну десятичную точку при помощи <code>\.</code> и минимум одну цифру справа от десятичной точки при помощи <code>\d+</code>. Вышеупомянутое регулярное выражение не будет соответствовать числу, подобному <code>3.</code>, потому что для соответствия нам требуется по крайней мере одна цифра справа от десятичной точки.
<h3>По традиции, решим пару простых задачек:</h3>Найдите все английские слова в отрывке ниже.

<pre>pattern: 
string:  3 <span>plus</span> 3 <span>is six but</span> 4 <span>plus three is</span> 7
matches:   <span>^^^^   ^^ ^^^ ^^^   ^^^^ ^^^^^ ^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/52" target="_blank" rel="nofollow">Решение</a>)

Найдите все обозначения размеров файлов в списке ниже. Размеры файлов будут состоять из числа (с десятичной точкой или без нее), за которым следуют <code>KB</code>, <code>MB</code>, <code>GB</code> или <code>TB</code>:

<pre>pattern:
string:  <span>11TB</span> 13 <span>14.4MB</span> 22HB <span>9.9GB</span> TB <span>0KB</span>
matches: <span>^^^^    ^^^^^^      ^^^^^    ^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/53" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 9: "optional" вопросительный знак <code>?</code></h2><img data-max-width="512" data-id="c90a5cc1-ce15-4e6e-944e-4e78b8eacdc5" src="/images/article/c90a5cc1-ce15-4e6e-944e-4e78b8eacdc5/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2 - 3">Вы уже написали regex для решения последней задачи? Это сработало? 

Теперь попробуйте применить его здесь:

<pre>pattern:
string:  1..3KB 5...GB ..6TB
matches:  
</pre>
Очевидно, что ни одно из этих обозначений не является допустимым размером файла, поэтому хорошее регулярное выражение не должно находить ни одно из них. Решение, которое я написал для решения последней задачи, соответствует им всем, по крайней мере частично:

<pre>pattern: <span>\d+\.*\d*[KMGT]B</span>
string:  <span>1..3KB</span> <span>5...GB</span> ..<span>6TB</span>
matches: <span>^^^^^^ ^^^^^^   ^^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/55" target="_blank" rel="nofollow">Пример</a>)

Так в чем-же проблема? На самом деле, нам нужно найти только одну десятичную точку, если она есть. Но <code>*</code> допускает любое количество совпадений, включая ноль. Есть ли способ сопоставлять только ноль раз или один раз? Но не более одного раза? Конечно есть.

"optional" <code>?</code> это модификатор, который соответствует нулю или одному из предыдущих символов, но не более:

<pre>pattern: <span>\d+\.?\d*[KMGT]B</span>
string:  1..<span>3KB</span> 5...GB ..<span>6TB</span>
matches:    <span>^^^          ^^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/56" target="_blank" rel="nofollow">Пример</a>)

Мы здесь приблизились к решению, но это еще не совсем то, что нам надо. Чуть позже мы увидим, как это исправить, через несколько шагов.
<h3>А пока решим такую задачу:</h3>В некоторых языках программирования (например, Java) за некоторыми целыми числами и числами с плавающей запятой (точкой) могут следовать <code>l</code> / <code>L</code> и <code>f</code> / <code>F</code>, чтобы указать, что они должны рассматриваться как long / float (соответственно), а не как обычные int / double. 

Найдите все действительные "long" числа в строке ниже:

<pre>pattern:
string:  <span>13L</span> long <span>2l 19</span> L lL <span>0</span>
matches: <span>^^^      ^^ ^^      ^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/54" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 10: знак "or" (или) <code>|</code></h2><img data-max-width="512" data-id="73571237-f76d-43ce-8533-ec779301b65a" src="/images/article/73571237-f76d-43ce-8533-ec779301b65a/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2 - 4">На шаге 8 у нас возникли некоторые трудности с нахождением различных типов чисел с плавающей точкой:

<pre>pattern: <span>\d*\.\d+</span>
string:  <span>0.011 .2</span> 42 <span>2.0 3.33 4.000</span> 5 6 <span>7.89012</span>
matches: <span>^^^^^ ^^    ^^^ ^^^^ ^^^^^     ^^^^^^^</span>  
</pre>
Приведенный выше шаблон сопоставляет числа с десятичной точкой и минимум одну цифру справа от десятичной точки. Но что, если мы также хотим сопоставить такие строки, как <code>0.</code>? (Без цифр справа от десятичной точки.)

Мы могли бы написать такое регулярное выражение:

<pre>pattern: <span>\d*\.\d*</span>
string:  <span>0.011 .2</span> 42 <span>2.0 3.33 4.000</span> 5 6 <span>7.89012 0. .</span>
matches: <span>^^^^^ ^^    ^^^ ^^^^ ^^^^^     ^^^^^^^ ^^ ^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/56" target="_blank" rel="nofollow">Пример</a>)

Это соответствует <code>0.</code>, но это также соответствует одиночной точке <code>.</code>, как вы можете видеть выше. 
На самом деле то, что мы пытаемся сопоставить, это два разных класса строк:
<ol>
<li>числа с минимум одной цифрой справа от десятичной точки</li>
<li>числа с хотя бы одной цифрой слева от десятичной точки</li>
</ol>Напишем 2 следующих, независимых друг от друга регулярных выражения:

<pre>pattern: <span>\d*\.\d+</span>
string:  <span>0.011 .2</span> 42 <span>2.0 3.33 4.000</span> 5 6 <span>7.89012</span> 0. .
matches: <span>^^^^^ ^^    ^^^ ^^^^ ^^^^^     ^^^^^^^</span>  
</pre>
<pre>pattern: <span>\d+\.\d*</span>
string:  <span>0.011</span> .2 42 <span>2.0 3.33 4.000</span> 5 6 <span>7.89012 0.</span> .
matches: <span>^^^^^       ^^^ ^^^^ ^^^^^     ^^^^^^^ ^^</span> 
</pre>
Мы видим, что ни в одном из этих случаев подстроки <code>42</code>, <code>5</code>, <code>6</code> или <code>.</code> не находятся движком. Для получения необходимого результата, нам не помешало-бы объединить эти регулярки. Как мы можем этого достичь?

Знак "or" <code>|</code> позволяет нам указать в регулярном выражении сразу несколько возможных последовательностей совпадений. Подобно тому, как <code>[]</code> позволяет нам указывать альтернативные одиночные символы, с помощью знака "or" <code>|</code> мы можем указывать альтернативные многосимвольные выражения.

Например, если мы хотим найти "собаку" или "кошку", мы могли-бы написать как-то так:

<pre>pattern: <span>\w\w\w</span>
string:  <span>Obviously</span>, a <span>dog</span> is a <span>better pet tha</span>n a <span>cat</span>.
matches: <span>^^^^^^^^^    ^^^      ^^^^^^ ^^^ ^^^    ^^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/57" target="_blank" rel="nofollow">Пример</a>)

... но это соответствует всем тройным последовательностям символов класса "word". 

Но "dog" и "cat"  даже не имеют общих букв, поэтому и квадратные скобки не помогут нам здесь. Вот самое простое регулярное выражение, которое мы могли бы использовать, оно соответствует обоим и только этим двум словам:

<pre>pattern: <span>dog|cat</span>
string:  Obviously, a <span>dog</span> is a better pet than a <span>cat</span>.
matches:              <span>^^^                        ^^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/58" target="_blank" rel="nofollow">Пример</a>)

Механизм регулярных выражений сначала пытается сопоставить всю последовательность слева от знака <code>|</code>, но если ему это не удается, то затем он пытается сопоставить последовательность справа от знака <code>|</code>. Несколько знаков <code>|</code> также могут быть объединены в цепочки для соответствия более чем двум альтернативным последовательностям:

<pre>pattern: <span>dog|cat|pet</span>
string:  Obviously, a <span>dog</span> is a better <span>pet</span> than a <span>cat</span>.
matches:              <span>^^^             ^^^        ^^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/59" target="_blank" rel="nofollow">Пример</a>)

<h3>Теперь решим очередную пару задачек, чтобы лучше усвоить этот шаг:</h3>Используйте знак <code>|</code>, чтобы исправить десятичное регулярное выражение, указанное выше, и получить такой результат:

<pre>pattern:
string:  <span>0.011 .2</span> 42 <span>2.0 3.33 4.000</span> 5 6 <span>7.89012 0.</span> .
matches: <span>^^^^^ ^^    ^^^ ^^^^ ^^^^^     ^^^^^^^ ^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/60" target="_blank" rel="nofollow">Решение</a>)

Используйте знак <code>|</code>, классы символов, "optional" <code>?</code> и т.д., чтобы создать одно регулярное выражение, соответствующее как целым числам, так и числам с плавающей запятой (точкой), как обсуждалось в задаче в конце предыдущего шага (эта задачка немного посложнее, да ;))

<pre>pattern: 
string:  <span>42L 12</span> x <span>3.4f 6l 3.3 0F</span> L F <span>.2F 0.</span>
matches: <span>^^^ ^^   ^^^^ ^^ ^^^ ^^     ^^^ ^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/61" target="_blank" rel="nofollow">Решение</a>)

<a href="https://javarush.com/groups/posts/2681-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-3" target="_blank">20 коротких шагов для освоения регулярных выражений. Часть 3</a>
<a href="https://javarush.com/groups/posts/2682-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-4" target="_blank">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4</a>