Основы регулярных выражений в Java. Часть 3
<p>----------------------------------------</p>
Продолжаем изучение регулярных выражений.
Предыдущие уроки:


    Основы регулярных выражений,
    Регулярные выражения в Java


В этой статье мы рассмо
<p>----------------------------------------</p>
Продолжаем изучение регулярных выражений.

В этой статье мы рассмотрим предопределенные классы символов, а также квантификацию (поиск последовательностей).

<img data-id="ebbd73b0-2f64-44e7-8b16-22e1542cc07b" data-max-width="760" alt="Основы регулярных выражений в Java. Часть 3 - 1" src="https://cdn.javarush.com/images/article/ebbd73b0-2f64-44e7-8b16-22e1542cc07b/1024.jpeg"><h2>Предопределенные классы символов</h2>API класса <code>Pattern</code> содержит предопределенные классы символов, предлагающие удобные сокращения часто используемых регулярных выражений.
<img data-id="c3d0eebf-85ab-4c01-8da0-1456cf6f881c" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 2" src="https://cdn.javarush.com/images/article/c3d0eebf-85ab-4c01-8da0-1456cf6f881c/1024.jpeg">В этой таблице конструкции в левой колонке — сокращенное представление выражений из правой колонки. Например, <code>\d</code> означает цифру (0-9), <code>\w</code> означает любую заглавную или прописную букву, символ подчеркивания или цифру). Используйте предопределенные классы символов, где это возможно. Это сделает ваш код проще для чтения и исправления ошибок.

Конструкции, начинающиеся с обратного слеша, называются экранированными или защищенными. В предыдущих статьях мы уже говорили об экранировании специальных символов обратным слешем или символами <code>\Q</code> и <code>\E</code> для использования их в качестве обычных символов. Если вы используете обратный слеш с обычными символами (литералами), то необходимо экранировать этот бэк слеш, чтобы выражение скомпилировалось.

<pre class='lang-java line-numbers'><code>
private final String REGEX = "\\d"; // цифра
</code></pre>
В этом примере <code>\d</code> — регулярное выражение; дополнительный обратный слеш необходим для того, чтобы программа скомпилировалась. Наша тестовая программа читает <a href='https://javarush.com/groups/posts/2013-reguljarnihe-vihrazhenija-v-java' target='_blank'>регулярные выражения</a> прямо из консоли, поэтому дополнительный слеш не нужен.

Следующий пример демонстрирует использование предопределенных символьных классов:
<img data-id="1b01383c-1811-4648-8923-b6987db5e19d" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 3" src="https://cdn.javarush.com/images/article/1b01383c-1811-4648-8923-b6987db5e19d/1024.jpeg"><img data-id="4e1c1668-4406-4488-a2ab-17d0111c8aa6" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 4" src="https://cdn.javarush.com/images/article/4e1c1668-4406-4488-a2ab-17d0111c8aa6/1024.jpeg">В первых трех примерах регулярное выражение — просто «<code>.</code>» (специальный символ точка), что означает любой символ. Поэтому поиск был успешным во всех случаях. В других примерах используются предопределенные символьные классы, значения которых мы рассмотрели в таблице выше.
<h2>Квантификаторы</h2><img data-id="46bbc180-b0c7-4fd2-964a-d74319f7838b" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 4" src="https://cdn.javarush.com/images/article/46bbc180-b0c7-4fd2-964a-d74319f7838b/1024.jpeg"><strong>Квантификаторы</strong> позволяют задавать количество вхождений символа в строку. Рассмотрим подробнее тонкости работы жадных, ленивых и очень жадных квантификаторов. На первый взгляд может показаться, что квантификаторы X?, X?? и X?+ работают одинаково: «X есть один раз или нет совсем». Есть небольшие отличия в реализации этих квантификаторов, которые мы рассмотрим ниже.
<h2>Совпадения нулевой длины</h2>Начнем с жадного. Напишем три разных регулярных выражения: буква «a» со специальными символами ?, * или +. Посмотрим, что произойдет если тестировать эти регулярки на пустой строке:
<img data-id="2222afd9-7255-43ef-9c29-5ebfbc56aab9" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 5" src="https://cdn.javarush.com/images/article/2222afd9-7255-43ef-9c29-5ebfbc56aab9/1024.jpeg">В примере выше, поиск был удачным в первых двух случаях, потому что выражения a? и a* допускают отсутствие символа a в строке. Также обратите внимание, что начальный и последний индексы совпадения одинаковы (0). Так как входная строка не имеет длины, программа находит ничего :) на первой же позиции. Этот случай называется совпадением нулевой длины. Такие совпадения встречаются в нескольких случаях: при пустой входной строке, в начале входной строки, после последнего символа строки или между символами строки. Совпадения нулевой длины легко обнаружить: они начинаются и заканчиваются на одной и той же позиции.

Рассмотрим еще несколько примеров совпадений нулевой длины.

Let’s explore zero-length matches with a few more examples. Изменим входную строку на символ «a» и наблюдаем интересный эффект:
<img data-id="e1c808a7-5a1c-48a1-ada5-8e7398ce7711" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 6" src="https://cdn.javarush.com/images/article/e1c808a7-5a1c-48a1-ada5-8e7398ce7711/1024.jpeg">Все три квантификатора нашли символ «a», но первые два, которые допускают отсутствие символа, нашли совпадение нулевой длины на позиции 1 — после последнего символа строки. Так происходит, потому что программа воспринимает символ «a» как строку и «бежит» по ней пока совпадения не закончатся. В зависимости от используемого квантификатора, программа будет или не будет находить «ничего» в конце строки.

Теперь изменим входную строку на последовательность из пяти букв «a»:
<img data-id="01af5247-7fa0-429a-b3ea-5a5a15ef1f7f" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 7" src="https://cdn.javarush.com/images/article/01af5247-7fa0-429a-b3ea-5a5a15ef1f7f/1024.jpeg">Регулярное выражение a? находит совпадение для каждой буквы в строке отдельно. Выражение a* находит два совпадения: последовательность символов «a»‘ и совпадение нулевой длины на 5 позиции. И, наконец, регулярное выражение a+ находит только последовательность символов «a», не находя при этом «ничего» :)

Что же будет происходить, если на вход подать строку, содержащую разные символы? Например, «ababaaaab»:
<img data-id="015a8b48-4d89-4af1-987e-2a7cab1b62d3" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 8" src="https://cdn.javarush.com/images/article/015a8b48-4d89-4af1-987e-2a7cab1b62d3/1024.jpeg">Символ «b» находится на 1, 3 и 8 позициях и программа находит совпадения нулевой длины на этих позициях. Регулярное выражение a? не обращает внимания на «b», а просто ищет присутствие (или отсутствие) символа «a». Если квантификатор допускает отсутствие «a» все символы в строке отличные от «a» будут показаны как совпадение нулевой длины.

Для нахождения последовательностей заданной длины, просто укажите длину в фигурных скобках:
<img data-id="c871b787-760d-4a53-b3bd-6b04d4afd41e" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 9" src="https://cdn.javarush.com/images/article/c871b787-760d-4a53-b3bd-6b04d4afd41e/1024.jpeg">Регулярное выражение a{3} ищет последовательность из трех символов «a». В первой строке ничего не найдено, потому что в строке недостаточно символов a. Вторая содержит 3 символа, которые и находит программа. Третий тест также находит совпадение в начале строки. Все что находится за 3 символом не удовлетворяет регулярному выражению, в коде ниже — удовлетворяет и найдутся несколько совпадений:
<img data-id="aac87994-bca7-414d-a7c1-aadf017c1281" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 10" src="https://cdn.javarush.com/images/article/aac87994-bca7-414d-a7c1-aadf017c1281/1024.jpeg">Для указания минимальной длины последовательности — используйте:

<pre class='lang-java line-numbers'><code>
Enter your regex: a{3,}
Enter input string to search: aaaaaaaaa
I found the text "aaaaaaaaa" starting at index 0 and ending at index 9.
</code></pre>
В этом примере программа находит только одно совпадение, потому что строка удовлетворяет требованию минимальной длины последовательности (3) символов «a».

Наконец, задание максимальной длины последовательности:
<img data-id="722ccf78-ee60-42b3-aae6-373aa310cc19" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 11" src="https://cdn.javarush.com/images/article/722ccf78-ee60-42b3-aae6-373aa310cc19/1024.jpeg">В этом примере первое совпадение закончилось на шестом символе. Второе совпадение  содержит символы после шестого, т.к. они удовлетворяют требованию минимальной длины. Если бы строка была на один символ короче, второго совпадения не было бы.
<h2>Использование групп символов и классов с квантификаторами</h2>До этого момента мы тестировали квантификаторы на строках, содержащих один и тот же символ. Квантификаторы распространяют свое действие только на один символ, поэтому регулярное выражение «abc+» будет находить стоки содержащие «ab» и «c» один или более раз. Оно не будет означать «abc» один или более раз. Но квантификаторы могут применяться вместе с группами и классами символов, например, [abc]+ (a или b или c, один или более раз) или (abc)+ («abc» один или более раз).

Найдем группу символов (dog), три раза в строке:
<img data-id="0414bbda-dd55-4ac1-af29-9dcf53b20c05" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 12" src="https://cdn.javarush.com/images/article/0414bbda-dd55-4ac1-af29-9dcf53b20c05/1024.jpeg">В первом примере программа находит совпадение, т.к. квантификатор распространяется на группу символов. Если убрать скобки — квантификатор {3} будет распространяться только на букву «g».

Так же можно применять квантификаторы с классами символов:
<img data-id="8477b7f2-fdd5-4f23-9890-f2015a6ba011" data-max-width="650" alt="Основы регулярных выражений в Java. Часть 3 - 13" src="https://cdn.javarush.com/images/article/8477b7f2-fdd5-4f23-9890-f2015a6ba011/1024.jpeg">Квантификатор {3} распространяет действие на класс символов в скобках в первом примере, а во втором — только на символ «c».
<h2>Различия жадных, ленивых и сверхжадных квантификаторов</h2>Есть небольшие различия между жадными (greedy), ленивыми (reluctant) и ревнивыми (possessive) квантификаторами.

Жадные квантификаторы названы так, потому что пытаются найти максимально длинное совпадение: сначала программа пытается «съесть» всю строку, если совпадение не найдено, то отбрасывается один символ и поиск повторяется, пока не будет найдено совпадение или не останется больше символов.

Ленивые — наоборот, начинают с начала строки, добавляя символ за символом, пока не найдут совпадение.

Наконец, ревнивая квантификация просматривает сразу всю строку единожды, не убирая символы, как в жадной.

Для демонстрации будем использовать строку xfooxxxxxxfoo.
<img data-id="dab5f212-bec3-4246-bee7-d969dcb04894" data-max-width="740" alt="Основы регулярных выражений в Java. Часть 3 - 14" src="https://cdn.javarush.com/images/article/dab5f212-bec3-4246-bee7-d969dcb04894/1024.jpeg">Первый пример использует жадный квантификатор .* для поиска любого символа, 0 или более раз, за которым расположены символы "f" "o" "o". Так как кантификатор жадный — найденное совпадение содержит всю строку. Жадный квантификатор не найдет все совпадения в строке, т.к. на первом шаге, просмотрев всю строку, он найдет совпадение и закончит работу.

Второй пример — ленивый и начинает с начала строки, добавляя символ за символом. Начинается работа программы с проверки «пустоты», но т.к. последовательности «foo» нет в начале строки, поиск продолжается с добавление символа «x», после которого будет найдено первое совпадение между индексами 0 и 4. Поиск продолжается до конца строки и второе совпадение будет найдено между индексами 4 и 13.

Третий пример не находит совпадений потому что квантификатор ревнивый. В этом случае регулярное выражение .*+ «съело» всю строку не оставив ничего для «foo». Используйте ревнивый квантификатор, когда нужно отбросить все не нужное в строке, он будет эффективнее эквивалентного жадного квантификатора.

На этом всё! 

Ссылка на первоисточник: <a href='http://easy-code.ru/lesson/java-quantifiers-regular-expressions' rel='nofollow' target='_blank'>Основы регулярных выражений в Java. Часть 3</a>