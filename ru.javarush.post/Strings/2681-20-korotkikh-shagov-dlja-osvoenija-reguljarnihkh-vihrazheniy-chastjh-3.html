RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 3
<p>----------------------------------------</p>
В этой части мы перейдем к вещам еще чуть более сложным. Но, освоить их, как и прежде, не составит особого труда. Повторюсь, что RegEx на самом деле легче, чем он может показаться вначале, и не нужно быть...
<p>----------------------------------------</p>
<a href="https://javarush.com/groups/posts/2679-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-1" target="_blank" rel="nofollow">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1.</a>
<a href="https://javarush.com/groups/posts/2680-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-2" target="_blank" rel="nofollow">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2.</a>

В этой части мы перейдем к вещам еще чуть более сложным. Но, освоить их, как и прежде, не составит особого труда. Повторюсь, что RegEx на самом деле легче, чем он может показаться вначале, и не нужно быть семи пядей во лбу, чтобы его освоить, и начать применять на деле.

Англоязычный оригинал этой статьи <a href="https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc" target="_blank" rel="nofollow">здесь</a>.
<img data-max-width="800" data-id="28dfd2a7-4d2d-4d0e-b44b-40ec3f7de68d" src="/images/article/28dfd2a7-4d2d-4d0e-b44b-40ec3f7de68d/800.jpeg" class="img-fluid" alt="20 коротких шагов для освоения регулярных выражений. Часть 3 - 1"><h2>Шаг 11: круглые скобки <code>()</code> как группы захвата</h2><img data-max-width="512" data-id="5cef32b7-18e8-4c46-8c78-3798b3a4f8fa" src="/images/article/5cef32b7-18e8-4c46-8c78-3798b3a4f8fa/512.jpeg" class="img-fluid" alt="20 коротких шагов для освоения регулярных выражений. Часть 3 - 2">В последней задаче мы искали различные виды целочисленных значений и числовых значений с плавающей запятой (точкой). Но механизм регулярных выражений не делал различий между этими двумя типами значений, поскольку все было отражено в одном большом регулярном выражении.

Мы можем сказать движку регулярных выражений, что нужно различать разные виды совпадений, если заключим наши мини-шаблоны в круглые скобки:

<pre>pattern: <span>([A-Z])|([a-z])</span>
string:  <span>The current President of Bolivia is Evo Morales</span>.
matches: <span>^^^ ^^^^^^^ ^^^^^^^^^ ^^ ^^^^^^^ ^^ ^^^ ^^^^^^^</span>
group:   <span>122 2222222 122222222 22 1222222 22 122 1222222</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/62" target="_blank" rel="nofollow">Пример</a>)

Приведенное выше регулярное выражение определяет две группы захвата, которые индексируются начиная с 1. Первая группа захвата соответствует любой отдельной заглавной букве, а вторая группа захвата соответствует любой отдельной строчной букве. Используя знак 'или' <code>|</code> и круглые скобки <code>()</code> как группу захвата, мы можем определить одно регулярное выражение, которое соответствует нескольким видам строк.

Если мы применим это к нашему регулярному выражению для поиска long / float из предыдущей части статьи, то механизм регулярных выражений будет фиксировать соответствующие совпадения в соответствующих группах. Проверяя, какой группе соответствует подстрока, мы можем сразу определить, является ли она значением float или значением long:

<pre>pattern: <span>(\d*\.\d+[fF]|\d+\.\d*[fF]|\d+[fF])|(\d+[lL])</span>
string:  <span>42L</span> 12 x <span>3.4f 6l</span> 3.3 <span>0F</span> L F <span>.2F</span> 0.
matches: <span>^^^      ^^^^ ^^     ^^     ^^^</span>
group:   <span>222      1111 22     11     111</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/63" target="_blank" rel="nofollow">Пример</a>)

Это регулярное выражение довольно сложное, и, чтобы его лучше понять, давайте разберем его на части, и рассмотрим каждый из этих шаблонов:

<pre>(                // совпадает с любой "float" подстрокой
  \d*\.\d+[fF]
  |
  \d+\.\d*[fF]
  |
  \d+[fF]
)
|               // OR
(               // совпадает с любой "long" подстрокой
  \d+[lL]
) 
</pre>
Знак <code>|</code> и группы захвата в скобках <code>()</code> позволяют нам сопоставлять различные типы подстрок. В этом случае мы сопоставляем либо числа с плавающей запятой "float", либо длинные длинные целые числа "long".

<pre>(
  \d*\.\d+[fF]  // 1+ цифр справа от десятичной точки
  |
  \d+\.\d*[fF]  // 1+ цифр слева от десятичной точки
  |
  \d+[fF]       // без точки, только 1+ цифр
)
|
(
  \d+[lL]       // без точки, только 1+ цифр
)
</pre>
В группе захвата "float" у нас есть три варианта: числа с минимум 1 цифрой справа от десятичной точки, числа с минимум одной цифрой слева от десятичной точки и числа без десятичной точки. Любые из них являются "float", при условии, что к их концу добавлены буквы "f" или "F".  

Внутри группы захвата "long" у нас есть только одна опция - у нас должна быть 1 или более цифр, за которыми следует символ "l" или "L". 

Механизм регулярных выражений будет искать эти подстроки в данной строке и индексировать их в соответствующей группе захвата.  

<mark>Обратите внимание</mark>, что мы не сопоставляем ни одно из чисел, к которым не добавлено ни одного из "l", "L", "f" или "F". Как следует классифицировать эти цифры? Ну, если они имеют десятичную точку, по умолчанию в языке Java используется значение "double". В противном случае они должны быть "int".
<h3>Закрепим пройденное парой задачек:</h3>Добавьте еще две группы захвата к приведенному выше регулярному выражению, чтобы оно также классифицировало числа double или int. (Это еще один сложный вопрос, не расстраивайтесь, если это займет некоторое время, в крайнем случае смотрите мое решение.)

<pre>pattern: 
string:  <span>42L 12</span> x <span>3.4f 6l 3.3 0F</span> L F <span>.2F 0.</span>
matches: <span>^^^ ^^   ^^^^ ^^ ^^^ ^^     ^^^ ^^</span>
group:   <span>333 44   1111 33 222 11     111 22</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/64" target="_blank" rel="nofollow">Решение</a>)

Следущая задачка немного по-проще. Используйте группы захвата в скобках <code>()</code>, знак 'или' <code>|</code> и диапазоны символов для сортировки следующих возрастов: "разрешено пить в США". (&gt;= 21) и "запрещено пить в США" (&lt;21):

<pre>pattern: 
string:  <span>7 10 17 18 19 20 21 22 23 24 30 40 100 120</span>
matches: <span>^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^^ ^^^</span>
group:   <span>2 22 22 22 22 22 11 11 11 11 11 11 111 111</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/65" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 12: сначала определите более конкретные совпадения</h2><img data-max-width="512" data-id="58f3b2e5-a331-4c9c-b52d-e5fa5449ad15" src="/images/article/58f3b2e5-a331-4c9c-b52d-e5fa5449ad15/512.jpeg" class="img-fluid" alt="20 коротких шагов для освоения регулярных выражений. Часть 3 - 3">Возможно, у вас возникли некоторые проблемы с последней задачей, если вы попытались определить "законно пьющих" как первую группу захвата, а не вторую. Чтобы понять почему, давайте посмотрим на другой пример. 

Предположим, мы хотим записать отдельно фамилии, содержащие менее 4 символов, и фамилии, содержащие 4 или более символов. Давайте отдадим более короткие имена первой группой захвата, и посмотрим что произойдет:

<pre>pattern: <span>([A-Z][a-z]?[a-z]?)|([A-Z][a-z][a-z][a-z]+)</span>
string:  <span>Kim Job</span>s <span>Xu Clo</span>yd <span>Moh</span>r <span>Ngo Roc</span>k.
matches: <span>^^^ ^^^  ^^ ^^^   ^^^  ^^^ ^^^</span>
group:   <span>111 111  11 111   111  111 111</span>   
</pre>
(<a href="https://regex101.com/r/Mf9L3O/66" target="_blank" rel="nofollow">Пример</a>)

По умолчанию большинство движков регулярных выражений используют <a href="https://stackoverflow.com/a/2301298/2925434" target="_blank" rel="nofollow">жадное сопоставление</a> с основными символами, которые мы видели до сих пор. Это означает, что механизм регулярных выражений будет захватывать максимально длинную группу, определенную как можно раньше в предоставленном регулярном выражении. Таким образом, хотя вторая группа, приведенная выше, могла бы захватить больше символов в именах, таких как, например, "Jobs" и "Cloyd", но, поскольку первые три символа этих имен уже были захвачены первой группой захвата, они не могут быть захвачены снова второй. 

Теперь внесем небольшое исправление - просто изменим порядок групп захвата, поместив первой более конкретную (более длинную) группу:

<pre>pattern: <span>([A-Z][a-z][a-z][a-z]+)|([A-Z][a-z]?[a-z]?)</span>
string:  <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span>.
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span>
group:   <span>222 1111 22 11111 1111 222 1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/67" target="_blank" rel="nofollow">Пример</a>)
<h3>Задача... на этот раз только одна :)</h3>"Более конкретный" шаблон почти всегда означает "более длинный". Предположим, что мы хотим найти два вида "слов": сначала те, которые начинаются с гласных (более конкретно), потом те, которые <b>не</b> начинаются с гласных (любое другое слово). 

Попробуйте написать регулярное выражение для захвата и идентификации строк, которые соответствуют этим двум группам. (Группы ниже обозначены буквами, а не пронумерованы. Вы должны определить, какая группа должна соответствовать первой, а какая - второй.)

<pre>pattern: 
string:  <span>pds6f uub 24r2gp ewqrty l ui_op</span>
matches: <span>^^^^^ ^^^ ^^^^^^ ^^^^^^ ^ ^^^^^</span>
group:   <span>NNNNN VVV NNNNNN VVVVVV N VVVVV</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/68" target="_blank" rel="nofollow">Решение</a>)

В общем, чем точнее ваше регулярное выражение, тем длиннее оно получится в итоге. И чем оно точнее, тем меньше вероятность, что вы захватите то, что вам не нужно. Поэтому, хотя они могут выглядеть пугающими, более длинные регулярные выражения ~= лучшие регулярные выражения. <a href="https://emailregex.com/" target="_blank" rel="nofollow">К сожалению</a>.
<h2>Шаг 13: фигурные скобки <code>{}</code> для определенного числа повторений</h2><img data-max-width="512" data-id="0d148d85-2088-4c43-9ae9-77fa5cf1e221" src="/images/article/0d148d85-2088-4c43-9ae9-77fa5cf1e221/512.jpeg" class="img-fluid" alt="20 коротких шагов для освоения регулярных выражений. Часть 3 - 4">В примере с фамилиями из предыдущего шага у нас было 2 почти повторяющихся группы в одном шаблоне:

<pre>pattern: <span>([A-Z][a-z][a-z][a-z]+)|([A-Z][a-z]?[a-z]?)</span>
string:  <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span>.
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span>
group:   <span>222 1111 22 11111 1111 222 1111</span>    
</pre>
Для первой группы нам нужны были фамилии с четырьмя или более буквами. Вторая группа должна была захватывать фамилии с тремя или менее буквами.  
Существует-ли какой-то более простой способ написать это, чем повторять эти <code>[a-z]</code> группы снова и снова? Существует, если использовать для этого фигурные скобки <code>{}</code>. 

Фигурные скобки <code>{}</code> позволяют нам указать минимальное и (необязательно) максимальное количество совпадений предыдущего символа или группы захвата. Есть три варианта использования <code>{}</code>:

<pre>{X}   // совпадает точно X раз
{X,}  // совпадает &gt;= X раз
{X,Y} // совпадает &gt;= X and &lt;= Y раз
</pre>
Вот примеры этих трех различных синтаксисов:

<pre>pattern: <span>[a-z]{11}</span>
string:  <span>humuhumunuk</span>unukuapua'a.
matches: <span>^^^^^^^^^^^</span>   
</pre>
(<a href="https://regex101.com/r/Mf9L3O/69" target="_blank" rel="nofollow">Пример</a>)

<pre>pattern: <span>[a-z]{18,}</span>
string:  <span>humuhumunukunukuapua</span>'a.
matches: <span>^^^^^^^^^^^^^^^^^^^^</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/71" target="_blank" rel="nofollow">Пример</a>)

<pre>pattern: <span>[a-z]{11,18}</span>
string:  <span>humuhumunukunukuap</span>ua'a.
matches: <span>^^^^^^^^^^^^^^^^^^</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/70" target="_blank" rel="nofollow">Пример</a>)

В приведенных выше примерах есть несколько моментов, на которые следует <mark>обратить внимание:</mark>. Во-первых, используя нотацию {X}, предыдущий символ или группа будет соответствовать именно этому числу (X) раз. Если в "слове" есть больше символов (чем число X), которые могли бы соответствовать шаблону (как показано в первом примере), то они не будут включены в соответствие. Если количество символов меньше X, то полное сопоставление завершится неудачно (попробуйте изменить 11 на 99 в первом примере).

Во-вторых, обозначения {X,} и {X,Y} являются жадными. Они будут пытаться соответствовать как можно большему числу символов, в то же время удовлетворяя заданному регулярному выражению. Если вы укажете {3,7}, то можно будет сопоставить от 3 до 7 символов, и если следующие 7 символов действительны, тогда будут сопоставлены все 7 символов. Если вы укажете {1,}, и все следующие 14 000 символов совпадают, то все 14 000 из этих символов будут включены в соответствующую строку.

Как мы можем использовать это знание, чтобы переписать наше выражение выше? Самым простым улучшением может быть замена соседних групп <code>[a-z]</code> на <code>[a-z]{N}</code>, где N выбирается соответствующим образом:

<pre>pattern: <span>([A-Z][a-z]{2}[a-z]+)|([A-Z][a-z]?[a-z]?)</span>  
</pre>
... но это не делает ситуацию намного лучше. 

Посмотрите на первую группу захвата: у нас есть <code>[a-z]{2}</code> (что соответствует ровно 2 строчным буквам), за которыми следует <code>[a-z]+</code> (что соответствует 1 или более строчным буквам). Мы можем упростить это, запросив 3 или более строчных букв, используя фигурные скобки:

<pre>pattern: <span>([A-Z][a-z]{3,})|([A-Z][a-z]?[a-z]?)</span> 
</pre>
Вторая группа захвата отличается. Нам нужно не более трех символов в этих фамилиях, что означает, что у нас есть верхний предел, но наш нижний предел равен нулю:

<pre>pattern: <span>([A-Z][a-z]{3,})|([A-Z][a-z]{0,2})</span> 
</pre>
Специфичность всегда лучше при использовании регулярных выражений, поэтому было бы разумно остановиться на этом, но я не могу не заметить, что эти два диапазона символов (<code>[AZ]</code> и <code>[az]</code>) рядом друг с другом выглядят почти как класс "word character" (символ слова), <code>\w</code> (<code>[A-Za-z0-9_]</code>). 

Если мы уверены, что наши данные содержат только хорошо отформатированные фамилии, то мы могли бы упростить наше регулярное выражение, и написать просто:

<pre>pattern: <span>(\w{4,})|(\w{1,3})</span> 
</pre>
Первая группа захватывает любую последовательность из 4 или более "word characters" (<code>[A-Za-z0-9_]</code>), а вторая группа захватывает любую последовательность от 1 до 3 "word characters" (включительно). Сработает-ли это?

<pre>pattern: <span>(\w{4,})|(\w{1,3})</span>
string:  <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span>.
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span>
group:   <span>222 1111 22 11111 1111 222 1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/72" target="_blank" rel="nofollow">Пример</a>)

Сработало! Как насчет такого подхода? И это намного чище, чем в нашем предыдущем примере. Поскольку первая группа захвата соответствует всем фамилиям с четырьмя или более символами, то мы могли бы даже изменить вторую группу захвата просто на <code>\w+</code>, так как это позволило бы нам захватить все оставшиеся фамилии (с 1, 2 или 3 символами):

<pre>pattern: <span>(\w{4,})|(\w+)</span>
string:  <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span>.
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span>
group:   <span>222 1111 22 11111 1111 222 1111</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/73" target="_blank" rel="nofollow">Пример</a>)
<h3>Давайте поможем мозгу усвоить это, и решим следующие 2 задачи:</h3>Используйте фигурные скобки <code>{}</code>, чтобы переписать регулярное выражение для поиска номера социального страхования из шага 7:

<pre>pattern:
string:  113-25=1902 <span>182-82-0192</span> H23-_3-9982 1I1-O0-E38B
matches:             <span>^^^^^^^^^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/74" target="_blank" rel="nofollow">Решение</a>)

Предположим, что система проверки надежности пароля на веб-сайте требует, чтобы пароли пользователей составляли от 6 до 12 символов. Напишите регулярное выражение, помечающее <strong>неверные</strong> пароли в списке ниже. Каждый пароль содержится в скобках <code>()</code> для удобства сопоставления, поэтому убедитесь, что регулярное выражение начинается и заканчивается буквальными <code>(</code>и<code>)</code> символами. 

Подсказка: убедитесь, что вы запрещаете литеральные скобки в паролях с помощью <code>[^()]</code> или аналогичных, в противном случае вы получите в конечном итоге соответствие всей строке!

<pre>pattern: 
string:  <span>(12345) (my password)</span> (Xanadu.2112) <span>(su_do)</span> (OfSalesmen!)
matches: <span>^^^^^^^ ^^^^^^^^^^^^^               ^^^^^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/75" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 14: <code>\b</code> символ границы нулевой ширины</h2><img data-max-width="512" data-id="acd92a73-25a8-4eb9-9877-e0338362538c" src="/images/article/acd92a73-25a8-4eb9-9877-e0338362538c/512.jpeg" class="img-fluid" alt="20 коротких шагов для освоения регулярных выражений. Часть 3 - 5">Последняя задача была довольно сложной. Но что, если мы еще немного усложним ее, заключив пароли в кавычки <code>""</code> вместо скобок <code>()</code>? Можем ли мы написать аналогичное решение, просто заменив все символы круглых скобок на символы кавычек?

<pre>pattern: <span>\"[^"]{0,5}\"|\"[^"]+\s[^"]*\"</span>
string:  <span>"12345" "my password"</span> "Xanadu.2112<span>" "</span>su_do" "OfSalesmen!"
matches: <span>^^^^^^^ ^^^^^^^^^^^^^             ^^^     ^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/76" target="_blank" rel="nofollow">Пример</a>)

Получилось не очень впечатляюще. Вы уже догадались почему?

Проблема в том, что мы ищем здесь неправильные пароли. 

"Xanadu.2112" - хороший пароль, поэтому, когда регулярное выражение понимает, что эта последовательность не содержит пробелов или литеральных символов <code>"</code>, оно сдается непосредственно перед символом <code>"</code>, который ограничивает пароль в правой части. (Поскольку мы указали, что символы <code>"</code> не могут быть найдены внутри паролей, используя <code>[^"]</code>.)

Как только механизм регулярных выражений убедится, что эти символы не соответствуют определенному регулярному выражению, он запускается снова, именно в том месте, где он остановился - где был символ <code>"</code>, который ограничивает "Xanadu.2112" справа. Оттуда он видит один символ пробела, и другой символ <code>"</code> - для него это неправильный пароль! В общем, он находит эту последовательность <code>" "</code> и идет дальше. Это совсем не то, что мы хотели-бы получить... 

Было бы здорово, если бы мы могли указать, что первый символ пароля должен быть <b>не</b> пробелом. Есть-ли способ сделать это? (К настоящему моменту, вы, наверное, уже поняли, что ответом на все мои риторические вопросы является "да".) Да! Такой способ есть!

Многие движки регулярных выражений предоставляют такую escape-последовательность как "граница слова" <code>\b</code>. "Граница слова" <code>\b</code> - это escape-последовательность нулевой ширины, которая, как ни странно, соответствует границе слова. Помните, что когда мы говорим "слово", то мы имеем в виду как любую последовательность символов в классе <code>\w</code>, так и такую <code>[A-Za-z0-9_]</code>.

Совпадение по границе слова означает, что символ непосредственно перед, или сразу после последовательности <code>\b</code> должен быть <code>не</code> символом слова. Однако, при сопоставлении, мы не включаем этот символ в нашу захваченную подстроку. Это и есть нулевая ширина. Чтобы увидеть, как это работает, давайте рассмотрим небольшой пример:

<pre>pattern: <span>\b[^ ]+\b</span>
string:  <span>Ve still vant ze money</span>, <span>Lebowski</span>.
matches: <span>^^ ^^^^^ ^^^^ ^^ ^^^^^  ^^^^^^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/78" target="_blank" rel="nofollow">Пример</a>)

Последовательность <code>[^ ]</code> должна соответствовать любому символу, который не является символом буквального пробела. Так почему же это не соответствует запятой <code>,</code> после money или точке "<code>.</code> после Lebowski? Это потому что запятая <code>,</code> и точка <code>.</code> не являются символами слова, поэтому между символами слова и несловесными символами создаются границы. Они появляются между <code>y</code> в конце слова money и запятой <code>,</code> которая следует за ним, и между "<code>i</code> слова Lebowski и точкой <code>.</code> (полной остановкой / периодом), которая следует за ним. Регулярное выражение совпадает на границах этих слов (но не на несловесных символах, которые только помогают их определить).

Но что произойдет, если мы не включим последовательность <code>\b</code> в наш шаблон?

<pre>pattern: <span>[^ ]+</span>
string:  <span>Ve still vant ze money, Lebowski.</span>
matches: <span>^^ ^^^^^ ^^^^ ^^ ^^^^^^ ^^^^^^^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/79" target="_blank" rel="nofollow">Пример</a>)

Ага, теперь мы находим и эти знаки препинания.

Теперь давайте воспользуемся границами слов, чтобы исправить регулярное выражение для паролей в кавычках:

<pre>pattern: <span>\"\b[^"]{0,5}\b\"|\"\b[^"]+\s[^"]*\b\"</span>
string:  <span>"12345" "my password"</span> "Xanadu.2112" <span>"su_do"</span> "OfSalesmen!"
matches: <span>^^^^^^^ ^^^^^^^^^^^^^               ^^^^^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/80" target="_blank" rel="nofollow">Пример</a>)

Размещая границы слов внутри кавычек ("\b ... \b"), мы фактически говорим, что первый и последний символы совпадающих паролей должны быть "символами слова". Так что здесь все работает нормально, но не будет работать так же хорошо, если первый или последний символ пароля пользователя не является символом слова:

<pre>pattern: <span>\"\b[^"]{0,5}\b\"|\"\b[^"]+\s[^"]*\b\"</span>
string:  "thefollowingpasswordistooshort" "C++"
matches:   
</pre>
(<a href="https://regex101.com/r/Mf9L3O/81" target="_blank" rel="nofollow">Пример</a>)

Посмотрите, как второй пароль не помечен как "неверный", даже если он явно слишком короткий. Вы должны быть <mark>осторожны</mark> с последовательностями <code>\b</code>, так как они соответствуют границам только между символами <code>\w</code> и не <code>\w</code>. В приведенном выше примере, поскольку в паролях мы допустили символы не <code>\w</code>, граница между <code>\</code> и первым/последним символом пароля не гарантируется как граница слова <code>\b</code>.
<h3>В завершение этого шага решим только одну простую задачу:</h3>Границы слова полезны в механизмах подсветки синтаксиса, когда мы хотим сопоставить определенную последовательность символов, но хотим убедиться, что они встречаются только в начале или конце слова (или сами по себе). Предположим, мы пишем подсветку синтаксиса и хотим выделить слово var, но только тогда, когда оно появляется само по себе (не касаясь других символов слова). 

Сможете ли вы написать регулярное выражение для этого? Конечно сможете, ведь это совсем простая задача ;)

<pre>pattern: 
string:  <span>var</span> varx _var (<span>var</span> j) barvarcar *<span>var var</span>-&gt; {<span>var</span>}
matches: <span>^^^            ^^^               ^^^ ^^^    ^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/82" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 15: "caret" <code>^</code> как "начало строки" и знак доллара <code>$</code> как "конец строки"</h2><img data-max-width="512" data-id="2388206b-f4e6-4cd4-869b-3072cf7f931c" src="/images/article/2388206b-f4e6-4cd4-869b-3072cf7f931c/512.jpeg" class="img-fluid" alt="20 коротких шагов для освоения регулярных выражений. Часть 3 - 6">Последовательность границ слова <code>\b</code> (из последнего шага предыдущей части статьи) - не единственная специальная последовательность нулевой ширины, доступная для использования в регулярных выражениях. Двумя наиболее популярными из них являются "caret" <code>^</code> - "начало строки" и знак доллара <code>$</code> - "конец строки". Включение одного из них в ваши регулярные выражения означает, что данное совпадение должно появиться в начале или в конце исходной строки:

<pre>pattern: <span>^start|end$</span>
string:  <span>start</span> end start end start end start <span>end</span>
matches: <span>^^^^^                               ^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/83" target="_blank" rel="nofollow">Пример</a>)

Если ваша строка содержит разрывы строк, то <code>^start</code> будет соответствовать последовательности "start" в начале любой строки, а <code>end$</code> будет соответствовать последовательности "end" в конце любой строки (хотя это трудно показать здесь). Эти символы особенно полезны при работе с данными, которые содержат разделители.

Давайте вернемся к проблеме "размера файла" из шага 9, используя <code>^</code> "начало строки". В этом примере наши размеры файлов разделены пробелами "<code> </code>". Поэтому мы хотим, чтобы каждый размер файла начинался с цифры, которой предшествует символ пробела или начало строки:

<pre>pattern: <span>(^| )(\d+|\d+\.\d+)[KMGT]B</span>
string:  <span>6.6KB</span> 1..3KB <span>12KB</span> 5G <span>3.3MB</span> KB .6.2TB <span>9MB</span>.
matches: <span>^^^^^       ^^^^^   ^^^^^^          ^^^^</span>
group:   <span>222         122     1222            12</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/84" target="_blank" rel="nofollow">Пример</a>)

Мы уже так близко к цели! Но вы можете заметить, что у нас все еще есть одна небольшая проблема: мы сопоставляем символ пробела перед допустимым размером файла. Теперь мы можем просто игнорировать эту группу захвата (1), когда наш движок регулярных выражений найдет ее, или мы можем использовать группу без захвата, которую мы увидим на следующем шаге.
<h3>А пока, решим еще 2 задачки для тонуса:</h3>Продолжая наш пример подсветки синтаксиса из последнего шага, некоторые подсветки синтаксиса будут отмечать конечные пробелы, то есть любые пробелы, которые находятся между непробельным символом и концом строки. Можете ли вы написать регулярное выражение для подсветки только конечных пробелов?

<pre>pattern: 
string:  myvec &lt;- c(1, 2, 3, 4, 5)  
matches: <span>                         ^^^^^^^</span>  
</pre>
(<a href="https://regex101.com/r/Mf9L3O/85" target="_blank" rel="nofollow">Решение</a>)

Простой синтаксический анализатор с разделителями-запятыми (CSV) будет искать "токены", разделенные запятыми. Как правило, пробел не имеет значения, если он не заключен в кавычки <code>""</code>. Напишите простое регулярное выражение для разбора CSV, которое сопоставляет токены между запятыми, но игнорирует (не захватывает) пробел, который <strong>не</strong> находится между кавычек.

<pre>pattern: 
string:  <span>a, "b", "c d",e,f,   "g h", dfgi,, k, "", l</span>
matches: <span>^^ ^^^^ ^^^^^^^^^^   ^^^^^^ ^^^^^^ ^^ ^^^ ^</span>
group:   <span>21 2221 2222212121   222221 222211 21 221 2</span>    
</pre>
(<a href="https://regex101.com/r/Mf9L3O/114" target="_blank" rel="nofollow">Решение</a>)

<a href="https://javarush.com/groups/posts/2682-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-4" target="_blank" rel="nofollow">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4.</a>