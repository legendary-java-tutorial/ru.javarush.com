Ах, эти строки...
<p>----------------------------------------</p>
Класс java.lang.String, пожалуй, является одним из самых используемых в Java. И очень часто его используют неграмотно, что порождает множество проблем, прежде всего с производительностью. В этой статье я хочу рассказать о строках, о тонкостях при их использовании ...
<p>----------------------------------------</p>
Класс <strong>java.lang.String</strong>, пожалуй, является одним из самых используемых в Java. И очень часто его используют неграмотно, что порождает множество проблем, прежде всего с производительностью. В этой статье я хочу рассказать о строках, о тонкостях при их использовании, об источниках проблем и т.п.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="2d25a539-763e-4af8-820c-9ef746e7fc45" data-max-width="710" alt="Ах, эти строки... - 1" src="https://cdn.javarush.com/images/article/2d25a539-763e-4af8-820c-9ef746e7fc45/1024.jpeg"></div></div>Вот о чем мы поговорим:
<ul>
<li>Устройство строки</li>
<li>Строковые литералы</li>
<li>Сравнение строк</li>
<li>Сложение строк</li>
<li>Выборка подстроки и копирующий конструктор</li>
<li>Изменение строки</li>
<li>Начнем с основ.</li>
</ul><h2>Устройство строки</h2>Класс <strong>java.lang.String</strong> содержит в себе три поля:

<pre class='lang-java line-numbers'><code>
/**
 * NOTE: This is just a partial API
 */
public final class String{

    private final char value[];
    private final int offset;
    private final int count;

}
</code></pre>
На самом деле там содержатся и другие поля, например, hash-код, но сейчас это неважно. Основные – эти.

Итак, в основе строки лежит массив символов (<strong>char</strong>). При хранении символов в памяти используется кодировка Unicode <em>UTF-16BE</em>. Подробнее о ней можно почитать <a href="http://www.skipy.ru/technics/encodings.html#UTF" rel="nofollow" >тут</a>. Начиная с версии Java 5.0 введена поддержка Unicode версии выше 2 и, соответственно, символов с кодами больше <strong>0xFFFF</strong>. Для этих символов используются уже не один <strong>char</strong>, а два, подробнее о кодировке этих символов <a href="http://www.skipy.ru/technics/encodings.html#UTF" rel="nofollow" >в той же статье</a>.

Хоть поддержка этих символов и введена, да вот незадача – отобразить их не получится. Я нашел набор музыкальных символов (<a href="http://www.unicode.org/charts/PDF/U1D100.pdf" rel="nofollow" >U1D100</a>) и попробовал вывести хоть куда-нибудь скрипичный ключ (символ с кодом 1D120). Перевел код в два <strong>char</strong>, как и положено – '\uD834' и '\uDD20'. Декодер на них не ругается, честно распознает как один символ. Вот только шрифта нет, в котором этот символ существует. А потому – квадратик. И судя по всему – это надолго. Так что введение поддержки Unicode 4 можно рассматривать исключительно через призму задела на будущее.

Пойдем дальше. Я прошу обратить пристальное внимание на второе и третье поля – <strong>offset</strong> и <strong>count</strong>. Казалось бы, массив полностью определяет строку, если используются <strong>ВСЕ</strong> символы. Если же существуют такие поля – символы в массиве могут использоваться не все. Так оно и есть, об этом мы поговорим в части выборка подстроки и копирующий конструктор.<cut>

<h2>Строковые литералы</h2>Что такое строковый литерал? Это строка, записаная в двойных кавычках, например, такая: "abc". Такие выражения используются в коде сплошь и рядом. Строка эта может содержать escape-последовательности unicode, например, \u0410, что будет соответствовать русской букве 'А'. Однако, эта строка <strong>НЕ МОЖЕТ</strong> содержать последовательностей \u000A и \u000D, соответствующие символам LF и CR соответственно. Дело в том, что последовательности обрабатываются на самой ранней стадии компиляции, и символы эти будут заменены на реальные LF и CR (как если бы в редакторе просто нажали "Enter"). Для вставки в строку этих символов следует использовать последовательности \n и \r, соответственно.

Строковые литералы сохраняются в пуле строк. Я упоминал о пуле в статье о сравнении на практике, но повторюсь. Виртуальная машина Java поддерживает пул строк. В него кладутся все строковые литералы, объявленные в коде. При совпадении литералов (с точки зрения equals, см. <a href="http://www.skipy.ru/technics/objCompPr.html#str_equals_vs_eqeq" rel="nofollow" >тут</a>) используется один и тот же объект, находящийся в пуле. Это позволяет сильно экономить память, а в некоторых случаях и повышать производительность. Дело в том, что строку в пул можно поместить принудительно, с помощью метода <strong>String.intern()</strong>. Этот метод возвращает из пула строку, равную той, у которой был вызван этот метод. Если же такой строки нет – в пул кладется та, у которой вызван метод, после чего возвращается ссылка на нее же. Таким образом, при грамотном использовании пула появляется возможность сравнивать строки не по значению, через equals, а по ссылке, что значительно, на порядки, быстрее. Так реализован, например, класс <strong>java.util.Locale</strong>, который имеет дело с кучей маленьких, в основном двухсимвольных, строк – кодами стран, языков и т.п. См. также тут: <a href="http://www.skipy.ru/technics/objCompPr.html#str_equals_vs_eqeq" rel="nofollow" >Сравнение объектов: практика – метод String.intern</a>.

Очень часто я вижу в различной литературе конструкции следующего вида:

<pre class='lang-java line-numbers'><code>
public static final String SOME_STRING = new String("abc");
</code></pre>
Если говорить еще точнее, нарекания у меня вызывает <strong>new String("abc")</strong>. Дело в том, что конструкция эта – безграмотна. В Java строковый литерал – "abc" – <strong>УЖЕ</strong> является объектом класса <strong>String</strong>. А потому, использование еще и конструктора приводит к <strong>КОПИРОВАНИЮ</strong> строки. Поскольку строковый литерал уже хранится в пуле, и никуда из него не денется, то созданный <strong>НОВЫЙ</strong> объект – ничто иное как пустая трата памяти. Эту конструкцию с чистой совестью можно переписать вот так:

<pre class='lang-java line-numbers'><code>
public static final String SOME_STRING = "abc";
</code></pre>
С точки зрения кода это будет абсолютно то же самое, но несколько эффективнее.

Переходим к следующему вопросу –

<h2>Сравнение строк</h2>Собственно, все об этом вопросе я уже писал в статье <a href="http://www.skipy.ru/technics/objCompPr.html" rel="nofollow" >Сравнение объектов: практика</a>. И добавить больше нечего. Резюмируя сказаное там – строки надо сравнивать по значению, с использованием метода <strong>equals</strong>. По ссылке их можно сравнивать, но аккуратно, только если точно знаешь, что делаешь. В этом помогает метод <strong>String.intern</strong>.

Единственный момент, который хотелось бы упомянуть – сравнение с литералами. Я часто вижу конструкции типа <strong>str.equals("abc")</strong>. И тут есть небольшие грабли – перед этим сравнением правильно бы было сравнить <strong>str</strong> с <strong>null</strong>, чтобы не получить <strong>NullPointerException</strong>. Т.е. правильной будет конструкция <strong>str != null && str.equals("abc")</strong>. Между тем – ее можно упростить. Достаточно написать всего лишь <strong>"abc".equals(str)</strong>. Проверка на <strong>null</strong> в этом случае не нужна.

На очереди у нас...

<h2>Сложение строк</h2>Строки – единственный объект, для которого определена операция сложения ссылок. Во всяком случае, так было до версии Java 5.0, в которой появился autoboxing/unboxing, но речь сейчас не об этом. Общее описание принципа работы оператора конкатенации можно найти в статье о ссылках, а именно – <a href="http://www.skipy.ru/technics/references.html#concat" rel="nofollow" >тут</a>. Я же хочу затронуть более глубокий уровень.

Представьте себе, представьте себе... Прямо как в песенке про кузнечика. :) Так вот, представьте себе, что нам надо сложить две строки, вернее, к одной прибавить другую:

<pre class='lang-java line-numbers'><code>
String str1 = "abc";
str1 += "def";
</code></pre>
Как происходит сложение? Поскольку объект класса строки неизменяем, то результатом сложения будет новый объект. Итак. Сначала выделяется память, достаточная для того, чтобы вместить туда содержимое обеих строк. В эту память копируется содержимое сначала первой строки, потом второй. Далее переменной str1 присваивается ссылка на новую строку, а старая строка отбрасывается.

Усложним задачу. Пусть у нас есть файл из четырех строк:

<pre class='lang-java line-numbers'><code>
abc
def
ghi
jkl
</code></pre>
Нам надо прочитать эти строки и собрать их в одну. Поступаем по той же схеме.

<pre class='lang-java line-numbers'><code>
BufferedReader br = new BufferedReader(new FileReader("... filename ..."));
String result = "";
while(true){
    String line = br.readLine();
    if (line == null) break;
    result += line;
}
</code></pre>
Вроде пока все хорошо и логично. Давайте разберем, что происходит на нижнем уровне.

Первый проход цикла. <strong>result=""</strong>, <strong>line="abc"</strong>. Выделяется память на 3 символа, туда копируется содержимое <strong>line</strong> – <strong>"abc"</strong>. Переменной <strong>result</strong> присваивается ссылка на новую строку, старая отбрасывается.

Второй проход цикла. <strong>result="abc"</strong>, <strong>line="def"</strong>. Выделяется память на 6 символов, туда копируется содержимое <strong>result</strong> – <strong>"abc"</strong>, затем <strong>line</strong> – <strong>"def"</strong>. Переменной <strong>result</strong> присваивается ссылка на новую строку, старая отбрасывается.

Третий проход цикла. <strong>result="abcdef"</strong>, <strong>line="ghi"</strong>. Выделяется память на 9 символов, туда копируется содержимое <strong>result</strong> – <strong>"abcdef"</strong>, затем <strong>line</strong> – <strong>"ghi"</strong>. Переменной <strong>result</strong> присваивается ссылка на новую строку, старая отбрасывается.

Четвертый проход цикла. <strong>result="abcdefghi"</strong>, <strong>line="jkl"</strong>. Выделяется память на 12 символов, туда копируется содержимое <strong>result</strong> – <strong>"abcdefghi"</strong>, затем <strong>line</strong> – <strong>"jkl"</strong>. Переменной <strong>result</strong> присваивается ссылка на новую строку, старая отбрасывается.

Пятый проход цикла. <strong>result="abcdefghijkl"</strong>, <strong>line=null</strong>. Цикл закончен.

Итак. Три символа "abc" копировались в памяти 4 раза, "def" – 3 раза, "ghi" – 2 раза, "jkl" – один раз. Страшно? Не особо? А вот теперь представьте себе файл с длиной строки 80 символов, в котором где-то 1000 строк. Всего-навсего 80кб. Представили? Что будет в этом случае? первая строка, как нетрудно подсчитать, будет скопирована в памяти 1000 раз, вторая – 999 и т.д. И при средней длине 80 символов через память пройдет ((1000 + 1) * 1000 / 2) * 80 = ... барабанная дробь... 40 040 000 символов, что составляет около 80 Мб (!!!) памяти.

Каков же итог <strong>ТАКОГО</strong> цикла? Чтение 80-килобайтного файла вызвало выделение 80 Мб памяти. Ни много ни мало – в 1000 раз больше, чем полезный объем.

Какой из этого следует сделать вывод? Очень простой. Никогда, запомните – <strong>НИКОГДА</strong> не используйте прямую конкатенацию строк, особенно в циклах. Даже в каком-нибудь методе <strong>toString</strong>, если он вызывается достаточно часто, имеет смысл использовать <strong>StringBuffer</strong> вместо конкатенации. Собственно, компилятор при оптимизации чаще всего так и делает – прямые сложения он выполняет через <strong>StringBuffer</strong>. Однако в случаях, подобных тому, что привел я, оптимизацию компилятор сделать не в состоянии. Что и приводит к весьма печальным последствиям, описаным чуть ниже.

К сожалению, подобные конструкции встречаются слишком часто. Потому я и счел необходитмым заострить на этом внимание.

<em>Собственный опыт

Не могу не вспомнить один эпизод из собственной практики. Один из программистов, работавших со мной, как-то пожаловался, что у него очень медленно работает его код. Он читал достаточно большой файл в HTML формате, после чего производил какие-то манипуляции. И действительно, работало все с черепашьей скоростью. Я взял посмотреть исходник, и обнаружил, что он... использует конкатенацию строк. У него было по 200-250 строк в каждом файле, и при чтении файла около 200Кб через память проходило более 40Мб! В итоге я переписал немного код, заменив операции со строками на операции со StringBuffer-ом. Честно сказать, когда я запустил переписаный код, я подумал, что он просто где-то "упал". Обработка занимала доли секунды. Скорость выросла в 300-800 раз. После этого я коренным образом пересмотрел свое отношение к строковым операциям.</em>

Следующий акт марлезонского балета –

<h2>Выборка подстроки и копирующий конструктор</h2>Представим, что у нас есть строка, из которой надо вырезать подстроку. Вопроса "как это сделать" не стоит – и так понятно. Вопрос в другом – что при этом происходит?

<pre class='lang-java line-numbers'><code>
String str = "abcdefghijklmnopqrstuvwxyz";
str = str.substring(5,10);
</code></pre>
Вроде тривиальный код. И первая мысль такая – выбирается подстрока "efghi", переменной str присваивается ссылка на новую строку, а старый объект отбрасывается. Так? Почти.

Дело в том, что для увеличения скорости при выборке подстроки используется ТОТ ЖЕ МАССИВ, что и в исходной строке. Иначе говоря, мы получим не объект, в котором массив <strong>value</strong> (cм. <a href="http://www.skipy.ru/technics/strings.html#internal" rel="nofollow" >устройство строки</a>) имеет длину 5 и содержит в себе символы 'e', 'f', 'g', 'h' и 'i', count=5 и offset=0. Нет, длина массива будет по-прежнему 26, count=5 и offset=5. И при отбрасывании старой строки массив НЕ ОТБРОСИТСЯ, а по-прежнему будет находиться в памяти, ибо на него есть ссылка из новой строки. И существовать в памяти он будет до того момента, как будет отброшена уже новая строка. Это совсем неочевидный момент, который может привести к проблемам с памятью.

Возникает вопрос – как этого избежать? Ответ – с помощью копирующего конструктора <strong>String(String)</strong>. Дело в том, что в этом конструкторе в явном виде выделяется память под новую строку, и в эту память копируется содержимое исходной. Таким образом, если мы перепишем код так:

<pre class='lang-java line-numbers'><code>
String str = "abcdefghijklmnopqrstuvwxyz";
str = new String(str.substring(5,10));
</code></pre>
..., то длина массива <strong>value</strong> у объекта <strong>str</strong> будет действительно 5, count=5 и offset=0. И это – единственный случай, где оправдано применение копирующего конструктора для строки.

И как финальный аккорд –

<h2>Изменение строки</h2>Это к строке как таковой относится слабо. Я лишь хочу показать тот факт, что строка является неизменяемой только до известной степени. Итак, код.

<pre class='lang-java line-numbers'><code>
package tests;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

/**
 * This application demonstrates how to modify java.lang.String object
 * through reflection API.
 *
 * @version 1.0
 * @author Eugene Matyushkin
 */
public class StringReverseTest {

    /**
     * final static string that should be modified.
     */
    public static final String testString = "abcde";

    public static void main(String[] args) {
        try{
            System.out.println("Initial static final string:  "+testString);
            Field[] fields = testString.getClass().getDeclaredFields();
            Field value = null;
            for(int i=0; i<fields.length; i++){
                Field field = fields[i];
                if (field.getType().equals(char[].class)){
                    value = field;
                    break;
                }
            }
            if (value == null){
                System.err.println("value wasn't found!");
                return;
            }
            value.setAccessible(true);  // 1.
            char[] charValue = (char[])value.get(testString);
            for(int i=0; i<charValue.length/2; i++ ){
                char tmp=charValue[i];
                charValue[i] = charValue[charValue.length-1-i];
                charValue[charValue.length-1-i] = tmp;
            }
            value.set(testString, charValue);
            System.out.print("Reversed static final string: ");
            System.out.println(testString);
        }catch (Throwable th){
            System.err.println("Exception: "+th);
            th.printStackTrace();
        }
    }
}
</code></pre></code>
Что тут происходит? Сначала я ищу поле типа <strong>char[]</strong>. Я мог бы искать и по имени. Однако имя может измениться, а вот тип – сильно сомневаюсь. Далее, я у найденого поля вызываю метод <strong>setAccessible(true)</strong>. Это ключевой момент – я отключаю проверку уровня доступа к полю (иначе я просто не смогу изменить значение, ибо поле <strong>private</strong>). В этом месте я могу получить по голове от менеджера безопасности, который проверяет, разрешено ли такое действие (через вызов <strong>checkPermission(new ReflectPermission("suppressAccessChecks"))</strong>). Если разрешено (а по умолчанию для обычных приложений так и есть) – я могу получить доступ к <strong>private</strong>-полю. Остальное, как говорится, дело техники. В результате я получаю вывод:

<pre class='lang-java line-numbers'><code>
Initial static final string:  abcde
Reversed static final string: edcba
</code></pre>
Что и требовалось доказать. А потому – в реальных приложениях я советую более тщательно подходить к настройке политики безопасности. Иначе может оказаться, что объекты, которые вы считаете гарантированно неизменяемыми, таковыми не являются.

* * *

Наверное, это все, что я хочу рассказать о строках на данный момент. Спасибо за внимание!

<em>Ссылка на первоисточник: <a href="http://www.skipy.ru/technics/strings.html" rel="nofollow" >Ах, эти строки...</a></em>