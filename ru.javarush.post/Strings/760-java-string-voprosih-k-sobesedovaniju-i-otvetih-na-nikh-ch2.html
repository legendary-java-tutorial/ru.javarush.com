Java String. Вопросы к собеседованию и ответы на них, ч.2
<p>----------------------------------------</p>
Напишите функцию для нахождения самого длинного палиндрома в данной строке. Строка может содержать в себе строки-палиндромы, и нахождение самого длинного палиндрома – это вопрос программирования. Ключевым моментом здесь является...
<p>----------------------------------------</p>
К сожалению статья не поместилась одним фрагментом, пришлось разбить её на две части.

<a href='https://javarush.com/groups/posts/759-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch1' target='_blank'><em>Начало смотрите тут</em></a>
<img data-id="eb145e69-1efc-4262-843b-a91fb058c6e8" data-max-width="850" alt="Java String. Вопросы к собеседованию и ответы на них, ч.2 - 1" src="https://cdn.javarush.com/images/article/eb145e69-1efc-4262-843b-a91fb058c6e8/1024.jpeg"><h2>12. Напишите функцию для нахождения самого длинного палиндрома в данной строке</h2>Строка может содержать в себе строки-палиндромы, и нахождение самого длинного палиндрома – это вопрос программирования.

Ключевым моментом здесь является то, что из середины любого палиндрома, если мы пойдем направо и налево на 1 символ, это всегда будет одинаковый символ. К примеру, 12321, середина тут 3, и если мы продолжим движение с текущей позиции в обе стороны, мы получим 2, а затем 1.

Мы используем подобную логику в нашей Java программе для нахождения самого длинного палиндрома. Однако если длина палиндрома четная, длина середины тоже четная, так что мы должны убедиться, что в нашей программе это так же предусмотрено, к примеру, 12333321, тут середина 33, и если мы продолжим движение в обе стороны, мы получим 3, 2 и 1.

В нашей программе мы проходим по полученной строке с серединой на первом месте и проверяем левый и правый символ. Так же мы имеем две глобальные переменные для хранения начальной позиции палиндрома. Нам также необходимо проверить наличие уже найденного более длинного палиндрома, так как мы можем найти несколько палиндромов в данной строке.

Ниже приведен пример программы, которая отлично работает во всех случаях. Мы можем усовершенствовать приведенный код, переместив цикл while в отдельный метод, но я оставил эту часть для вас  . Пожалуйста, дайте мне знать, если у вас есть более удачная реализация, или программа не срабатывает в каком-то случае.

<pre class='lang-java line-numbers'><code>
package com.journaldev.util;
 
public class LongestPalindromeFinder {
 
    public static void main(String[] args) {
        System.out.println(longestPalindromeString("1234"));
        System.out.println(longestPalindromeString("12321"));
        System.out.println(longestPalindromeString("9912321456"));
        System.out.println(longestPalindromeString("9912333321456"));
        System.out.println(longestPalindromeString("12145445499"));
    }
 
    public static String longestPalindromeString(String in) {
        char[] input = in.toCharArray();
        int longestPalindromeStart = 0;
        int longestPalindromeEnd = 0;
 
        for (int mid = 0; mid < input.length; mid++) {
            // для случая нечетного палиндрома как 12321, 3 будет серединой
            int left = mid-1;
            int right = mid+1;
            // нам необходимо двигаться влево и вправо на 1 позицию до конца
            while (left >= 0 && right < input.length) {
                // ниже проверка, является ли это палиндромом
                if (input[left] == input[right]) {
                    // обновление глобальных позиций, только если палиндром длиннее имеющегося
                    if (right - left > longestPalindromeEnd
                            - longestPalindromeStart) {
                        longestPalindromeStart = left;
                        longestPalindromeEnd = right;
                    }
                }
                left--;
                right++;
            }
            // для четного палиндрома у нас должна быть подобная логика с размером середины 2
            // для этого мы начнем на одну позицию правее
            left = mid-1;
            right = mid + 2;// к примеру, для 12333321 мы выбрали 33 в качестве середины
            while (left >= 0 && right < input.length)
            {
                if (input[left] == input[right]) {
                    if (right - left > longestPalindromeEnd
                            - longestPalindromeStart) {
                        longestPalindromeStart = left;
                        longestPalindromeEnd = right;
                    }
                }
                left--;
                right++;
            }
        }
        // теперь у нас есть позиции для самого длинного палиндрома
        return in.substring(longestPalindromeStart, longestPalindromeEnd + 1);
    }
}
</code></pre>
<strong>Программа выведет следующее:</strong>

<pre class='lang-java line-numbers'><code>
1
12321
12321
12333321
454454
</code></pre><h2>13. Какие различия между String, StringBuffer и StringBuilder</h2>Строка является неизменной и финализированной в Java, поэтому все наши манипуляции со строкой всегда будут создавать новую строку.

Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками – <code>StringBuffer</code> и <code>StringBuilder</code>.

<code>StringBuffer</code> и <code>StringBuilder</code> являются изменяемыми классами. Операции с <code>StringBuffer</code> потокобезопасны и синхронизированы, а методы <code>StringBuilder</code> не потокобезопасны. Поэтому когда несколько нитей работают с одной строкой, мы должны использовать <code>StringBuffer</code>, но в однопоточном окужении мы должны использовать <code>StringBuilder</code>.

<code>StringBuilder</code> более производительный, чем <code>StringBuffer</code>, поскольку не обременен синронизацией.
<h2>14. Почему строка неизменная и финализированная в Java</h2>Есть несколько преимуществ в неизменности строк:
<ol>
    <li><p>Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти (heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.</p></li>
    <li><p>Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.</p></li>
    <li><p>Так как строка неизменная, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными нитями. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.</p></li>
    <li><p>Строки используются в Java <code>classloader</code> и неизменность обеспечивает правильность загрузки класса при помощи <code>Classloader</code>. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить <code>java.sql.Connection</code> класс, но значение ссылки изменено на <code>myhacked.Connection</code> класс, который может осуществить нежелательные вещи с вашей базой данных.</p></li>
    <li><p>Поскольку строка неизменная, её <code>hashcode</code> кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в <code>Map</code> и его обработка будет быстрее, чем других ключей <code>HashMap</code>. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа <code>HashMap</code>.</p></li>
</ol><h2>15. Как разделить строку на части?</h2>Мы можем использовать метод <code>split(String regex)</code> для разделения строки на массив строк, используя в качестве разделителя регулярное выражение.

<pre class='lang-java line-numbers'><code>
import java.util.Arrays;

public class JavaSplitString {
    public static void main(String[] args) {
        String line = "I am a java developer";
        String[] words = line.split(" ");
        String[] twoWords = line.split(" ", 2);
        System.out.println("String split with delimiter: "+Arrays.toString(words));
        System.out.println("String split into two: "+Arrays.toString(twoWords));
        //split string delimited with special characters
        String wordsWithNumbers = "I|am|a|java|developer";
        String[] numbers = wordsWithNumbers.split("\\|");
        System.out.println("String split with special character: "+Arrays.toString(numbers));
    }
}
</code></pre>
Метод <code>split(String regex, int numOfStrings)</code> является перегруженным методом для разделения строки на заданное количество строк. Мы можем использовать обратную черту для использования специальных символов регулярных выражений в качестве обычных символов.

Программа выведет следующее:

<pre class='lang-java line-numbers'><code>
String split with delimiter: [I, am, a, java, developer]
String split into two: [I, am a java developer]
String split with special character: [I, am, a, java, developer]
</code></pre><h2>16. Почему массив строк предпочтительнее строки для хранения пароля?</h2>Строка неизменяемая в Java и хранится в пуле строк. С тех пор, как она была создана, она остается в пуле, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, он остается доступным в памяти некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто-либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.

Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности, свойственного строке.
<h2>17. Как вы проверите две строки на подобность в Java?</h2>Есть два способа проверить, являются ли две строки эквивалентными – используя оператор “<code>==</code>”, или используя метод <code>equals</code>. Когда мы используем оператор “<code>==</code>”, он проверяет значение строки, как ссылки, но в программировании большую часть времени мы проверяем эквивалентность строки только для значения. Поэтому мы должны использовать метод equals для проверки двух строк на эквивалентность.

Еще есть метод <code>equalsIgnoreCase</code>, который мы можем использовать для игнорирования регистра.

<pre class='lang-java line-numbers'><code>
String s1 = "abc";
String s2 = "abc";
String s3= new String("abc");
System.out.println("s1 == s2 ? "+(s1==s2)); //true
System.out.println("s1 == s3 ? "+(s1==s3)); //false
System.out.println("s1 equals s3 ? "+(s1.equals(s3))); //true
</code></pre><h2>18. Что такое пул строк?</h2>Как подсказывает название, пул строк – это набор строк, который хранится в памяти Java heap. Мы знаем, что <code>String</code> это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.

Диаграмма ниже объясняет, как пул строк размещается в памяти Java heap и что происходит, когда мы используем различные способы создания строк.
<img data-id="2be3a814-3b0a-4032-bf07-2b3d3e474d25" data-max-width="650" alt="Java String. Вопросы к собеседованию и ответы на них, ч.2 - 2" src="https://cdn.javarush.com/images/article/2be3a814-3b0a-4032-bf07-2b3d3e474d25/1024.jpeg">Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. Пул строк также является примером паттерна Приспособленец (Flyweight).
Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.

Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. Тем не менее, когда мы используем оператор new, мы принуждаем класс <code>String</code> создать новый объект строки, а затем мы можем использовать метод <code>intern()</code> для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект<code>String</code> с таким же значением.

Ниже приведен пример, показывающий работу пула строк.

<pre class='lang-java line-numbers'><code>
public class StringPool {
    public static void main(String[] args) {
        String s1 = "Cat";
        String s2 = "Cat";
        String s3 = new String("Cat");
         
        System.out.println("s1 == s2 :"+(s1==s2));
        System.out.println("s1 == s3 :"+(s1==s3));
    }
}
</code></pre>
<strong>Программа выведет следующее:</strong>

<pre class='lang-java line-numbers'><code>
s1 == s2 :true
s1 == s3 :false
</code></pre><h2>19. Что делает метод intern()?</h2>Когда метод <code>intern()</code> вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом <code>equals(Object)</code>, тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.

Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.

Ниже приведен пример работы метода <code>intern()</code>:

<pre class='lang-java line-numbers'><code>
public class StringPool {
    public static void main(String[] args) {
        String a = "string a";
        String b = new String("string a");
        String c = b.intern();

        System.out.println(a == b);
        System.out.println(b == c);
        System.out.println(a == c);
    }
}</code>
Программа выведет следующее:
<code>false
false
true
</code></pre><h2>20. Являются ли строки потокобезопасными в Java?</h2>Строки являются неизменными, поэтому мы не можем изменить их значение в программе. Следовательно они потокобезопасные и могут благополучно использоваться в мультипоточном окружении.
<h2>21. Почему строка является популярным ключем в HashMap в Java?</h2>Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в <code>Map</code> и они обрабатываются быстрее, чем другие объекты-ключи <code>HashMap</code>. Вот почему строки преимущественно используются в качестве ключей <code>HashMap</code>.

Надеюсь, что вопросы, перечисленные в этой статье помогут вам на собеседованиях, пожалуйста, дайте мне знать, если я что-то пропустил.

<a href='https://www.journaldev.com/1321/java-string-interview-questions-and-answers' rel='nofollow' target='_blank'><em>Ссылка на оригинальную статью</em></a>
<em>Автор: <a href='https://plus.google.com/+PankajKumarJ' rel='nofollow' target='_blank'>Pankaj Kumar</a></em>