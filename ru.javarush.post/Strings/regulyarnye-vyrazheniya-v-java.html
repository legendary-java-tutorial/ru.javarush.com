Регулярные выражения в Java (RegEx)
<p>----------------------------------------</p>
Регулярные выражения — тема, которую программисты, даже опытные, зачастую откладывают на потом. Однако большинству Java-разработчиков рано или поздно придётся столкнуться с обработкой текстовой информации. Чаще всего — с операциями поиска в тексте и редактированием ...
<p>----------------------------------------</p>
<strong>Регулярные выражения</strong> — тема, которую программисты, даже опытные, зачастую откладывают на потом. Однако большинству Java-разработчиков рано или поздно придётся столкнуться с обработкой текстовой информации. Чаще всего — с операциями поиска в тексте и редактированием. Без регулярных выражений продуктивный и компактный программный код, связанный с обработкой текстов, попросту немыслим. Так что хватит откладывать, разберёмся с «регулярками» прямо сейчас. Это не такая уж и сложная задача.<h2>Что такое регулярное выражение RegEx?</h2>На самом деле регулярное выражение (RegEx в Java) – это шаблон для поиска строки в тексте. В Java исходным представлением этого шаблона всегда является строка, то есть объект класса String. Однако не любая строка может быть скомпилирована в регулярное выражение, а только та, которая соответствует правилам написания регулярного выражения – синтаксису, определенному в спецификации языка.

Для написания регулярного выражения используются буквенные и цифровые символы, а также метасимволы – символы, имеющие специальное значение в синтаксисе регулярных выражений. Например:

<pre class="lang-java line-numbers"><code>
String regex = "java"; // шаблон строки "java";
String regex = "\\d{3}"; // шаблон строки из трех цифровых символов;
</code></pre><h2>Создание регулярных выражений в Java</h2>Чтобы создать RegEx в Java, нужно сделать два простых шага:
<ol>
<li>написать его в виде строки с учётом синтаксиса регулярных выражений;</li>
<li>скомпилировать эту строку в регулярное выражение; </li>
</ol>Работа с регулярными выражениями в любой Java-программе начинается с создания объекта класса <code>Pattern</code>. Для этого необходимо вызвать один из двух имеющихся в классе статических методов <code>compile</code>. Первый метод принимает один аргумент – строковый литерал регулярного выражения, а второй – плюс еще параметр, включающий режим сравнения шаблона с текстом:

<pre class="lang-java line-numbers"><code>
public static Pattern compile (String literal)
public static Pattern compile (String literal, int flags)
</code></pre>
<a href="https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#CASE_INSENSITIVE" rel="nofollow" target="_blank">Список</a> возможных значений параметра <code>flags</code> определен в классе <code>Pattern</code> и доступен нам как статические переменные класса. Например: 

<pre class="lang-java line-numbers"><code>
Pattern pattern = Pattern.compile("java", Pattern.CASE_INSENSITIVE);//поиск совпадений с шаблоном будет производиться без учета регистра символов.
</code></pre>
По сути, класс <code>Pattern</code> — это конструктор регулярных выражений. Под «капотом» метод <code>compile</code> вызывает закрытый конструктор класса <code>Pattern</code> для создания скомпилированного представления. Такой способ создания экземпляра шаблона реализован с целью создания его в виде неизменяемого объекта. При создании производится синтаксическая проверка регулярного выражения. При наличии ошибок в строке – генерируется исключение <code>PatternSyntaxException</code>.
<h2>Синтаксис регулярных выражений</h2>Синтаксис регулярных выражений основан на использовании символов <code>&lt;([{\^-=$!|]})?*+.&gt;</code>, которые можно комбинировать с буквенными символами. В зависимости от роли их можно разделить на несколько групп:

<center><em>1. Метасимволы для поиска совпадений границ строк или текста</em></center><table>
<tbody><tr>
<th>Метасимвол
</th>
<th>Назначение
</th>
</tr>
<tr>
<td>^
</td>
<td>начало строки
</td>
</tr>
<tr>
<td>$
</td>
<td>конец строки
</td>
</tr>
<tr>
<td>\b
</td>
<td>граница слова
</td>
</tr>
<tr>
<td>\B
</td>
<td>не граница слова
</td>
</tr>
<tr>
<td>\A
</td>
<td>начало ввода
</td>
</tr>
<tr>
<td>\G
</td>
<td>конец предыдущего совпадения
</td>
</tr>
<tr>
<td>\Z
</td>
<td>конец  ввода
</td>
</tr>
<tr>
<td>\z
</td>
<td>	конец ввода
</td>
</tr>
</tbody></table>
<center><em>2. Метасимволы для поиска символьных классов</em></center><table>
<tbody><tr>
<th>Метасимвол
</th>
<th>Назначение
</th>
</tr>
<tr>
<td>\d
</td>
<td>цифровой символ
</td>
</tr>
<tr>
<td>\D
</td>
<td>нецифровой символ
</td>
</tr>
<tr>
<td>\s
</td>
<td>символ пробела
</td>
</tr>
<tr>
<td>\S
</td>
<td>непробельный символ
</td>
</tr>
<tr>
<td>\w
</td>
<td>буквенно-цифровой символ или знак подчёркивания
</td>
</tr>
<tr>
<td>\W
</td>
<td>любой символ, кроме буквенного, цифрового или знака подчёркивания
</td>
</tr>
<tr>
<td>.
</td>
<td>любой символ
</td>
</tr>
</tbody></table>
<center><em>3. Метасимволы для поиска символов редактирования текста</em></center><table>
<tbody><tr>
<th>Метасимвол
</th>
<th>Назначение
</th>
</tr>
<tr>
<td>\t
</td>
<td>символ табуляции
</td>
</tr>
<tr>
<td>\n
</td>
<td>символ новой строки
</td>
</tr>
<tr>
<td>\r
</td>
<td>символ возврата каретки
</td>
</tr>
<tr>
<td>\f
</td>
<td>переход на новую страницу
</td>
</tr>
<tr>
<td>\u 0085
</td>
<td>символ следующей строки
</td>
</tr>
<tr>
<td>\u 2028
</td>
<td>символ разделения строк
</td>
</tr>
<tr>
<td>\u 2029
</td>
<td>символ разделения абзацев
</td>
</tr>
</tbody></table>
<center><em>4. Метасимволы для группировки символов</em></center><table>
<tbody><tr>
<th>Метасимвол
</th>
<th>Назначение
</th>
</tr>
<tr>
<td>[абв]
</td>
<td>любой из перечисленных (а,б, или в)
</td>
</tr>
<tr>
<td>[^абв]
</td>
<td>любой, кроме перечисленных (не а,б, в)
</td>
</tr>
<tr>
<td>[a-zA-Z]
</td>
<td>слияние диапазонов (латинские символы от a до z без учета регистра )
</td>
</tr>
<tr>
<td>[a-d[m-p]]	
</td>
<td>объединение символов (от a до d и от m до p)
</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[def]]
</td>
<td>пересечение символов (символы d,e,f)
</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^bc]]
</td>
<td>вычитание символов (символы a, d-z)
</td>
</tr>
</tbody></table>
<center><em>5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов.</em></center><table>
<tbody><tr>
<th>Метасимвол
</th>
<th>Назначение
</th>
</tr>
<tr>
<td>?
</td>
<td>один или отсутствует
</td>
</tr>
<tr>
<td>*
</td>
<td>ноль или более раз
</td>
</tr>
<tr>
<td>+
</td>
<td>один или более раз
</td>
</tr>
<tr>
<td>{n}
</td>
<td>n раз
</td>
</tr>
<tr>
<td>{n,}
</td>
<td>n раз и более
</td>
</tr>
<tr>
<td>{n,m}
</td>
<td>не менее n раз и не более m раз
</td>
</tr>	
</tbody></table><h2>Жадный режим квантификатора</h2>Особенностью квантификаторов является возможность использования их в разных режимах: жадном, сверхжадном и ленивом. <strong>Сверхжадный режим</strong> включается добавлением символа «<code>+</code>» после квантификатора, а ленивый – символа «<code>?</code>». Например:

<pre class="lang-java line-numbers"><code>
"А.+а" // жадный режим
"А.++а" // сверхжадный режим
"А.+?а" // ленивый режим
</code></pre>
Попробуем на примере этого шаблона разобраться в работе квантификаторов в различных режимах. 

По умолчанию квантификатор работает в жадном режиме. Это означает, что он ищет максимально длинное совпадение в строке. В результате выполнения этого кода:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
    String text = "Егор Алла Александр";
    Pattern pattern = Pattern.compile("А.+а");
    Matcher matcher = pattern.matcher(text);
    while (matcher.find()) {
        System.out.println(text.substring(matcher.start(), matcher.end()));
    }
}
</code></pre>
<strong>мы получим такой вывод:

<em>Алла Алекса</em></strong>

Алгоритм поиска по заданному шаблону "<code>А.+а</code>", выполняется в следующей последовательности:
<ol>
<li><p>В заданном шаблоне первый символ – это русский символ буквы <code>А</code>. <code>Matcher</code> сопоставляет его с каждым символом текста, начиная с нулевой позиции. На нулевой позиции в нашем тексте находиться символ <code>Е</code>, поэтому <code>Matcher</code> перебирает последовательно символы в тексте, пока не встретит совпадение с шаблоном. В нашем примере это символ на позиции №5.</p>
<img data-id="025a11b5-cffb-4158-9838-a50ff1659893" data-max-width="850" alt="Регулярные выражения в Java - 2" src="https://cdn.javarush.com/images/article/025a11b5-cffb-4158-9838-a50ff1659893/1024.jpeg"></li>
<li><p>После того, как найдено совпадение с первым символом шаблона, <code>Matcher</code> сверяет соответствие со вторым символом шаблона. В нашем случае это символ «<code>.</code>», который обозначает любой символ.</p>
<img data-id="d5995c0d-e88a-4627-845e-6cd3081289e0" data-max-width="850" alt="Регулярные выражения в Java - 3" src="https://cdn.javarush.com/images/article/d5995c0d-e88a-4627-845e-6cd3081289e0/1024.jpeg">
<p>На шестой позиции – символ буквы <code>л</code>. Разумеется, он соответствует шаблону «любой символ».</p></li>
<li><p><code>Matcher</code> переходит к проверке следующего символа из шаблона. В нашем шаблоне он задан с помощью квантификатора «<code>.+</code>». Поскольку количество повторений «любого символа» в шаблоне – один и более раз, <code>Matcher</code> берет по очереди следующий символ из строки и проверяет его на соответствие шаблону, до тех пор, пока будет выполняться условие «любой символ», в нашем примере – до конца строки (с поз. №7 -№18 текста).</p>
<img data-id="2880ac59-56a2-42c9-b6d3-285241d3e3db" data-max-width="850" alt="Регулярные выражения в Java - 4" src="https://cdn.javarush.com/images/article/2880ac59-56a2-42c9-b6d3-285241d3e3db/1024.jpeg">
<p>По сути, <code>Matcher</code>, захватывает все строку до конца – в этом как раз и проявляется его «жадность». </p></li>
<li><p>После того как <code>Matcher</code> дошел до конца текста и закончил проверку для части шаблона «<code>А.+</code>», Matcher начинает проверку для оставшейся части шаблона – символ буквы <code>а</code>. Так как текст в прямом направлении закончился, проверка происходит в обратном направлении, начиная с последнего символа:</p>
<img data-id="4edc0442-3476-4827-8b0a-f60944f030c9" data-max-width="850" alt="Регулярные выражения в Java - 5" src="https://cdn.javarush.com/images/article/4edc0442-3476-4827-8b0a-f60944f030c9/1024.jpeg"></li>
<li><p><code>Matcher</code> «помнит» количество повторений в шаблоне «<code>.+</code>» при котором он дошел до конца текста, поэтому он уменьшает количество повторений на единицу и проверяет соответствие шаблона тексту, до тех пор пока не будет найдено совпадение:
<img data-id="f7c55fca-83fb-4292-9485-fe9aa7449f50" data-max-width="850" alt="Регулярные выражения в Java - 6" src="https://cdn.javarush.com/images/article/f7c55fca-83fb-4292-9485-fe9aa7449f50/1024.jpeg"></p></li></ol><h2>Сверхжадный режим квантификатора</h2>В сверхжадном режиме работа матчера аналогична механизму жадного режима. Отличие состоит в том, что при захватывании текста до конца строки поиск в обратном направлении не происходит. То есть первые три этапа при сверхжадном режиме будут аналогичны жадному режиму. После захвата всей строки матчер добавляет остаток шаблона и сравнивает с захваченной строкой. В нашем примере при выполнении метода main с шаблоном "<code>А.++а</code>" совпадений не будет найдено.
<img data-id="43a0e49c-8e25-470c-bd80-1396334cb9a4" data-max-width="850" alt="Регулярные выражения в Java - 7" src="https://cdn.javarush.com/images/article/43a0e49c-8e25-470c-bd80-1396334cb9a4/1024.jpeg"> 
<h2>Ленивый режим квантификатора</h2><ol>
<li><p>В этом режиме на начальном этапе, как и в жадном режиме, ищется совпадение с первым символом шаблона:</p>
<img data-id="2e7f79db-6eba-464e-a3d0-f988ad46bd40" data-max-width="850" alt="Регулярные выражения в Java - 8" src="https://cdn.javarush.com/images/article/2e7f79db-6eba-464e-a3d0-f988ad46bd40/1024.jpeg"></li>
<li><p>Далее ищется совпадение со следующим символом шаблона – любым символом:</p>
<img data-id="e3046c84-473b-44d4-9873-a87e6fcb6a35" data-max-width="850" alt="Регулярные выражения в Java - 9" src="https://cdn.javarush.com/images/article/e3046c84-473b-44d4-9873-a87e6fcb6a35/1024.jpeg"></li>
<li><p>В отличие от жадного режима, в ленивом ищется самое короткое совпадение в тексте, поэтому после нахождения совпадения со вторым символом шаблона, который задан точкой и соответствует символу на позиции №6 текста, <code>Matcher</code> будет проверять соответствие текста остатку шаблона – символу «<code>а</code>»</p>
<img data-id="b24fe49e-ab84-4884-be09-f0599628a10b" data-max-width="850" alt="Регулярные выражения в Java - 10" src="https://cdn.javarush.com/images/article/b24fe49e-ab84-4884-be09-f0599628a10b/1024.jpeg"></li>
<li><p>Поскольку совпадение с шаблоном в тексте не найдено (на позиции №7 в тексте находится символ «<code>л</code>»), <code>Matcher</code> добавляет еще один «любой символ» в шаблоне, так как он задан как один и более раз, и опять сравнивает шаблон с текстом на позициях с №5 по №8:</p>
<img data-id="13543dd7-56bd-46d9-b466-d6e955b811e3" data-max-width="850" alt="Регулярные выражения в Java - 11" src="https://cdn.javarush.com/images/article/13543dd7-56bd-46d9-b466-d6e955b811e3/1024.jpeg"></li>
<li><p>В нашем случае найдено совпадение, но конец текста ещё не достигнут. Поэтому с позиции №9 проверка начинается с поиска первого символа шаблона по аналогичному алгоритму и далее повторяется вплоть до окончания текста.</p>
<img data-id="d77ca7c4-9281-4750-9199-800aff1130b0" data-max-width="850" alt="Регулярные выражения в Java - 12" src="https://cdn.javarush.com/images/article/d77ca7c4-9281-4750-9199-800aff1130b0/1024.jpeg"></li></ol>В результате работы метода <code>main</code> при использовании шаблона "<code>А.+?а</code>" мы получим следующий результат:

<em>Алла
Алекса</em>

Как видно из нашего примера, при использовании разных режимов квантификатора для одного и того же шаблона мы получили разные результаты. Поэтому необходимо учитывать эту особенность и выбирать нужный режим в зависимости от желаемого результата при поиске.

<div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><h2>Экранирование символов в регулярных выражениях</h2>Поскольку регулярное выражение в Java, а точнее — его исходное представление задается с помощью строкового литерала, необходимо учитывать те правила спецификации Java, которые касаются строковых литералов. В частности, символ обратной косой черты «<code>\</code>» в строковых литералах в исходном коде Java интерпретируется как символ управляющей последовательности, который предупреждает компилятор, что следующий за ним символ — специальный и что его нужно особым образом интерпретировать. Например: 

<pre class="lang-java line-numbers"><code>
String s = "The root directory is \nWindows";//перенос Windows на новую строку
String s = "The root directory is \u00A7Windows";//вставка символа параграфа перед Windows
</code></pre>
Поэтому в строковых литералах, которые описывают регулярное выражение, и используют символ «<code>\</code>» (например, для метасимволов) <strong>его нужно удваивать</strong>, чтобы компилятор байт-кода Java не интерпретировал его по-своему. Например:  

<pre class="lang-java line-numbers"><code>
String regex = "\\s"; // шаблон для поиска символов пробела
String regex = "\"Windows\""; // шаблон для поиска строки "Windows"
</code></pre>
Двойной символ обратной косой черты также следует использовать для экранирования символов, задействованных в качестве специальных, если мы планируем их использовать как «обычные» символы. Например: 

<pre class="lang-java line-numbers"><code>
String regex = "How\\?"; // шаблон для поиска строки “How?”
</code></pre><h2>Методы класса Pattern</h2>В классе <code>Pattern</code> есть и другие методы для работы с регулярными выражениями:

<code><strong>String pattern()</strong></code> – возвращает исходное строковое представление регулярного выражения, из которого был создан объект <code>Pattern</code>:

<pre class="lang-java line-numbers"><code>
Pattern pattern = Pattern.compile("abc");
System.out.println(Pattern.pattern())//"abc"
</code></pre>
<code><strong>static boolean matches(String regex, CharSequence input)</strong></code> – позволяет проверить регулярное выражение, переданное в параметре regex на соответствие тексту, переданному в параметре <code>input</code>. Возвращает:

<em>true</em> – если текст соответствует шаблону;
<em>false</em> – в противном случае;

Пример:

<pre class="lang-java line-numbers"><code>
System.out.println(Pattern.matches("А.+а","Алла"));//true
System.out.println(Pattern.matches("А.+а","Егор Алла Александр"));//false
</code></pre>
<code><strong>int flags()</strong></code> – возвращает значения параметра <code>flags</code> шаблона, которые были установлены при его создании, или 0, если этот параметр не был установлен. Пример:

<pre class="lang-java line-numbers"><code>
Pattern pattern = Pattern.compile("abc");
System.out.println(pattern.flags());// 0
Pattern pattern = Pattern.compile("abc",Pattern.CASE_INSENSITIVE);
System.out.println(pattern.flags());// 2
</code></pre>
<code><strong>String[] split(CharSequence text, int limit)</strong></code> – разбивает текст, переданный в качестве параметра на массив элементов <code>String</code>. Параметр <code>limit</code> определяет предельное количество совпадений, которое ищется в тексте:
<ul>
<li>при <code>limit&gt;0</code> – выполняется поиск <code>limit-1</code> совпадений; </li>
<li>при <code>limit&lt;0</code> – выполняется поиск всех совпадений в тексте</li>
<li>при <code>limit=0</code> – выполняется поиск всех совпадений в тексте, при этом пустые строки в конце массива отбрасываются;</li></ul>Пример:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
    String text = "Егор Алла Анна";
    Pattern pattern = Pattern.compile("\\s");
    String[] strings = pattern.split(text,2);
    for (String s : strings) {
        System.out.println(s);
    }
    System.out.println("---------");
    String[] strings1 = pattern.split(text);
    for (String s : strings1) {
        System.out.println(s);
    }
}
</code></pre>
Вывод на консоль:

<em>Егор
Алла Анна
--------
Егор
Алла
Анна</em>

Еще один метод класса для создания объекта <code>Matcher</code> рассмотрим ниже.
<h2>Методы класса Matcher</h2><code>Matcher</code> представляет собой класс, из которого создается объект для поиска совпадений по шаблону. <code>Matcher</code> – это «поисковик», «движок» регулярных выражений. Для поиска ему надо дать две вещи: шаблон поиска и «адрес», по которому искать. Для создания объекта <code>Matcher</code> предусмотрен следующий метод в классе <code>Pattern</code>:

<code><strong>рublic Matcher matcher(CharSequence input)</strong></code>

В качестве аргумента метод принимает последовательность символов, в котором будет производиться поиск. Это объекты классов, реализующих интерфейс <code>CharSequence</code>. в качестве аргумента можно передать не только <code>String</code>, но и <code>StringBuffer</code>, <code>StringBuilder</code>, <code>Segment</code> и <code>CharBuffer</code>.

Шаблоном для поиска является объект класса <code>Pattern</code>, на котором вызывается метод <code>matcher</code>.

Пример создания матчера:

<pre class="lang-java line-numbers"><code>
Pattern p = Pattern.compile("a*b");// скомпилировали регулярное выражение в представление
Matcher m = p.matcher("aaaaab");//создали поисковик в тексте “aaaaab” по шаблону "a*b"
</code></pre>
Теперь с помощью нашего «поисковика» мы можем искать совпадения, узнавать позицию совпадения в тексте, заменять текст с помощью методов класса.

Метод <code><strong>boolean find()</strong></code> ищет очередное совпадение в тексте с шаблоном. С помощью этого метода и оператора цикла можно производить анализ всего текста по событийной модели (осуществлять необходимые операции при наступлении события – нахождении совпадения в тексте). Например, с помощью методов этого класса <code><strong>int start()</strong></code> и <code><strong>int end()</strong></code> можно определять позиции совпадения в тексте, а с помощью методов <code><strong>String replaceFirst(String replacement)</strong></code> и <code><strong>String replaceAll(String replacement)</strong></code> заменять в тексте совпадения на другой текст replacement. 

Пример:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
    String text = "Егор Алла Анна";
    Pattern pattern = Pattern.compile("А.+?а");

    Matcher matcher = pattern.matcher(text);
    while (matcher.find()) {
        int start=matcher.start();
        int end=matcher.end();
        System.out.println("Найдено совпадение " + text.substring(start,end) + " с "+ start + " по " + (end-1) + " позицию");
    }
    System.out.println(matcher.replaceFirst("Ира"));
    System.out.println(matcher.replaceAll("Ольга"));
    System.out.println(text);
}
</code></pre>
Вывод программы:

<em>Найдено совпадение Алла с 5 по 8 позицию
Найдено совпадение Анна с 10 по 13 позицию
Егор Ира Анна
Егор Ольга Ольга
Егор Алла Анна</em>

Из примера видно, что методы <code>replaceFirst</code> и <code>replaceAll</code> создают новый объект <code>String</code> – строку, представляющую собой исходный текст, в котором совпадения с шаблоном заменены на текст, переданный методу в качестве аргумента. Причём метод <code>replaceFirst</code> заменяет только первое совпадение, а <code>replaceAll</code> – все совпадения в тесте. Исходный текст остается без изменений.

Использование других методов класса <code>Matcher</code>, а также примеры регулярных выражений можно посмотреть в этом цикле <a href="https://javarush.com/groups/posts/186-reguljarnihe-vihrazhenija-v-java-chastjh-3" target="_blank">статей</a>.

Наиболее частые операции с регулярными выражениями при работе с текстом из классов <code>Pattern</code> и <code>Matcher</code> встроены в класс <code>String</code>. Это такие методы как <code>split</code>, <code>matches</code>, <code>replaceFirst</code>, <code>replaceAll</code>. Но на самом деле «под капотом» они используют классы <code>Pattern</code> и <code>Matcher</code>. Поэтому, если вам нужно заменить текст или сравнить строки в программе без написания лишнего кода, используйте методы класса <code>String</code>. Если же вам нужны расширенные возможности – вспомните о классах <code>Pattern</code> и <code>Matcher</code>.
<h2>Заключение</h2>Регулярное выражение описывается в Java-программе с помощью строк, подходящих под определённый правилами шаблон. При выполнении кода Java перекомпилирует эту строку в объект класс <code>Pattern</code> и использует объект класса <code>Matcher</code> для поиска соответствий в тексте. Как я уже говорил в начале, регулярные выражения очень часто откладывают на потом, считая сложной темой. Однако если разобраться с основами синтаксиса, метасимволами, экранированием и изучить примеры регулярных выражений, они оказываются гораздо проще, чем кажутся на первый взгляд.