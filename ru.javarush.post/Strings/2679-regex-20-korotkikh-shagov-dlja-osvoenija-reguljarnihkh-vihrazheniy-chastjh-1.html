RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1
<p>----------------------------------------</p>
Не так давно я нашел на одном англоязычном сайте замечательную, на мой взгляд, статью, которая помогает довольно быстро научиться ориентироваться в регулярных выражениях (regex). Эта статья...
<p>----------------------------------------</p>
Оригинал этой статьи <a href="https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc" target="_blank" rel="nofollow">здесь</a>.

Наверное, теории много не бывает, и я приведу несколько ссылок на более подробный материал по regex в конце статьи. Но, мне показалось, что начинать вникать в такую тему как регулярные выражения будет гораздо интереснее, если есть возможность заниматься не только зубрежкой, но и сразу закреплять знания, выполняя небольшие задания по ходу обучения.
<img data-max-width="800" data-id="f577e156-e0bd-46ae-84b7-11f57c6204c1" src="/images/article/f577e156-e0bd-46ae-84b7-11f57c6204c1/800.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1 - 1">Пожалуй приступим.

Обычно противники использования регулярных выражений ('RegEx' или просто 'regex') в программировании приводят следующую цитату, приписываемую Джейми Завински:

<strong>"Некоторые люди, сталкиваясь с проблемой, думают: "Я знаю, я буду использовать регулярные выражения". Теперь у них две проблемы".</strong>

На самом деле, использование регулярных выражений еще не является хорошей или плохой идеей. И это само по себе не добавит проблем и не решит ни одну из них. Это всего-лишь инструмент. И то, как вы его используете (правильно или неправильно), определяет, какие результаты вы увидите. 

Если вы попытаетесь использовать regex, например, для создания HTML-парсера, то вы, скорее всего, <a href="https://www.cyberforum.ru/blogs/437401/blog4280.html" target="_blank" rel="nofollow">испытаете боль</a>. Но если вы хотите просто извлечь, например, временные метки из некоторых строк, у вас, вероятно, будет все в порядке.

Чтобы облегчить вам освоение регулярных выражений, я собрал этот урок, который поможет вам с нуля овладеть регулярными выражениями всего за двадцать коротких шагов. Это руководство в основном фокусируется на основных понятиях регулярных выражений и углубляется в более сложные темы только по мере необходимости.
<h2>Шаг 1: для чего нужно использовать регулярные выражения</h2><img data-max-width="512" data-id="773456e3-7996-4bbb-846e-b2e6dd0ae6e6" src="/images/article/773456e3-7996-4bbb-846e-b2e6dd0ae6e6/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1 - 2">Регулярные выражения используются для поиска совпадений в тексте по заданным шаблонам (образцам).

При помощи regex мы можем легко и просто извлекать <s>изюм из кекса</s> слова из текста, а также отдельные литеральные (буквальные) и мета (специальные) символы и их последовательности, отвечающие определенным критериям.

Вот что говорит нам о них <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F" target="_blank" rel="nofollow">Википедия:</a>
<em>Регуля́рные выраже́ния (англ. regular expressions) — формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (символов-джокеров, англ. wildcard characters). 
Для поиска используется строка-образец (англ. pattern, по-русски её часто называют "шаблоном", "маской"), состоящая из символов и метасимволов и задающая правило поиска. Для манипуляций с текстом дополнительно задаётся строка замены, которая также может содержать в себе специальные символы.</em>

Шаблон может быть таким-же простым, как, например, слово <code>dog</code> в этом предложении:

<pre>The quick brown fox jumps over the lazy dog.</pre>
Это регулярное выражение выглядит так:

<pre>dog</pre>
... Достаточно легко, неправда-ли?
Образцом может быть также любое слово, которое содержит букву <code>o</code>. 

Регулярное выражение для поиска такого шаблона может выглядеть так:

<pre>\w<span>*</span>o\w<span>*</span></pre>
(<a href="https://regex101.com/r/Mf9L3O/2" target="_blank" rel="nofollow">Опробовать это регулярное выражение можно здесь</a>),

Можно заметить, что по мере усложнения требований к "соответствию", регулярное выражение также усложняется. 

Существуют дополнительные формы записи для указания групп символов и соответствия повторяющимся шаблонам, что я объясню ниже. Но, как только мы находим соответствие шаблону в каком-то тексте, то что-же мы можем с ним делать? 

Современные движки регулярных выражений позволяют извлекать символы или их последовательности (подстроки) из содержащегося текста, или удалять их, или заменять их другим текстом. В общем, регулярные выражения используются для разбора и манипулирования текстом.

Мы можем извлечь, например, подстроки, которые выглядят как IP-адреса, а затем попытаться проверить их. Или мы можем извлечь имена и адреса электронной почты и сохранить их в базе данных. Или использовать регулярные выражения, чтобы найти конфиденциальную информацию 
(например, номера паспортов или номера телефонов) в электронных письмах и предупредить пользователя о том, что он может подвергнуть себя риску. Regex действительно универсальный инструмент, который легко выучить, но трудно освоить:

<strong>"Точно так же, как есть разница между хорошим исполнением музыкального произведения и созданием музыки, есть и разница между знанием регулярных выражений и их пониманием".</strong>

<em>- Джеффри Э. Ф. Фридл, Освоение регулярных выражений</em>
<h2>Шаг 2: квадратные скобки <code>[]</code></h2>Простейшие регулярные выражения, которые легко понять - это те, которые всего-лишь ищут соответствие по-символьно между шаблоном регулярного выражения и целевой строкой.

Давайте, например, попробуем найти кота:
<img data-max-width="512" data-id="7a4171fb-4cc7-4339-ae00-a4ba6db13f6d" src="/images/article/7a4171fb-4cc7-4339-ae00-a4ba6db13f6d/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1 - 3"><pre>pattern: <span>cat</span>
string:  The cat was cut when it ran under the car.
matches:     <span>^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/4" target="_blank" rel="nofollow">Как это работает в деле - смотрите здесь</a>)
<mark>NB!</mark> <em>Все решения представлены здесь только как варианты решений. В регулярных выражениях, как и в программировании вообще, можно решать одни и те же задачи разными способами.</em>

Однако, кроме строгого по-символьного сравнения, мы также можем указать альтернативные совпадения, используя квадратные скобки:

<pre>pattern: <span>ca[rt]</span>
string:  The cat was cut when it ran under the car.
matches:     <span>^^^             		           ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/5" target="_blank" rel="nofollow">Как это работает</a>)

Открывающие и закрывающие квадратные скобки сообщают механизму регулярных выражений, что он должен искать любой из указанных символов, но только один. Вышеуказанное регулярное выражение не найдет, например, слово <code>cart</code> целиком, а найдет только его часть:

<pre>pattern: <span>ca[rt]</span>
string:  The cat was cut when it ran under the cart.
matches:     <span>^^^                               ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/6" target="_blank" rel="nofollow">Как это работает</a>)

Когда вы используете квадратные скобки, вы указываете механизму регулярных выражений, чтобы он искал совпадения только с одним из символов, содержащихся в скобках. Движок находит символ <code>c</code>, потом символ <code>a</code>, но если следующий символ не <code>r</code> или <code>t</code>, то это еще не полное совпадение. 

Если он находит <code>ca</code>, а затем либо <code>r</code>, либо <code>t</code>, он останавливается. Он не будет пытаться сопоставить больше символов, потому что квадратные скобки указывают, что нужно искать только один из содержащихся символов. Когда он находит <code>ca</code>, то следующим находит <code>r</code> в слове <code>cart</code>, и останавливается, потому что он уже нашел совпадение последовательности <code>car</code>.
<h2>Задачи для тренировки:</h2>Напишите регулярное выражение, которое находит все 10 совпадений с шаблонами <code>had</code> и <code>Had</code> в этом отрывке непереводимой игры слов на местном диалекте:

<pre>pattern:
string:  Jim, where Bill had had <span>"had"</span>, had had <span>"had had"</span>. <span>"Had had"</span> had been correct.
matches:                 <span>^^^ ^^^  ^^^   ^^^ ^^^  ^^^ ^^^    ^^^ ^^^  ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/7" target="_blank" rel="nofollow">Смотрите возможное решение здесь</a>)

А как насчет всех названий животных в следующем предложении?

<pre>pattern:
string:  A bat, a cat, <span>and</span> a rat walked into a bar...
matches:   <span>^^^    ^^^        ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/8" target="_blank" rel="nofollow">Возможное решение</a>)

Или еще проще: найдите слова <code>bar</code> или <code>bat</code>:

<pre>pattern:
string:  A bat, a cat, <span>and</span> a rat walked into a bar...
matches:   <span>^^^                                 ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/9" target="_blank" rel="nofollow">Возможное решение</a>)

Вот мы уже и научились писать более-менее сложные регулярные выражения, и мы только на шаге 2! Продолжаем!
<h2>Шаг 3: escape-последовательности</h2><img data-max-width="512" data-id="435e664f-6244-4666-8b7d-276fcc0c5ae3" src="/images/article/435e664f-6244-4666-8b7d-276fcc0c5ae3/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1 - 4">На предыдущем шаге мы узнали о квадратных скобках <code>[]</code> и о том, как они помогают нам найти альтернативные совпадения при помощи движка regex. 

А что если мы хотим найти совпадения в виде самих открытых и закрытых квадратных скобок <code>[]</code>?

Когда мы хотели найти по-символьное совпадение со словом <code>cat</code>, то мы предоставляли движку regex эту последовательность символов (<code>cat</code>).

Давайте попробуем найти квадратные скобки <code>[]</code> таким же способом:

<pre>pattern: <span>[]</span>
string:  You can<span>'t match [] using regex! You will regret this!
matches:</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/10" target="_blank" rel="nofollow">Смотрим что получилось</a>)
 
Что-то не сработало, однако... Это происходит потому, что символы квадратной скобки работают как специальные символы движка regex, которые обычно используются для обозначения чего-то иного, и не являются буквальным шаблоном для поиска их самих. Как мы помним из шага 2, они используются для поиска альтернативных совпадений, чтобы движок regex мог найти соответствия любому из символов, содержащихся между ними. 

Если вы не поместите никаких символов между ними, это может привести к ошибке.

Чтобы найти соответствия этим особым символам, мы должны экранировать их, поставив перед ними символ backslash <code>\</code>. Backslash (или обратный слэш) это еще один специальный символ, который сообщает движку regex что надо искать следующий символ буквально, а не использовать его как метасимвол. Движок regex будет искать символы <code>[</code> и <code>]</code> буквально, только если им <strong>обоим</strong> будет предшествовать обратный слэш:

<pre>pattern: <span>\[\]</span>
string:  You can't match [] using regex! You will regret this!
matches:                 <span>^^</span> 
</pre>
(<a href="https://regex101.com/r/Mf9L3O/11" target="_blank" rel="nofollow">Смотрим что получилось на этот раз</a>)

ОК, а если мы хотим найти сам обратный слэш? Ответ прост. Поскольку backslash <code>\</code> тоже является специальным символом, то его тоже нужно экранировать.

Чем? Обратным слэшем же!

<pre>pattern: <span>\\</span>
string:  C:\Users\Tanja\Pictures\Dogs
matches:   <span>^     ^     ^        ^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/12" target="_blank" rel="nofollow">Этот же пример на деле</a>)

Только специальным символам должен предшествовать backslash. Все остальные символы интерпретируются буквально по умолчанию. Например, регулярное выражение <code>t</code> буквально соответствует только букве <code>t</code> в нижнем регистре:

<pre>pattern: <span>t</span>
string:  t  t   t   t
matches: <span>^  ^   ^   ^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/14" target="_blank" rel="nofollow">Пример</a>)

Однако, такая последовательность как <code>\t</code> работает иначе. Она представляет из себя шаблон для поиска символа табуляции:

<pre>pattern: <span>\t</span>
string:  t  t   t   t
matches:  <span>^  ^   ^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/13" target="_blank" rel="nofollow">Пример</a>)

Некоторые распространенные escape-последовательности включают в себя <code>\n</code> (разрывы строк в стиле UNIX) и <code>\r</code> (используются в разрывах строк в стиле Windows, <code>\r\n</code>). <code>\r</code> является символом "возврата каретки", а <code>\n</code> является символом "перевода строки", <a href="https://stackoverflow.com/q/3091524/2925434" target="_blank" rel="nofollow"> оба из которых были определены вместе со стандартом ASCII, когда телетайпы еще находились в повсеместном использовании.</a>

Другие распространенные escape-последовательности будут рассмотрены в этом руководстве позже.
<h2>А пока закрепим материал парой несложных задачек:</h2>Попробуйте написать регулярное выражение для поиска... регулярного выражения ;) Результат должен быть примерно таким:

<pre>pattern:
string:  ...match this regex `<span>\[\]</span>` with a regex?
matches:                      <span>^^^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/15" target="_blank" rel="nofollow">Решение</a>)

Справились? Молодцы! А теперь попробуйте создать regex для поиска таких escape-последовательностей:

<pre>pattern:
string:  `<span>\r</span>`, `<span>\t</span>`, and `<span>\n</span>` are all regex escape sequences.
matches:  <span>^^    ^^        ^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/16" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 4: ищем "any" (любой) символ при помощи точки <code>.</code></h2><img data-max-width="512" data-id="ffc5a944-84f0-4c0a-9bf2-ea0d3edca059" src="/images/article/ffc5a944-84f0-4c0a-9bf2-ea0d3edca059/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1 - 5">При написании решений для поиска escape-последовательностей, которые мы видели на предыдущем шаге, вы, возможно, задавались вопросом: "Могу ли я сопоставить символ обратной косой черты, а затем любой другой символ, следующий за ним?"... Конечно можете!

Есть еще один специальный символ, который используется для поиска соответствия (почти) любому символу - это символ точки (полной остановки). Вот что он делает:

<pre>pattern: <span>.</span>
string:  I'm sorry, Dave. I'm afraid I can't do that.
matches: <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/17" target="_blank" rel="nofollow">Пример</a>)

Если-же вы хотите сопоставить только шаблоны, которые выглядят как escape-последовательности, вы можете сделать что-то вроде этого:

<pre>pattern: <span>\\.</span>
string:  Hi Walmart is my grandson there his name is "<span>\n \r \t</span>".
matches: <span>                                             ^^ ^^ ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/18" target="_blank" rel="nofollow">Пример</a>)

И, как и со всеми специальными символами, если вы хотите сопоставить литерал<code>.</code>, то вам нужно поставить перед ним символ <code>\</code>:

<pre>pattern: <span>\.</span>
string:  War is Peace<span>.</span> Freedom is Slavery<span>.</span> Ignorance is Strength<span>.</span>
matches: <span>            ^                   ^                      ^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/19" target="_blank" rel="nofollow">Пример</a>)
<h2>Шаг 5: диапазоны символов</h2><img data-max-width="512" data-id="40e651ab-d0c3-4d5c-9826-d023a78891dc" src="/images/article/40e651ab-d0c3-4d5c-9826-d023a78891dc/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1 - 6">Что если вам нужны не любые символы, а вы хотите найти в тексте только буквы? Или цифры? Или гласные? 

Поиск по классам символов и их диапазонам позволит нам достичь этого.

<pre>`<span>\n</span>`, `<span>\r</span>`, and `<span>\t</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.	
</pre>
Символы являются "пробелами", <a href="https://en.wikipedia.org/wiki/Whitespace_character" target="_blank" rel="nofollow">если они не создают видимой отметки в тексте.</a>

Пробел "<code> </code>" - это пробел, разрыв строки или табуляция. Предположим, мы хотим найти escape-последовательности, представляющие только пробельные символы <code>\n</code>, <code>\r</code> и <code>\t</code> в приведенном выше отрывке, но не другие escape-последовательности. Как мы могли-бы это сделать?

<pre>pattern: <span>\\[nrt]</span>
string:  `<span>\n</span>`, `<span>\r</span>`, and `<span>\t</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.
matches:  <span>^^    ^^        ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/20" target="_blank" rel="nofollow">Пример</a>)

Это работает, но это не очень элегантное решение. Что, если позже нам нужно будет сопоставить escape-последовательность для символа "подача формы", <code>\f</code>? (Этот символ используется для обозначения разрывов страниц в тексте.)

<pre>pattern: <span>\\[nrt]</span>
string:  `<span>\n</span>`, `<span>\r</span>`, `<span>\t</span>`, and `<span>\f</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.
matches:  <span>^^    ^^    ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/38" target="_blank" rel="nofollow">Нерабочее решение</a>)

При таком подходе нам нужно отдельно перечислять каждую строчную букву, которую мы хотим сопоставить, в квадратных скобках. Более простой способ сделать это - использовать диапазоны символов для соответствия любой строчной букве:

<pre>pattern: <span>\\[a-z]</span>
string:  `<span>\n</span>`, `<span>\r</span>`, `<span>\t</span>`, and `<span>\f</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.
matches:  <span>^^    ^^    ^^        ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/39" target="_blank" rel="nofollow">А так уже работает</a>)

Диапазоны символов работают так, как вы могли бы ожидать, учитывая приведенный выше пример. Поместите в квадратные скобки первую и последнюю буквы, которые вы хотите сопоставить, с дефисом между ними. Например, если вы хотите найти только "комплекты" из backslash <code>\</code> и одной буквы от <code>a</code> до <code>m</code>, вы можете сделать следующее:

<pre>pattern: <span>\\[a-m]</span>
string:  `<span>\n</span>`, `<span>\r</span>`, `<span>\t</span>`, and `<span>\f</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.
matches:  <span>                      ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/40" target="_blank" rel="nofollow">Пример</a>)

Если вы хотите сопоставить несколько диапазонов, просто разместите их вплотную между квадратных скобок:

<pre>pattern: <span>\\[a-gq-z]</span>
string:  `<span>\n</span>`, `<span>\r</span>`, `<span>\t</span>`, and `<span>\f</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.
matches:        <span>^^    ^^        ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/41" target="_blank" rel="nofollow">Пример</a>)

Другие общие диапазоны символов включают в себя: <code>A-Z</code> и <code>0-9</code>
<h2>Испробуем их на практике, и решим пару задачек:</h2>Шестнадцатеричные числа могут содержать цифры <code>0-9</code>, а также буквы <code>A-F</code>. При использовании их для указания цветов, шестнадцатеричные коды могут содержать не более трех символов. Создайте регулярное выражение, чтобы найти действительные шестнадцатеричные коды в списке ниже:

<pre>pattern:
string:  1H8 <span>4E2 8FF</span> 0P1 T8B <span>776 42B</span> G12
matches:     <span>^^^ ^^^         ^^^ ^^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/25" target="_blank" rel="nofollow">Решение</a>)

Используя диапазоны символов, создайте регулярное выражение, которое будет выбирать только строчные согласные (не гласные буквы, включая <code>y</code>) в предложении ниже:

<pre>pattern:
string:  T<span>h</span>e <span>w</span>a<span>lls</span> i<span>n th</span>e <span>m</span>a<span>ll</span> a<span>r</span>e <span>t</span>o<span>t</span>a<span>lly</span>, <span>t</span>o<span>t</span>a<span>lly</span> <span>t</span>a<span>ll</span>.
matches:  <span>^  ^ ^^^  ^ ^^  ^ ^^  ^  ^ ^ ^^^  ^ ^ ^^^ ^ ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/26" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 6: "not", caret, циркумфлекс, знак вставки... символ <code>^</code></h2><img data-max-width="512" data-id="5b520c70-ca37-4a56-a456-6697709d2f65" src="/images/article/5b520c70-ca37-4a56-a456-6697709d2f65/512.jpeg" class="img-fluid" alt="RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 1 - 7">Поистине, over 9000 имен у этого символа :) Но, для простоты, пожалуй остановимся на "not". Мое решение последней задачи немного длинное. Потребовалось 17 символов, чтобы сказать: "получить весь алфавит, кроме гласных". Конечно, есть более простой способ сделать это.

Знак "not" <code>^</code> позволяет нам определять символы и диапазоны символов, которые должны <strong>не</strong> соответствовать указанным в шаблоне. Более простое решение последней задачи, приведенной выше, состоит в том, чтобы найти символы, которые не обозначают гласные буквы:

<pre>pattern: <span>[^aeiou]</span>
string:  <span>Th</span>e <span>w</span>a<span>lls</span> i<span>n th</span>e <span>m</span>a<span>ll</span> a<span>r</span>e <span>t</span>o<span>t</span>a<span>lly, t</span>o<span>t</span>a<span>lly</span> <span>t</span>a<span>ll.</span>
matches: <span>^^ ^^ ^^^^ ^^^^ ^^ ^^^ ^ ^^ ^ ^^^^^^ ^ ^^^^^ ^^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/27" target="_blank" rel="nofollow">Пример</a>)

Знак "not" <code>^</code> как крайний левый символ в квадратных скобках <code>[]</code> указывает механизму регулярных выражений на совпадение с одним (любым) символом, которого нет в квадратных скобках. Это означает, что приведенное выше регулярное выражение также соответствует всем пробелам, точке <code>.</code>, запятой <code>,</code> и заглавной <code>T</code> в начале предложения. Чтобы исключить их, мы можем точно также поместить их в квадратные скобки:

<pre>pattern: <span>[^aeiou .,T]</span> 
string:  T<span>h</span>e <span>w</span>a<span>lls</span> i<span>n th</span>e <span>m</span>a<span>ll</span> a<span>r</span>e <span>t</span>o<span>t</span>a<span>lly</span>, <span>t</span>o<span>t</span>a<span>lly</span> <span>t</span>a<span>ll</span>.
matches:  <span>^  ^ ^^^  ^ ^^  ^ ^^  ^  ^ ^ ^^^  ^ ^ ^^^ ^ ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/28" target="_blank" rel="nofollow">Пример</a>)

<mark>Обратите внимание</mark>, что в этом случае, нам не нужно экранировать точку обратным слэшем, как мы делали прежде, когда искали ее, не пользуясь при этом квадратными скобками. Многие специальные символы в квадратных скобках обрабатываются буквально, включая открытый <code>[</code>- но не закрывающий <code>]</code> символ скобки (догадываетесь почему?). 

Символ обратной косой черты <code>\</code> тоже не трактуется буквально. Если вы хотите сопоставить литеральную (буквальную) обратную косую черту <code>\</code> с использованием квадратных скобок, то вы должны экранировать ее, поставив перед ней следующую обратную косую черту <code>\\</code>. 
Такое поведение было назначено для того, чтобы символы пробелов тоже можно было разместить в квадратных скобках для сопоставления:

<pre>pattern: <span>[\t]</span>
string:  t  t   t   t
matches:  <span>^  ^   ^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/29" target="_blank" rel="nofollow">Пример</a>)

Знак "not" <code>^</code> также может быть использован с диапазонами. Если бы я хотел захватить только символы <code>a</code>, <code>b</code>, <code>c</code>, <code>x</code>, <code>y</code> и <code>z</code>, я мог бы сделать например так:

<pre>pattern: <span>[abcxyz]</span>
string:  <span>abc</span>defghijklmnopqrstuvw<span>xyz</span>
matches: <span>^^^                    ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/31" target="_blank" rel="nofollow">Пример</a>)

... или, я мог бы указать, что я хочу найти любой символ, который находится <strong>не</strong> между <code>d</code> и <code>w</code>:

<pre>pattern: <span>[^d-w]</span>
string:  <span>abc</span>defghijklmnopqrstuvw<span>xyz</span>
matches: <span>^^^                    ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/32" target="_blank" rel="nofollow">Пример</a>)

Однако, <mark>будьте осторожны</mark> с  "not" <code>^</code>. 

Легко подумать "ну, я указал <code>[^ b-f]</code>, поэтому я должен получить строчную букву <code>a</code> или что-то после <code>f</code>. Это не тот случай.

Это регулярное выражение будет соответствовать любому символу, не входящему в этот диапазон, включая буквы, цифры, знаки препинания и пробелы.

<pre>pattern: <span>[^d-w]</span>
string:  <span>abc</span>defg h<span>.</span>i<span>,</span>j<span>-</span>klmnopqrstuvw<span>xyz</span>
matches: <span>^^^    ^ ^ ^ ^             ^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/33" target="_blank" rel="nofollow">Пример</a>)
<h2>Задачки для прокачки:</h2>Используйте знак "not" <code>^</code> в квадратных скобках, чтобы сопоставить все слова ниже, которые не заканчиваются на <code>y</code>:

<pre>pattern:
string:  day <span>dog hog</span> hay <span>bog</span> bay ray <span>rub</span>
matches:     <span>^^^ ^^^     ^^^         ^^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/34" target="_blank" rel="nofollow">Решение</a>)

Напишите регулярное выражение, используя диапазон и знак "not" <code>^</code>, чтобы найти все годы между 1977 и 1982 (включительно):

<pre>pattern:
string:  1975 1976 <span>1977 1978 1979 1980 1981 1982</span> 1983 1984
matches:           <span>^^^^ ^^^^ ^^^^ ^^^^ ^^^^ ^^^^</span></pre>
(<a href="https://regex101.com/r/Mf9L3O/35" target="_blank" rel="nofollow">Решение</a>)

Напишите регулярное выражение для поиска всех символов, которые не являются символом знака "not" <code>^</code> :

<pre>pattern:
string:  <span>abc1</span>^<span>23*()</span>
matches: <span>^^^^ ^^^^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/36" target="_blank" rel="nofollow">Решение</a>)
<h2>Шаг 7: классы символов</h2>Классы символов даже проще, чем диапазоны символов. Различные движки регулярных выражений имеют разные доступные классы, поэтому здесь я расскажу только об основных. (Проверьте, какую версию regex вы используете, потому что их может быть больше - или они могут отличаться от показанных здесь.)

Классы символов работают почти как диапазоны, но при этом, вы не можете указать значения 'start' и 'end':
<table>
<thead>
<tr>
<th>класс</th>
<th>символы</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\d</code></td>
<td>"цифры" <code>[0-9]</code>
</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>"символы слова" <code>[A-Za-z0-9_]</code>
</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>"пробелы" <code>[ \t\r\n\f]</code>
</td>
</tr>
</tbody>
</table>
Класс символов <code>\w</code> "word" особенно полезен, поскольку этот набор символов часто требуется для допустимых идентификаторов (имен переменных, функций и т.д.) в различных языках программирования.

Мы можем использовать <code>\w</code>, чтобы упростить регулярное выражение, которое мы видели ранее:

<pre>pattern: <span>\\[a-z]</span>
string:  `<span>\n</span>`, `<span>\r</span>`, `<span>\t</span>`, and `<span>\f</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.
matches:  <span>^^    ^^    ^^        ^^</span>	
</pre>
Используя <code>\w</code> мы можем написать так:

<pre>pattern: <span>\\\w</span>
string:  `<span>\n</span>`, `<span>\r</span>`, `<span>\t</span>`, and `<span>\f</span>` <span>are</span> whitespace characters, `<span>\.</span>`, `<span>\\</span>` and `<span>\[</span>` are <span>not</span>.
matches:  <span>^^    ^^    ^^        ^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/42" target="_blank" rel="nofollow">Пример</a>)
<h2>2 задачи для удачи:</h2>Как мы с вами знаем, в Java идентификатор (имя переменной, класса, функции и т.д.) может начинаться только с буквы <code>a</code>-<code>zA</code>-<code>Z</code>, знака доллара <code>$</code> или подчеркивания <code>_</code>. (<em>подчеркивание, конечно плохой стиль, но компилятор пропускает, прим. переводчика</em>). Остальная часть символов должна быть символами "word" <code>\w</code>. Используя один или несколько классов символов, создайте регулярное выражение для поиска допустимых идентификаторов Java среди следующих трехсимвольных последовательностей:

<pre>pattern:
string:  <span>__e $12</span> .x2 <span>foo Bar</span> 3mm
matches: <span>^^^ ^^^     ^^^ ^^^</span>	
</pre>
(<a href="https://regex101.com/r/Mf9L3O/43" target="_blank" rel="nofollow">Решение</a>)

Номера социального страхования США (SSN) представляют собой 9-значные номера в формате XXX-XX-XXXX, где каждый X может быть любой цифрой <code>[0-9]</code>. Используя один или несколько классов символов, напишите регулярное выражение, чтобы найти правильно отформатированные номера SSN в списке ниже:

<pre>pattern:
string:  113-25=1902 <span>182-82-0192</span> H23-_3-9982 1I1-O0-E38B
matches:             <span>^^^^^^^^^^^</span>
</pre>
(<a href="https://regex101.com/r/Mf9L3O/44" target="_blank" rel="nofollow">Решение</a>)

<a href="https://javarush.com/groups/posts/2680-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-2" target="_blank" rel="nofollow">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 2.</a>
<a href="https://javarush.com/groups/posts/2681-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-3" target="_blank" rel="nofollow">20 коротких шагов для освоения регулярных выражений. Часть 3.</a>
<a href="https://javarush.com/groups/posts/2682-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-4" target="_blank" rel="nofollow">RegEx: 20 коротких шагов для освоения регулярных выражений. Часть 4.</a>