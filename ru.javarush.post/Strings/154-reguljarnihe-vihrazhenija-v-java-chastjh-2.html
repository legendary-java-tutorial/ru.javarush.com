Регулярные выражения в Java, часть 2
<p>----------------------------------------</p>
Предлагаем вашему вниманию перевод краткого руководства по регулярным выражениям в языке java, написанного Джеффом Фрисеном (Jeff Friesen) для сайта javaworld. для простоты чтения мы разделили статью на несколько частей.
<p>----------------------------------------</p>
Предлагаем вашему вниманию перевод краткого руководства по регулярным выражениям в языке Java, написанного Джеффом Фрисеном (Jeff Friesen) для сайта <a href="https://www.javaworld.com/article/3188545/learn-java/java-101-regular-expressions-in-java-part-1.html" target="_blank">javaworld</a>. Для простоты чтения мы разделили статью на несколько частей.
<img data-max-width="800" data-id="25466d03-ef3d-422f-bc4c-ef1f4b6d97fe" src="/images/article/25466d03-ef3d-422f-bc4c-ef1f4b6d97fe/800.jpeg" class="img-fluid" alt="Регулярные выражения в Java, часть 2 - 1"><a href="https://javarush.com/groups/posts/136-reguljarnihe-vihrazhenija-v-java-chastjh-1" target="_blank">Регулярные выражения в Java, часть 1</a>
<table>
<thead>
<tr>
<th>Слияние нескольких диапазонов</th>
</tr>
</thead>
<tbody>
<tr>
<td>Можно сливать несколько диапазонов в один диапазонный класс символов, размещая их бок о бок. Например, класс <code>[a-zA-Z]</code> соответствует всем латинским алфавитным символам в нижнем или верхнем регистре.
</td>
</tr>
</tbody>
</table><h2>Слияние нескольких диапазонов</h2>Можно сливать несколько диапазонов в один диапазонный класс символов путем размещения их бок о бок. Например, класс <code>[a-zA-Z]</code> соответствует всем латинским алфавитным символам в нижнем или верхнем регистре.
<h3>Объединение классов символов</h3>Объединение классов символов состоит из нескольких вложенных классов символов и соответствует всем входящим в результирующее объединение символам. Например, класс <code>[a-d[m-p]]</code> соответствует символам от <code>a</code> до <code>d</code> и от <code>m</code> до <code>p</code>.

Рассмотрим следующий пример:

<code>java RegexDemo [ab[c-e]] abcdef</code>

В этом примере будут найдены символы <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> и <code>e</code>, для которых есть соответствия в <code>abcdef</code>:

<pre class="lang-java line-numbers"><code>
regex = [ab[c-e]]
input = abcdef
Found [a] starting at 0 and ending at 0
Found [b] starting at 1 and ending at 1
Found [c] starting at 2 and ending at 2
Found [d] starting at 3 and ending at 3
Found [e] starting at 4 and ending at 4
</code></pre><h3>Пересечение классов символов</h3>Пересечение классов символов состоит из символов, общих для всех вложенных классов и соответствует только общим символам. Например, класс <code>[a-z&amp;&amp;[d-f]]</code> соответствует символам <code>d</code>, <code>e</code> и <code>f</code>.

Рассмотрим следующий пример:

<code>java RegexDemo "[aeiouy&amp;&amp;[y]]" party</code>

Обратите внимание, что на моей операционной системе Windows необходимы двойные кавычки, так как командная оболочка рассматривает <code>&amp;</code> как разделитель команд.

В этом примере будет найден только символ <code>y</code>, для которого есть соответствие в <code>party</code>:

<pre class="lang-java line-numbers"><code>
regex = [aeiouy&amp;&amp;[y]]
input = party
Found [y] starting at 4 and ending at 4
</code></pre><h3>Вычитание классов символов</h3>Вычитание классов символов состоит из всех символов, кроме тех, которые содержатся во вложенных классах символов, и соответствует только этим остальным символам. Например, класс <code>[a-z&amp;&amp;[^m-p]]</code> соответствует символам от <code>a</code> до <code>l</code> и от <code>q</code> до <code>z</code>:

<code>java RegexDemo "[a-f&amp;&amp;[^a-c]&amp;&amp;[^e]]" abcdefg</code>

В этом примере будет найден символы <code>d</code> и <code>f</code>, для которых есть соответствия в <code>abcdefg</code>:

<pre class="lang-java line-numbers"><code>
regex = [a-f&amp;&amp;[^a-c]&amp;&amp;[^e]]
input = abcdefg
Found [d] starting at 3 and ending at 3
Found [f] starting at 5 and ending at 5
</code></pre><h3>Предопределенные классы символов</h3>Некоторые классы символов встречаются в <a href="https://javarush.com/groups/posts/2013-reguljarnihe-vihrazhenija-v-java" target="_blank">регулярных выражениях</a> достаточно часто, чтобы оправдать использование сокращенных обозначений. Класс <code>Pattern</code> предлагает в качестве подобных сокращений предопределенные классы символов. Вы можете воспользоваться ими, чтобы упростить свои регулярные выражения и минимизировать синтаксические ошибки.

Имеется несколько категорий предопределенных классов символов: стандартные, POSIX, <code>java.lang.Character</code> и такие свойства Unicode, как сценарий, блок, категория и двоичное свойство. В следующем списке приведена только категория стандартных классов:
<ul>
<li><code>\d</code>: Цифра. Эквивалентно <code>[0-9]</code>.</li>
<li><code>\D</code>: Нецифровой символ. Эквивалентно <code>[^0-9]</code>.</li>
<li><code>\s</code>: Пробельный символ. Эквивалентно <code>[ \t\n\x0B\f\r]</code>.</li>
<li><code>\S</code>: Не пробельный символ. Эквивалентно <code>[^\s]</code>.</li>
<li><code>\w</code>: Словообразующий символ. Эквивалентно <code>[a-zA-Z_0-9]</code>.</li>
<li><code>\W</code>: Не словообразующий символ. Эквивалентно <code>[^\w]</code>.</li>
</ul>В следующем примере используется предопределенный класс символов <code>\w</code> для описания всех словообразующих символов во входном тексте:

<code>java RegexDemo \w "aZ.8 _"</code>

Посмотрите внимательно на следующие результаты выполнения, показывающие, что символы точки и пробела не считаются словообразующим:

<pre class="lang-java line-numbers"><code>
regex = \w
input = aZ.8 _
Found [a] starting at 0 and ending at 0
Found [Z] starting at 1 and ending at 1
Found [8] starting at 3 and ending at 3
Found [_] starting at 5 and ending at 5
</code></pre><table>
<thead>
<tr>
<th>Разделители строк</th>
</tr>
</thead>
<tbody>
<tr>
<td>Документация по SDK класса <code>Pattern</code> описывает метасимвол точки как предопределенный класс символов, соответствующий любому символу, кроме разделителей строк (одно- или двухсимвольные последовательности, отмечающие конец строки). Исключение составляет режим dotall (который мы обсудим далее), в котором точка соответствуют и разделителям строк. Класс <code>Pattern</code> различает следующие разделители строк:
<ul>
<li>cимвол возврата каретки (<code>\r</code>);</li>
<li>cимвол новой строки (символ протяжки бумаги на одну строку) (<code>\n</code>);</li>
<li>cимвол возврата каретки, за которым непосредственно следует символ новой строки (<code>\r\n</code>);</li>
<li>cимвол следующей строки (<code>\u0085</code>);</li>
<li>cимвол разделения строк (<code>\u2028</code>);</li>
<li>cимвол разделения абзацев (<code>\u2029</code>)</li>
</ul></td>
</tr>
</tbody>
</table><h3>Захватываемые группы</h3>Захватываемая группа (capturing group) служит для сохранения найденного набора символов с целью дальнейшего использования при поиске по шаблону. Эта конструкция представляет собой последовательность символов, заключенную в метасимволы круглых скобок ( <code>( )</code> ). Все символы внутри захватываемой группы рассматриваются при поиске по шаблону как единое целое. Например, захватываемая группа (<code>Java</code>) объединяет буквы <code>J</code>, <code>a</code>, <code>v</code> и <code>a</code> в единое целое. Эта захватываемая группа находит все вхождения шаблона <code>Java</code> во входной текст. При каждом совпадении предыдущие сохраненные символы <code>Java</code> заменяются следующими.

Захватываемые группы могут быть вложены в другие захватываемые группы. Например, в регулярном выражении <code>(Java( language))</code> группа <code>(language)</code> вложена внутрь группы <code>(Java)</code>. Каждой вложенной или не вложенной захватываемой группе присваивается свой номер, начиная с 1, причем нумерация идет слева направо. В предыдущем примере, <code>(Java( language))</code> соответствует захватываемой группе номер 1, а <code>(language)</code> – захватываемой группе номер 2. В регулярном выражении <code>(a)(b)</code>, <code>(a)</code> соответствует захватываемой группе номер 1, а <code>(b)</code> захватываемой группе номер 2.
<img data-max-width="800" data-id="3cc6fb1e-090e-416e-a342-6af3c8e7986a" src="/images/article/3cc6fb1e-090e-416e-a342-6af3c8e7986a/800.jpeg" class="img-fluid" alt="Регулярные выражения в Java, часть 2 - 2">К сохраненным захватываемыми группами совпадениям можно позднее обратиться при помощи обратных ссылок. Задаваемая в виде символа обратной косой черты с последующим цифровым символом, соответствующим номеру захватываемой группы, обратная ссылка позволяет обратиться к символам захваченного группой текста. Наличие обратной ссылки приводит к обращению сопоставителя к сохраненному захватываемой группой результату поиска, на основе номера из неё, с последующим использованием символов из этого результата для попытки дальнейшего поиска. 

В следующем примере показано использование обратной ссылки для поиска грамматических ошибок в тексте:

<code>java RegexDemo "(Java( language)\2)" "The Java language language"</code>

В этом примере регулярное выражение <code>(Java( language)\2)</code> используется для поиска грамматической ошибки с дублированием слова <code>language</code> непосредственно после <code>Java</code> во входном тексте <code>"The Java language language"</code>. В этом регулярном выражении заданы две захватываемые группы: номер 1 – <code>(Java( language)\2)</code>, соответствующей <code>Java language language</code> и номер 2 – <code>(language)</code>, соответствующей символу пробела, за которым следует <code>language</code>. Обратная ссылка <code>\2</code> позволяет повторно обратиться к сохраненному результату группы номер 2, благодаря чему сопоставитель может выполнить поиск второго вхождения пробела, за которым следует <code>language</code>, непосредственно после первого вхождения пробела и <code>language</code>. Результаты работы сопоставителя <code>RegexDemo</code> представляют собой следующее:

<pre class="lang-java line-numbers"><code>
regex = (Java( language)\2)
input = The Java language language
Found [Java language language] starting at 4 and ending at 25
</code></pre><h3>Граничные сопоставители</h3>Иногда бывает нужно выполнить сопоставление с шаблоном в начале строки, на границе слов, в конце текста и т.д. Сделать это можно с помощью одного из граничных сопоставителей класса <code>Pattern</code>, представляющих собой конструкции регулярных выражений для поиска совпадений в следующих местоположениях:
<ul>
<li><code>^</code>: Начало строки;</li>
<li><code>$</code>: Конец строки;</li>
<li><code>\b</code>: Граница слова;
</li><li><code>\B</code>: Граница псевдослова;</li>
<li><code>\A</code>: Начало текста;</li>
<li><code>\G</code>: Конец предыдущего совпадения;</li>
<li><code>\Z</code>: Конец текста, не считая итогового разделителя строк (если таковой присутствует);</li>
<li><code>\z</code>: Конец текста</li>
</ul>В следующем примере используется метасимвол <code>^</code> граничного сопоставителя для поиска строк, начинающихся с <code>The</code>, за которым следует ноль или более словообразующих символов:

<code>java RegexDemo "^The\w*" Therefore</code>

Символ <code>^</code> указывает на то, что первые три символа входного текста должны соответствовать идущим один за другим символам шаблона <code>T</code>, <code>h</code> и <code>e</code>, за которыми может следовать любое число словообразующих символов. Вот результат выполнения:

<pre class="lang-java line-numbers"><code>
regex = ^The\w*
input = Therefore
Found [Therefore] starting at 0 and ending at 8
</code></pre>
Что произойдет, если изменить командную строку на <code>java RegexDemo "^The\w*" " Therefore"</code>? Совпадения найдено не будет, поскольку перед <code>Therefore</code> во входном тексте стоит символ пробела.
<h3>Совпадения нулевой длины</h3>Иногда, при работе с граничными сопоставителями вы будете встречаться с совпадениями нулевой длины. <code>Совпадение нулевой длины</code> – это совпадение, не содержащее символов. Они могут встретиться в пустом входном тексте, в начале входного текста, после последнего символа входного текста и между любыми двумя символами этого текста. Совпадения нулевой длины легко распознать, поскольку они всегда начинаются и заканчиваются на одной и той же позиции.

Рассмотрим следующий пример:

<code>java RegExDemo \b\b "Java is"</code>

В этом примере происходит поиск двух последовательных границ слова, его результаты выглядят следующим образом:

<pre class="lang-java line-numbers"><code>
regex = \b\b
input = Java is
Found [] starting at 0 and ending at -1
Found [] starting at 4 and ending at 3
Found [] starting at 5 and ending at 4
Found [] starting at 7 and ending at 6
</code></pre>
Мы видим в результатах несколько совпадений нулевой длины. Конечные позиции тут на единицу меньше начальных, поскольку в исходном коде <code>RegexDemo</code> в листинге 1 я указал <code>end() – 1</code>.
<img data-max-width="800" data-id="52109426-a6d4-42f2-8c31-05805a5d6b9a" src="/images/article/52109426-a6d4-42f2-8c31-05805a5d6b9a/800.jpeg" class="img-fluid" alt="Регулярные выражения в Java, часть 2 - 3"><h3>Квантификаторы</h3>Квантификатор – это конструкция регулярного выражения, явно или неявно связывающая шаблон с числовым значением. Этот числовое значение определяет, сколько раз искать шаблон. Квантификаторы делятся на жадные, ленивые и сверхжадные:
<ul>
<li>Жадный квантификатор (<code>?</code>, <code>*</code> или <code>+</code>) предназначен для поиска самого длинного совпадения. Можно задать <code>X</code>? для поиска одного или менее вхождений <code>X</code>, <code>X*</code> для поиска нуля или более вхождений <code>X</code>, <code>X+</code> для поиска одного или более вхождений <code>X</code>, <code>X{n}</code> для поиска <code>n</code> вхождений <code>X</code>, <code>X{n,}</code> для поиска не менее (а возможно, и более) <code>n</code> вхождений <code>X</code> и <code>X{n,m}</code> для поиска не менее <code>n</code>, но не более <code>m</code> вхождений <code>X</code>.</li>
<li>Ленивый квантификатор (<code>??</code>, <code>*?</code> или <code>+?</code>) предназначен для поиска самого короткого совпадения. Можно задать <code>X??</code> для поиска одного или менее вхождений <code>X</code>, <code>X*</code>? для поиска нуля или более вхождений <code>X</code>, <code>X+?</code> для поиска одного или более вхождений <code>X</code>, <code>X{n}?</code> для поиска <code>n</code> вхождений <code>X</code>, <code>X{n,}?</code> для поиска не менее (а возможно, и более) <code>n</code> вхождений <code>X</code> и <code>X{n,m}?</code> для поиска не менее <code>n</code>, но не более <code>m</code> вхождений <code>X</code>.</li>
<li>Сверхжадный квантификатор (<code>?+</code>, <code>*+</code> или <code>++</code>) аналогичен жадному, за исключением того, что сверхжадный квантификатор выполняет только одну попытку найти самое длинное совпадение, в то время как жадный может выполнять несколько попыток. Можно задать <code>X?+</code> для поиска одного или менее вхождений <code>X</code>, <code>X*+</code> для поиска нуля или более вхождений <code>X</code>, <code>X++</code> для поиска одного или более вхождений <code>X</code>, <code>X{n}+</code> для поиска <code>n</code> вхождений <code>X</code>, <code>X{n,}+</code> для поиска не менее (а возможно, и более) <code>n</code> вхождений <code>X</code> и <code>X{n,m}+ </code>для поиска не менее <code>n</code>, но не более <code>m</code> вхождений <code>X</code>.</li>
</ul>Следующий пример иллюстрирует использование жадного квантификатора:

<code>java RegexDemo .*ox "fox box pox"</code>

Вот его результаты:

<pre class="lang-java line-numbers"><code>
regex = .*ox
input = fox box pox
Found [fox box pox] starting at 0 and ending at 10
</code></pre>
Жадный квантификатор (<code>.*</code>) находит самую длинную последовательность символов, завершающуюся на <code>ox</code>. Он поглощает весь входной текст, после чего откатывается вплоть до обнаружения того, что входной текст заканчивается этими символами.

Рассмотрим теперь ленивый квантификатор:

<code>java RegexDemo .*?ox "fox box pox"</code>

Его результаты:

<pre class="lang-java line-numbers"><code>
regex = .*?ox
input = fox box pox
Found [fox] starting at 0 and ending at 2
Found [ box] starting at 3 and ending at 6
Found [ pox] starting at 7 and ending at 10
</code></pre>
Ленивый квантификатор (<code>.*?</code>) находит самую короткую последовательность символов, завершающуюся на <code>ox</code>. Он начинает с пустой строки и постепенно поглощает символы до тех пор, пока не находит соответствие. А затем продолжает работу вплоть до исчерпания входного текста.

Наконец, рассмотрим сверхжадный квантификатор:

<code>java RegexDemo .*+ox "fox box pox"</code>

И вот его результаты:

<pre class="lang-java line-numbers"><code>
regex = .*+ox
input = fox box pox
</code></pre>
Сверхжадный квантификатор (<code>.*+</code>) не находит совпадений, поскольку он поглощает весь входной текст и не остается ничего, что могло бы соответствовать <code>ox</code> в конце регулярного выражения. В отличие от жадного квантификатора, сверхжадный квантификатор не выполняет откат назад.
<h3>Совпадения нулевой длины</h3>Иногда при работе с квантификаторами вы будете сталкиваться с совпадениями нулевой длины. Например, использование следующего жадного квантификатора приводит к нескольким совпадениям нулевой длины:

<code>java RegexDemo a? abaa</code>

Результаты выполнения этого примера:

<pre class="lang-java line-numbers"><code>
regex = a?
input = abaa
Found [a] starting at 0 and ending at 0
Found [] starting at 1 and ending at 0
Found [a] starting at 2 and ending at 2
Found [a] starting at 3 and ending at 3
Found [] starting at 4 and ending at 3
</code></pre>
В результатах выполнения присутствуют пять совпадений. Хотя первое, третье и четвертое вполне ожидаемы (они соответствуют позициям трёх букв <code>a</code> в <code>abaa</code>), второе и пятое может вас удивить. Создается такое впечатление, будто они указывают, что <code>a</code> соответствует <code>b</code> и концу текста, но на самом деле всё не так. Регулярное выражение <code>a?</code> не ищет <code>b</code> в конце текста. Оно выполняет поиск наличия или отсутствия <code>a</code>. Когда <code>a?</code> не обнаруживает <code>a</code>, сообщает об этом в виде совпадения нулевой длины.
<h3>Вложенные флаговые выражения</h3>Сопоставители принимают некоторые допущения по умолчанию, которые можно перекрыть при компиляции регулярного выражения в шаблон. Мы обсудим этот вопрос позже. Регулярное выражение позволяет перекрыть любое из умолчаний, используя вложенное флаговое выражение. Эта конструкция регулярного выражения задается в виде метасимволов круглых скобок вокруг метасимвола знака вопроса (<code>?</code>), с последующей латинской буквой в нижнем регистре. Класс <code>Pattern</code> понимает следующие вложенные флаговые выражения:
<ul>
<li><code>(?i)</code>: активирует нечувствительный к регистру поиск по шаблону. Например, при использовании команды <code>java RegexDemo (?i)tree Treehouse</code> последовательность символов <code>Tree</code> соответствует шаблону <code>tree</code>. По умолчанию используется поиск по шаблону с учетом регистра.</li>
<li><code>(?x)</code>: разрешает использование внутри шаблона пробельных символов и комментариев, начинающихся с метасимвола <code>#</code>. Сопоставитель будет игнорировать и те, и другие. Например, для <code>java RegexDemo ".at(?x)#match hat, cat, and so on" matter</code> последовательность символов <code>mat</code> соответствует шаблону <code>.at</code>. По умолчанию, пробельные символы и комментарии запрещены, сопоставитель рассматривает их как символы, участвующие в поиске.</li>
<li><code>(?s)</code>: активирует режим dotall, в котором метасимвол точки соответствует разделителям строк, помимо любого другого символа. Например, при команде <code>java RegexDemo (?s). \n</code> будет найден символ новой строки. По умолчанию используется противоположный dotall режим: разделители строк не будут находиться. Например, при команде <code>Java RegexDemo . \n</code> символ новой строки найден не будет.</li><li><code>(?m)</code>: активирует многострочный режим, при котором <code>^</code> соответствует началу, а <code>$</code> – концу каждой строки. Например, <code>java RegexDemo "(?m)^abc$" abc\nabc</code> находит во входном тексте обе последовательности <code>abc</code>. По умолчанию используется однострочный режим: <code>^</code> соответствует началу всего входного текста, а <code>$</code> — его концу. Например, <code>java RegexDemo "^abc$" abc\nabc</code> возвращает ответ об отсутствии совпадений.</li>
<li><code>(?u)</code>: активирует выравнивание регистра с учетом Unicode. Этот флаг, при совместном использовании с <code>(?i)</code>, позволяет осуществлять поиск по шаблону без учета регистра в соответствии со стандартом Unicode. Настройка по умолчанию — поиск с учетом регистра и только по символам из набора US-ASCII.</li>
<li><code>(?d)</code>: активирует режим строк в стиле Unix, при котором сопоставитель распознает в контексте метасимволов <code>.</code>, <code>^</code> и <code>$</code> только разделитель строк <code>\n</code>. По умолчанию используется режим строк в стиле не-Unix: сопоставитель распознает в контексте вышеупомянутых метасимволов все разделители строк.</li>
</ul>Вложенные флаговые выражения напоминают захватываемые группы, поскольку их символы окружаются метасимволами круглых скобок. В отличие от захватываемых групп, вложенные флаговые выражения – пример не захватываемых групп, представляющих собой конструкцию регулярных выражений, не захватывающую текстовые символы. Они определяются как последовательности символов, окруженные метасимволами круглых скобок.
<table>
<thead>
<tr>
<th>Указание нескольких вложенных флаговых выражений</th>
</tr>
</thead>
<tbody>
<tr>
<td>Существует возможность указания нескольких вложенных флаговых выражений в регулярном выражении путем или расположения их бок о бок (<code>(?m)(?i))</code>), или размещения последовательно определяющих их букв (<code>(?mi)</code>).
</td>
</tr>
</tbody>
</table><h2>Заключение</h2>Как вы уже, наверное, поняли, регулярные выражения чрезвычайно полезны и становятся еще более полезны по мере освоения вами нюансов их синтаксиса. До сих пор я познакомил вас с основами регулярных выражений и классом <code>Pattern</code>. Во второй части мы заглянем глубже в API Regex и изучим методы классов <code>Pattern</code>, <code>Matcher</code> и <code>PatternSyntaxException</code>. Я также продемонстрирую вам два практических приложения API Regex, которые вы сможете сразу же использовать в своих программах.

<a href="https://javarush.com/groups/posts/186-reguljarnihe-vihrazhenija-v-java-chastjh-3" target="_blank">Регулярные выражения в Java, часть 3</a>
<a href="https://javarush.com/groups/posts/229-reguljarnihe-vihrazhenija-v-java-chastjh-4" target="_blank">Регулярные выражения в Java, часть 4</a>
<a href="https://javarush.com/groups/posts/247-reguljarnihe-vihrazhenija-v-java-chastjh-5" target="_blank">Регулярные выражения в Java, часть 5</a>
<table>
<tbody><tr>
<th><p>Что еще почитать:
</p>
</th>
</tr>
<tr>
<td><ul>
<li><a href="https://javarush.com/groups/posts/72-kak-praviljhno-nachatjh-razrabotku-pod-subd-oracle" target="_blank">Как правильно начать разработку под СУБД Oracle</a></li>
<li><a href="https://javarush.com/groups/posts/254-top-5-bibliotek-mashinnogo-obuchenija-dlja-java" target="_blank">Топ 5 библиотек машинного обучения для Java</a></li>
<li><a href="https://javarush.com/groups/posts/264-populjarno-o-ljambda-vihrazhenijakh-v-java-s-primerami-i-zadachami-chastjh-1-" target="_blank">Популярно о лямбда-выражениях в Java. С примерами и задачами. Часть 1</a></li>
</ul></td>
</tr>
</tbody></table>