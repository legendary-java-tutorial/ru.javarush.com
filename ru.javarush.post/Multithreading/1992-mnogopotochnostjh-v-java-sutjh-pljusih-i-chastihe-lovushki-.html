Многопоточность в Java: суть, «плюсы» и частые ловушки
<p>----------------------------------------</p>
Привет!  Прежде всего, поздравляю: ты дошел до темы «Многопоточность»! Это серьезное достижение, позади — немалый путь. Но приготовься: это одна из самых трудных тем в курсе. И дело не в том, что здесь используются сложные классы или много методов ...
<p>----------------------------------------</p>
Привет!  Прежде всего, поздравляю: ты дошел до темы Многопоточность в Java! Это серьезное достижение, позади — немалый путь. Но приготовься: это одна из самых трудных тем в курсе.

И дело не в том, что здесь используются сложные классы или много методов: наоборот, и двух десятков не наберется. Скорее в том, что нужно немного изменить мышление. 

Раньше твои программы выполнялись последовательно. Одни строчки кода шли после других, одни методы — за другими, и в целом все было понятно. Сначала посчитать что-нибудь, потом вывести результат на консоль, потом завершить программу.

Чтобы понять многопоточность, лучше мыслить с точки зрения параллельности. Начнем с чего-нибудь совсем простого :)<img data-id="7218d092-5484-4603-b20a-66a06fd0321f" data-max-width="850" alt="Многопоточность в Java: суть, «плюсы» и частые ловушки - 1" src="https://cdn.javarush.com/images/article/7218d092-5484-4603-b20a-66a06fd0321f/1024.jpeg">Представь, что твоя семья переезжает из одного дома в другой. Важная часть переезда — собрать книги. Книг у вас накопилось много, и надо сложить их в коробки. 

Сейчас свободен только ты. Мама готовит еду, брат собирает одежду, а сестра ушла в магазин. В одиночку ты худо-бедно справляешься, и, рано или поздно, даже сам выполнишь задание, но времени понадобится очень много. Впрочем, через 20 минут из магазина вернется твоя сестра, и других дел у нее нет. Так что она может присоединиться к тебе. 

Задача не менялась: сложить книги в коробки. Только выполняется в два раза быстрее. Почему?

Потому что работа делается параллельно. Два разных «потока» (ты и твоя сестра) одновременно выполняют одну и ту же задачу и, если ничего не изменится, разница по времени будет очень большой по сравнению с ситуацией, в которой ты бы делал все один. 

Если брат скоро справится со своей задачей, он может помочь вам, и дело пойдет еще быстрее.

<h2>Проблемы, которые решает многопоточность в Java</h2>По сути, многопоточность Java была придумана, чтобы решить две главные задачи:
<ol>
<li><p>Одновременно выполнять несколько действий.</p>
<p>В примере выше разные потоки (т.е. члены семьи) параллельно выполняли несколько действий: мыли посуду, ходили в магазин, складывали вещи.</p>
<p>Можно привести и более «программистский» пример. Представь, что у тебя есть программа с пользовательским интерфейсом. При нажатии кнопки «Продолжить» внутри программы должны произойти какие-то вычисления, а пользователь должен увидеть следующий экран интерфейса. Если эти действия осуществляются последовательно, после нажатия кнопки «Продолжить» программа просто зависнет. Пользователь будет видеть все тот же экран с кнопкой «Продолжить», пока все внутренние вычисления не будут выполнены, и программа не дойдет до части, где начнется отрисовка интерфейса.</p>
<p>Что ж, подождем пару минут!</p>
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="f0ced206-41a8-4f2a-bdb9-5ca0c90751e7" data-max-width="410" alt="Многопоточность в Java: суть, «плюсы» и частые ловушки - 3" src="https://cdn.javarush.com/images/article/f0ced206-41a8-4f2a-bdb9-5ca0c90751e7/1024.jpeg"></div></div>
<p>А еще мы можем переделать нашу программу, или, как говорят программисты, «распараллелить». Пусть нужные вычисления выполняются в одном потоке, а отрисовка интерфейса — в другом. У большинства компьютеров хватит на это ресурсов. В таком случае программа не будет «тупить», и пользователь будет спокойно переходить между экранами интерфейса не заботясь о том, что происходит внутри. Одно другому не мешает :)</p></li>
<li><p>Ускорить вычисления.</p>
<p>Тут все намного проще. Если наш процессор имеет несколько ядер, а большинство процессоров сейчас многоядерные, список наших задач могут параллельно решать несколько ядер. Очевидно, что если нам нужно решить 1000 задач и каждая из них решается за секунду, одно ядро справится со списком за 1000 секунд, два ядра — за 500 секунд, три — за 333 с небольшим секунды и так далее.</p></li>
</ol>
Но, как ты уже читал в лекции, современные системы очень умны, и даже на одном вычислительном ядре они способны реализовать параллельность, или псевдопараллельность, когда задачи выполняются попеременно. 

Давай перейдем от общих вещей к конкретным и познакомимся с главным классом в библиотеке Java, относящимся к многопоточности, — java.lang.Thread.

Собственно говоря, потоки в Java представляются экземплярами класса <code>Thread</code>. То есть чтобы создать и запустить выполнение 10 потоков, понадобится 10 объектов этого класса. 

Напишем самый простой пример:

<pre class="lang-java line-numbers"><code>
public class MyFirstThread extends Thread {

   @Override
   public void run() {
       System.out.println("I'm Thread! My name is " + getName());
   }
}
</code></pre>
Чтобы формировать и запускать потоки, нам нужно создать класс, унаследовать его от класса <code>java.lang</code>.<code>Thread</code> и переопределить в нем метод <code>run()</code>.

Последнее — очень важно. Именно в методе <code>run()</code> мы прописываем ту логику, которую наш поток должен выполнить. 

Теперь, если мы создадим экземпляр <code>MyFirstThread</code> и запустим его, метод <code>run()</code> выведет в консоль строку с его именем: метод <code>getName()</code> выводит «системное» имя потока, которое присваивается автоматически.

Хотя, собственно, почему «если»? Давай создадим и проверим!

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       for (int i = 0; i &lt; 10; i++) {

           MyFirstThread thread = new MyFirstThread();
           thread.start();
       }
   }
}
</code></pre>
Вывод в консоль:

<em>I'm Thread! My name is Thread-2
I'm Thread! My name is Thread-1
I'm Thread! My name is Thread-0
I'm Thread! My name is Thread-3
I'm Thread! My name is Thread-6
I'm Thread! My name is Thread-7
I'm Thread! My name is Thread-4
I'm Thread! My name is Thread-5
I'm Thread! My name is Thread-9
I'm Thread! My name is Thread-8</em>

Создаем 10 потоков (объектов) <code>MyFirstThread</code>, который наследуется от <code>Thread</code> и запускаем их, вызывая у объекта метод <code>start()</code>. После вызова метода <code>start()</code> начинает работу его метод <code>run()</code>, и выполняется та логика, которая была в нем написана.

Обрати внимание: имена потоков идут не по порядку. Это довольно странно, почему они не выполнялись по очереди: <code>Thread-0</code>, <code>Thread-1</code>, <code>Thread-2</code> и так далее?

Это как раз пример того, когда стандартное, «последовательное» мышление не подойдет. Дело в том, что мы в данном случае только отдаем команды на создание и запуск 10 потоков. В каком порядке их запускать — решает планировщик потоков: особый механизм внутри операционной системы.

Как именно он устроен и по какому принципу принимает решения — тема очень сложная, и сейчас не будем в нее погружаться. Главное запомни, что последовательность выполнения потоков программист контролировать не может.

Чтобы осознать серьезность ситуации, попробуй запустить метод <code>main()</code> из примера выше еще пару раз.

Второй вывод в консоль:

<em>I'm Thread! My name is Thread-0
I'm Thread! My name is Thread-4
I'm Thread! My name is Thread-3
I'm Thread! My name is Thread-2
I'm Thread! My name is Thread-1
I'm Thread! My name is Thread-5
I'm Thread! My name is Thread-6
I'm Thread! My name is Thread-8
I'm Thread! My name is Thread-9
I'm Thread! My name is Thread-7</em>

Третий вывод в консоль:

<em>I'm Thread! My name is Thread-0
I'm Thread! My name is Thread-3
I'm Thread! My name is Thread-1
I'm Thread! My name is Thread-2
I'm Thread! My name is Thread-6
I'm Thread! My name is Thread-4
I'm Thread! My name is Thread-9
I'm Thread! My name is Thread-5
I'm Thread! My name is Thread-7
I'm Thread! My name is Thread-8</em>

<h2>Проблемы, которые создает многопоточность</h2>На примере с книгами ты увидел, что многопоточность решает достаточно важные задачи, и ее использование ускоряет работу наших программ. Во многих случаях — в разы. Но многопоточность недаром считается сложной темой. Ведь при неправильном использовании она создает проблемы вместо того, чтобы решать их.

Говоря «создавать проблемы» я не имею в виду что-то абстрактное.

Есть две конкретные проблемы, которые может вызвать использование многопоточности — взаимная блокировка (deadlock) и состояние гонки (race condition).

Deadlock — ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение. Мы еще поговорим о нем в следующих лекциях, пока достаточно этого примера:
<img data-id="1b662d0c-03ec-43c1-9819-e4e0dc8312ec" data-max-width="850" alt="Многопоточность в Java: суть, «плюсы» и частые ловушки - 4" src="https://cdn.javarush.com/images/article/1b662d0c-03ec-43c1-9819-e4e0dc8312ec/1024.jpeg">
Представь, что поток-1 работает с каким-то Объектом-1, а поток-2 работает с Объектом-2. При этом программа написана так: 
<ol>
<li>Поток-1 перестанет работать с Объектом-1 и переключится на Объект-2, как только Поток-2 перестанет работать с Объектом 2 и переключится на Объект-1. </li>
<li>Поток-2 перестанет работать с Объектом-2 и переключится на Объект-1, как только Поток-1 перестанет работать с Объектом 1 и переключится на Объект-2.</li>
</ol>
Даже не обладая глубокими знаниями в многопоточности ты легко поймешь, что ничего из этого не получится. Потоки никогда не поменяются местами и будут ждать друг друга вечно.

Ошибка кажется очевидной, но на самом деле это не так. Допустить ее в программе можно запросто. Мы рассмотрим примеры кода, вызывающего deadlock, в следующих лекциях. Кстати, на Quora есть отличный <a href="https://www.quora.com/What-are-some-real-life-examples-of-deadlock" rel="nofollow" target="_blank">пример из реальной жизни</a>, объясняющий что такое<em> deadlock</em>.

«В некоторых штатах Индии вам не продадут землю сельскохозяйственного назначения, если вы не зарегистрированы как фермер. При этом вас не зарегистрируют в качестве фермера, если вы не владеете сельскохозяйственными землями».

Здорово, что тут сказать! :)

Теперь про race condition — состояние гонки.
<img data-id="7aad1594-7e86-4488-b7ab-5bcc82f8ae74" data-max-width="850" alt="Многопоточность в Java: суть, «плюсы» и частые ловушки - 5" src="https://cdn.javarush.com/images/article/7aad1594-7e86-4488-b7ab-5bcc82f8ae74/1024.jpeg">Состояние гонки — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Вспомни пример с запуском потоков: 

<pre class="lang-java line-numbers"><code>
public class MyFirstThread extends Thread {

   @Override
   public void run() {
       System.out.println("Выполнен поток " + getName());
   }
}

public class Main {

   public static void main(String[] args) {

       for (int i = 0; i &lt; 10; i++) {

           MyFirstThread thread = new MyFirstThread();
           thread.start();
       }
   }
}
</code></pre>
A теперь представь, что программа отвечает за работу робота, который готовит еду!

<em>Поток-0 достает яйца из холодильника.
Поток-1 включает плиту.
Поток-2 достает сковородку и ставит на плиту.
Поток-3 зажигает огонь на плите.
Поток-4 выливает на сковороду масла.
Поток-5 разбивает яйца и выливает их на сковороду.
Поток-6 выбрасывает скорлупу в мусорное ведро.
Поток-7 снимает готовую яичницу с огня.
Поток-8 выкладывает яичницу в тарелку.
Поток-9 моет посуду.</em>

Посмотри на результаты работы нашей программы:

<em><em>Выполнен поток Thread-0
Выполнен поток Thread-2
Выполнен поток Thread-1
Выполнен поток Thread-4
Выполнен поток Thread-9
Выполнен поток Thread-5
Выполнен поток Thread-8
Выполнен поток Thread-7
Выполнен поток Thread-3
Выполнен поток Thread-6</em></em>

Веселый получился сценарий? :) А все потому, что работа нашей программы зависит от порядка выполнения потоков.

При малейшем нарушении последовательности наша кухня превращается в ад, а сошедший с ума робот крушит все вокруг себя. Это тоже распространенная проблема в многопоточном программировании, о которой ты еще не раз услышишь.

В завершение лекции, хочу посоветовать тебе книгу, посвященную многопоточности.
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="4f7ed12d-eac6-4103-89be-65c432356c95" data-max-width="450" alt="Многопоточность в Java: суть, «плюсы» и частые ловушки - 6" src="https://cdn.javarush.com/images/article/4f7ed12d-eac6-4103-89be-65c432356c95/1024.jpeg"></div></div>«Java Concurrency in Practice» написана еще в 2006 году, но не утратила актуальность. Она посвящена многопоточному программированию на Java, начиная от основ и заканчивая списком самых распространенных ошибок и антипаттернов.

Если когда-нибудь решишь стать гуру многопоточного программирования, эта книга обязательна к прочтению.

Увидимся на следующих лекциях! :)