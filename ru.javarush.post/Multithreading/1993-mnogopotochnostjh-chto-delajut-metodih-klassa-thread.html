Многопоточность: что делают методы класса Thread
<p>----------------------------------------</p>
Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -&gt; «что он делает». С методами Thread так не получится :) ...
<p>----------------------------------------</p>
Привет! Сегодня продолжаем говорить о многопоточности. Рассмотрим класс Thread и работу его нескольких методов. Раньше, когда мы изучали методы класса, чаще всего просто писали это так: «название метода» -> «что он делает».
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="a721b583-c502-4047-b2d9-a49895b5a89a" data-max-width="710" alt="Многопоточность: что делают методы класса Thread - 1" src="https://cdn.javarush.com/images/article/a721b583-c502-4047-b2d9-a49895b5a89a/1024.jpeg"></div></div>С методами Thread так не получится :) Их логика сложнее, и без нескольких примеров не разобраться. 

<h2>Метод Thread.start()</h2>Начнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса <code>Thread</code> и переопределив в нем метод <code>run()</code>.

Но сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод <code>start()</code>.
<img data-id="b9b6e5a5-b771-4c79-8122-2e453ab57ace" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 2" src="https://cdn.javarush.com/images/article/b9b6e5a5-b771-4c79-8122-2e453ab57ace/1024.jpeg">Давай вспомним пример из предыдущей лекции:

<pre class='lang-java line-numbers'><code>
public class MyFirstThread extends Thread {

   @Override
   public void run() {
       System.out.println("Выполнен поток " + getName());
   }
}


public class Main {

   public static void main(String[] args) {

       for (int i = 0; i < 10; i++) {
           MyFirstThread thread = new MyFirstThread();
           thread.start();
       }
   }
}
</code></pre>
<em><strong>Обрати внимание:</strong></em> чтобы запустить поток, необходимо вызвать специальный метод <code>start()</code>, а не метод <code>run()</code>! Эту ошибку легко допустить, особенно в начале изучения многопоточности. 

Если в нашем примере ты 10 раз вызовешь у объекта метод <code>run()</code> вместо <code>start()</code>, результат будет таким:

<pre class='lang-java line-numbers'><code>
public class Main {

   public static void main(String[] args) {

       for (int i = 0; i < 10; i++) {
           MyFirstThread thread = new MyFirstThread();
           thread.run();
       }
   }
}
</code></pre>

<em><strong>Выполнен поток Thread-0
Выполнен поток Thread-1
Выполнен поток Thread-2
Выполнен поток Thread-3
Выполнен поток Thread-4
Выполнен поток Thread-5
Выполнен поток Thread-6
Выполнен поток Thread-7
Выполнен поток Thread-8
Выполнен поток Thread-9</strong></em>

Посмотри на последовательность вывода: все идет строго по порядку. Странно, да? Мы к такому не привыкли, ведь уже знаем, что порядок запуска и выполнения потоков определяет сверхразум внутри нашей операционной системы — планировщик потоков. Может, просто повезло?

Конечно, дело не в везении. В этом можешь убедиться, запустив программу еще пару раз.

Дело в том, что прямой вызов метода <code>run()</code> не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод <code>main()</code>. Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся. 

Поэтому запомни на будущее и постоянно себя проверяй. Хочешь, чтобы выполнился <code>run()</code>, вызывай <code>start()</code>. Поехали дальше.

<h2>Метод Thread.sleep()</h2>Для приостановки выполнения текущего потока на какое-то время, используем метод <code>sleep()</code>.
<img data-id="1e9f01d2-6dba-4189-9bf6-121c25c29110" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 3" src="https://cdn.javarush.com/images/article/1e9f01d2-6dba-4189-9bf6-121c25c29110/1024.jpeg">Метод <code>sleep()</code> принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.

<pre class='lang-java line-numbers'><code>
public class Main {

   public static void main(String[] args) throws InterruptedException {

       long start = System.currentTimeMillis();

       Thread.sleep(3000);

       System.out.println(" - Сколько я проспал? \n - " + ((System.currentTimeMillis()-start)) / 1000 + " секунды");

   }
}
</code></pre>
<strong>Вывод в консоль:

<em> - Сколько я проспал? 
 - 3 секунды</em></strong>

Обрати внимание: метод <code>sleep()</code> — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.

Еще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение <code>InterruptedException</code>. Мы рассмотрим пример ниже.

Кстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.

После того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в <code>Thread.sleep()</code>, — он переходит в состояние <em>runnable</em>, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.

Обязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!

<h2>Метод Thread.join()</h2><img data-id="c3c0548b-4341-4b3f-a577-44ba15c84b23" data-max-width="850" alt="Многопоточность: что делают методы класса Thread - 4" src="https://cdn.javarush.com/images/article/c3c0548b-4341-4b3f-a577-44ba15c84b23/1024.jpeg">Метод <code>join()</code> приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.

Если у нас есть 2 потока, <code>t1</code> и <code>t2</code>, и мы напишем —

<pre class='lang-java line-numbers'><code>
t1.join()
</code></pre>
<code>t2</code> не начнет работу, пока t1 не завершит свою. Метод <code>join()</code> можно использовать, чтобы гарантировать последовательность выполнения потоков. 

Давай рассмотрим работу <code>join()</code> на примере:

<pre class='lang-java line-numbers'><code>
public class ThreadExample extends Thread {

   @Override
   public void run() {

       System.out.println("Начало работы потока " + getName());

       try {
           Thread.sleep(5000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
       System.out.println("Поток " + getName() +  " завершил работу.");
   }
}


public class Main {

   public static void main(String[] args) throws InterruptedException {

       ThreadExample t1 = new ThreadExample();
       ThreadExample t2 = new ThreadExample();

       t1.start();

      
 /*Второй поток t2 начнет выполнение только после того, как будет завершен
       (или бросит исключение) первый поток - t1*/
       try {
           t1.join();
       } catch (InterruptedException e) {
           e.printStackTrace();
       }

       t2.start();

       //Главный поток продолжит работу только после того, как t1 и t2 завершат работу
       try {
           t1.join();
           t2.join();
       } catch (InterruptedException e) {
           e.printStackTrace();
       }

       System.out.println("Все потоки закончили работу, программа завершена");

   }
}
</code></pre>
Мы создали простой класс <code>ThreadExample</code>. Его задача — вывести на экран сообщение о начале работы, потом уснуть на 5 секунд и в конце сообщить о завершении работы. Ничего сложного.

Главная логика заключена в классе <code>Main</code>. Посмотри на комментарии: с помощью метода <code>join()</code> мы успешно управляем последовательностью выполнения потоков. Если ты вспомнишь начало темы, этим занимался планировщик потоков. Он запускал их на свое усмотрение: каждый раз по-разному. 

Здесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток <code>t1</code>, затем — <code>t2</code>, и только после них — главный поток выполнения программы.  

Идем дальше.

В реальных программах тебе не раз встретятся ситуации, когда необходимо будет прервать выполнение какого-то потока.

Например, наш поток выполняется, но при этом ждет определенного события или выполнения условия. Если это произошло, он останавливается. Было бы, наверное, логично, если бы существовал какой-то метод типа <code>stop()</code>.

Однако все не так просто. Когда-то давно метод <code><strong>Thread.stop()</strong></code> в Java действительно был и позволял прерывать работу потока. Но позже его удалили из библиотеки Java. Ты можешь найти его в документации Oracle и увидеть, что он помечен как <em>deprecated</em>.

Почему? Потому что он просто останавливал поток без какой-либо дополнительной работы. 

Например, поток мог работать с данными и что-то в них менять. Потом его резко вырубали методом <code>stop()</code> посреди работы — и все. Ни корректного завершения работы, ни освобождения ресурсов, ни хотя бы обработки ошибок — ничего этого не было.

Метод <code>stop()</code>, если утрировать, просто крушил все на своем пути.

Его работу можно сравнить с тем, как кто-то выдергивает вилку из розетки, чтобы выключить компьютер. Да, нужного результата добиться можно. Но все понимают, что через пару недель компьютер не скажет за это «спасибо».

По этой причине логику прерывания потоков в Java изменили, и теперь используется специальный метод — <code>interrupt()</code>.

<h2>Метод Thread.interrupt()</h2>Что произойдет, если у потока вызвать <strong>метод</strong> <code><strong>interrupt()</strong></code>?

Есть 2 варианта:

<ol>
<li>Если объект находился в этот момент в состоянии ожидания, например, <code>join</code> или <code>sleep</code>, ожидание будет прервано, и программа выбросит <code>InterruptedException</code>.</li>
<li>Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг <code><strong>interrupted</strong></code>.</li></ol>
Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе <code>Thread</code> есть специальный метод — <code><strong>boolean isInterrupted()</strong></code>.

Давай вернемся к примеру с часами, который был в лекции основного курса. Для удобства он немного упрощен:

<pre class='lang-java line-numbers'><code>
public class Clock extends Thread {

   public static void main(String[] args) throws InterruptedException {
       Clock clock = new Clock();
       clock.start();

       Thread.sleep(10000);
       clock.interrupt();
   }

   public void run() {
       Thread current = Thread.currentThread();

       while (!current.isInterrupted())
       {
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               System.out.println("Работа потока была прервана");
               break;
           }
           System.out.println("Tik");
       }
   }
}
</code></pre>
В нашем случае часы стартуют и начинают тикать каждую секунду. На 10-й секунде мы прерываем поток часов.

Как ты уже знаешь, если поток, который мы пытаемся прервать, находится в одном из состояний ожидания, это приводит к <code>InterruptedException</code>. Данный вид исключения — проверяемый, поэтому его можно легко перехватить и выполнить нашу логику завершения программы. Что мы и сделали.

<strong>Вот наш результат:</strong>

<em><strong>Tik
Tik
Tik
Tik
Tik
Tik
Tik
Tik
Tik</strong></em>

Работа потока была прервана

На этом мы заканчиваем знакомство с основными методами класса <code>Thread</code>.

Чтобы закрепить знания, можешь посмотреть эту видеолекцию о многопоточности: 
<div class="row">
<div class="col col-md-10 col-lg-8">
<div class="embed-responsive embed-responsive-16by9">
<iframe width="560" height="315" src="https://www.youtube.com/embed/zxZ0BXlTys0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
</div>
</div>она послужит отличным дополнительным материалом! В конце, после обзора методов, в ней рассказывается как раз о том, что мы будем проходить дальше по курсу :)

Успехов!