Сказ о двух итераторах: стратегии конкурентной модификации в Java 
<p>----------------------------------------</p>
Среди наиболее популярных вопросов на собеседованиях по языку Java есть и такой: В чём различие между fail-fast и fail-safe итераторами? Максимально упрощённый ответ на него ...

<p>----------------------------------------</p>
<em>Автор заметки — Гжегож Мирек — разработчик программного обеспечения из Кракова (Польша). Он занялся разработкой на Java около 6 лет назад, ещё в университете, и, с этого времени, неустанно шлифует своё мастерство в данной сфере. Его особенно интересует вопрос производительности JVM и оптимизации, о чем он, в основном, и пишет в своём <a href='http://performantcode.com/concurrency/a-tale-of-two-iterators/' target='_blank'>блоге</a>.</em>
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="964fc369-68d3-4507-9bb1-6f407882491f" data-max-width="600" alt="Сказ о двух итераторах: стратегии конкурентной модификации в Java  - 1" src="https://cdn.javarush.com/images/article/964fc369-68d3-4507-9bb1-6f407882491f/1024.jpeg"></div></div>Среди наиболее популярных вопросов на собеседованиях по языку Java есть и такой:

<em>В чём различие между fail-fast и fail-safe итераторами?</em>

Максимально упрощённый ответ на него:

<em>Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.</em>

Хотя это звучит достаточно осмысленно, остается непонятным, что интервьюер понимает под fail-safe? Спецификации языка Java не определяют этот термин в отношении итераторов. Однако существуют четыре стратегии конкурентной модификации.
<h2>Конкурентная модификация</h2>Во-первых, давайте определимся, что такое конкурентная (или параллельная) модификация. Допустим у нас есть коллекция и при активном итераторе происходят какие-либо её изменения, не исходящие от данного итератора. В таком случае у нас получается конкурентная модификация. 

Приведу простейший пример: допустим, у нас есть несколько нитей. Первая нить выполняет итерации, а вторая вставляет элементы в ту же коллекцию или удаляет их из неё. Однако мы можем получить исключение <strong>ConcurrentModificationException</strong> и при работе в однопоточной среде:

<pre class='lang-java line-numbers'><code>
List&ltString&gt cities = new ArrayList&lt&gt();
cities.add(“Warsaw”);
cities.add(“Prague”);
cities.add(“Budapest”);
 
Iterator&ltString&gt cityIterator = cities.iterator();
cityIterator.next();
cities.remove(1);
cityIterator.next(); // генерирует ConcurrentModificationException
</code></pre><h2>Fail-fast</h2>Вышеприведенный фрагмент кода – пример <strong>fail-fast</strong> итератора. Как вы можете видеть, при попытке извлечения второго элемента из итератора было сгенерировано исключение <strong>ConcurrentModificationException</strong>. Откуда итератор узнает, что коллекция была модифицирована после его создания? Например, в коллекции может быть метка даты/времени, скажем, <strong>lastModified</strong>. При создании итератора вам стоит скопировать это поле и сохранить его в объекте итератора. Затем, при каждом вызове метода <strong>next()</strong>, нужно будет просто сравнить значение <strong>lastModified</strong> из коллекции с копией из итератора. Очень близкий подход используется, например, в реализации класса <strong>ArrayList</strong>. В нём есть переменная экземпляра <strong>modCount</strong>, в которой хранится количество модификаций списка:

<pre class='lang-java line-numbers'><code>
final void checkForComodification() {
   if (modCount != expectedModCount)
       throw new ConcurrentModificationException();
}
</code></pre>
Важно отметить, что <strong>fail-fast</strong> итераторы работают на основе принципа "по мере возможности", то есть не дается никаких гарантий генерации исключения <strong>ConcurrentModificationException</strong> в случае конкурентной модификации. Так что полагаться на это не стоит – скорее, их следует использовать для обнаружения ошибок. Большинство неконкурентных коллекций предоставляют <strong>fail-fast</strong> итераторы.
<h2>Слабая согласованность</h2>Большинство конкурентных коллекций из пакета <strong>java.util.concurrent</strong> (например, <strong>ConcurrentHashMap</strong> и большинство <strong>Queue</strong>) предоставляют слабо согласованные итераторы. Смысл этого термина очень хорошо разъясняется в <a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#Weakly' target='_blank'>документации</a>:
<ul>
<li>Они могут обрабатываться конкурентно с другими операциями</li>
<li>Они никогда не генерируют исключение<strong> ConcurrentModificationException</strong></li>
<li>Они гарантированно обходят существовавшие на момент создания итератора элементы ровно один раз, и могут (но не обязаны) отражать последующие модификации.</li>
</ul><h2>Снимок состояния</h2>При такой стратегии итератор связывается с состоянием коллекции на момент его создания – это и есть снимок состояния (снепшот) коллекции. Любые произведенные над исходной коллекцией изменения приводят к созданию новой версии нижележащей структуры данных. При этом наш снимок состояния остается неизменным, так что он не отражает изменения в коллекции, которые произошли после создания итератора. <strong>Это старая добрая методика копирования при записи (copy-on-write, COW)</strong>. Она полностью решает проблему конкурентных модификаций, поэтому исключение <strong>ConcurrentModificationException</strong> при таком подходе не генерируется. Кроме того, итераторы не поддерживают операции, которые меняют элементы.

Коллекции с копированием при записи обычно требуют слишком больших расходов ресурсов при использовании, но имеет смысл воспользоваться ими, если изменения происходят намного реже, чем обходы итераторов. Примерами могут служить классы <strong>CopyOnWriteArrayList</strong> и <strong>CopyOnWriteArraySet</strong>.
<h2>Неопределенное поведение</h2>Неопределенное поведение может встретиться вам в устаревших унаследованных типах коллекций, таких как <strong>Vector</strong> и <strong>Hashtable</strong>. В обеих есть стандартные <strong>fail-fast</strong> итераторы, но кроме этого, они позволяет использовать реализации интерфейса <strong>Enumeration</strong>, а они не знают, как себя вести в случае конкурентной модификации. Вы можете столкнуться с тем, что некоторые элементы повторяются или оказываются пропущенными, а то и вовсе увидите какие-то странные исключения. Лучше с ними не играться!
<table>
<tr><th>Что еще почитать?</th>
</tr>
<tr>
<td>
<p><a href='https://javarush.com/groups/posts/392-kak-v-java-napechatatjh-chisla-ot-1-do-100-bez-ciklov-i-usloviy-' target='_blank'>Как в Java напечатать числа от 1 до 100 без циклов и условий?</a></p>
<p><a href='https://javarush.com/groups/posts/366-top-10-bibliotek-java-kotorihe-pomogut-sehkonomitjh-vremja-' target='_blank'>Топ-10 библиотек Java, которые помогут сэкономить время</a></p>
</td>
</tr>
</table>