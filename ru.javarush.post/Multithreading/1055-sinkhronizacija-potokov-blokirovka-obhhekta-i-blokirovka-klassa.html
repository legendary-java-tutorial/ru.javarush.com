Синхронизация потоков, блокировка объекта и блокировка класса
<p>----------------------------------------</p>
Синхронизация относится к многопоточности. Синхронизированый блок кода может быть выполнен только одним потоком одновременно. Java поддерживает несколько потоков для выполнения. Это может ...
<p>----------------------------------------</p>

<img data-id="e210b671-ad70-46b0-8e5d-30dc14a2513e" data-max-width="850" alt="Синхронизация потоков, блокировка объекта и блокировка класса - 1" src="https://cdn.javarush.com/images/article/e210b671-ad70-46b0-8e5d-30dc14a2513e/1024.jpeg"><em>Синхронизация относится к многопоточности. Синхронизированый блок кода может быть выполнен только одним потоком одновременно.</em>

Java поддерживает несколько потоков для выполнения. Это может привести к тому, что два или более потока получат доступ к одному и тому же полю или объекту. Синхронизация это процесс, который позволяет выполнять все параллельные потоки в программе синхронно. Синхронизация позволяет избежать ошибок согласованности памяти, вызванные из-за непоследовательного доступа к общей памяти.

Когда метод объявлен как синхронизированный — нить держит монитор для объекта, метод которого исполняется. Если другой поток выполняет синхронизированный метод, ваш поток заблокируется до тех пор, пока другой поток не отпустит монитор.

Синхронизация достигается в Java использованием зарезервированного слова <code>synchronized</code>. <strong>Вы можете использовать его в своих классах определяя синхронизированные методы или блоки. Вы не сможете использовать <code>synchronized</code> в переменных или атрибутах в определении класса.</strong>
<h2>Блокировка на уровне объекта</h2>Это механизм синхронизации не статического метода или не статического блока кода, такой, что только один поток сможет выполнить данный блок или метод на данном экземпляре класса.

Это нужно делать всегда, когда необходимо сделать данные на уровне экземпляра потокобезопасными.

Пример:

<pre class='lang-java line-numbers'><code>
public class DemoClass{
    public synchronized void demoMethod(){}
}
</code></pre>
или

<pre class='lang-java line-numbers'><code>
public class DemoClass{
    public void demoMethod(){
        synchronized (this)        {
            //other thread safe code
        }
    }
}
</code></pre>
или

<pre class='lang-java line-numbers'><code>
public class DemoClass{
    private final Object lock = new Object();
    public void demoMethod(){
        synchronized (lock)        {
            //other thread safe code
        }
    }
}
</code></pre><h2>Блокировка на уровне класса</h2>Предотвращает возможность нескольким потокам войти в синхронизированный блок во время выполнения в любом из доступных экземпляров класса. Это означает, что если во время выполнения программы имеется 100 экземпляров класса <code>DemoClass</code>, то только один поток в это время сможет выполнить <code>demoMethod()</code> в любом из случаев, и все другие случаи будут заблокированы для других потоков.

Это необходимо когда требуется сделать статические данные потокобезопасными.

<pre class='lang-java line-numbers'><code>
public class DemoClass{
    public synchronized static void demoMethod(){}
}
</code></pre>
или

<pre class='lang-java line-numbers'><code>
public class DemoClass{
    public void demoMethod(){
        synchronized (DemoClass.class)        {
            //other thread safe code
        }
    }
}
</code></pre>
или

<pre class='lang-java line-numbers'><code>
public class DemoClass
{
    private final static Object lock = new Object();
    public void demoMethod(){
        synchronized (lock)        {
            //other thread safe code
        }
    }
}
</code></pre><h2>Некоторые важные замечания</h2><ol>
<li>Синхронизация в Java гарантирует, что никакие два потока не смогут выполнить синхронизированный метод одновременно или параллельно.</li><br />
<li><code><strong>synchronized</strong></code> можно использовать только с методами и блоками кода. Эти методы или блоки могут быть статическими или не-статическими.</li><br />
<li>когда какой либо поток входит в синхронизированный метод или блок  он приобретает блокировку и всякий раз, когда поток выходит из синхронизированного метода или блока JVM снимает блокировку. Блокировка снимается, даже если нить оставляет синхронизированный метод после завершения из-за каких-либо ошибок или исключений.</li><br />
<li><code><strong>synchronized</strong></code> в Java <a href='https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B5%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C' rel='nofollow' target='_blank'>рентерабельна</a> это означает, что если синхронизированный метод вызывает другой синхронизированный метод, который требует такой же замок, то текущий поток, который держит замок может войти в этот метод не приобретая замок.</li><br />
<li>Синхронизация в Java будет бросать <code>NullPointerException</code> если объект используемый в синхронизированном блоке null. Например, в вышеприведенном примере кода, если замок инициализируется как <code>null</code>, синхронизированный (lock) бросит <code>NullPointerException</code>.</li><br />
<li>Синхронизированные методы в Java вносят дополнительные затраты на производительность вашего приложения. Так что используйте синхронизацию, когда она абсолютно необходима. Кроме того, рассмотрите вопрос об использовании синхронизированных блоков кода для синхронизации только критических секций кода.</li><br />
<li>Вполне возможно, что и статический и не статический синхронизированные методы могут работать одновременно или параллельно, потому что они захватывают замок на другой объект.</li><br />
<li>В соответствии со спецификацией языка вы не можете использовать <code><strong>synchronized</strong></code> в конструкторе это приведет к ошибке компиляции.</li><br />
<li>Не синхронизируйте по не финальному (no final) полю, потому что ссылка, на не финальное поле может измениться в любое время, а затем другой поток может получить синхронизацию на разных объектах  и уже не будет никакой синхронизации вообще. Лучше всего использовать класс <code>String</code>, который уже неизменяемый и финальный.</li><br /></ol><em>Удачи в обучении!!</em>

<em>Оригинал: <a href='https://howtodoinjava.com/java/multi-threading/object-vs-class-level-locking/' rel='nofollow' target='_blank'>Object level lock vs Class level lock in Java</a></em>