В чем разница между мьютексом, монитором и семафором
<p>----------------------------------------</p>
Привет! Изучая многопоточность на JavaRush, ты часто встречал понятия «мьютекс» и «монитор». Сможешь сейчас, без подглядывания ответить, чем они отличаются? :) Если смог — молодец! Если же нет (а чаще всего так и бывает) — неудивительно...
<p>----------------------------------------</p>
Привет!

Изучая многопоточность на JavaRush, ты часто встречал понятия «мьютекс» и «монитор». Сможешь сейчас, без подглядывания ответить, чем они отличаются? :)

<img data-id="98bc41b3-a1db-4ba9-8821-8e0520c6053e" data-max-width="850" alt="В чем разница между мьютексом, монитором и семафором - 1" src="https://cdn.javarush.com/images/article/98bc41b3-a1db-4ba9-8821-8e0520c6053e/1024.jpeg">Если смог — молодец! Если же нет (а чаще всего так и бывает) — неудивительно.

Понятия «мьютекс» и «монитор» действительно связаны между собой. Более того, читая лекции и смотря видео по многопоточности на внешних ресурсах в Интернете, ты столкнешься с еще одним похожим понятием — «семафор». 

Его функционал тоже во многом схож с монитором и мьютексом. Поэтому разберемся с этими тремя терминами, рассмотрим несколько примеров и окончательно упорядочим в голове понимание того, чем же они друг от друга отличаются :)

<h2>Мьютекс</h2>Мьютекс — это специальный объект для синхронизации потоков. Он «прикреплен» к каждому объекту в Java — это ты уже знаешь :)

Неважно, пользуешься ли ты стандартными классами или создал собственные классы, скажем, <code>Cat</code> и <code>Dog</code>: <strong>у всех объектов всех классов есть мьютекс</strong>.

Название «мьютекс» происходит от английского «MUTual EXclusion» — «взаимное исключение», и это отлично отражает его предназначение.

Как мы и говорили в одной из прошлых лекций, <strong>задача мьютекса — обеспечить такой механизм, чтобы доступ к объекту в определенное время был только у одного потока</strong>. 

Популярной аналогией мьютекса в реальной жизни можно считать «пример с туалетом».

Когда человек заходит в туалет, он закрывает изнутри дверь на замок.

Туалет выполняет роль объекта, доступ к которому получают несколько потоков. Замок на двери туалета — роль мьютекса, а очередь из людей снаружи — роль потоков.

Замок на двери — мьютекс туалета: он гарантирует, что внутри одновременно может находиться только один человек. 
<img data-id="2af6a4b9-893f-44e3-8c31-d584a0ae27c8" data-max-width="850" alt="В чем разница между мьютексом, монитором и семафором - 2" src="https://cdn.javarush.com/images/article/2af6a4b9-893f-44e3-8c31-d584a0ae27c8/1024.jpeg">Иными словами, только один поток в определенное время может работать с общими ресурсами. Попытки других потоков (людей) получить доступ к занятым ресурсам будут неудачными.

У мьютекса есть несколько важных особенностей.

<strong>Во-первых</strong>, возможны только два состояния — «свободен» и «занят». 

Это упрощает понимание принципа работы: можно провести параллели с булевыми переменными<em> true/false</em> или двоичной системой счисления 1/0.

<strong>Во-вторых</strong>, состояниями нельзя управлять напрямую. В Java нет механизмов, которые позволили бы явно взять объект, получить его мьютекс и присвоить ему нужный статус. Иными словами, ты не можешь сделать что-то типа:

<pre class='lang-java line-numbers'><code>
Object myObject = new Object();
Mutex mutex = myObject.getMutex();
mutex.free();
</code></pre>
Таким образом освободить мьютекс объекта нельзя. Прямой доступ к нему есть только у Java-машины. Программисты же работают с мьютексами с помощью средств языка.
<h2>Монитор</h2>Монитор — это дополнительная «надстройка» над мьютексом.

Фактически <strong>монитор — это «невидимый» для программиста кусок кода</strong>. 

Говоря о мьютексе ранее, мы приводили простой пример:

<pre class='lang-java line-numbers'><code>
public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       synchronized (obj) {

           //логика, которая одновременно доступна только для одного потока
       }
   }
}
</code></pre>
В блоке кода, который помечен словом <code><strong>synchronized</strong></code>, происходит захват мьютекса нашего объекта <code><strong>obj</strong></code>.

Хорошо, захват-то происходит, но как именно обеспечивается «защитный механизм»? Почему при виде слова <code>synchronized</code> остальные потоки не могут пройти внутрь блока? 

Защитный механизм создает именно монитор! Компилятор преобразует слово <code><strong>synchronized</strong></code> в несколько специальных кусков кода.

Еще раз вернемся к нашему примеру с методом <code><strong>doSomething()</strong></code> и дополним его:

<pre class='lang-java line-numbers'><code>
public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       //логика, которая одновременно доступна только для одного потока
       synchronized (obj) {

           /*выполнить важную работу, при которой доступ к объекту
           должен быть только у одного потока*/
           obj.someImportantMethod();
       }
   }
}
</code></pre>
Вот что будет происходить «под капотом» нашей программы после того, как компилятор преобразует этот код:

<pre class='lang-java line-numbers'><code>
public class Main {

   private Object obj = new Object();

   public void doSomething() throws InterruptedException {

       //...какая-то логика, доступная для всех потоков

       //логика, которая одновременно доступна только для одного потока:
     
       /*до тех пор, пока мьютекс объекта занят -
       любой другой поток (кроме того, который его захватил), спит*/
       while (obj.getMutex().isBusy()) {
           Thread.sleep(1);
       }

       //пометить мьютекс объекта как занятый
       obj.getMutex().isBusy() = true;

       /*выполнить важную работу, при которой доступ к объекту
       должен быть только у одного потока*/
       obj.someImportantMethod();

       //освободить мьютекс объекта
       obj.getMutex().isBusy() = false;
   }
}
</code></pre>
Пример, конечно, ненастоящий. Здесь мы с помощью Java-подобного кода попытались отразить то, что происходит в этот момент внутри Java-машины. Однако этот псевдокод дает отличное понимание того, что на самом деле происходит с объектом и потоками внутри блока <code>synchronized</code> и как компилятор преобразует это слово в несколько «невидимых» для программиста команд.

По сути, <strong>монитор в Java выражен с помощью слова <code>synchronized</code></strong>. Весь код, который появился вместо слова <code>synchronized</code> в последнем примере, — это и есть монитор.
<h2>Семафор</h2>Еще одно слово, с которым ты сталкиваешься при самостоятельном изучении многопоточности — «семафор». Давай разберемся что это такое, и чем он отличается от монитора и мьютекса.

Семафор — это средство для синхронизации доступа к какому-то ресурсу.

<strong>Его особенность заключается в том, что при создании механизма синхронизации он использует счетчик.</strong>

Счетчик указывает нам, сколько потоков одновременно могут получать доступ к общему ресурсу.
<img data-id="532cb267-686d-430d-aacc-1539d2eb9ffc" data-max-width="850" alt="В чем разница между мьютексом, монитором и семафором - 3" src="https://cdn.javarush.com/images/article/532cb267-686d-430d-aacc-1539d2eb9ffc/1024.jpeg">Семафоры в Java представлены классом <code>Semaphore</code>.

При создании объектов-семафоров мы можем использовать такие конструкторы:

<pre class='lang-java line-numbers'><code>
Semaphore(int permits)
Semaphore(int permits, boolean fair)
</code></pre>
В конструктор мы передаем:
<ul>
<li><p><code><strong>int permits</strong></code> — начальное и максимальное значение счетчика. То есть то, сколько потоков одновременно могут иметь доступ к общему ресурсу;</p></li>
<li><p><code><strong>boolean fair</strong></code> — для установления порядка, в котором потоки будут получать доступ. Если <code>fair</code> = <em>true</em>, доступ предоставляется ожидающим потокам в том порядке, в котором они его запрашивали. Если же он равен <em>false</em>, порядок будет определять планировщик потоков.</p></ul>Классический пример использования семафоров — <a href='https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE%D0%B1_%D0%BE%D0%B1%D0%B5%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D1%85_%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B0%D1%85' rel='nofollow' target='_blank'>задача об обедающих философах</a>.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="433e2831-8242-4394-99c1-c902994a7fce" data-max-width="850" alt="В чем разница между мьютексом, монитором и семафором - 4" src="https://cdn.javarush.com/images/article/433e2831-8242-4394-99c1-c902994a7fce/1024.jpeg"></div></div>Мы немного упростим ее условия, для лучшего понимания.

Представь, что у нас есть 5 философов, которым нужно пообедать.
При этом у нас есть один стол, и одновременно находиться за ним могут не более двух человек. 

Наша задача — накормить всех философов. Никто из них не должен остаться голодным, и при этом они не должны «заблокировать» друг друга при попытке сесть за стол (мы должны избежать deadlock).

Вот как будет выглядеть наш класс философа:

<pre class='lang-java line-numbers'><code>
class Philosopher extends Thread {

   private Semaphore sem;

   // поел ли философ
   private boolean full = false;

   private String name;

   Philosopher(Semaphore sem, String name) {
       this.sem=sem;
       this.name=name;
   }

   public void run()
   {
       try
       {
           // если философ еще не ел
           if (!full) {
               //Запрашиваем у семафора разрешение на выполнение
               sem.acquire();
               System.out.println (name + " садится за стол");

               // философ ест
               sleep(300);
               full = true;

               System.out.println (name + " поел! Он выходит из-за стола");
               sem.release();

               // философ ушел, освободив место другим
               sleep(300);
           }
       }
       catch(InterruptedException e) {
           System.out.println ("Что-то пошло не так!");
       }
   }
}
</code></pre>
А вот код для запуска нашей программы:

<pre class='lang-java line-numbers'><code>
public class Main {

   public static void main(String[] args) {

       Semaphore sem = new Semaphore(2);
       new Philosopher(sem,"Сократ").start();
       new Philosopher(sem,"Платон").start();
       new Philosopher(sem,"Аристотель").start();
       new Philosopher(sem,"Фалес").start();
       new Philosopher(sem,"Пифагор").start();
   }
}
</code></pre>
Мы создали семафор со счетчиком 2, чтобы соответствовать условию: одновременно есть могут только два философа. То есть, одновременно работать могут только два потока, ведь наш класс <code>Philosopher</code> унаследован от <code>Thread</code>!

Методы <code><strong>acquire()</strong></code> и <code><strong>release()</strong></code> класса <code>Semaphore</code> управляют его счетчиком разрешений. Метод <code>acquire()</code> запрашивает разрешение на доступ к ресурсу у семафора. Если счетчик > 0, разрешение предоставляется, а счетчик уменьшается на 1.

Метод <code>release()</code> «освобождает» выданное ранее разрешение и возвращает его в счетчик (увеличивает счетчик разрешений семафора на 1).

Что же у нас получится при запуске программы? Решена ли задача, не передерутся ли наши философы, ожидая своей очереди? :)

Вот какой вывод в консоль мы получили:

<em>Сократ садится за стол
Платон садится за стол
<u>Сократ поел! Он выходит из-за стола
Платон поел! Он выходит из-за стола</u>
Аристотель садится за стол
Пифагор садится за стол
<u>Аристотель поел! Он выходит из-за стола
Пифагор поел! Он выходит из-за стола</u>
Фалес садится за стол
<u>Фалес поел! Он выходит из-за стола</u></em>

У нас все получилось! И хотя Фалесу пришлось обедать в одиночку, думаю, он на нас не в обиде :)

<strong>Ты мог заметить некоторое сходство между мьютексом и семафором.</strong>
 
У них, в общем-то, одинаковое предназначение: синхронизировать доступ к какому-то ресурсу.
<img data-id="cd3b352a-d979-4826-84b7-0a0e5c836035" data-max-width="850" alt="В чем разница между мьютексом, монитором и семафором - 5" src="https://cdn.javarush.com/images/article/cd3b352a-d979-4826-84b7-0a0e5c836035/1024.jpeg">Разница только в том, что мьютекс объекта может захватить одновременно только один поток, а в случае с семафором используется счетчик потоков, и доступ к ресурсу могут получить сразу несколько из них. И это не просто случайное сходство :)

На самом деле <strong>мьютекс — это одноместный семафор</strong>. То есть, это семафор, счетчик которого изначально установлен в значении 1. Его еще называют «двоичным семафором», поскольку его счетчик может иметь только 2 значения — 1 («свободно») и 0 («занято»).

Вот и все! Как видишь, все оказалось не таким уж и запутанным :) Теперь, если ты захочешь изучить тему многопоточности подробнее в Интернете, тебе будет чуть проще ориентироваться в понятиях. До встречи на следующих уроках!