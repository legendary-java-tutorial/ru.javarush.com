Многопоточность в Java
<p>----------------------------------------</p>
Прежде, чем узнать про потоки Java, давайте заглянем в недалёкое будущее. Представьте, что вы подали резюме и прошли собеседование. Вас и пару дюжин будущих коллег пригласили на работу в большую Software-компанию. Среди прочих хлопот нужно подать бумажные документы ...
<p>----------------------------------------</p>
<h2>Введение</h2>Прежде, чем узнать про потоки Java, давайте заглянем в недалёкое будущее. Представьте, что вы подали резюме и прошли собеседование. Вас и пару дюжин будущих коллег пригласили на работу в большую Software-компанию. Среди прочих хлопот нужно подать бумажные документы для трудоустройства уставшему сотруднику HR-отдела.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="2c598518-12ed-4340-b90e-d93ccdc2edb4" data-max-width="710" alt="Многопоточность в Java - 1" src="https://cdn.javarush.com/images/article/2c598518-12ed-4340-b90e-d93ccdc2edb4/1024.jpeg"></div></div>Чтобы ускорить процесс, претендентов на должность можно разделить на две группы и распределить их между двумя HR-менеджерами (если таковые есть в компании). В результате мы получаем ускорение процесса за счёт параллельной (<strong>parallel</strong>) работы по оформлению.  
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="dfdf82b7-3e6c-43ae-8487-c3a9edf82af3" data-max-width="710" alt="Многопоточность в Java - 2" src="https://cdn.javarush.com/images/article/dfdf82b7-3e6c-43ae-8487-c3a9edf82af3/1024.jpeg"></div></div>Если же кадровик в компании один, то придётся как-то выкручиваться. Например, можно снова- таки разбить всех на две группы, например, собеседовать поочерёдно девушек и юношей.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="1aa9d9e7-064b-47f7-b07a-298574392956" data-max-width="710" alt="Многопоточность в Java - 3" src="https://cdn.javarush.com/images/article/1aa9d9e7-064b-47f7-b07a-298574392956/1024.jpeg"></div></div>Или по другому принципу: так как в нижней группе больше народа, будем чередовать на одного юношу двух девушек.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="b71a2a0c-089c-4540-beff-2eb5603df77b" data-max-width="710" alt="Многопоточность в Java - 4" src="https://cdn.javarush.com/images/article/b71a2a0c-089c-4540-beff-2eb5603df77b/1024.jpeg"></div></div> Такой способ организации работы называется <strong>многопоточным</strong>. Наш утомлённый кадровик переключается на разные группы для оформления из них очередного сотрудника. Групп, может быть, одиннадцать, а кадровиков – четыре. В этом случае многопоточная (<strong>multithreading</strong>) обработка будет происходить параллельно несколькими HR-ами, которые могут брать очередного человека из любой группы для обработки его документов.
<h2>Процессы</h2>Процессом (<strong>process</strong>) в данном случае будет организация работы приёма документов. В организации можно выделить несколько процессов: бухгалтерский учёт, разработка ПО, встречи с клиентами, работа склада и т. д. На каждый процесс выделены ресурсы:  помещение, сотрудники для его исполнения.

Процессы изолированы друг от друга: у кадровиков отсутствует доступ в бухгалтерскую базу, а менеджеры по работе с клиентами не бегают по складу. Если процесс должен получить доступ к чужим ресурсам, необходимо наладить межпроцессное взаимодействие: служебные записки, совместные совещания.
<h2>Потоки</h2>Работа в процессе организована в виде потоков (<code>java thread</code>). Для отдела кадров, поток – это организация работы по обслуживанию группы. На самой первой картинке – один поток, последующих трёх – два. Внутри процесса потоки могут выполняться параллельно – два кадровика принимают две или более группы будущих сотрудников.

Взаимодействие кадровиков с группами – обработку потоков внутри процесса – называют <strong>синхронизацией потоков</strong>. На рисунках оформления одним кадровиком двух групп видны показаны способы: равномерный (девушка – юноша – девушка – юноша) и с разными приоритетами (две девушки чередуются с одним юношей).

Потоки имеют доступ к ресурсам процесса, к которому они относятся: группам к кадровику даны образцы бланков заявлений, ручки для заполнения документов. Но если потоки взаимодействуют с общими для них вещами – то возможны казусы. Если кадровик попросит крикнуть имя последнего человека в очереди – то, в случае с двумя группами, он не уверен заранее, что услышит женское имя или мужское. Подобные конфликты доступа к данным, блокировки и способы их разрешения – очень важная тема.
<h2>Состояния потока</h2>Каждый поток пребывает в одном из следующих состояний (state):
<ul>
<li>Создан (<code>New</code>) – очередь к кадровику готовится, люди организуются.</li>
<li>Запущен (<code>Runnable</code>) – наша очередь выстроилась к кадровику и обрабатывается.</li>
<li>Заблокирован (<code>Blocked</code>) – последний в очереди юноша пытается выкрикнуть имя, но услышав, что девушка в соседней группе начала делать это раньше него, замолчал. </li>
<li>Завершён (<code>Terminated</code>) — вся очередь оформилась у кадровика и в ней нет необходимости. </li>
<li>Ожидает(<code>Waiting</code>) – одна очередь ждёт сигнала от другой.</li>
</ul>Организация потоков и их взаимодействие – это основа эффективной работы процессов.
<h2>Вернемся в IT-мир</h2>В XXI веке многопоточное и параллельное выполнение стало актуальным. С 90-х годов прошлого века многозадачные операционные системы Windows, MacOS и Linux прочно обосновались на домашних компьютерах. В них часто можно встретить четырёх- и более ядерные процессоры. Число параллельных блоков GPU-видеокарт уже перевалило за тысячу. Популярные программы пишутся с учетом многопоточности (multithreading), например, современные версии ПО обработки графики, видео или оперирующих большим объемом данных: Adobe Photoshop, WinRar, Mathematica, современные игры.

Многопоточность Java – очень важная, востребованная и сложная тема. Поэтому в курсе JavaRush встречается много задач, чтобы разобраться с ней очень хорошо. Java-примеры на многопоточность помогут освоить основные нюансы и тонкости этой области, синхронизации работы потоков.
<h2>Процесс</h2><strong>Process</strong> (процесс) – выполняющийся экземпляр программы, которому Операционная Система (ОС) выделила память, процессорное время/ядра и прочие ресурсы. Важно, что память выделяется отдельно, адресные пространства различных процессов недоступны друг другу. Если процессам необходимо обмениваться данными, они могут это сделать с помощью файлов, каналов и иных способов межпроцессного взаимодействия.
<h2>Поток</h2>Java <code>Thread</code> (поток). Иногда, чтобы не путать с другими классами Java – <code>Stream</code> и подобными, потоки Java часто переводят как нить. Они используют выделенные для процесса ресурсы и являются способом выполнения процесса. Главный поток выполняет метод <code>main</code> и завершается. При выполнении процесса могут порождаться дополнительные потоки (дочерние). Потоки одного процесса могут между собой обмениваться данными. Многопоточность Java требует учитывать синхронизацию данных, не забывайте об этом.

В Java процесс завершается тогда, когда закончил работу последний его поток. Для фоновых задач поток можно запустить как демон (<code>daemon</code>), отличие которого от обычного в том, что они будут принудительно завершены при окончании работы всех не-<code>daemon</code> потоков процесса. 
<h2>Первое многопоточное приложение</h2>Существует более полудюжины способов создания потоков, в рамках JavaRush курса мы их подробно разберём. Для начала познакомимся с одним из базовых.

Имеется специальный класс <code>Thread</code> в методе <code>run()</code> которого необходимо написать код, реализующий логику программы. После создания потока, можно запустить его, вызвав метод <code>start()</code>.

Напишем демонстрационную программу, реализующую пример многопоточности  Java.

<pre class='lang-java line-numbers'><code>
class PeopleQueue extends Thread    {// Наша очередь из сотрудников, наследник класса Thread
    private String[] names;

    PeopleQueue(String... names) {// Конструктор, аргумент- массив имен сотрудников
        this.names = names;
    }

    @Override
    public void run() { // Этот метод будет вызван при старте потока
        for (int i = 0; i < names.length; i++) { // Вывод в цикле с паузой 0.5 сек очередного сотрудника
            System.out.println("Обработаны документы: " + names[i]);
            try {
                sleep(500); // Задержка в 0.5 сек
            } catch (Exception e) {}
        }
    }
}

public class HR    {// Класс для демонстрации работы потока
    public static void main(String[] args) {
        // Создаем две очереди
        PeopleQueue queue1 = new PeopleQueue("Иван","Сергей","Николай","Фердинанд","Василий");
        PeopleQueue queue2 = new PeopleQueue("Мария","Людмила","Алиса","Карина","Ольга");

        System.out.println("Начали!"); // Сообщение из главного потока программы
        queue1.start();    //Запускаем одну очередь (дочерний поток)
        queue2.start(); //Запускаем вторую (дочерний поток)
    }
}
</code></pre>
Запустим программу. В консоли виден вывод сообщения главным потоком. Далее, каждый дочерний поток <code>queue1</code> и <code>queue2</code> поочередно выводят сообщения в общую для них консоль об очередном обработанном сотруднике. Один из возможных вариантов работы программы:

<pre class='lang-java line-numbers'><code>
Начали!
Обработаны документы: Мария
Обработаны документы: Иван
Обработаны документы: Людмила
Обработаны документы: Сергей
Обработаны документы: Алиса
Обработаны документы: Николай
Обработаны документы: Карина
Обработаны документы: Фердинанд
Обработаны документы: Ольга
Обработаны документы: Василий

Process finished with exit code 0
</code></pre>
<strong>Многопоточность в Java</strong> – тема трудная и многосторонняя. Умение писать код с использованием параллельных, многозадачных и многопоточных вычислений поможет вам эффективно реализовать задачи на современных многоядерных процессорах и кластерах, состоящих из множества компьютеров.