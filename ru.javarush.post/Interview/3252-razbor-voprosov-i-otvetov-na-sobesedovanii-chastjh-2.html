Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 2
<p>----------------------------------------</p>
И снова всем привет! Продолжаем искать ответы на 250+ вопросов для Junior, Middle и Senior разработчиков. Вопросы довольно интересные, и мне самому нравится их разбирать: в такие моменты можно обнаружить пробелы в теоретических знаниях...
<p>----------------------------------------</p>
И снова всем привет!

Продолжаем искать ответы на <a href="https://dou.ua/lenta/articles/interview-questions-java-developer/" rel="nofollow" target="_blank">250+ вопросов</a> для Junior, Middle и Senior разработчиков. Вопросы довольно интересные, и мне самому нравится их разбирать: в такие моменты можно обнаружить пробелы в теоретических знаниях, причем в самых неожиданных местах.<img data-max-width="800" data-id="bd30dc30-2338-428a-9dee-0a4c8ccacba8" src="https://cdn.javarush.com/images/article/bd30dc30-2338-428a-9dee-0a4c8ccacba8/800.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 2 - 1">С предыдущей частью можно ознакомиться <a href="https://javarush.com/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">в этой статье</a>. 
 
Но прежде чем мы начнём, я хочу напомнить, что:<ol>
<li>Вопросы, которые пересекаются с <a href="https://javarush.com/groups/posts/2590-top-50-java-core-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">этой серией статей</a>, я буду пропускать, чтобы лишний раз не дублировать информацию. Рекомендую прочитать эти материалы, так как там представлены самые частые (популярные) вопросы для собеседований по Java Core. </li>
<li>Вопросы на DOU представлены на украинском, но у меня тут будет все на русском.</li>
<li>Ответы можно было и расписать подробнее, но я не буду, так как тогда ответ на каждый вопрос может затянуть на целую статью. Да и так подробно вас ни на одном собесе не спросят.</li>

</ol>По надобности буду оставлять ссылки, для более глубокого изучения. Полетели!<h4>11. Назовите все методы класса Object</h4>У класса Object есть 11 методов:<ul>
<li><span class="code">Class&lt;?&gt; getClass()</span> — получение класса текущего объекта;</li>
<li><span class="code">int hashCode()</span> — получение хеш кода текущего объекта;</li>
<li><span class="code">boolean equals​(Object obj)</span> — сравнение текущего объекта с другим;</li>
<li><span class="code">Object clone()</span> — создание и возвращение копии текущего объекта;</li>
<li><span class="code">String toString()</span> — получение строкового представления объекта;</li>
<li><span class="code">void notify()</span> — пробуждение одного потока, ожидающего на мониторе данного объекта (выбор потока рандомный);</li>
<li><span class="code">void notifyAll()</span> — пробуждение всех потоков, ожидающего на мониторе данного объекта;</li>
<li><span class="code">void wait()</span> — переключает текущий поток в режим ожидания (замораживает его) на текущий монитор, работает только в synchronized блоке, пока какой-нибудь notify или notifyAll не разбудит поток;</li>
<li><span class="code">void wait(long timeout)</span> — также замораживает текущий поток на текущий монитор (на текущий synchronized), но уже с таймером выхода из этого состояния (ну или опять же: пока notify или notifyAll не разбудит);</li>
<li><span class="code">void wait(long timeout, int nanos)</span> — метод, аналогичный вышеописанному, но с более точным таймеров выхода из заморозки;</li>
<li><span class="code">void finalize()</span> — перед удалением этого объекта сборщиком мусора вызывается  этот метод (напоследок). Он используется для очистки занимаемых ресурсов.</li>
</ul>Для корректного использования методов <span class="code">hashCode</span>, <span class="code">equals​</span>, <span class="code">clone</span>, <span class="code">toString</span>, finalize их необходимо переопределять, учитывая текущую задачу и обстоятельства.<h4>12. В чем различие между try-with-resources и try-catch-finally при работе с ресурсами?</h4>Как правило при использовании <span class="code">try-catch-finally</span> блок final применяли для закрытия ресурсов. В Java 7 появился новый вид оператора <span class="code">try-with-resources</span>, аналог <span class="code">try-catch-finally</span> для освобождения ресурсов, но более компактный и удобочитаемый.

Давайте вспомним, как выглядит <span class="code">try-catch-finally</span>:

<pre class="language-java line-numbers"><code>
String text = "some text......";
BufferedWriter bufferedWriter = null;
try {
   bufferedWriter = new BufferedWriter(new FileWriter("someFileName"));
   bufferedWriter.write(text); 
} catch (IOException e) {
   e.printStackTrace();
} finally {
   try {
       bufferedWriter.close();
   } catch (IOException e) {
       e.printStackTrace();
   }
}
</code></pre>
А теперь давайте перепишем этот код, но с использованием <span class="code">try-with-resources</span>:

<pre class="language-java line-numbers"><code>
String text = "some text......";
try(BufferedWriter bufferedWriter =new BufferedWriter(new FileWriter("someFileName"))) {
   bufferedWriter.write(text);
} catch (IOException e) {
   e.printStackTrace();
}
</code></pre>
Как-то проще стало, не находите? Помимо упрощения, ещё есть пара моментов:<ol>
<li><p>В <span class="code">try-with-resources</span> ресурсы, объявленные в скобках (которые будут закрыты), должны имплементировать AutoCloseable интерфейс и его единственный метод — <span class="code">close()</span>.</p>
 
<p>Метод <span class="code">close</span> выполняется в <span class="text-bold">неявном finally блоке</span>, иначе как программа поймет, как именно данный закрывать ресурс?</p>
 
<p>Но, скорее всего, вы редко будете писать свои имплементации ресурсов и их метод закрытия.</p></li>
<li><p>Последовательность выполнения блоков:</p><ol>
<li>Блок <span class="code">try</span>.</li>
<li>Неявный <span class="code">finally</span>.</li>
<li>Блок <span class="code">catch</span>, который ловит исключения в предыдущих шагах.</li>
<li>Явный <span class="code">finally</span>.</li></ol><p></p>
<p>Как правило исключения, которые выпали ниже по списку, перебивают те, что выпали выше.</p></li>

</ol>Представьте ситуацию, что при использовании <span class="code">try-catch-finally</span> у вас в <span class="code">try</span> падает исключение. Соответственно, сразу начинает исполняться определенный блок <span class="code">catch</span>, в котором вы прописываете другое исключение (например, с сообщением, которое более подробно описывает ошибку), и вы хотите, чтобы метод прокидывал это исключение дальше. Следом идет выполнение блока <span class="code">finally</span>, и в нём тоже падает исключение. Но уже другое.
 
Какое же из этих двух исключений в итоге выбросит данный метод? Исключение, которое выбросил блок <span class="code">finally</span>!
 
Но и тут есть один момент с <span class="code">try-with-resources</span>. 
 
Теперь рассмотрим поведение <span class="code">try-with-resources</span> в этой же ситуации. У нас падает исключение в блоке <span class="code">try</span> при попытке закрытия ресурсов в методе <span class="code">close()</span>, то есть в неявном <span class="code">finally</span>.
 
Какое же из этих исключений отловит <span class="code">catch</span>? То, которое выбросил блок <span class="code">try</span>! Исключение из неявного <span class="code">finally</span> (из метода <span class="code">close()</span>) будет игнорироваться. Это игнорирование еще называют подавлением исключений.<h4>13. Что такое побитовые операции?</h4><span class="text-bold">Побитовые операции</span> — это операции над цепочками битов, которые включают в себя логические операции и побитовые сдвиги.
 
<span class="text-bold">Логические операции:</span><ul>
<li><p>побитовое <span class="text-bold">И</span> — сравнивает битовые значения, и по ходу этого любой бит, установленный в 0 (false), устанавливает соответствующий бит в результате как 0. То есть, если в обоих сравниваемых значениях бит был 1 (true), в результирующем тоже будет 1.</p>
<p>Обозначается как — <span class="text-bold">AND</span>, <span class="text-bold">&amp;</span></p>
<p>Пример: 10111101 &amp; 01100111 = 00100101</p></li>
 
<li><p>побитовое <span class="text-bold">ИЛИ</span> — операция, обратная предыдущей. Любой бит, установленный в 1, устанавливает аналогичный бит в результате как 1.  И соответственно, если в обоих сравниваемых значениях бит был 0, в результирующем тоже будет 0.</p>
<p>Обозначается как — <span class="text-bold">OR</span>, <span class="text-bold">|</span></p>
<p>Пример: 10100101 | 01100011 = 11100111</p></li>
 
<li><p>побитовое <span class="text-bold">НЕ</span> — применяется к одному значению, переворачивает (инвертирует) биты. То есть, те биты что были 1, станут 0; а те что были 0, станут 1.</p>
<p>Обозначается как — <span class="text-bold">NOT</span>, <span class="text-bold">~</span></p>
<p>Пример: ~10100101 = 01011010</p></li>
 
<li><o>побитовое <span class="text-bold">исключающее ИЛИ</span> — сравнивает битовые значения, и если в обоих значениях бит равен 1, то результат будет 0, также если в обоих значениях бит 0, результат будет 0. То есть, чтобы результат был равен 1, нужно, чтобы только один из битов был равен 1, а второй равен 0.<p></p>
<p>Обозначается как — <span class="text-bold">XOR</span>, <span class="text-bold">^</span></p>
<p>Пример: 10100101 ^ 01100011 = 11000110</p></o></li>
</ul><span class="text-bold">Побитовые сдвиги</span> — <span class="text-bold">&gt;&gt;</span> или <span class="text-bold">&lt;&lt;</span> сдвигают биты значения в указанную сторону, на указанное число. Освободившиеся позиции заполняются нулями.

Например:<ol>
<li>01100011 &gt;&gt; 4 = 00000110</li>
<li>01100011 &lt;&lt; 3 = 00011000</li>
</ol>Также есть исключение при сдвиге вправо отрицательного числа.

Как вы помните, первый бит отвечает за знак, и если этот бит равен 1, то число отрицательное.
 
Если вы будете двигать отрицательное число, освободившиеся позиции будут заполняться уже не нулями, а единицами, так как необходимо поддерживать знаковый бит. 

Например: 10100010 &gt;&gt; 2 = 11101000
 
При этом в Java существует дополнительный оператор беззнакового сдвига вправо &gt;&gt;&gt;

Данный оператор — аналог &gt;&gt;,  при сдвиге которым освободившиеся позиции заполняются 0, независимо от того, отрицательное число или положительное.

Например: 10100010 &gt;&gt;&gt; 2 = 00101000
 
Подробнее о побитовых операциях читаем <a href="https://javarush.com/groups/posts/1925-pobitovihe-operacii" target="_blank">вот тут</a>.<img data-max-width="512" data-id="9edb3020-ded1-4a63-b355-6a44424bf89f" src="https://cdn.javarush.com/images/article/9edb3020-ded1-4a63-b355-6a44424bf89f/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 2 - 2">В качестве примеров использования побитовых сдвигов в Java, вы можете привести метод <span class="code">hash()</span> у HashMap-ы, который используется для определения специального внутреннего хеш кода ключа:<img data-max-width="512" data-id="edeab2f0-4079-4959-af2d-5e57c3909774" src="https://cdn.javarush.com/images/article/edeab2f0-4079-4959-af2d-5e57c3909774/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 2 - 3">Этом метод позволяет равномерно распределять данные в HashMap, чтобы минимизировать количество коллизий.<h4>14. Объекты каких стандартных классов immutable есть в Java?</h4><span class="text-bold">Immutable</span> — это объект, который не позволяет изменять свои первоначальные параметры. Возможно, он имеет методы, которые возвращают новые объекты данного типа, с параметрами, которые вы хотели изменить.
 
Некоторые стандартные immutable объекты:<ul>
<li>безусловно, самый известный immutable объект в Java — это String;</li>
<li>экземпляры классов-оберток, которые оборачивают стандартные типы: Boolean, Character, Byte, Short, Integer, Long, Double, Float; </li>
<li>объекты, которые как правило используются для особо БОЛЬШИХ чисел —  BigInteger и BigDecimal; </li>
<li>объект, который является единицей в стектрейсах (например, в стектрейсе исключений) StackTraceElement;</li>
<li>объект класса File — может изменять файлы, но при этом сам по себе он неизменен;</li>
<li>UUID — который часто используется как уникальный id элементов;</li>
<li>все объекты классов пакета java.time;</li>
<li>Locale — используется для определения географического, политического или культурного региона.</li>
 
</ul><h4>15. Каковы преимущества immutable object перед обычными объектами?</h4><ol>

<li>Такие объекты — <span class="text-bold">безопасные при использовании в многопоточной среде</span>. Используя их, вы можете не беспокоиться о том, что  будут утеряны данные из-за состояния гонки потоков. В отличие от работы с обычными объектами: в таком случае вам придется очень хорошо продумать и проработать механизмы использования объекта в параллельной среде.</li>
<li>Immutable объекты являются хорошими ключами в map, ведь если использовать изменяемый объект, а затем объект изменит свое состояние, при использовании HashMap может возникнуть путаница: объект все еще будет присутствовать, и если использовать <span class="code">containsKey()</span>, то его можно и не найти.</li>
<li>Immutable объекты отлично подходят для хранения неизменных (константных) данных, которые ни в коем случае не должны быть изменены во время работы программы.</li>
<li>“Атомарность по отношению к сбою” — если immutable объект выбросит исключение, то он всё равно не останется в нежелательном (сломанном) состоянии.</li>
<li>Данные классы просты в тестировании.</li>
<li>Не нужны такие дополнительные механизмы как конструктор копирования и реализация клона.</li>

</ol><h3>Вопросы по ООП</h3><img data-max-width="512" data-id="75980fe1-af72-4a33-8154-0fb7b1ce2b7c" src="https://cdn.javarush.com/images/article/75980fe1-af72-4a33-8154-0fb7b1ce2b7c/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 2 - 4"><h4>16. В чём преимущества ООП в целом и по сравнению с процедурным программированием?</h4>Итак, преимущества ООП:<ol>
<li>Сложные приложения писать проще, чем процедурным программированием, так как у нас все разбито на маленькие модули — объекты, которые взаимодействуют между собой — и в итоге программирование сводится ко взаимоотношениями между объектами.</li>
<li>Приложения, написанные с помощью ООП, гораздо более простые в модификации (при соблюдении концепций проектирования).</li>
<li>Так как данные и операции над ними образуют единую сущность, они не размазываются по всему приложению (что нередко бывает при процедурном программировании).</li>
<li>Инкапсуляция информации защищает наиболее критичные данные для работы от пользователя.</li>
<li>Возможно переиспользование одного и того же кода, с разными данными, ведь классы позволяют создавать множество объектов, у каждого из которых есть собственные значения атрибутов.</li>
<li>Наследование и полиморфизм также позволяют переиспользовать и расширять уже существующий код (вместо дублирования похожего функционала).</li>
<li>Более простая расширяемость приложения, нежели при процедурном подходе.</li>
<li>Подход ООП дает возможность абстрагироваться от деталей реализации.</li>
 
</ol><h4>17. Расскажите, какие недостатки есть в ООП</h4>К сожалению, и они присутствуют:<ol>

<li>ООП требует большой объём теоретических знаний, который нужно освоить, прежде чем вы сможете что-либо написать.<img data-max-width="512" data-id="5f6c7019-9c2d-4587-b627-4fb602e65c68" src="https://cdn.javarush.com/images/article/5f6c7019-9c2d-4587-b627-4fb602e65c68/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 2 - 5"></li>
<li>Идеи ООП не так просты для понимания и применения на практике (нужно быть в душе немного философом).</li>
<li>При применении ООП немного снижается производительность функционирования ПО из-за более сложной организации системы.</li>
<li>Для ООП подхода требуется больше памяти, так как всё состоит из классов, интерфейсов, методов, которые занимают гораздо больше памяти, нежели обычные переменные.</li>
<li>Временные затраты на первоначальный анализ больше, чем при процедурном.</li>
 
</ol><h4>18. Что такое статический и динамический полиморфизм</h4>Полиморфизм дает возможность объектам вести себя по-разному для одного и того же класса или интерфейса.

Существует два вида полиморфизма, которые еще известны как <span class="text-bold">ранее</span> и <span class="text-bold">позднее связывание</span>.

<span class="text-bold">Статический полиморфизм, или ранее связывание:</span><ul>

<li>происходит во время компиляции (на ранней стадии жизненного цикла программы);</li>
<li>решает, какой метод выполнять во время компиляции;</li>
<li>перегрузка метода — это пример статического полиморфизма;</li>
<li>к раннему связыванию относятся приватные, статические и терминальные методы; </li>
<li>наследование не участвует в раннем связывании;</li>
<li>в статическом полиморфизме участвуют не конкретные объекты, а информация о классе, тип которого представлен слева от имени переменной.</li>

</ul><span class="text-bold">Динамический полиморфизм, или позднее связывание:</span><ul>
<li>происходит во время выполнения (во время работы программы);</li>
<li>динамический полиморфизм решает, какая конкретно реализация будет у метода во время выполнения;</li>
<li>переопределение метода — пример динамического полиморфизма;</li>
<li>позднее связывание — это назначение конкретного объекта, ссылки его типа или его суперкласса;</li>
<li>наследование связано с динамическим полиморфизмом.</li>

</ul>Подробнее о различиях раннего и позднего связывания можно прочесть <a href="https://javarush.com/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java" target="_blank">вот в этой статье</a>.<h4>19. Дайте определение принципа абстракции в ООП</h4><span class="text-bold">Абстракция</span> в ООП — это способ выделить набор значимых характеристик объекта, исключив незначимые детали.

То есть при проектировании программы с ООП подходом вы сосредотачиваетесь на моделях в общем, без углубления в детали их реализации. В Java за абстракцию отвечают <a href="https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih" target="_blank">интерфейсы</a>.

Например, у вас есть машина, и это будет интерфейс. А различные взаимодействия с ней — например, завести двигатель, использовать коробку передач — это функции, которые мы используем без углубления в детали реализации.

Ведь в тот момент, когда вы ведете машину, вы не думаете, как конкретно коробка передач исполняет своё предназначение, или как ключ заводит двигатель, или каким именно образом руль поворачивает колеса. 

И если даже реализацию одной из этой функциональности заменить (например, двигатель), вы этого можете и не заметить. Вам это не важно: вы не углубляетесь в детали реализации. Вам важно чтобы действие выполнялось.

Собственно, это и есть абстрагирование от деталей реализации.
 
На этом моменте мы сегодня и остановимся: продолжение следует!<img data-max-width="512" data-id="e1f28b87-b6e7-425e-a1e9-64572dc81b52" src="https://cdn.javarush.com/images/article/e1f28b87-b6e7-425e-a1e9-64572dc81b52/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 2 - 6"><table><tbody>
<tr><th>
Другие материалы серии:
</th></tr><tr><td>
<ul><li><a href="https://javarush.com/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 1</a></li>
<li><a href="https://javarush.com/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3</a></li>
<li><a href="https://javarush.com/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 4</a></li>
<li><a href="https://javarush.com/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5</a></li>
<li><a href="https://javarush.com/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6</a></li>
<li><a href="https://javarush.com/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 7</a></li>
<li><a href="https://javarush.com/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 8</a></li>
<li><a href="https://javarush.com/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 9</a></li>
<li><a href="https://javarush.com/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10</a></li>
<li><a href="https://javarush.com/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 11</a></li>
<li><a href="https://javarush.com/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 12</a></li>
<li><a href="https://javarush.com/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 13</a></li>
<li><a href="https://javarush.com/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 14</a></li>
<li><a href="https://javarush.com/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 15</a></li>
<li><a href="https://javarush.com/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 16</a></li>
</ul>
</td></tr></tbody></table>