Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10
<p>----------------------------------------</p>
Привет! Как много часов нужно потратить, чтобы стать в чём-то мастером? Часто слышал что-то вроде: “Чтобы стать мастером в любом деле, нужно потратить 10000 часов”...
<p>----------------------------------------</p>
Привет!
 
Как много часов нужно потратить, чтобы стать в чём-то мастером? Часто слышал что-то вроде: “Чтобы стать мастером в любом деле, нужно потратить 10000 часов”. Пугающая цифра, не так ли? 

<img data-max-width="800" data-id="6e514b6b-2f0a-42fb-b59e-f008956f054c" src="https://cdn.javarush.com/images/article/6e514b6b-2f0a-42fb-b59e-f008956f054c/800.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10 - 1">Тем не менее, мне интересно, а правда ли это? И я постоянно пытаюсь прикидывать, сколько часов я уже вложил в овладение программистским искусством.
 
И когда я перешагну те заветные 10000 часов и стану мастером, почувствую ли я эту разницу? Или я уже их давно перешагнул, не осознав этого?
 
Так или иначе, чтобы стать программистом, не нужно вкладывать такое огромное количество времени. Главное — использовать его с умом. 
 
Ваша первостепенная цель — пройти собеседование. А на собеседованиях новичков в первую очередь как раз спрашивают теорию, поэтому вы должны быть в ней сильны. 
 
Собственно, при самой подготовке к собеседованию ваша задача — обнаружить все ваши пробелы в базовой теории Java-разработчика и покрыть их знаниями. И сегодня я вам помогу в этом деле, ведь я тут, чтобы продолжить разбор самых популярных вопросов. Итак, продолжим!
<h4>89. Чем отличается ArrayList от LinkedList?</h4>Это один из самых популярных вопросов наравне с вопросом о внутреннем устройстве <span class="code">HashMap</span>. Ни одно собеседование не обходится без него, и поэтому ответ на него у вас должен “отскакивать от зубов”.
 
Помимо очевидного — разного названия — они отличаются внутренним устройством. Ранее мы разбирали внутренние устройство и <span class="code">ArrayList</span>-а и <span class="code">LinkedList</span>-а, поэтому вдаваться в детали их реализации я не буду.
 
Лишь напомню, что <span class="code">ArrayList</span> реализован на основе внутреннего массива, который по надобности увеличивается по формуле:

<pre class="language-java line-numbers"><code>
&lt;размерТекущегоМассива&gt; * 3 / 2  + 1
</code></pre>
В то же время <span class="code">LinkedList</span> реализован на основе внутреннего двухсвязного списка, то есть, каждый элемент имеет ссылку на предыдущий и следующий, исключая значения, которые являются началом/концом списка.
 
Этот вопрос любят задавать в формате: “Что лучше — <span class="code">ArrayList</span> или <span class="code">LinkedList</span>?”, надеясь вас подловить. Ведь если вы в качестве ответа укажете на один из них, это будет неправильный ответ.
<img data-max-width="512" data-id="d3701523-2a0b-47c0-a1e5-c7bf5e0711e5" src="https://cdn.javarush.com/images/article/d3701523-2a0b-47c0-a1e5-c7bf5e0711e5/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10 - 2">Вместо этого вам стоит уточнить, о какой конкретной ситуации идет речь — доступ по индексу или вставка в середину списка. В зависимости от ответа вы сможете объяснить свой выбор.
 
Ранее я уже описывал, как работает <span class="code">ArrayList</span> и <span class="code">LinkedList</span> в той или иной ситуации. Давайте подытожим это, поставив их в один ряд для сравнения:
 
<span class="text-bold">Добавление элемента (add)</span><ol>
<li><p>Добавление нового элемента без указания индекса как местоположения будет происходить автоматически в конец обоих списков. В <span class="code">LinkedList</span> новый элемент станет новым хвостом (происходит только перезаписывание пары ссылок — алгоритмическая сложность <span class="text-bold">O(1)</span>).</p>    

<p>В <span class="code">ArrayList</span> будет добавлен новый элемент в последнюю пустую ячейку массива —  <span class="text-bold">O(1)</span>.</p></li>

<li><p>Добавление элемента по индексу как правило подразумевает вставку  примерно в середину списка. В <span class="code">LinkedList</span> сперва будет вестись поиск нужного места с помощью перебора  элементов с “хвоста” и “головы” — <span class="text-bold">O(n/2)</span>, а после — вставка значения путем переопределения ссылок элементов, между которыми вставляется новый — <span class="text-bold">O(1)</span>. Суммарная алгоритмическая сложность данного действия будет <span class="text-bold">O(n/2)</span>. </p>

<span class="code">ArrayList</span> в данной ситуации по индексу находит элемент — <span class="text-bold">O(1)</span>, и все элементы справа (включая элемент, который уже хранится по данному индексу) двигаются на одну единицу вправо (при этом возможно понадобится создание нового списка и копирование элементов в него) — <span class="text-bold">O(n/2)</span>. Суммарная сложность — <span class="text-bold">O(n/2)</span>.<p></p></li>

<li><p>Добавление элемента в начало списка в <span class="code">LinkedList</span> будет ситуация схожая с добавлением в конец: новый элемент станет новой “головой” — <span class="text-bold">O(1)</span>, в то же время когда <span class="code">ArrayList</span>-у нужно будет двигать все элементы вправо — <span class="text-bold">O(n)</span>.</p></li>

</ol>Итог: в <span class="code">LinkedList</span> алгоритмическая сложность будет колебаться от <span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span>. То есть, чем ближе вставка к концу или началу списка, тем она быстрее. В то же время у <span class="code">ArrayList</span> она колеблется от <span class="text-bold">O(1)</span> до <span class="text-bold">O(n)</span>: чем вставка ближе к концу списка, тем она быстрее.
 
<span class="text-bold">Задание элемента (set)</span>
 
Данная операция записывает элемент в указанную позицию в списке, перезаписывая предыдущий, если он есть. 
 
В <span class="code">LinkedList</span> эта операция будет схожа с добавлением, т.к. самая большая сложность тут — поиск элемента. Перезапись элемента будет проходить путем перезаписывания пары ссылок, поэтому тут также алгоритмическая сложность будет колебаться от <span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span> в зависимости от удаленности позиции от конца или начала списка.
 
В то время в <span class="code">ArrayList</span> для этой операции по индексу будет найдена нужная ячейка, а в нее записан новый элемент. Поиск по индексу, как и данная операция, имеет алгоритмическую сложность <span class="text-bold">O(1)</span>. 
 
<span class="text-bold">Взять элемент по индексу (get)</span>

В <span class="code">LinkedList</span> взятие элемента будет происходить по тому же принципу, что и поиск для других операций — в зависимости от удаленности от конца или начала, т.е. от <span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span>. 
 
В <span class="code">ArrayList</span>, как я и сказал ранее, поиск элемента в массиве по индексу имеет сложность <span class="text-bold">O(1)</span>.
 
<span class="text-bold">Удалить элемент по индексу (remove)</span>
 
Для <span class="code">LinkedList</span> тут тоже срабатывает его принцип действия: сперва находится элемент, а потом происходит перезаписывание ссылок — соседи элемента начинают ссылаться друг на друга, теряя ссылки на данный элемент, который впоследствии будет удален сборщиком мусора. То есть, алгоритмическая сложность всё такая же — от <span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span>.
 
Для <span class="code">ArrayList</span> данная операция больше схожа с операцией добавления нового элемента (add). Сперва находится искомый элемент — <span class="text-bold">O(1)</span>, потом он удаляется, и все элементы, которые были справа от него перемещаются на одну единицу влево, чтобы закрыть образовавшуюся брешь. Операция удаления будет иметь ту же алгоритмическую сложность, что и операция добавления — от <span class="text-bold">O(1)</span> до <span class="text-bold">O(n)</span>. Чем удаление ближе к концу списка, тем меньшая у него алгоритмическая сложность.
 
Собственно, это были все основные операции.
 
Напоминаю: при сравнении этих двух списков вам нужно уточнить, о какой конкретной ситуации идёт речь, и тогда уже и можно однозначно ответить на поставленный вопрос. 
<h4>90. Чем отличается ArrayList от HashSet?</h4>Если <span class="code">ArrayList</span> и <span class="code">LinkedList</span> можно было сравнить по операциям — где кто лучше — то с <span class="code">ArrayList</span> с <span class="code">HashSet</span> сравнить уже не так просто, ведь это совершенно разные коллекции.
 
Можно сравнить одно сладкое блюдо с другим, но с мясным уже получится — больно уж они разные.
 
Тем не менее, я попробую привести их некоторые различия:<ul>
<li><p><span class="code">ArrayList</span> реализует интерфейс <span class="code">List</span>, в то время как <span class="code">HashSet</span> реализует интерфейс <span class="code">Set</span>;</p></li>

<li><p>В <span class="code">ArrayList</span> возможен доступ по индексу элемента: операция <span class="code">get</span> имеет алгоритмическую сложность <span class="text-bold">O(1)</span>, а в <span class="code">HashSet</span> необходимый элемент можно получить лишь путём перебора, а это у нас от <span class="text-bold">O(1)</span> до <span class="text-bold">O(n)</span>;</p></li>

<li><p><span class="code">ArrayList</span> допускает присутствие дубликатов элементов. В <span class="code">HashSet</span> все элементы уникальны: добавить в <span class="code">HashSet</span> элемент, аналог которого уже присутствует в коллекции, не получится (проверка дубликатов ведется по hashcode, отсюда и название этой коллекции); </p></li>

<li><p><span class="code">ArrayList</span> реализован с помощью внутреннего массива, а <span class="code">HashSet</span> реализован с помощью внутренней <span class="code">HashMap</span>;</p></li>

<li><p><span class="code">ArrayList</span> поддерживает порядок вставки элементов, в то время как <span class="code">HashSet</span> — это неупорядоченное множество и не поддерживает порядок элементов;</p></li>

<li><p><span class="code">ArrayList</span> допускает любое количество пустых значений (null), в <span class="code">HashSet</span> можно вставить лишь одно значение null (как-никак, уникальность элементов).</p></li>
 
</ul><h4>91. Зачем в Java такое разнообразие имплементации динамического массива?</h4><img data-max-width="512" data-id="84c21648-4cc5-4175-9ea2-f8e4fdbbe329" src="https://cdn.javarush.com/images/article/84c21648-4cc5-4175-9ea2-f8e4fdbbe329/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10 - 3">Ну, это скорее философский вопрос. Ну а зачем придумывают такое количество новых разнообразных технологий? Для удобства. Собственно, так же и с большим количеством имплементаций динамического массива. 
 
Ни одну из них нельзя назвать лучшей или идеальной. У каждой есть преимущество в какой-то конкретной ситуации. И наша задача — знать их различия, их сильные/слабые стороны: чтобы суметь в нужной ситуации использовать самую подходящую из них. 
<h4>92. Зачем в Java такое разнообразие имплементаций key-value storage?</h4>Здесь ситуация такая же, как и с имплементациями динамического массива. Однозначно лучших нет: у каждой есть сильные и слабые стороны. И мы, конечно, должны по максимуму использовать сильные стороны.
 
<span class="text-bold">Пример:</span> в пакете concurrent, в котором есть множество многопоточных технологий, имеются свои <span class="code">Concurrent</span> коллекции. У той же <a href="https://javarush.com/groups/posts/713-hashmap-i-concurrenthashmap-populjarnihe-voprosih-na-sobesedovanijakh" target="_blank">ConcurrentHashMap</a> есть преимущество в безопасности многопоточной работы с данными в сравнении с обычной <span class="code">HashMap</span>, но не в многопоточной среде она проигрывает в скорости работы.
 
Ну а имплементации, которые ни в одной из ситуаций не бывают сильнейшими, постепенно перестают использовать. 
 
<span class="text-bold">Пример:</span> <span class="code">Hashtable</span>, которая изначально задумывалась как потокобезопасная <span class="code">HashMap</span>, но <span class="code">ConcurrentHashMap</span> превзошла ее при работе в многопоточной среде, и в итоге о <span class="code">Hashtable</span> позабыли и перестали использовать.
<h4>93. Как отсортировать коллекцию элементов?</h4>Первое, что нужно сказать, — класс элемента коллекции должен имплементировать интерфейс <span class="code">Comparable</span> и его метод <span class="code">compareTo</span>. Или же нужен класс, который имплементирует <span class="code">Comaprator</span> с его методом <span class="code">comparator</span>.

Подробнее о них можно почитать в <a href="https://javarush.com/groups/posts/1939-comparator-v-java" target="_blank">этом посте</a>.
 
Оба способа указывают, каким образом нужно сравнивать объекты данного типа. При сортировке это критически важно, ведь нужно понимать принцип, по которому элементы можно сравнить.
 
В основном используется способ через имплементацию <span class="code">Comparable</span>, реализуемый непосредственно в классе, который вы хотите сортировать. 
 
В то же время применение <span class="code">Comparator</span>-а более редко. Скажем, вы используете класс с какой-то библиотеки, у которого нет реализации <span class="code">Comparable</span>, но вам как-то нужно будет его сортировать. Не имея возможности изменить код данного класса (кроме как расширить его), вы можете написать реализацию <span class="code">Comparator</span>-а, в котором укажете, по какому принципу нужно сравнивать объекты данного класса. 
 
И еще один пример. Допустим, вам нужны разные принципы сортировки объектов одного и того же типа, поэтому вы пишете несколько <span class="code">Comparator</span>-ов которые используете в разных ситуациях.
 
Как правило, многие классы из коробки уже реализуют интерфейс <span class="code">Comparable</span> — тот же <span class="code">String</span>. Собственно, при их использовании вам не нужно париться, как их сравнить. Вы просто берете и используете их.
 
<span class="text-bold">Первый</span> и самый очевидный способ — использовать коллекцию типа <span class="code">TreeSet</span> или <span class="code">TreeMap</span>, которые хранят элементы в ужеотсортированном порядке, согласно компаратору класса элементов. Не забывайте, что <span class="code">TreeMap</span> сортирует ключи, но не значения. 
 
Если вы используете имплементацию <span class="code">Comparator</span> вместо <span class="code">Comparable</span>, вам нужно будет передать его объект в конструктор коллекции при создании:
 
<pre class="language-java line-numbers"><code>
TreeSet treeSet = new TreeSet(customComparator);
</code></pre>
А что если у вас коллекция другого типа? Как её отсортировать? 
 
В этом случае подходит <span class="text-bold">второй</span> способ утилитного класса <span class="code">Collections</span> — метод <span class="code">sort()</span>. Он статический, поэтому всё, что вам нужно — имя класса и метод, в который передается необходимый список.
 
Например:

<pre class="language-java line-numbers"><code>
Collections.sort(someList);
</code></pre>
Если вы используете не <span class="code">Comparable</span>, а реализацию <span class="code">Comparator</span>, его нужно передать вторым параметром:
 
<pre class="language-java line-numbers"><code>
Collections.sort(someList, customComparator);
</code></pre>
В итоге внутренний порядок элементов переданного списка изменится: он будет отсортирован согласно компаратору элементов.
 
Отмечу, что передаваемый список элементов должен быть мутабельным, т.е. изменяемым, иначе метод не сработает и будет выброшено <span class="code">UnsupportedOperationException</span>.
 
В качестве <span class="text-bold">третьего</span> способа можно использовать <span class="code">Stream</span> операцию <span class="code">sort</span>, которая сортирует элементы коллекции, если используется имплементация <span class="code">Comparable</span>:
 
<pre class="language-java line-numbers"><code>
someList = someList.stream().sorted().collect(Collectors.toList());
</code></pre>
если <span class="code">Comparator</span>:

<pre class="language-java line-numbers"><code>
someList = someList.stream().sorted(customComparator).collect(Collectors.toList());
</code></pre>
 
Подробнее о <span class="code">Stream</span> можно почитать в <a href="https://javarush.com/groups/posts/2203-stream-api" target="_blank">этой статье</a>.
<span class="text-bold">Четвертый</span> способ — ручная реализация сортировки, например, <a href="https://javarush.com/groups/posts/634-realizacija-puzihrjhkovoy-sortirovki-na-java" target="_blank">сортировки пузырьком</a> или <a href="https://javarush.com/groups/posts/2202-sortirovka-slijaniem-merge-sort" target="_blank">сортировки слиянием</a>.
<h3>Class Object. Equals and HashCode</h3><h4>94. Дайте краткую характеристику class object в Java</h4>Во второй части разбора мы уже говорили о методах класса <span class="code">Object</span>, и я напомню, что класс <span class="code">Object</span> — прародитель всех классов в Java. У него есть 11 методов, которые, соответственно, наследуются всеми классами.
<img data-max-width="512" data-id="f67dd5ea-dfce-40d1-94b6-d06bc38ec912" src="https://cdn.javarush.com/images/article/f67dd5ea-dfce-40d1-94b6-d06bc38ec912/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10 - 4">Информацию обо всех 11 методах можно найти <a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">во второй части</a> разбора вопросов.
<h4>95. Для чего используют Equals и HashCode в Java?</h4><span class="code">hashCode()</span> — это метод класса <span class="code">Object</span>, который наследуется всеми классами. Его задача — генерирование некоторого числа, которое представляет конкретный объект.
 
Примером использования данного метода может служить его применение в <span class="code">HashMap</span> на объекте ключа для дальнейшего определения локального хешкода, по которому определится ячейка внутреннего массива (бакета), в которой будет сохранена пара.
 
Подробно о работе <span class="code">HashMap</span> мы говорили <a href="https://javarush.com/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">в 9 части разбора</a>, поэтому особо останавливаться на этом не будем.
<img data-max-width="512" data-id="147525b9-ab24-444e-bbfb-65ca5b9db478" src="https://cdn.javarush.com/images/article/147525b9-ab24-444e-bbfb-65ca5b9db478/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10 - 5">Также как правило данный метод используется в методе <span class="code">equals()</span> как один из его основных инструментов определения идентичности объектов.
 
<span class="code">equals()</span> — метод класса <span class="code">Object</span>, задача которого — сравнивать объекты и определять, равны они или нет.
 
Данный метод используется повсеместно там, где нам необходимо сравнить объекты, ведь обычное сравнение через <span class="code">==</span> не подходит для объектов, т.к. сравнивает только ссылки на них.
<h4>96. Расскажите про контракт между Equals и HashCode в Java?</h4>Первое, что скажу — для корректной работы методов <span class="code">equals()</span> и <span class="code">hashCode()</span> их нужно правильно переопределить. После этого они должны соблюдать правила:<ul>

<li>одинаковые объекты, для которых сравнение через <span class="code">equals</span> возвращает <em>true</em>, <span class="text-bold">обязательно</span> имеют одинаковые хеш-коды;</li>
<li>объекты с одинаковыми хеш-кодами <span class="text-bold">не всегда</span> могут быть равны.</li>

</ul>На этом мы и сделаем паузу до следующей части разбора!<img data-max-width="512" data-id="34677cb0-c690-4de0-b0bf-4150c8d0ad8e" src="https://cdn.javarush.com/images/article/34677cb0-c690-4de0-b0bf-4150c8d0ad8e/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10 - 6"><table><tbody>
<tr><th>
Другие материалы серии:
</th></tr><tr><td>
<ul>
<li><a href="https://javarush.com/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 1</a></li>
<li><a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 2</a></li>
<li><a href="https://javarush.com/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3</a></li>
<li><a href="https://javarush.com/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 4</a></li>
<li><a href="https://javarush.com/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5</a></li>
<li><a href="https://javarush.com/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6</a></li>
<li><a href="https://javarush.com/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 7</a></li>
<li><a href="https://javarush.com/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 8</a></li>
<li><a href="https://javarush.com/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 9</a></li>
<li><a href="https://javarush.com/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 11</a></li>
<li><a href="https://javarush.com/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 12</a></li>
<li><a href="https://javarush.com/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 13</a></li>
<li><a href="https://javarush.com/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 14</a></li>
<li><a href="https://javarush.com/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 15</a></li>
<li><a href="https://javarush.com/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 16</a></li>
</ul>
</td></tr></tbody></table>