Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6
<p>----------------------------------------</p>
Hello, World! Не переставать развиваться очень важно для любого разработчика. Ведь если остановиться, есть риск стать невостребованным и вовсе вылететь с рынка: IT мир постоянно развивается и двигается вперед...
<p>----------------------------------------</p>
Hello, World!

Не переставать развиваться очень важно для любого разработчика. Ведь если остановиться, есть риск стать невостребованным и вовсе вылететь с рынка: IT мир постоянно развивается и двигается вперед, и нужно двигаться вместе с ним.

Но и при этом нельзя только зацикливаться только на новых и свежих технологиях, чтобы не забывать, так сказать, о классике (классических темах). Сегодня я хочу продолжить, свой разбор вопросов по “классическим” темам для Java-разработчика.

<img data-max-width="800" data-id="587d4a1b-d8c9-4d26-b6a3-4ef3f0399f3a" src="https://cdn.javarush.com/images/article/587d4a1b-d8c9-4d26-b6a3-4ef3f0399f3a/800.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6 - 1">Отмечу, что мои ответы не являются последней инстанцией — это всего лишь то, как я вижу правильные ответы на данные вопросы, и с чем-то вы можете быть не согласны. Это будет вполне нормально, так что не стесняйтесь делиться своим мнением в комментариях. 

Ссылки на части разбора — в конце статьи.<img data-max-width="512" data-id="cab15092-c31a-490f-99de-f79b11fef12b" src="https://cdn.javarush.com/images/article/cab15092-c31a-490f-99de-f79b11fef12b/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6 - 2"><h3>Библиотеки и стандарты</h3><h4>52. Что такое Hibernate? В чём разница между JPA и Hibernate?</h4>Я думаю, чтобы ответить на данный вопрос, нам сперва нужно понять, что такое <a href="https://javarush.com/groups/posts/2259-jpa--znakomstvo-s-tekhnologiey" target="_blank">JPA</a>.
 
<span class="text-bold">JPA</span> — это спецификация, описывающая объектно-реляционное отображение простых Java объектов и предоставляющая API для сохранения, получения и управления такими объектами.
 
То есть, как мы помним, реляционные <a href="https://javarush.com/groups/posts/2946-java-proekt-ot-a-do-ja-razbiraem-bazih-dannihkh-i-jazihk-sql" target="_blank">базы данных</a> (БД) представлены в виде множества связанных между собой таблиц. И <span class="text-bold">JPA</span> — общепринятый стандарт, который описывает, как объекты могут взаимодействовать с реляционными базами данных.
 
Как видите, <span class="text-bold">JPA</span> — это что-то абстрактное и неосязаемое. Это как бы сама идея, подход.<img data-max-width="512" data-id="117c78f8-e2bf-4226-8f34-6c2d62a6ac89" src="https://cdn.javarush.com/images/article/117c78f8-e2bf-4226-8f34-6c2d62a6ac89/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6 - 3">В то же время <span class="text-bold"><a href="https://javarush.com/groups/posts/hibernate-java" target="_blank">Hibernate</a></span> — это конкретная библиотека, реализующая парадигмы <span class="text-bold">JPA</span>. То, есть с помощью этой библиотеки вы можете работать с реляционной базой данных через объекты, которые представляют данные с БД (Entity). 
 
Как говорят, данная библиотека очень близка к идеалам <span class="text-bold">JPA</span> и возможно, поэтому она стала популярна. А как вы понимаете, популярность использования — хороший аргумент для дальнешйей разработки и улучшений.

К тому же за частым использованием стоит огромное комьюнити, которое разобрало уже все возможные и невозможные вопросы, связанные с данным инструментом. 
 
Вот <a href="https://javarush.com/groups/posts/498-hibernate-dlja-chaynikov-obzor-knigi-java-persistence-api-i-hibernate" target="_blank">пример книги</a>, которая подробно разбирает все темные закоулки данной технологии. То есть, Hibernate максимально изучен и, получается, надежен.
 
Собственно, не зря даже идеальная реализация JPA со стороны Spring-а под капотом как правило использует Hibernate.<h4>53. Что такое каскадность? Как она используется в Hibernate?</h4>Как я и сказал ранее, в Hibernate взаимодействие ведется через объекты данных, называемые <span class="text-bold">entity</span>. Эти entity представляют какие-то конкретные таблицы в базе данных, и как вы помните, в Java классы могут содержать ссылки на другие классы. 
 
Эти отношения отражаются и на базе данных. В БД, как правило, это либо внешние ключи (для OneToOne, OneToMany, ManyToOne), либо промежуточные таблицы (для ManyToMany) Подробнее о взаимосвязи между сущностями можно почитать <a href="https://javarush.com/groups/posts/1982-jpa-entities--db-relationships" target="_blank">в этой статье</a>.
 
Когда в вашем entity есть ссылки на другие связанные сущности, над этими ссылками ставятся аннотации для указания типа связи: @OneToOne, @OneToMany, @ManyToOne, @ManyToMane, в чьих параметрах вы можете указать значение свойства — <span class="text-bold">cascade</span> — тип каскаданости для данной связи.
 
У <span class="text-bold">JPA</span> есть специфические методы для взаимодействия с сущностями (persist, save, merge…). Каскадные типы как раз используются для того, чтобы показать, как должны себя вести связанные данные при использовании этих методов на целевую сущность.
 
Итак, какие же существуют стратегии каскаскадности (типы каскадности)? 
 
Стандарт JPA подразумевает использование шести видов каскадности:<ul>

<li><p><span class="text-bold">PERSIST</span> — операции сохранения будут происходить каскадно (для методов <span class="code">save()</span> и <span class="code">persist()</span>).  То есть, если мы сохраняем сущность, связанную с другими сущностями, они также сохраняются в БД (если их ещё там нет)</p><p></p></li>
<li><p><span class="text-bold">MERGE</span> — операции обновления будут происходить каскадно (для метода <span class="code">merge()</span>)</p></li>
<li><p><span class="text-bold">REMOVE</span> — операции удаления происходят каскадно (метод <span class="code">remove()</span>)</p></li>
<li><p><span class="text-bold">ALL</span> — содержит сразу три каскадные операции — <span class="text-bold">PERSIST</span>  -  <span class="text-bold">MERGE</span>  -  <span class="text-bold">REMOVE</span></p></li>

</ul>В <span class="text-bold">JPA</span> есть понятие персистентная (<em>persistence</em>) сущность — сущность, связанная с её данными в БД, которая управляется текущей сессией (соединением). Если её изменить, но при этом не сохранить изменения в БД, всё равно её данные в БД будут изменены.<ul>

<li><p><span class="text-bold">DETACH</span> — связанные сущности не будут управляться сессией (метод <span class="code">detach()</span>). То есть, при их изменении не будет автоматического изменения их данных в БД — они переводятся из состояния persistence в detached (сущность, не управляемая JPA)</p></li>
<li><p><span class="text-bold">REFRESH</span> — при каждом обновлении сущности данными из БД (<span class="code">refresh()</span> — обновляет detached объекты) связанные сущности обновляются так же. Например, вы изменили как-то данные, взятые из БД, и хотите вернуть их изначальные значения. В таком случае вам и пригодится данная операция.</p></li>

 </ul><img data-max-width="512" data-id="f9f3623d-4c86-4cbd-a22d-44cd1d5e2c9e" src="https://cdn.javarush.com/images/article/f9f3623d-4c86-4cbd-a22d-44cd1d5e2c9e/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6 - 4">Hibernate поддерживает все эти стандартные каскадные операции, но также привносит три свои:<ul>

<li><p><span class="text-bold">REPLICATE</span> — используется, когда у нас есть более одного источника данных и мы хотим, чтобы данные синхронизировались (метод Hibernate — replicate). У всех сущностей должны быть идентификаторы (id), чтобы не было проблем с их генерацией (чтобы для разных БД одна и та же сущность не имела разных id)</p></li>
<li><p><span class="text-bold">SAVE_UPDATE</span> — каскадное сохранение/удаление (для метода Hibernate — <span class="text-bold">saveOrUpdate</span>)</p></li>
<li><p><span class="text-bold">LOCK</span> — операция, обратная к <span class="text-bold">DETACHED</span>: переводит <span class="text-bold">detached</span> сущность обратно в состояние <span class="text-bold">persistence</span>, т.е. entity станет снова отслеживаемой текущей сессией</p></li>

</ul>Если не выбран тип каскадирования, никакая операция с сущностью не будет иметь эффекта для связанных с ней других entity.<h4>54. Может ли Entity класс быть абстрактным?</h4>В <a href="https://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf?AuthParam=1619340265_e6d5555a1d0e8eee38710c27caed21c0" rel="nofollow" target="_blank">спецификации JPA</a> в пункте <span class="text-bold">2.1 The Entity Class</span> есть строка: “<em>И абстрактные, и конкретные классы могут быть сущностями</em>”. То есть, ответ — да, абстрактный класс может быть сущностью и может быть аннотирован с помощью @Entity.<h4>55. Что такое entity manager? За что отвечает?</h4>В первую очередь хотелось бы отметить, что <span class="text-bold">EntityManager</span> — один из ключевых компонентов <span class="text-bold">JPA</span>, который используется для взаимодействия сущностей с базой данных.
 
В общем-то методы взаимодействия сущности с БД у него-то и вызываются (persist, merge, remove, detach)... Но также отмечу, что данный компонент как правило не является одним на всё приложение: чаще всего он легковесен, часто удаляется и создается новый с помощью <span class="text-bold">EntityManagerFactory</span>.
 
Если проводить параллель с <span class="text-bold">JDBC</span>, где <span class="text-bold">EntityManagerFactory</span> будет являться аналогом <span class="text-bold">DataSource</span>, то <span class="text-bold">EntityManager</span> в свою очередь будет являться аналогом <span class="text-bold">Connection</span>.
 
Ранее я упоминал про персистентную (<em>persistence</em>) сущность, как сущность, которая управляется текущим соединением.

Так вот: эта сущность управляется именно <span class="text-bold">EntityManager</span>-ом, который тесно связан с текущим соединением и <span class="text-bold">TransactionManager</span>-ом, который отвечает за открытие/закрытие транзакций.
 
Далее на рисунке ниже вы можете видеть жизненный цикл сущности:<img data-max-width="800" data-id="fe81f8a3-ff85-4b22-986e-1ca664052373" src="https://cdn.javarush.com/images/article/fe81f8a3-ff85-4b22-986e-1ca664052373/800.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6 - 5">EntityManager управляет сущностью, когда она на этапе Managed (в это время она персистентная, т.к. имеет связь с EntityManager-ом). То есть, она уже не new и ещё не removed. Можно сказать, что когда сущность new или removed, она также и detached, т.к. она не управляется EntityManager-ом.
 
Существуют разные стратегии для EntityManager-а. То есть, может быть один синглтоновый EntityManager на всё приложение, а может создаваться каждый раз новый, под каждое соединение. Если же вы используете Spring, то управление созданием/удалением EntityManager-а происходит автоматически под капотом (но это не значит, что нельзя настроить это под себя ^^).
 
Стоит сказать, что один или несколько EntityManager-ов и образуют и <em>persistence context</em>.
 
<span class="text-bold">Persistence context</span> — это среда в которой экземпляры сущностей синхронизируются с аналогичными сущностями в базе данных (как я и говорил, это работает только для персистентных сущностей).
 
Если вы углубитесь в изучение <span class="text-bold">JPA</span> (что я очень вам рекомендую), то с данными понятием вы будете сталкиваться очень и очень часто.<h4>56. Что такое класс Assert? Зачем его использовать?</h4>В <span class="text-bold">JPA</span> я о таком классе не слышал, поэтому предположу, что тут имеется ввиду класс <span class="text-bold"><a href="https://javarush.com/groups/posts/605-junit" target="_blank">JUnit</a></span> библиотеки, которая используется для модульного тестирования кода.

Класс данной библиотеки, <span class="code">Assert</span>, используется для проверки результатов выполнения кода (<span class="text-bold">assert</span> — утверждение, что в определенном месте у вас определенное состояние/данные).

Например, вы тестируете метод, который должен создавать кота. Вы запускаете метод и получаете некоторый результат:

<pre class="language-java line-numbers"><code>
Cat resultOfTest = createCat();
</code></pre>
Но ведь вам нужно убедиться, что он был правильно создан, не так ли? 

Поэтому вы до этого создали некого кота — <span class="code">expectedCat</span>  — вручную с точно такими параметрами, которые вы ожидаете от кота, полученного с метода <span class="code">createCat()</span>.

Далее вы и используете класс <span class="code">Assert</span> для сверки полученных результатов:

<pre class="language-java line-numbers"><code>
Assert.assertEquals(resultOfTest, expectedCat);
</code></pre>
Если коты будут отличаться, будет выброшено исключение <span class="text-bold">AssertionError</span>, которое говорит нам о том, что ожидаемые результаты не сходятся.

У класса <span class="code">Assert</span> есть множество различных методов, которые покрывают множество задач по проверке ожидаемых результатов. Вот некоторые из них:<ul>

<li><p><span class="code">assertTrue(&lt;boolean&gt;)</span> — ожидаемое значение, полученное в качестве аргумента, должно быть <span class="text-bold">true</span></p><p></p></li>
<li><p><span class="code">assertFalse(&lt;boolean&gt;)</span> — ожидаемое значение, полученное в качестве аргумента, должно быть <span class="text-bold">false</span></p></li>
<li><p><span class="code">assertNotEquals(&lt;object1&gt;, &lt;object2&gt;)</span> — объекты, полученные в качестве аргументов, при сравнении посредством equals должны быть разными (<span class="text-bold">false</span>)</p></li>
<li><p><span class="code">assertThrows(&lt;ClassNameOfException&gt;.class, &lt;exceptionObject&gt;)</span> — ожидается, что вторым аргументом будет исключение класса, прописанного первым аргументом (т.е. как правило на месте второго аргумента вызывается метод, который должен бросать исключение нужного типа)</p></li>

</ul><h3>String</h3><h4>57. Дайте характеристику String в Java</h4><span class="code">String</span> — стандартный класс в Java, отвечающий за хранение и манипуляции со строковыми значениями (последовательности символов), является <span class="text-bold">immutable</span> классом (об <span class="text-bold">immutable</span> я писал <a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">ранее</a>), т.е. данные объектов данного класса невозможно изменить после создания.
 
Хотелось бы сразу отметить, что классы <span class="code">StringBuilder</span> и <span class="code">StringBuffer</span> — это два фактически одинаковых класса с той лишь разницей, что один из них предназначен для использования в многопоточной среде (StringBuffer).
 
Эти классы являются аналогами <span class="code">String</span>, но в отличие от него они <span class="text-bold">изменяемы</span>.
 
То есть объекты после создания допускают модификацию строки, которую представляют, без создания нового объекта. 
 
Собственно, методы отличаются от стандартных методов <span class="code">String</span> и направлены на удовлетворение потребностей по изменению строки (не зря же builder-ом назвали).

Подробнее о <span class="code">String</span>, <span class="code">StringBuffer</span> и <span class="code">StringBuilder</span> читайте вот <a href="https://javarush.com/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java" target="_blank">в этой статье</a>.<h4>58. Какие есть способы создания объекта String? Где он создаётся?</h4>Самый привычный способ создания строки — простое задание нужного нам значения в двойных скобках:

<pre class="language-java line-numbers"><code>
String str = "Hello World!";
</code></pre>
Также можно сделать это непосредственно через <span class="code">new</span>:

<pre class="language-java line-numbers"><code>
String str = new String("Hello World!");
</code></pre>
 Можно создать строку и отталкиваясь от массива символов:

<pre class="language-java line-numbers"><code>
char[] charArr = {'H','e','l','l','o',' ', 'W','o','r','l','d','!'};
String str = new String(charArr);
</code></pre>
 Как результат работы метода <span class="code">toString</span> на некотором объекте:

<pre class="language-java line-numbers"><code>
String str = someObject.toString();
</code></pre>
 Как результат работы любого другого метода возвращает строковое представление. Например:

<pre class="language-java line-numbers"><code>
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
String str =  reader.readLine();
</code></pre>
Как вы поняли, способов создания строки может быть очень и очень много.

При создании объекта <span class="code">String</span> он сохраняется в <span class="text-bold">строковом пуле</span>, о котором подробнее мы поговорим в одном из вопросов далее.<h4>59. Как сравнить две строки в Java и как их отсортировать?</h4>Для сравнения значений в Java используется знак двойного равно <span class="code">==</span>.

Если бы нам нужно было сравнивать некоторые простые значения вроде <span class="code">int</span>, мы бы воспользовались им. 
 
Но для сравнения полноценных объектов данный способ неприменим. В таком случае это будет лишь сравнение ссылок — указывают ли они на один и тот же они объект или нет. То есть при сравнении двух объектов с совершенно одинаковыми значениями внутренних полей сравнение через <span class="code">==</span> даст результат <span class="text-bold">false</span>: несмотря на одинаковость полей объектов, сами объекты занимают разные ячейки памяти.
 
А объекты класса <span class="code">String</span>, несмотря на обманчивую простоту, всё же являются объектами. И сравнение через <span class="code">==</span> для них также неприменимо (даже несмотря на наличие строкового пула).
 
Тут за дело берется стандартный метод класса <span class="code">Object</span> — <span class="code">equals</span>, который необходимо переопределить в классе для его корректной работы (иначе по умолчанию он сравнивает через <span class="code">==</span>).
 
В классе <span class="code">String</span> он переопределен, значит просто берем и используем его:
 
<pre class="language-java line-numbers"><code>
String firstStr = "Hello World!";
String secondStr = "Hello World!";
boolean isEquals = firstStr.equals(secondStr);
</code></pre><img data-max-width="512" data-id="c4cbf258-2841-4708-843d-e16e59c06bc3" src="https://cdn.javarush.com/images/article/c4cbf258-2841-4708-843d-e16e59c06bc3/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6 - 6">Мы говорили о сравнении на соответствие, а теперь разберем сравнение для сортировки. Ведь для сортировки чего-либо нам нужно знать, по какому принципу сортировать. Для этого можно воспользоваться стандартным отсортированным множеством — <span class="code">TreeSet</span>.
 
Подробнее о различных коллекциях в Java вы можете почитать <a href="https://javarush.com/groups/posts/2985-chto-mogut-sprositjh-na-sobesedovanii-strukturih-dannihkh-v-java" target="_blank">в этой статье</a>.
 
Данный список работает на основе алгоритма красно-черного дерева и сортирует множество в соответствии с заданным принципом сортировки.
 
Как я и сказал ранее, нужно понимать, как отсортировать объекты определенного типа. Чтобы задать способ сравнения для сортировки, используют <a href="https://javarush.com/groups/posts/2262-comparator-v-java" target="_blank">компараторы</a>.
 
Как правило их необходимо реализовывать для классов, которые вы хотите сортировать, но в случае со <span class="code">String</span> они уже реализованы.
 
Поэтому просто добавляем нужные нам строки в <span class="code">TreeSet</span>, а он их отсортирует:

<pre class="language-java line-numbers"><code>
TreeSet&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();
sortedSet.add("B");
sortedSet.add("C");
sortedSet.add("A");
sortedSet.forEach(System.out::println);
</code></pre>
 Вывод в консоли:

<div class="terminal">A
B
C</div><h4>60. Приведите алгоритм перевода строки в символ. Напишите соответствующий код</h4>Как я и говорил ранее, у объектов класса <span class="code">String</span> очень много разных полезных методов. Один из таких — <span class="code">toCharArray</span>. Данный метод переводит строку в массив символов:
 
<pre class="language-java line-numbers"><code>
String str = "Hello world";
char[] charArr = str.toCharArray();
</code></pre>
 Далее у нас есть массив символов, которые можем вызывать по индексу:

<pre class="language-java line-numbers"><code>
char firstChar = charArr[0]; // H
</code></pre><h4>61. Как перевести строку в массив байтов и назад ? Напишите соответствующий код</h4>Аналогичный методу <span class="code">toCharArray</span>, класс <span class="code">String</span> имеет метод <span class="code">getBytes</span>, который возвращает массив байтов строки:

<pre class="language-java line-numbers"><code>
String str = "Hello world";
byte[] byteArr = str.getBytes();
byte firstChar = byteArr[6]; // 119
</code></pre>
Сегодняшняя часть разбора подошла к логическому концу.  Спасибо за внимание!<img data-max-width="512" data-id="27b2740d-7749-4a0f-bcc4-3ee9cc5b4884" src="https://cdn.javarush.com/images/article/27b2740d-7749-4a0f-bcc4-3ee9cc5b4884/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6 - 7"><table><tbody>
<tr><th>
Другие материалы серии:
</th></tr><tr><td>
<ul><li><a href="https://javarush.com/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 1</a></li>
<li><a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 2</a></li>
<li><a href="https://javarush.com/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3</a></li>
<li><a href="https://javarush.com/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 4</a></li>
<li><a href="https://javarush.com/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5</a></li>
<li><a href="https://javarush.com/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 7</a></li>
<li><a href="https://javarush.com/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 8</a></li>
<li><a href="https://javarush.com/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 9</a></li>
<li><a href="https://javarush.com/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10</a></li>
<li><a href="https://javarush.com/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 11</a></li>
<li><a href="https://javarush.com/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 12</a></li>
<li><a href="https://javarush.com/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 13</a></li>
<li><a href="https://javarush.com/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 14</a></li>
<li><a href="https://javarush.com/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 15</a></li>
<li><a href="https://javarush.com/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 16</a></li>
</ul>
</td></tr></tbody></table>