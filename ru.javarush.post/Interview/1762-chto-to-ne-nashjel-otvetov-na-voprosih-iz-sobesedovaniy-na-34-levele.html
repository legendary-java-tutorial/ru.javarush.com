Уровень 34. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
Поискал на сайте родным поиском и с помощью гугла всё облазил — нет ответов на вопросы из этого левела. Может я что-то пропустил, и они всё-такие где-то есть здесь на сайте!? 
<p>----------------------------------------</p>
Поискал на сайте родным поиском и с помощью гугла всё облазил — нет ответов на вопросы из этого левела. Может я что-то пропустил, и они всё-такие где-то есть здесь на сайте!? 

<img data-id="af3ca0ba-0322-4440-ae01-2fb9c31740d0" data-max-width="850" alt="Уровень 34. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/af3ca0ba-0322-4440-ae01-2fb9c31740d0/1024.jpeg">На всякий случай прикладываю ответы, которые я написал для себя:

<strong>Вопросы к собеседованию:</strong>
<ol>
<li>Что такое сборка мусора?</li>
<li>Когда вызывается метод <code>finalize</code>?</li>
<li>Что произойдет, если в методе <code>finalize</code> возникнет исключение?</li>
<li>Что такое <code>SoftReference</code>?</li>
<li>Что такое <code>WeakReference</code>?</li>
<li>Что такое <code>PhantomReference</code>?</li>
<li>Как работает <code>WeakHashMap</code>? Где он используется?</li>
<li>Зачем нужно передавать очередь в конструктор <code>PhantomReference</code>?</li>
<li>Зачем нужен логгер?</li>
<li>Какие настройки логгера вы знаете?</li>
</ol><strong>Мои ответы:</strong>
<ol>
<li><p>Это механизм уничтожения ненужных объектов. Ненужные объекты — это неиспользуемые объекты. Существует два способа поиска таких объектов: подсчёт ссылок и трассировка. В первом случае с каждым объектом связывается некоторая переменная, которая хранит количество ссылок на этот объект. Если это количество опускается до нуля, то объект считается мёртвым. Во втором случае сборщик мусора идёт по ссылкам объектов из корневых точек до конца (до значения нулл), обходя всё это дерево. Объекты, до которых он не может добраться из корневых точек, считаюся мёртвыми. Корневыми точками считаются все активные нити, метод main, аргументы метода <code>main()</code>, а также все статические переменные класса, в которой находится метод <code>main()</code>.</p>
<p>Определение объектов, пригодных к уничтожению - это только первая часть работы сборщика мусора. Вторая часть - это собственно их удаление и работа с памятью. Здесь используется гибридный подход. Вся доступная для объектов память разделяется на три области: область молодых объектов, область старых объектов и область перманентных объектов (это классы, метаданные, интернированные строки и т.д.). Первая область разделяется ещё на три подобласти: на Eden и suvivor space 1 и 2. В Eden хранятся все только созданные объекты. В остальных двух зонах хранятся объекты, выживщие после последней сборки мусора. Сборщик мусора работает со всей этой областью (областью молодых объектов) следующим образом. Во время очередной сборки мусора он находит живые объекты в области Eden и копирует их во вторую область выживших. После этого он в первой области также ищет живые объекты и копирует их либо в вторую область выживших, либо, если они уже достаточно "старые" - область старого поколения. После этого он очищает область Eden и первую область выживших. Дальше он считает вторую область выживших первой. И всё, на это сборка мусора заканчивается для этой области.</p>
<p>Для второй области сборка мусора идёт несколько по-другому. Там есть одна большая область, она ни на что не делится, но сборщик мусора все живые объекты в ней во время своей работы перемещает в начало области. Соответственно, вторая часть области будет состоять только из пустого пространства и мёртвых объектов. После этого сборщик мусора завершает свою работу.</p></li>
<li><p>Перед уничтожение объекта сборщиком мусора. Также можно вручную запустить вызовы этого метода у всех недостижимых объектов, для этого надо вызвать метод <code>System.runFinalization()</code> или <code>Runtime.getRuntime().runFinalization()</code>.</p></li>
<li><p>Это исключение будет проигнорировано, и произойдёт выход из метода.</p></li>
<li><p><code>SoftReference</code> переводится как "мягкая ссылка". Эта ссылка на объект, но более слабая, чем обычная ссылка (StrongReference). Объекты, на которые сущесвуют только мягкие ссылки, называются мягкодостижимыми. Такие объекты не уничтожаются в обычном случае. Но если у JVM закочиналась память, то сборщик мусоры удаляет все такие объекты.</p></li>
<li><p><code>WeakReference</code> — это так называемая слабая ссылка на объект. Она ещё слабее Soft-ссылки. Все объекты, на которые существуют только слабые ссылки, будут удалены при ближайщей сборке мусора.</p></li>
<li><p><code>PhantomReference</code> — это самая слабая ссылка. Механизм работы с такими ссылка запускается только если на объект нет больше никаких других ссылок. Призрачные ссылки используются для сложной процедуры удаления объекта. Это может быть необходимо, если объект делает что за граница Java-машины, например, вызывает низкоуровневые функции ОС или пишет своё состояние в файл, или делает ещё что-то важное и сложное. </p>
<p>Механизм работы с такими ссылками следующий. Если на объект не осталось больше никаких других ссылок, и у него переопределён метода <code>finalize()</code>, то этот метода будет вызван во время ближащей сборки мусора. Если же этот метод не переопределён, то этот объект пропускает текущую сборку мусора, и попадает только в следующую. Во время этой (следующей) сборки мусора данный объект помещается в очередь призрачных объектов, из которой будет удалён, когда у его призрачной ссылки вызовут метод <code>clear()</code>.  Также стоит отметить, что метода <code>get()</code> у призрачной ссылка всегда возвращает null (в отличие от двух других несильных ссылок, у которых он возвращает <code>null</code>, только если объект уже уничтожен).</p></li>
<li><p><code>WeakHashMap</code> — это <code>HashMap</code>, у которого ключами являются слабые ссылки. Поэтому, если во время ближайшей сборки мусора будет обнаружено, что на объект существует только ссылка в <code>WeakHashMap</code>, то из <code>WeakHashMap</code> будет удалена вся пара "ключ-значение", связанная с этим объектом.</p>
<p>В связи с этим данная коллекция может быть использована для хранения какой-то дополнительной, не очень важной информации об объекте. Также её удобно использоваться для хранения какой-то временной информации (которая нужная только в рамках данной операции).</p></li>
<li><p>Эта очередь используется для отслеживания того, что объект больше не нужен. Может быть использовано для закрытия ресурсов, открытых данным объектом (например, удаление созданных файлов).</p></li>
<li><p>Логгер нужен для сохранения информации о поведении программы, а также некоторых её состояниях. Может быть использован для отладки и выявления ошибок в работе программы и сбоев. Также логгер является позволяет разработчику получать обратную связь от своей программы во время её работы. Кроме того, при критических сбоях логгер может оперативно оповещать нужных людей (например, разработчиков, клиентов, менеджеров проектов, службу техподдержки и т.д.) об этих сбоях.</p></li>
<li><p>При настройки логгрирования можно указать следующие вещи:</p><ul style="list-style-type:lower-alpha">
<li>место, куда будет писаться информация (файл, консоль, база данных, сеть и т.д.)</li>
<li>сообщения какого уровня будут записываться</li>
<li>вид записей в логе</li>
<li>для файлов можно указать: путь к файлу и каталогу, размер файлов, количество файлов</li>
<li>указать для каждого отдельного пакета свой уровень сообщений, которые будут писаться в лог</li>
</ul>