Уровень 38. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
Здравствуйте. Опять-таки, похоже нет ответов на вопросы из этого уровня. Поэтому, как обычно, выкладываю свои. Вдруг, кому помогут (или кто-то что-то дополнит или ответит лучше) 

<p>----------------------------------------</p>

<img data-id="293894ba-ab75-4808-9c9a-1980fae71e68" data-max-width="850" alt="Уровень 38. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/293894ba-ab75-4808-9c9a-1980fae71e68/1024.jpeg">Здравствуйте. Опять-таки, похоже нет ответов на вопросы из этого уровня. Поэтому, как обычно, выкладываю свои. Вдруг, кому помогут (или кто-то что-то дополнит или ответит лучше).

<strong>Итак, были такие вопросы:</strong>
<ol>
    <li>Что такое Agile?</li>
    <li>Что такое Scrum?</li>
    <li>Какие роли Scrum вы знаете?</li>
    <li>Что такое спринт? Расскажите с подробностями</li>
    <li>Кто такие QA?</li>
    <li>Кто такой product owner?</li>
    <li>Расскажите об иерархии исключений</li>
    <li>Что делать если JVM выкинула Error?</li>
    <li>Какие нововведения в области исключений из Java 7 вы знаете?</li>
    <li>Зачем нужны аннотации? Как ими пользоваться?</li>
</ol><strong>А теперь мои ответы:</strong>
<ol><li><p><strong>Agile</strong> — это серия подходов к разработке программного обеспечения, ориентированных на использование итеративной разработки, динамическое формирование требований и обеспечение их реализации в результате взаимодействия внутри самооранизующихся рабочих групп, состоящих из специалистов разных профилей. Существует несколько методик, относящих к гибкой методологии разработки, в частности экстремальное программирование,  DSDM, Scrum, FDD.</p>
<p>Основные концепции agile-методов:</p>
<ul>
    <li>люди и взаимодействие важнее процессов и инструментов;</li>
    <li>работающий продукт важнее исчерпывающей документации;</li>
    <li>сотрудничество с заказчиком важнее согласование условий контракта;</li>
    <li>готовность к изменениям важнее следованию первоначального плана.</li>
</ul><p>Также были сформулированы основные принципы такого подхода:</p>
<ul>
    <li>удовлетвореие клиента за счёт ранней и бесперебойной поставки ценного программного обеспечения;</li>
    <li>приветствие изменений требований даже в конце разработки (это может повысить конкурентноспособность продукта на рынке);</li>
    <li>частая поставка рабочего программного обеспечения (каждый месяц или каждую неделю, или даже ещё чаще);</li>
    <li>тесное, ежедневно общение заказчика с разработчика на протяжении всего проекта;</li>
    <li>проектом занимаются мотивированные личности, обеспеченые нужные условиями работы, поддержкой и доверием;</li>
    <li>рекомендуемый метода передачи информации - личный разговор (лицом к лицу);</li>
    <li>работающее программное обеспечение - лучший измеритель прогресса;</li>
    <li>спонсоры, разработчики и пользователи должны поддерживать постоянный темп на неопределённый срок;</li>
    <li>постоянно внимание улучшению технического мастерства и удобному дизайну;</li>
    <li>простота - искусство не делать лишней работы;</li>
    <li>лучшие технические требования, архитектура и дизайн полуются у самороорганизованной команды;</li>
    <li>постоянная адаптация к изменяющимся условиям.</li>
</ul><p>Основной проблемой разработки было признано то, что никто из участников ни на одном этапе не обладает всей полнотой информации о том, что делать.</p></li>
<li><p><strong>Scrum</strong> — это одна из методик гибкой разработки. Она делает акцент на качественном контроле процесса разработки. Основная особенность скрама — это разбиение процесса разработки на итерации имеющий чёткую протажённость по времени (обычно 2-6 недель; их называют "спринтами").</p>
<p>В начале спринта проводится "планирование спринта" — совещание на 3-4 часа, где обсуждаются основные задачи, которые будут решаться на протяжении спринта. В конце спринта  проводится "демо" – демонтрация результатов работы команды за этот спринт. </p>
<p>Перед самым первым спринтом заказчик (или его представитель) формирует список требований, предъявляемых к будущему продукту. Такие требования называются "user story", а самого заказчика называют "product owner". Также в этом списке заказчик (PO) указывает приоритет для каждой задачи. Сначала будут реализовываться задачи с более высоким приоритетом.  Весь список называется "product backlog", или "резерв продукта".</p>
<p>Кроме product owner, среди участников ещё выделяют scrum-мастера: он проводит все совещания, следит за соблюдением всех принципов скрама, разрешает противоречия и защищает команду от отвлекающих факторов. Обычно в качестве скрам-мастера выступает кто-то из команды.</p>
<p>На первом совещании в начале спринта каждой задаче, кроме того, что назначается приоритет, даётся ещё приблизительная оценка в "абстрактных человеко-днях", которые ещё называют "story point". Затем команда решает, сколько она успеет выполнить задач за время спринта. Например, заказчик отобрал 7 задач, а команда сможет сделать только 5. Тогда остальные две задачи пойдут на следующий спринт. Если заказчику это не нравится, он может повысить их приоритет, но тогда другие задачи выпадут из спринта. Кроме того, скрам-мастер может разбить некоторые задачи на более мелкие и расставить им различные приоритеты, чтобы заказчик остался доволен. </p>
<p>Список отобранных задач на спринт называются "sprint backlog", или "резерв спринта". Для лучшей наглядности обычно составляется таблица, в которой указываются задачи, которые нужно реализовать, которые находятся в процессе реализации, и те которые  уже выполнены. Также строится диаграмма "сгорания задач". Она графически показывает, сколько ещё задач осталось выполнить. В идеале график сгорания задач к концу спринта должен опустится до нуля. </p>
<p>Также в течение спринта каждый день или через день проводятся небольшие совещания внутри команды на 5-15 минут, где каждый участник команды рассказывает, что сделал за этот день (или эти два дня), что ещё ему предстоит сделать, а также рассказывает о том, что ему мешает что-то сделать.</p>
<p>Когда спринт завершается, scrum-master проводит demo, на котором демонстрируется список всего, что полностью сделано. Затем проводится «разбор полетов» — совещание тоже на пару часов. На нем обычно пытаются выяснить, что было сделано хорошо, а что (и как) можно было сделать лучше.</p>
<p>Обычно за 2-3 спринта можно выявить основные проблемы, которые мешают команде работать эффективнее, и устранить их. Это приводит к большей продуктивности, не увеличивая нагрузку на команду. Такое было невозможным до эры гибких методологий.</p>
<p>Также в середине спринта, иногда еще проводят «вычесывание» — совещание посвященное планированию следующего спринта. На нем обычно уточняют приоритеты задач, а так же могут разбить некоторые задачи на части и/или добавить новые задачи в product backlog – резерв продукта.</p></li>
<li><p>В скрам участников делят на "свиней" и "кур". "Свиньи" полностью задействованы в процессе, "куры" — только частично. К категории "свиней" относят следующие роли:</p>
<ul>
<li>Скрам-мастер (проводит совещания, следит за выполнением принципов скрама и пр.; это кто-то из команды, produst owner не может быть скрам-мастером);</li>
<li>Владетелей продукта (Product Owner) (представляет интересы конечных пользователей и других заинтересованных в продукте сторон);</li>
<li>Команда разработки (Development Team) (кросс-функциональная команда, состоящая из специалистов разных профилей: разработчиков, тестировщиков, дизайнеров, архитекторов и т.д. Размер команды в идеале составляет от 3 до 9 человек. Команда является единственные полностью вовлечённым участником разработки и отвечает за результат как единое целое. Никто, кроме команды, не может вмешиваться в процесс разработки на протяжении спринта).</li></ul><p>К "курам" относятся следующие роли:</p>
<ul>
<li>Пользователи (Users)</li>
<li>Клиенты, продавцы (Stakeholders) (лица, которые инициируют проект и для кого проект будет приносить выгоду. Они вовлечены в скрам только во время обзорного совещания по спринту (Sprint Review));</li>
<li>Управляющие (Managers) (люди, которые управляют персоналом);</li>
<li>Эксперты-консультанты (Consulting Experts).</li>
</ul></li>
<li><p><strong>Спринт</strong> — это одна итерация цикла разработки программного обеспечения в Скраме. Обычно спринт жёстко фиксирован по времени. Продолжительность спринта выбирается на основании размера команды, специфики работы, требований, размера проекта. Чаще всего это подбирается опытным путём, на основании проб и ошибок. В среднем спринт может быть продолжительность от 2 недель до 4 (хотя в некоторых компания его продолжительность бывает равна и 6 неделям). Для оценка объёма работ в спринте может быть использована  предварительная оценка, измеряемая в очках истории. Предварительная оценка фиксируется в беклоге проекта.</p></li>
<li><p><strong>QA</strong> расшифровывается как Quality Assuarance (то есть "Гарантия качества", если перевести дословно). К этой категории относятся тестировщики. Это люди, которые выявляют в программе баги и ошибки. Для этого они используют разные средства, как ручные, так и автоматические. После выявления багов и ошибок они сообщают об этом разработчикам, и те исправляют эти ошибки.</p></li>
<li><p><strong>Product Owner</strong> (владелец проекта) — это заказчик или представитель заказчика. Это либо кто-то со стороны клиента (сторонняя фирма или физ.лицо), либо какой-то другой сотрудник фирмы, определяющий требования к конечному продукту и следящий за их выполнением (например, бизнес-аналитик). Как уже было сказано, он определяет требования к продукту и задачи, которые должна решить команда разработки, чтобы получить конечный продукт. Список требований (или задач) он оформляет в определённым порядке и с заданным приоритетом для каждого требования (задачи). Обычно он участвует в планировании спринта (перед началом спринта) и в демонстрации результатов спринта (после окончания спринта).</p></li>
<li><p>Во главе иерархии исключений в Java стоит класс <code>Throwable</code>. От не наследуются два класса: <code>Error</code> и <code>Exception</code>. Объекты первого класс выбрасываются, когда возникают какие-то серьёзные ошибки в работе программы и java-машины в целом (а также в работе ОС и аппаратной части компьютера), так, что программа больше не может продолжать работать и закрывается. Это может быть недостаток памяти (OutOfMemoryError) или переполнение стека (StackOverflowError).</p>
<p>Экземпляры второго класса могут выбраться при самых различных исключительных ситуаций. Собственно от этого класса наследуется класс <code>RuntimeException</code> и все остальные классы. Первый класс так выделяют, потому что, во-первых, исключительные ситуации такого типа являются непроверяемые (unchecked), а, во-вторых, к данным исключительным ситуациям относятся ошибки выполнения программы. Обычно это возникает из-за несовершенства кода. Все остальные исключительные ситуации обычно являются следствием непредвиденного стечения обстоятельств, например, ошибки ввода-вывода. </p>
<p>Также исключения делятся на проверяемые (checked) и непроверяемые (unchecked). Первые необходимо либо отлавливать в блоке <code>try-catch</code>, либо указывать в качестве выбрасываемых в сигнатуре метода (используя слово <em>throws</em>). Непроверяемые этого не требуют, и выбор остаётся за программистом. К проверяемым относятся исключения типа <code>Throwable</code> (а также наследуемые от него) и типа <code>Exception</code> (и наследуемые от него, кроме исключений типа <code>RuntimeException</code>). К непроверяемым относятся исключения типа <code>Error</code> (а также наследуемые от него) и исключения типа Runtime (и наследуемые от него). </p></li>
<li><p>Ничего, программа просто закроется. Обычно это критические ошибки, не всегда возникшие по вине программиста (например, выход из строя жёсткого диска или сбой операционной системе). Правда, среди них есть две ошибки, которые могу следствием несовершенства кода — это <code>StackOverflowError</code> и <code>OutOfMemoryError</code>. Первый тип ошибок возник, при переполнении стека вызовов — то есть, когда вызывается слишком много методов и стек вызовов становится слишком больший  (типичный пример — бесконечная рекурсия или рекурсия с большим количеством итераций). Вторая ошибка — <code>OutOfMemoryError</code> — возникает, когда переполняет память отведённая под объекты, то есть когда создаётся слишком много тяжеловесных объектов, и они все держатся в памяти (или когда сборщик мусора не успевает их уничтожать).</p></li>
<li><p>В Java 7 в плане исключение были введены три новых "вещи":</p>
<ul>
<li><code>Multicatching</code>. Это когда в одном <code>catch</code>-блоке сразу обрабатывается несколько исключений:</p>
<pre class='lang-java line-numbers'><code>
try {
 } catch (Exception1|Exception2|Exception3| ... | ExceptionN ex) {}
</code></pre>
<p>В таком случае параметр <code>ex</code> будет неявно иметь модификатор <code>final</code>. Кроме того, байт-код, сгенерированный компиляцией такого кода (с единым <code>catch</code>-блоком) будет короче, чем байт-код, сгенерированный компиляцией кода с несколькими <code>catch</code>-блоками.</p></li>
<li><code>Try-with-resources</code>. Эта конструкция позволяет после слова <code>try</code> в скобках указать открываемые ресурсы, которые сами закроются после окончания конструкции <code>try () {} catch{}</code>. В качестве ресурса в данной конструкции может быть использован любой объект, реализующий интерфейс <code>AutoCloseable</code>.</p>
<p>Во время закрытия ресурсов тоже может быть брошено исключение. В <code>try-with-resources</code> добавлена возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения, получившиеся во время закрытия. Получить последние можно вызовом метода <code>getSuppressed()</code> от исключения, брошенного <code>try</code>-блоком.</p></li>
<li><p> <code>Rethrowing</code>. Перебрасывание исключений с улучшенной проверкой соответствия типов.</p>
<p>Компилятор Java SE 7 тщательнее анализирует перебрасываемые исключения. Рассмотрим следующий пример:</p>
<pre class='lang-java line-numbers'><code>
 static class FirstException extends Exception { }
 static class SecondException extends Exception { }
 
 public void rethrowException(String exceptionName) throws Exception {
     try {
         if ("First".equals(exceptionName)) {
             throw new FirstException();
         } else {
             throw new SecondException();
         }
     } catch (Exception ex) {
         throw e;
     }
 }
</code></pre>
<p>В примере <code>try</code>-блок может бросить либо <code>FirstException</code>, либо <code>SecondException</code>. В версиях до Java SE 7 невозможно указать эти исключения в декларации метода, потому что <code>catch</code>-блок перебрасывает исключение <code>ex</code>, тип которого – <code>Exception</code>.</p>
<p>В Java SE 7 вы можете указать, что метод <code>rethrowException</code> бросает только <code>FirstException</code> и <code>SecondException</code>. Компилятор определит, что исключение <code>Exception</code> ex могло возникнуть только в <code>try</code>-блоке, в котором может быть брошено <code>FirstException</code> или <code>SecondException</code>. Даже если тип параметра <code>catch</code> — <code>Exception</code>, компилятор определит, что это экземпляр либо <code>FirstException</code>, либо <code>SecondException</code>:</p>

<pre class='lang-java line-numbers'><code>
public void rethrowException(String exceptionName) throws FirstException, SecondException {
     try {
         // ...
     } catch (Exception e) {
         throw e;
     }
 }
</code></pre>
<p>Если <code>FirstException</code> и <code>SecondException</code> не являются наследниками <code>Exception</code>, то необходимо указать и <code>Exception</code> в объявлении метода. </p></li>
<li><p>Аннотации используются для размещения рядом с классом, полем, методом или переменой какой-то дополнительной, служебной информации (метаданных), относящейся к ней. Чтобы указать аннотацию, надо над заголовком класса или метода, либо надо объявлением поля или переменной, написать после @ название аннотации (класса аннотации), например так:</p>
<pre class='lang-java line-numbers'><code>
 ...
 @Override
 public void doSomeThing() {
 }
 ...
</code></pre>
<p>Кроме того, у аннотации могут быть свойства, они указывают в скобках через запятую в виде пар "ключ=значение", где в качестве ключа выступает название свойства, а качестве значения — собственно, значение, которое должно принять это свойство. Выглядит это так:</p>

<pre class='lang-java line-numbers'><code>
@CatInfo(manager=Catmanager.class, unique=true)
class Cat {}
</code></pre>
<p>Если указывается указывает значение только для одного свойства, то имя свойства и знак равно можно не писать: <code>@SuppressWarnings("unchecked")</code>.</p>
<p>Также можно вообще не ставить скобки, если никаким свойствам не присваиваются никакие значения.</p>
<p>Чтобы создать свою аннотацию, надо указать модификатор доступа, потом после пробела ключевое слово "<em>@interface</em>" и дальше опять после пробела имя аннотации (принять начинать его с большой буква). Дальше идёт тело аннотации в фигурных скобках. Внутри тела указываются свойства в виде объявлений методов (как в интерфейсах). Также у свойств можно указать значения по умолчанию (они их будут принимать, если при указании аннотации в нужном месте, этому свойству не будет присвоено какое-то значение). Всё вместе это выглядит так:</p>
<pre class='lang-java line-numbers'><code>
@interface CatManager
{
 Class manager();
 boolean unique();
 String name() default "Unknown Cat";
}
</code></pre>
<p>Аннотации выполняют следующие функции:</p>
<ul style="list-style-type:lower-alpha">
<li>дают необходимую информацию для компилятора;</li>
<li>дают информацию различным инструментам для генерации другого кода, конфигураций и т. д.;</li>
<li>могут использоваться во время работы кода;</li>
<li>повышают читабельность кода и его понимание программистами.</li>
</ul>На данный момент компилятором используют три аннотации: <code>@Deprecated</code>, <code>@Override</code> и <code>@SuppressWarnings</code>. Первой аннотацией помечаются устаревшие методы и классы, нерекомендованные к использованию (компилятор по их поводу показывает предупреждение). Вторая аннтоциая ставится над переопределёнными методами класса-наследника (это позволяет контролировать связь между исходным методом и переопределённым). Третья аннотация позволяет подавлять (не выводить) некоторые исключительные предупреждения, обычно выводимые компилятором в связи с данным методом или классом (например, что он уже устарел и нерекомендован к использованию).</p></li></ol>