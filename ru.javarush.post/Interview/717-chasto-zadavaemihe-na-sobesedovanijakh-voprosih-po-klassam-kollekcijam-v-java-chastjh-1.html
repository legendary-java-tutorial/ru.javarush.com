Часто задаваемые на собеседованиях вопросы по классам коллекциям в Java (Часть 1)
<p>----------------------------------------</p>
Без сомнения, коллекции в Java это крайне важная область, и вопросы по коллекциям будут задавать на собеседованиях как новичкам так и опытным программистам. Тема настолько обширна, что практически...
<p>----------------------------------------</p>
Без сомнения, коллекции в Java это крайне важная область, и вопросы по коллекциям будут задавать на собеседованиях как новичкам так и опытным программистам. Тема настолько обширна, что практически невозможно покрыть ее целиком. И все же, основываясь на моих предыдущих собеседованиях, я попробую перечислить как можно больше ХОРОШИХ вопросов, к которым вы должны быть готовы.

<img data-id="55b28d57-6208-48f7-98b0-901123de48d0" data-max-width="850" alt="Часто задаваемые на собеседованиях вопросы по классам коллекциям в Java (Часть 1) - 1" src="https://cdn.javarush.com/images/article/55b28d57-6208-48f7-98b0-901123de48d0/1024.jpeg">Вопросы будут как сложные так и простые, так что если вопрос кажется вам слишком примитивным - не забывайте что он отлично подойдет менее опытному программисту.

<h2>Вопросы в этой статье:</h2><strong>Общие вопросы</strong><ol>
<li>Что такое коллекции в Java? Перечислите их преимущества</li>
<li>Расскажите про иерархию коллекций</li>
<li>Почему коллекции не наследуют интерфейсы <code>Cloneable</code> и <code>Serializable</code>?</li>
<li>Почему интерфейс <code>Map</code> не наследует интерфейс <code>Collection</code>?</li></ol><strong>Вопросы про списки</strong><ol><li value="5">Почему мы используем списки? Какие основные классы реализуют интерфейс <code>List</code>?</li>
<li>Как преобразовать массив строк в <code>ArrayList</code>?</li>
<li>Как отсортировать список в обратном порядке?</li></ol><strong>Вопросы про множества</strong><ol>
<li value="8">Почему мы используем множества? Какие основные классы реализуют интерфейс <code>Set</code>?</li>
<li>Как хранятся элементы в <code>HashSet</code>?</li>
<li>Может ли элемент <code>null</code> быть добавлен в <code>TreeSet</code> или <code>HashSet</code>?</a></li></ol><strong>Вопросы про словари</strong><ol>
<li value="11">Почему мы используем словари? Какие основные классы реализуют интерфейс <code>Map</code>?</a></li>
<li>Что такое <code>IdentityHashMap</code> и <code>WeakHashMap</code>?</li>
<li>Объясните что такое <code>ConcurrentHashMap</code>? Как оно работает?</li>
<li>Как работают словари?</li>
<li>Как создать хороший ключ для словаря?</li>
<li>Какие представления содержимого предоставляет интерфейс <code>Map</code>?</li>
<li>Когда нужно использовать <code>HashMap</code>, а когда <code>TreeMap</code>?</li></ol><strong><a href='https://javarush.com/groups/posts/716-chasto-zadavaemihe-na-sobesedovanijakh-voprosih-po-klassam-kollekcijam-v-java-chastjh-2' target='_blank'>Вопросы о различиях разных коллекций</a></strong><ol>
<li value="18">Назовите различия между <code>Set</code> и <code>List</code>?</li>
<li>Назовите различия между <code>List</code> и <code>Map</code>?</li>
<li>Назовите различия между <code>HashMap</code> и <code>HashTable?</code></li>
<li>Назовите различия между <code>Vector</code> и <code>ArrayList</code>?</li>
<li>Назовите различия между <code>Iterator</code> и <code>Enumeration</code>?</li>
<li>Назовите различия между <code>HashMap</code> и <code>HashSet</code>?</li>
<li>Назовите различия между <code>Iterator</code> и <code>ListIterator</code>?</li>
<li>Назовите различия между <code>TreeSet</code> и <code>SortedSet</code>?</li>
<li>Назовите различия между <code>ArrayList</code> и <code>LinkedList</code>?</li></ol><strong><a href='https://javarush.com/groups/posts/716-chasto-zadavaemihe-na-sobesedovanijakh-voprosih-po-klassam-kollekcijam-v-java-chastjh-2' target='_blank'>И еще вопросы</a></strong><ol>
<li value="27">Как сделать коллекцию только для чтения?</li>
<li>Как сделать потокобезопасную коллекцию?</li>
<li>Почему не существует метода <code>Iterator.add()</code> для добавления элементов в коллекцию?</li>
<li>Какие существуют способы перебирать элементы списка?</li>
<li>Как вы понимаете работу свойства итератора <code>fail-fast</code>?</li>
<li>Какая разница между <code>fail-fast</code> и <code>fail-safe</code>?</li>
<li>Как избежать <code>ConcurrentModificationException</code> во время перебора коллекции?</li>
<li>Что такое <code>UnsupportedOperationException</code>?</li>
<li>Какие классы коллекций дают доступ к любому элементу?</li>
<li>Что такое <code>BlockingQueue</code>?</li>
<li>Что такое очередь и стэк, перечислите различия между ними?</li>
<li>Что такое интерфейсы <code>Comparable</code> и <code>Comparator</code>?</li>
<li>Что такое классы <code>Collections</code> и <code>Arrays</code>?</li>
<li>Список использованной литературы</li>
</ol>Не тратя зря время, приступим к объяснениям</ol><h2>Общие вопросы</h2><ol>
<li><p><strong>Что такое коллекции в Java? Перечислите их преимущества?</strong></p>
<p>По определению — коллекция это объект представляющий собой группу объектов. Как в теории множеств — множество это группа объектов. Просто, не так ли? До выхода JDK 1.2, существовали классы такие как <code>Vector</code> и <code>HashTable</code>, но не было фреймворка <code>Collection</code>. Потом было решено добавить поддержку многократно используемых структур данных. Данный фреймворк был разработан преимущественно Джошуа Блохом, и впервые появился в JDK 1.2.</p>
<p>В качестве главных преимуществ мы можем перечислить:</p><ul>
<li>Уменьшаются затраты времени на написание кода</li>
<li>Улучшается производительность, благодаря использованию высокоэффективных алгоритмов и структур данных</li>
<li>Коллекции являются универсальным способом хранения и передачи данных, что упрощает взаимодействие разных частей кода</li>
<li>Простота в изучении, потому что необходимо выучить только самые верхние интерфейсы и поддерживаемые операции</li>
</ul></li>
<li><p><strong>Расскажите про иерархию коллекций?</strong></p>
<img data-id="b266e805-26b9-4e74-9808-66fce11e7a7d" data-max-width="650" alt="Часто задаваемые на собеседованиях вопросы по классам коллекциям в Java (Часть 1) - 2" src="https://cdn.javarush.com/images/article/b266e805-26b9-4e74-9808-66fce11e7a7d/1024.jpeg">
<p>Как показано на картинке, фреймворк коллекций содержит один интерфейс верхнего уровня — <code>Collection</code>, от которого наследуются <code>Set</code>, <code>List</code> и <code>Queue</code>. Ниже мы рассмотрим еще множество классов, содержащихся в этих трех ветвях. Запомните заголовок интерфейса <code>Collection</code>, это поможет вам с многими вопросами.</p>

<pre class='lang-java line-numbers'><code>
public interface Collection extends Iterable {
//описание методов
}
</code></pre>
<p>Также фреймворк содержит <a href='https://javarush.com/groups/posts/763-9-glavnihkh-voprosov-o-map-v-java' target='_blank'>интерфейс Map</a>, который не является наследником интерфейса <code>Collection</code>. Причину почему он не наследует <code>Collection</code>, мы разберем в четвертом вопросе.</p></li>
<li><p><strong>Почему коллекции не наследуют интерфейсы <code>Cloneable</code> и <code>Serializable</code>?</strong></p>
<p>Ну, простейший ответ — "потому что не надо". Функционал предоставляемый интерфейсами <code>Cloneable</code> и <code>Serializable</code> просто не нужен для коллекций.</p>
<p>Еще одна причина — далеко не всегда нужен подкласс <code>Cloneable</code> потому что каждая операция клонирования потребляет очень много памяти, и неопытные программисты могут расходовать ее сами не понимая последствий.</p>

<p>И последняя причина — клонирование и сериализация являются очень узкоспецифичными операциями, и реализовывать их нужно только когда это необходимо. Многие классы коллекции реализуют данные интерфейсы, но совершенно незачем закладывать их для всех коллекций вообще. Если вам нужно клонирование и сериализация - просто воспользуйтесь теми классами где она есть, если нет — остальными классами.</p></li>
<li><p><strong>Почему интерфейс <code>Map</code> не наследует интерфейс <code>Collection</code>?</strong></p>
<p>Хороший ответ на этот вопрос — "потому что они несовместимы". В интерфейсе <code>Collection</code> описан метод <code>add(Object o)</code>.</p> <p>Словари не могут содержать этот метод, потому что работают с парами ключ/значение. Также, словари имеют представления <code>keySet</code>, <code>valueSet,</code> которых нет в коллекциях.</p>
<p>В связи с этими различиями, интерфейс <code>Map</code> не может наследовать интерфейс <code>Collection</code>, и представляет собой отдельную ветвь иерархии.</p></li></ol><h2>Вопросы про списки</h2><ol>
<li value="5"><p><strong>Почему мы используем списки? Какие основные классы реализуют интерфейс <code>List</code>?</strong></p>
<p>Списки в Java это упорядоченная коллекция элементов. Каждый элемент имеет индекс, начинающийся с нуля. Все индексы уникальны. Кроме методов описанных в интерфейсе <code>Collection</code>, списки имеют свои собственные методы, в основном для работы с элементами коллекциями по их индексу. Можно разделить эти методы на 3 группы — поиск элемента, получение конкретного элемента, перебор коллекции и выборка подгруппы. Все эти операции могут производиться по индексу элемента.</p>
<p>Основные классы, реализующие интерфейс <code>List</code> это <code>Stack</code>, <code>Vector</code>, <code>ArrayList</code> и <code>LinkedList</code>. За более подробной информацией по ним, обратитесь к документации.</p></li>
<li><p><strong>Как преобразовать массив строк в <code>ArrayList</code>?</strong></p>
<p>Вопрос этот несколько глубже чем просто по программированию, как это видится новичкам. Цель его — проверить знание кандидатом служебных классов фреймворка <code>Collection</code>. Рассмотрим два таких класса, наиболее востребованных на собеседованиях — <code>Collections</code> и <code>Arrays</code>.</p>
<p>Класс <code>Collections</code> предоставляет статические методы для операций над коллекциями. Соответственно <code>Arrays</code> предоставляет статические методы для операций над массивами.</p>

<pre class='lang-java line-numbers'><code>
String[] words = {"аз", "буки", "веди", "глагол", "добро"};
//Как вы можете обратить внимание, у нас есть массив строк String[] words. 
//В котором у нас лежат 5 строк.
List wordList = Arrays.asList(words);
//легким движением руки, а точнее вызовом Arrays.asList() мы превратили наш
//массив строк в список List wordList.
</code></pre>
<p>Также хотелось бы отметить, что этот метод способен обрабатывать не только строки, он создаст список элементов любого типа, которого был массив.</p>
<pre class='lang-java line-numbers'><code>
Integer[] nums = {1, 2, 3, 4};
List numList = Arrays.asList(nums);
</code></pre></li>
<li><p><strong>Как отсортировать список в обратном порядке?</strong></p>
<p>Как и предыдущий, этот вопрос проверяет ваше знание служебных классов <code>Collection</code></p>
<pre class='lang-java line-numbers'><code>
List reversedList = Collections.reverse(list);
</code></pre></li></ol><h2>Вопросы про множества</h2><ol><li value="8"><p>Почему мы используем множества? Какие основные классы реализуют интерфейс <code>Set</code>?</p>
<p>Он моделирует математическое множество, из теории множеств. Интерфейс <code>Set</code> похож на <code>List</code>, но имеет некоторые отличия. Первое — это не упорядоченная коллекция. Следовательно, добавление/удаление элементов не требует их сортировки. Главная особенность множеств - уникальность элементов, то есть один и тот же элемент не может содержаться в множестве дважды.<p>

<p>Очень важными для функционирования множеств являются методы <code>equals()</code> и <code>hashCode()</code>, они позволяют сравнивать множества разных классов. Два множества являются идентичными только если они содержат одни и те же элементы.</p>
<p>Как следует из вышеизложенного, множества не поддерживают операций основанных на индексе элемента, как списки. Множества имеют только те методы которые описаны в интерфейсе <code>Collection</code></p>

<p>Основными классами, реализующими интерфейс <code>Set</code>, являются <code>EnumSet</code>, <code>HashSet</code>, <code>LinkedHashSet</code> и <code>TreeSet</code>. Если хотите узнать больше — почитайте соответствующие разделы документации Java.</p></li>
<li><p><strong>Как хранятся элементы в <code>HashSet</code>?</strong></p>
<p>Как вы уже в курсе, <code>HashMap</code> хранит пары ключ/значение, и ключи должны быть уникальны. <code>HashSet</code> использует эту особенность <code>HashMap</code> для обеспечения уникальности своих элементов. В классе <code>HashSet</code>, словарь описан следующим образом:</p>
<pre class='lang-java line-numbers'><code>
private transient HashMap&lt;E, Object&gt; map;
private static final Object PRESENT = new Object();
</code></pre>
<p>Итак, когда вы сохраняете элемент в множестве, оно кладет данный элемент в качестве ключа в словарь, а значением идет объект PRESENT, как это описано ниже:</p>
<pre class='lang-java line-numbers'><code>
public boolean add(E e) {
  return map.put(e, PRESENT) == null;
}
</code></pre>
<p>Я настоятельно рекомендую вам прочесть <a href='https://howtodoinjava.com/java/collections/hashmap/how-hashmap-works-in-java/' rel='nofollow' target='_blank'>эту статью</a>, это поможет вам с легкостью ответить на все связанные с <code>HashMap</code> вопросы.</p></li>
<li><p><strong>Может ли элемент <code>null</code> быть добавлен в <code>TreeSet</code> или <code>HashSet</code>?</strong></p>
<p>Как видно из предыдущего ответа, в методе <code>add()</code> нет проверки на <code>null</code>. Также, <code>HashMap</code> позволяет один ключ <code>null</code>, следовательно, один элемент <code>null</code> может быть добавлен в <code>HashSet</code>.</p>
<p><code>TreeSet</code> работает по тому же принципу что и <code>HashSet</code>, но использует <code>NavigableMap</code> для хранения элементов</p>
<pre class='lang-java line-numbers'><code>
private transient NavigableMap&lt;E,Object&gt; m;
private static final Object PRESENT = new Object();
</code></pre>

<p><code>NavigableMap</code> это класс-наследник <code>SortedMap</code>, а <code>SortedMap</code> не позволяет использование ключей <code>null</code>. Следовательно, и <code>TreeMap</code> не поддерживает хранение элементов типа <code>null</code>. Если вы попробуете добавить <code>null в TreeSet</code>, получите исключение <code>NullPointerException</code>.</p></li></ol><h2>Вопросы про словари</h2><ol>
<li value="11"><p><strong>Почему мы используем словари (<code>Map</code>)? Какие основные классы реализуют интерфейс <code>Map</code>?</strong></p>
<p>Словари — специальный тип коллекции, которая используется для хранения пар ключ/значение. По этой причине он не является наследником интерфейса <code>Collection</code>. Словарь предоставляет методы для добавления пар ключ/значение, удаления, поиска и перебора по предоставляемым словарем представлениям данных.</p>
<p>Основные классы реализующие интерфейс <code>Map</code>: <code>HashMap</code>, <code>Hashtable</code>, <code>EnumMap</code>, <code>IdentityHashMap</code>, <code>LinkedHashMap</code> и <code>Properties</code>.</p></li>
<li><p><strong>Что такое <code>IdentityHashMap</code> и <code>WeakHashMap</code>?</strong></p>
<p><code>IdentityHashMap</code> похож на <code>HashMap</code> за одним исключением — для сравнения объектов используется сравнение указателей на объекты, если указатели не равны (указывают на объекты лежащие по разным адресам), значит объекты считаются различными.</p><p><code>IdentityHashMap</code> является довольно редко используемым. Хотя он реализует интерфейс <code>Map</code>, он нарушает один из основных принципов устройства <code>Map</code>, который требует использования метода <code>equals()</code> для сравнения объектов.</p><p><code>IdentityHashMap</code> используется только в тех случаях, когда требуется сравнение объектов по их адресам.</p>
<p><code>WeakHashMap</code> это реализация интерфейса <code>Map</code>, которая содержит слабые ссылки на элементы. То есть, если за пределами <code>WeakHashMap</code> не осталось ни одной ссылки на его элемент, этот элемент удаляется сборщиком мусора. Класс предназначен для использования с объектами, у которых метод <code>equals()</code> проверяет идентичность объектов с помощью оператора <code>==</code>. После того как элемент будет удален сборщиком мусора, он уже не может быть восстановлен, и к большому удивлению программиста найти его в словаре больше не получится.</p></li>
<li><p><strong>Объясните что такое <code>ConcurrentHashMap</code>? Как оно работает?</strong></p>
<p><em>Взято с официальной документации:</em><br />
Реализация словаря полностью поддерживающая многопоточное добавление/удаление/поиск элементов. Данный класс следует тем же спецификациям что и <code>Hashtable</code>, и содержит методы соответствующие методам <code>Hashtable</code>. Однако, хотя все операции являются потокобезопасными, операция по выборке элементов не блокирует таблицу, и вообще нет возможности запретить весь доступ к таблице. Этот класс совместим с <code>Hashtable</code> во всем кроме вопросов многопоточной синхронизации.</p></li>
<li><p><strong>Как работает <code>hashmap</code>?</strong></p>
<p>Самый важный вопрос, который скорее всего будет задан на собеседовании программисту любого уровня. Вы должны хорошо разбираться в этой теме, и не только потому что это самый задаваемый вопрос, но и потому что понимание устройства <code>hashmap</codE> позволяет вам легче разобраться в других особенностях работы коллекций.</p>
<p>Ответ на этот вопрос очень обширный, и полностью его можно прочесть в этой статье — <a href = "http://howtodoinjava.com/2012/10/09/how-hashmap-works-in-java/" rel="nofollow" > как работает hashmap</a>. А на данный момент просто запомните что <code>HashMap</code> работает на основе хэширования. Словарь, по определению, это объект который связывает ключи и значения. Для хранения таких структур, он использует внутренний класс <code>Entry</code>.</p>

<pre class='lang-java line-numbers'><code>
static class Entry implements Map.Entry
{
final K key;
V value;
Entry next;
final int hash;
...//Еще много кода тут
}
</code></pre>
<p>Переменные <code>key</code> и <code>value</code> служат для хранения ключа и значения. А сами объекты <code>Entry</code> лежат в массиве.</p>
<pre class='lang-java line-numbers'><code>
/**
* Размер таблицы меняется по необходимости, 
* и обязательно должен быть равен степени двойки
*/
transient Entry[] table;
</code></pre>
<p>Индекс нужного элемента в массиве вычисляется по хэш-коду ключа. Больше информации можете получить по ссылке в начале ответа.</p></li>
<li><p><strong>Как создать хороший ключ для словаря?</strong></p>
<p>Следующий хороший вопрос, который обычно задают следом за вопросом о функционировании <code>HashMap</code>. Итак, главное ограничение — ключ должен быть таким, чтобы потом по нему можно было получить из словаря значение. Иначе в его использовании просто нет смысла. Если вы понимаете как функционирует <code>hashmap</code>, вы знаете что его работа сильно зависит от методов <code>hashCode()</code> и <code>equals()</code> объектов-ключей.</p>
<p>Как следует из вышеизложенного, хороший ключ должен давать один и тот же <code>hashCode</code> снова и снова, независимо от того сколько раз он запрашивается. А также, одинаковые ключи, при вызове метода <code>equals()</code> должны возвращать true, а разные — false.</p>
<p>Из чего следует, что лучшими кандидатами на роль ключа являются неизменяемые классы.</p>
<p>Можете почитать еще по <a href = "http://howtodoinjava.com/2013/05/02/how-to-design-a-good-key-for-hashmap/" rel="nofollow" > адресу</a>.</p></li>

<li><p><strong>Какие представления содержимого предоставляет интерфейс <code>Map</code>?</strong></p>
<p>Интерфейс <code>Map</code> предоставляет три представления хранящихся данных:</p>
<ul>
    <li>множество всех ключей</li>
    <li>множество всех значений</li>
    <li>множество объектов <code>Entry</code>, содержащих в себе и ключ и значение</li>
</ul><p>Перемещаться по ним можно с помощью итераторов.</p></li>
<li><p><strong>Когда нужно использовать <code>HashMap</code>, а когда <code>TreeMap</code>?</strong></p>
<p><code>HashMap</code> это очень широко используемый класс, и вы это знаете. Так что, я ограничусь тем, что скажу что в нем хранятся пары ключ/значение и он позволяет проводить над ними многие операции.</p>
<p><code>TreeMap</code> это особая разновидность <code>HashMap</code>. Разница в том, что ключи в <code>TreeMap</code> хранятся упорядоченно. По умолчанию применяется "естественная сортировка". Переопределить сортировку можно предоставив экземпляр класса <code>Comparator</code>, метод <code>compare</code> которого и будет использован для сортировки ключей.</p>
<p>Обратите внимание, что все ключи добавленные в словарь должны реализовывать интерфейс <code>Comparable</code> (это необходимо для сортировки). Более того, все ключи должны быть взаимно совместимыми:<code> k1.compareTo(k2)</code> не должен вызывать <code>ClassCastException</code> для любых <code>k1</code> и <code>k2</code> хранящихся в словаре. Если пользователь попытается положить в словарь ключ который нарушает это условие (к примеру, строковый ключ в словарь где все ключи типа <code>Integer</code>), метод <code>put(Object key, Object value)</code> должен вызвать <code>ClassCastException</code>.</p></li></ol><a href='https://howtodoinjava.com/interview-questions/useful-java-collection-interview-questions/#difference_set_and_list' rel='nofollow' target='_blank'>Оригинал статьи</a>