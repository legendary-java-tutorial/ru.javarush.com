Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 1
<p>----------------------------------------</p>
Привет! На JavaRush собрались разные люди. Одни из нас только хотят стать Java-разработчиками, вкладывая много времени и сил в развитие, а другие — уже Java developer-ы. В том или ином случае, необходимо быть готовыми к испытаниям...
<p>----------------------------------------</p>
Привет!

На JavaRush собрались разные люди. Одни из нас только хотят стать Java-разработчиками, вкладывая много времени и сил в развитие, а другие — уже Java developer-ы. 

В том или ином случае, необходимо быть готовыми к испытаниям — техническим собеседованиям. Это испытание не из легких, и помимо моральной подготовки нужна и техническая.

<img data-max-width="800" data-id="4fb6a017-e62d-45e0-a911-e38732dbdd70" src="https://cdn.javarush.com/images/article/4fb6a017-e62d-45e0-a911-e38732dbdd70/800.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 1">Недавно я наткнулся на <a href="https://dou.ua/lenta/articles/interview-questions-java-developer/" rel="nofollow" target="_blank">большой список вопросов для собеседований</a> на Java разработчика на dou. Данные вопросы поделены на различные уровни — Junior, Middle и Senior. Не пугайтесь: не все вопросы из легких, но те, что “со звездочкой” довольно редко задают.

Вопросы — это хорошо, но мне бы хотелось попытаться ответить на большинство из них. Понятное дело, что я не вложусь в рамки одной статьи, как-никак, вопросов там чрезвычайно много. Поэтому это будет целый цикл из статьей-ответов на такие вопросы.

Сразу подчеркну несколько моментов:<ol>

<li><p>Есть отличная <a href="https://javarush.com/groups/posts/2590-top-50-java-core-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">статья</a> с топом вопросов и ответов для них. Некоторые вопросы пересекаются с представленным выше списком (250+), поэтому эти вопросы будут пропускаться, дабы не дублировать лишний раз информацию.</p></li>
<li><p>Вопросы представлены на украинском, но так как большинство участников JavaRush русскоязычные (да и я в большей мере тоже), ответы будут на русском.</p></li>
<li><p>Ответы будут краткими, так как если расписывать очень подробно, ответы на некоторые вопросы могут потянуть на отдельную статью. Да и на собеседованиях настолько подробные и объемные ответы не нужны, ведь у вас вашего интервьюера есть всего лишь час на то, чтобы опросить вас по необходимым темам (а, как вы помните, тем хватет). Для любителей покопать поглубже я буду оставлять ссылки.</p></li>

</ol>Итак, начнём.<h2>Вопросы и ответы уровня Junior</h2><img data-max-width="512" data-id="7cf11781-5474-467f-ad77-0c0c11ac80a0" src="https://cdn.javarush.com/images/article/7cf11781-5474-467f-ad77-0c0c11ac80a0/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 2"><h3>Общие вопросы</h3><h4>1. Какие вы знаете шаблоны проектирования? Расскажите о двух шаблонах, которые использовали в работе.</h4>Шаблонов есть огромное множество: начать знакомство с ними можно с <a href="https://javarush.com/groups/posts/1354-shablonih-proektirovanija-dlja-chaynikov" target="_blank">этой</a> и этой статьи. Ну а для тех из вас, кто хочет обстоятельно ознакомиться с ними, рекомендую прочитать книгу <span class="text-bold">“Head First. Паттерны проектирования”</span>. С ее помощью вы сможете подробно и в легкой форме изучить самые базовые паттерны проектирования.
 
Говоря о шаблонах проектирования, которые вы можете привести в качестве примеров на собеседовании, на ум приходят:<ul>
<li><a href="https://javarush.com/groups/posts/1990-pattern-shablon-builder" target="_blank">Builder</a> — часто используемый шаблон, альтернатива классическому созданию объектов; </li>
<li>паттерн <span class="text-bold">Стратегия</span>, который по своей сути представляет полиморфизм. То есть, у нас есть один интерфейс, но поведение программы будет меняться в зависимости от того, какую конкретно реализацию этого интерфейса передали в функционал (сейчас стратегия фактически везде используется в java-приложениях).</li>

</ul>Если этого вам мало, обратите внимание на <span class="text-bold">Spring</span> (если вы с ним уже знакомы), ведь он представляет собой целую платформу фреймворков, которые в свою очередь пронизаны паттернами вдоль и поперек.
 
Вот вам пара примеров того, о чем я говорю:<ul>
<li><span class="text-bold">Factory</span> — в ApplicationContext (ну или в BeanFactory);</li>
<li><span class="text-bold">Singleton</span> — все бины по умолчанию синглтоны;</li>
<li><span class="text-bold">Proxy</span> — по сути все в спринге так или иначе использует этот паттерн, например, АОП;</li>
<li><span class="text-bold">Chain of responsibility</span> — паттерн, по концепции которого работает Spring Security;</li>
<li><span class="text-bold">Template</span> — используется в Spring Jdbc.</li>
 
</ul><h3>Java Core</h3><img data-max-width="512" data-id="80fa5bad-3199-427a-8b96-a069c491678c" src="https://cdn.javarush.com/images/article/80fa5bad-3199-427a-8b96-a069c491678c/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 3"><h4>2. Какие типы данных есть в Java?</h4>В Java есть примитивные типы данных:<ul>
<li><span class="text-bold">byte</span> — целые числа в пределах -128 до 127, весит 1 байт;</li>
<li><span class="text-bold">short</span> — целые числа в пределах -32768 до 32767, весит 2 байта;</li>
<li><span class="text-bold">int</span> — целые числа -2147483648 до 2147483647, весит 4 байта;</li>
<li><span class="text-bold">long</span> — целые числа в пределах 9223372036854775808 до 9223372036854775807, весит 8 байтов;</li>
<li><span class="text-bold">float</span> — числа с плавающей запятой в пределах -3.4E+38 до 3.4E+38, весит 4 байта;</li>
<li><span class="text-bold">double</span> — числа с плавающей запятой в пределах -1.7E+308 до 1.7E+308, весит 8 байтов;</li>
<li><span class="text-bold">char</span> — одиночные символы в UTF-16, весит 2 байта;</li>
<li><span class="text-bold">boolean</span> значения <span class="text-bold">true/false</span>, весит 1 байт.</li>

</ul>И <a href="https://javarush.com/groups/posts/2642-ssihlochnihe-tipih-dannihkh-v-java" target="_blank">ссылочные типы данных</a>, которые указывают на объекты в куче.<h4>3. Чем объект отличается от примитивных типов данных?</h4>Первое отличие: количество занимаемой памяти: примитивы занимают очень мало, ведь они содержат лишь собственное значение, в то время как объекты могут содержать очень и очень много различных значений: как примитивов, так и ссылок на другие объекты.
 
Второе отличие: Java —это объектно-ориентированный язык, поэтому в ней все работает через взаимодействие между объектами, и примитивы тут не сильно вписываются (собственно, поэтому Java — это не 100% объектно-ориентированный язык).
 
Третье, вытекающее со второго: так как Java ориентирована на взаимодействие между объектами, у этих объектов есть много различных механизмов для управления. Например, конструкторы, методы, исключения (которые работают в первую очередь с объектами), и т.д.
 
Собственно, чтобы примитивы могли как-то ввязаться (работать) в этой объектно ориентированной среде и были придуманы <a href="https://javarush.com/groups/posts/1948-objertki-raspakovka-i-zapakovka" target="_blank">обертки</a> (wrappers) для примитивных типов (<span class="text-bold">Integer</span>, <span class="text-bold">Character</span>, <span class="text-bold">Double</span>, <span class="text-bold">Boolean</span>...)<h4>4. Чем отличаются передача параметров по ссылке и по значению?</h4>Примитивные поля хранят свое значение: например, если мы задали <span class="code">int i = 9;</span> поле <span class="code">i</span> хранит значение <span class="code">9</span>. Когда у нас есть ссылка на объект, это значит, что мы имеем поле со ссылкой на объект, или другими словами — со значением адреса объекта в памяти.
 
<pre class="language-java line-numbers"><code>
Cat cat = new Cat();
</code></pre>
Получается, поля со ссылкой на объект тоже хранят <span class="text-bold">значения</span>, значения адреса памяти. То есть, <span class="code">cat</span> хранит значение адреса объекта <span class="code">new Cat()</span> в памяти. Когда мы передаем параметр в некоторый метод, то происходит копирование его значения.
 
В случае с примитивом будет копироваться значение примитива. Соответственно, в методе будет вестись работа с копией, при изменении которой оригинал не затронется.
 
В случае со ссылочным типом будет копироваться значение адреса памяти, соответственно, адрес будет все тем же, как и объект, на который он указывает. 
И если мы будем менять объект по этой новой ссылке, он будет изменен и для старой (ведь они обе указывают на один и тот же объект).<h4>5. Что такое JVM, JDK, JRE?</h4><span class="text-bold">JVM — Java Virtual Machine</span> — это виртуальная машина, которая запускает Java байткод, предварительно созданный компилятором.
 
<span class="text-bold">JRE — Java Runtime Environment</span> — по сути, это среда для запуска java-приложений, которая содержит <span class="text-bold">JVM</span>, стандартные библиотеки и другие компоненты для запуска апплетов и приложений, написанных на языке программирования Java.
 
Другими словами <span class="text-bold">JRE</span> — пакет всего необходимого для запуска скомпилированной Java-программы, но при этом не содержащий инструментов и утилит, таких как компиляторы или отладчики для разработки приложений.
 
<span class="text-bold">JDK — Java Development Kit</span> — расширенный набор <span class="text-bold">JRE</span>, то есть, среда не только для запуска, но и для разработки java-приложений.
 
JDK содержит все, что есть в JRE, плюс различные дополнительные инструменты — компиляторы и отладчики, которые нужны для создания приложений на Java (также содержит java-доки).<img data-max-width="512" data-id="98ca7325-01a8-4c2a-b117-164147992c59" src="https://cdn.javarush.com/images/article/98ca7325-01a8-4c2a-b117-164147992c59/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 4"><h4>6. Зачем используют JVM?</h4>Как говорилось выше, Java Virtual Machine — это виртуальная машина, которая запускает Java байткод, предварительно созданный компилятором.

То есть, JVM не понимает исходный код Java.
 
Поэтому сперва происходит компиляция <span class="text-bold">.java</span> файлов, которые после компиляции имеют расширение уже <span class="text-bold">.class</span> и которые и которые представлены в виде того самого байт кода, который понимает JVM. 
 
JVM для каждой OC своя, поэтому получив файлы в байт коде, JVM исполняет его, адаптируя под ОС, на которой это происходит.
 
Собственно, из-за разных JVM версии JDK (или JRE) отличаются для разных ОС (под каждую из них нужна своя JVM).
 
Давайте вспомним, как происходит разработка на других языках программирования. Вы разрабатываете программу, затем её код компилируется в машинный код для конкретной ОС, и после вы можете его запускать. Другими словами, под каждую систему вам нужно писать разные версии программы.
 
В то время как на Java, благодаря двойной обработке кода (компиляция и обработка байт кода JVM), вы можете пользоваться преимуществами кроссплатформенности. 
 
Мы создали однажды код, перекомпилировали его в байткод, перенесли его на любую ОС, и уже местная JVM и запускает код.
 
Это и есть легендарное свойство Java — <span class="text-bold">пишешь однажды, запускаешь где угодно</span>.<img data-max-width="512" data-id="a56a200b-3f18-4b7d-a844-19bebf4a6567" src="https://cdn.javarush.com/images/article/a56a200b-3f18-4b7d-a844-19bebf4a6567/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 5">Подробнее об этом — в статье “<a href="https://javarush.com/groups/posts/2256-kompiljacija-i-ispolnenie-java-prilozheniy-pod-kapotom" target="_blank">Компиляция и исполнение Java-приложений под капотом</a>”.<h4>7. Что такое bytecode?</h4>Как я и говорил выше, компилятор преобразовывает Java-код в промежуточный — <span class="text-bold">bytecode</span> (файлы с расширением .java в файлы с расширением .class).
 
Байткод во многом похож на машинный код, только он использует набор инструкций не реального процессора, а виртуального. При этом он может включать в себя участки, ориентированные на использование JIT-компилятора, оптимизирующего выполнение команд под реальный процессор, на котором запущена программа.
JIT-компиляция, называемая ещё компиляцией на лету— это технология, которая увеличивает производительность программы, использующей байткод, через компиляции байткода в машинный или в другой формат во время работы программы. 

Как вы могли догадаться, JVM и использует JIT-компилятор, когда запускает байткод.

Давайте взглянем на пример bytecode:<img data-max-width="512" data-id="a694a81e-2a82-4959-869a-b9511388eb70" src="https://cdn.javarush.com/images/article/a694a81e-2a82-4959-869a-b9511388eb70/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 6">Не слишком читаемо, не так ли? Ну так, это и не для нас инструкция, а для JVM. Вот <a href="https://javarush.com/groups/posts/394-mashinnihy-kod-i-bayt-kod-na-kakom-jazihke-govorit-vasha-programma" target="_blank">статья</a>, которая поможет получше разобраться в этом вопросе.<h4>8. Каковы признаки JavaBean?</h4><span class="text-bold">JavaBeans</span> — Java-класс с соблюдением определенных правил. Вот несколько правил для написания <span class="text-bold">JavaBean</span>:<ol>
<li><p>Класс должен содержать пустой (без параметров) конструктор с открытым доступом с модификатором доступа <span class="code">public</span>. Этот конструктор дает возможность создавать объект данного класса без лишних проблем (чтобы не было лишней возни с параметрами).</p></li>
<li><p>Доступ ко внутренним полям класса осуществляется через методы <span class="code">get</span> и <span class="code">set</span>, которые должны быть стандартными. Например, если поле <span class="code">name</span>, то <span class="code">getName</span> и <span class="code">setName</span> и т. д. Это, в свою очередь, позволяет различным инструментам (фреймворкам) без осложнений автоматически определять и обновлять содержание bean-ов.</p></li>
<li><p>Класс должен содержать переопределенные версии методов <span class="code">equals()</span> — <span class="code">hashCode()</span> и <span class="code">toString()</span>.</p></li>
<li><p>Класс должен быть сериализуемым, то есть должен иметь интерфейс маркер — Serializable или имплементировать интерфейс <a href="https://javarush.com/groups/posts/2023-znakomstvo-s-interfeysom-externalizable" target="_blank">Externalizable</a>. Это нужно для того, чтобы состояние объекта bean можно надежно сохранять, хранить и восстанавливать.</p></li>

</ol><img data-max-width="512" data-id="403216ef-83c6-4e54-930b-c323814b8cea" src="https://cdn.javarush.com/images/article/403216ef-83c6-4e54-930b-c323814b8cea/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 7">Про виды JavaBeans можно почитать в <a href="https://javarush.com/quests/lectures/questcollections.level06.lecture02" target="_blank">этом материале</a>.<h4>9. Что такое OutOfMemoryError?</h4><span class="text-bold">OutOfMemoryError</span> — одна из критических ошибок во время исполнения программы, связанная с работой виртуальной машины Java (JVM). Вызывается в тех случаях, когда JVM не может выделить объект, потому что на него не хватает памяти, и сборщик мусора не может выделить больше памяти. 
 
Некоторые виды <span class="text-bold">OutOfMemoryError</span>:<ul>
<li><p><span class="text-bold">OutOfMemoryError: Java heap space</span> — объект не может быть размещен в куче Java из-за недостатка памяти. Ошибку может вызвать утечка памяти или то, что размер кучи по умолчанию недостаточен для текущего приложения.</p></li>
<li><p><span class="text-bold">OutOfMemoryError: GC Overhead limit exceeded</span> — из-за того, что объем данных едва помещается в кучу, сборщик мусора работает все время, а программа Java работает очень медленно, и как итог —  превышается предел накладных расходов сборщика мусора и приложение падает с данной ошибкой.</p></li>
<li><p><span class="text-bold">OutOfMemoryError: Requested array size exceeds VM limit</span> — указывает на то, что приложение  попыталось выделить память для массива, размер которого превышает размер кучи, что, опять же может быть из-за недостаточного количества выделенной памяти по умолчанию.</p></li>
<li><p><span class="text-bold">OutOfMemoryError: Metaspace</span> — в куче закончилось место, выделенное для метаданных (метаданные — это инструкции классов, методов).</p></li>
<li><p><span class="text-bold">OutOfMemoryError: request size bytes for reason. Out of swap space</span> — произошел некоторый сбой при попытке выделения памяти из кучи и как итог — нехватка памяти в куче.</p></li>
 
</ul><h4>10. Что такое стек трейс? Как его получить?</h4>Стек трейс (Stack Trace) — это список классов и методов, которые были вызваны до этого момента приложения.
 
Вызвать стек трейс в определенной точке приложения можно так:
 
<pre class="language-java line-numbers"><code>
StackTraceElement[] stackTraceElements =Thread.currentThread().getStackTrace();
</code></pre>
Таким образом мы получим массив стек трейс элементов, расположенных в порядке <span class="text-bold">LIFO — Last In First Out</span>.<img data-max-width="512" data-id="d0b15ef9-d03f-449b-a78d-39812e0032cd" src="https://cdn.javarush.com/images/article/d0b15ef9-d03f-449b-a78d-39812e0032cd/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 8">В Java, как правило, когда говорят о стек трейсе то имеется ввиду стек трейс, который выводится в консоли при возникновении ошибки (или исключения).
 
Получить стек трейс исключений можно так:

<pre class="language-java line-numbers"><code>
StackTraceElement[] stackTraceElements;
try{
                ...
} catch (Exception e) {
   stackTraceElements = e.getStackTrace();
}
</code></pre>
Ну и если мы говорим о выводе стек трейса исключения в консоли:

<pre class="language-java line-numbers"><code>
try{
                ...
} catch (Exception e) {
  e.printStackTrace();
}
</code></pre>
Также, если у нас возникнет ошибка, <span class="text-bold">unchecked</span> исключение или <span class="text-bold">checked</span>, которое мы не обработаем, а только будем пробрасывать, то при падении приложения мы получим автоматически стек трейс исключений в консоли.
 
Небольшой пример стектрейс исключения в консоли:<img data-max-width="800" data-id="51fe5737-713c-43ca-bf97-f076d6cafe73" src="https://cdn.javarush.com/images/article/51fe5737-713c-43ca-bf97-f076d6cafe73/800.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 9">Подробнее о Stack Trace можете почитать <a href="https://javarush.com/groups/posts/2972-stack-trace-i-s-chem-ego-edjat" target="_blank">вот тут</a>.

На этом вопросе мы сегодня и остановимся...<img data-max-width="512" data-id="04d5e4c5-41a5-4f1d-b547-6496b17cb340" src="https://cdn.javarush.com/images/article/04d5e4c5-41a5-4f1d-b547-6496b17cb340/512.jpeg" alt="Разбор вопросов и ответов на собеседовании. Часть 1 - 10"><table><tbody>
<tr><th>
Другие материалы серии:
</th></tr><tr><td><ul>
<li><a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 2</a></li>
<li><a href="https://javarush.com/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3</a></li>
<li><a href="https://javarush.com/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 4</a></li>
<li><a href="https://javarush.com/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5</a></li>
<li><a href="https://javarush.com/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6</a></li>
<li><a href="https://javarush.com/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 7</a></li>
<li><a href="https://javarush.com/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 8</a></li>
<li><a href="https://javarush.com/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 9</a></li>
<li><a href="https://javarush.com/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10</a></li>
<li><a href="https://javarush.com/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 11</a></li>
<li><a href="https://javarush.com/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 12</a></li>
<li><a href="https://javarush.com/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 13</a></li>
<li><a href="https://javarush.com/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 14</a></li>
<li><a href="https://javarush.com/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 15</a></li>
<li><a href="https://javarush.com/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 16</a></li>
</ul></td></tr></tbody></table>