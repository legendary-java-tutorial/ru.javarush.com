Java Core. Вопросы к собеседованию, ч. 3
<p>----------------------------------------</p>
В предыдущих двух статьях мы обсудили некоторые важные вопросы, которые Вам чаще всего задают на собеседованиях. Настало время продолжить и рассмотреть остальную часть вопросов. Точной копией оригинала является его клон. В Java это означает возможность создавать ...
<p>----------------------------------------</p>
В предыдущих двух статьях мы обсудили некоторые важные вопросы, которые Вам чаще всего задают на собеседованиях. Настало время продолжить и рассмотреть остальную часть вопросов.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="0f9866ac-00cf-4322-8a00-b09432e1b5a6" data-max-width="710" alt="Java Core. Вопросы к собеседованию, ч. 3 - 1" src="https://cdn.javarush.com/images/article/0f9866ac-00cf-4322-8a00-b09432e1b5a6/1024.jpeg"></div></div><h2>Глубокое копирование и поверхностное копирование</h2>Точной копией оригинала является его клон. В Java это означает возможность создавать объект с аналогичной структурой, как и у исходного объекта. Метод <code>clone()</code> обеспечивает эту функциональность.

Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. <code>Object class</code> не знает о структуре класса, которого он копирует. При клонировании, JVM делает такие вещи:   
<ol>
    <li>Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект. </li>
    <li>Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.</li>
</ol>Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. Мы хотим сделать копию, при которой внесение изменений в любой элемент копии не затронет оригинальную коллекцию. 

<strong>Глубокое клонирование требует выполнения следующих правил:</strong>
<ol>
<li>Нет необходимости копировать отдельно примитивные данные;</li>
<li>Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться <code>super.clone()</code> при переопределении метода <code>clone()</code>;</li>
<li>Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному. </li>
</ol><a href="https://howtodoinjava.com/java/cloning/a-guide-to-object-cloning-in-java/" rel="nofollow" >Узнайте больше о клонировании здесь</a> 
<h2>Что такое синхронизация? Блокировка на уровне объекта и блокировка на уровне класса?</h2><strong>Синхронизация</strong> относится к многопоточности. Синхронизированный блок кода может исполняться одновременно только одним потоком. Java позволяет обрабатывать одновременно несколько потоков. Это может привести к тому, что два или более потока хотят получить доступ к одному и тому же полю. Синхронизация позволяет избежать ошибок памяти, возникающих при неправильном использовании ресурсов памяти. Когда метод объявлен как синхронизированный, нить удерживает его монитор. Если другая нить пытается в это время получить доступ к синхронизированному методу, то поток блокируется, и ждет освобождения монитора. 

Синхронизация в Java осуществляется специальным ключевым словом <strong>synchronized</strong>. Вы можете помечать таким образом отдельные блоки или методы в вашем классе. Ключевое слово synchronized не может быть использовано вместе с переменными или атрибутами класса. 

<strong>Блокировка на уровне объекта</strong> – механизм, когда вы хотите синхронизировать non-static метод или non-static блок кода таким образом, что только один поток сможет выполнить блок кода в данном экземпляре класса. Это нужно всегда делать, чтобы сделать экземпляр класса потокобезопасным. 

<strong>Блокировка на уровне класса</strong> предотвращает вход нескольких потоков в синхронизированный блок для всех доступных экземпляров класса. Например, если есть 100 экземпляров класса DemoClass, то только 1 поток сможет выполнить demoMethod () используя одну из переменных в определенный момент времени. Это должно быть всегда сделано, что бы обеспечить безопасность статического потока. 

<a href="https://howtodoinjava.com/java/multi-threading/object-vs-class-level-locking/" rel="nofollow" >Узнайте больше о синхронизации здесь.</a>
<h2>Какая разница между sleep() и wait()?</h2><code>Sleep()</code> — это метод, который используется, чтобы задержать процесс на несколько секунд. В случае с<code>wait()</code>, нить находится в состоянии ожидания, пока мы не вызовем метод <code>notify()</code> или <code>notifyAll()</code>.
  
Основное различие заключается в том, что <code>wait()</code> снимает блокировку монитора, в то время как <code>sleep()</code> не освобождает блокировку. <code>Wait()</code> используется для многопотоковых приложений, <code>sleep()</code> используют просто для паузы выполнения нити. 

<code>Thread.sleep()</code> ставит текущий поток в «Not Runnable» состояние на определенное количество времени. Нить сохраняет состояние монитора, которое было до вызова данного метода. Если же другая нить вызывает <code>t.interrupt()</code>, нить которая "заснула" — проснется. Обратите внимание, что <code>sleep()</code> является статическим методом, что означает, что он всегда влияет на текущий поток (тот, который выполняет метод <code>sleep()</code>). Распространенной ошибкой является вызов <code>t.sleep()</code>, где <code>t</code> является другим потоком; даже тогда, когда текущая нить, которая вызвала метод <code>sleep()</code>, не является <code>t</code> нитью. 

<code>Object.wait()</code> посылает текущий поток в "Not Runnable" состояние на некоторое время, так же как и <code>sleep()</code>, но все же с некоторым нюансом. <code>Wait()</code> вызывается для объекта, а не для нити; мы называем этот объект “lock object”. Перед вызовом <code>lock.wait()</code>, текущая нить должна быть синхронизирована с “lock object”; <code>wait()</code> после этого снимает эту блокировку, и добавляет нить в ”wait list” связанный с этой блокировкой. Позже, другая нить может быть синхронизирована с тем же самым lock object и вызвать метод <code>lock.notify()</code>.

Этот метод «разбудит» оригинальную нить, которая все еще ждет. В принципе, <code>wait()</code>/<code>notify()</code> можно сравнить с <code>sleep()</code>/<code>interrupt()</code>, только активной нити не нужен прямой указатель на спящую нить, нужно только знать общий lock object. 

<a href="https://howtodoinjava.com/java/multi-threading/sleep-vs-wait/" rel="nofollow" >Читайте детальную разницу здесь.</a>
<h2>Можно ли присвоить null к this ссылочной переменной?</h2>Нет, нельзя. В Java левая часть оператора присваивания должен быть переменной. "This" — это специальное ключевое слово, которое всегда дает текущий экземпляр класса. Это не любая переменная.

Точно также, null нельзя присвоить переменной, используя ключевое слово “super” или любое другое подобное. 

<h2>Какая разница между && и &?</h2><code>&</code> — побитово а <code>&&</code> — логически.
<ol>
<li><code>&</code> оценивает обе стороны операции;</li>
<li><code>&&</code> оценивает левую сторону операции. Если она true, он продолжает оценить правую сторону. </li>
</ol><a href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="nofollow" >Посмотрите здесь для более глубокого понимания.</a>
<h2>Как переопределить equals() и hachCode() методы?</h2><code>hashCode()</code> и <code>equals()</code> методы определены в классе <code>Object</code>, который является родительским классом для Java объектов. По этой причине, все объекты Java наследуют реализацию по умолчанию для методов.

Метод <code>hashCode()</code> используется для получения уникального целого числа для данного объекта. Это целое число используется для определения местоположения объекта, когда этот объект необходимо сохранить, например к <code>HashTable</code>. По умолчанию, <code>hashCode()</code> возвращает <code>integer</code> представление адреса ячейки памяти, где хранится объект.

Метод <code>equls()</code>, как и следует из его имени, используется, чтобы просто проверить равенство двух объектов. Реализация по умолчанию проверяет ссылки на объекты на предмет их равенства.

Ниже приведены важные рекомендации для перезагрузки данных методов:  
<ol>
<li>Всегда используйте одинаковые атрибуты объектов при генерации <code>hashCode()</code> и <code>equals()</code>;</li>
 <li>Симметричность. Т.е. если для каких-либо объектов <code>x</code> и <code>y</code> <code>x.equals(y)</code> возвращает true, то и <code>y.equals(x)</code> должен возвращать true;</li>
<li>Рефлексивность. Для любого объекта <code>x</code> <code>x.equals(x)</code> должен возвращать true;</li>
<li>Постоянство. Для любых объектов <code>x</code> и <code>y</code> <code>x.equals(y)</code> возвращает одно и то же, если информация, используемая в сравнениях, не меняется;</li>
<li>Транзитивность. Для любых объектов <code>x</code>, <code>y</code> и <code>z</code>, если <code>x.equals(y)</code> вернет true и <code>y.equals(z)</code> вернет true, то и <code>x.equals(z)</code> должен вернуть true;</li>
<li>Всякий раз, когда метод вызывается у одного и того же объекта во время выполнения приложения, он должен возвращать одно и то же число, если используемая информация не изменяется. <code>hashCode</code> может возвращать разные значения для идентичных объектов в различных экземплярах приложения;</li>
<li>Если два объекта равны, согласно <code>equals</code>, то их <code>hashCode</code> должны возвращать одинаковые значения;</li>
<li>Обратное требование необязательно. Два неравных объекта могут возвращать одинаковый hashCode. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.</li>
</ol><a href="https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/" rel="nofollow" >Интересные факты о данных методах читайте здесь.</a>
<h2>Расскажите про модификаторы доступа</h2>Классы Java, поля, конструкторы и методы могут иметь один из четырех различных модификаторов доступа:

<strong>private</strong>

Если метод или переменная помечены как <strong>private</strong>, то только код внутри одного класса может получить доступ к переменной, или вызвать метод. Код внутри подклассов не может получить доступ к переменной или методу, также как и не может получить доступ из любого другого класса.  Модификатор доступа private чаще всего используется для конструкторов, методов и переменных. 

<strong>default</strong>

Модификатор доступа <strong>default</strong> объявляется в том случае, если модификатор не указан вообще. Данный модификатор означает, что доступ к полям, конструкторам и методам данного класса может получить код внутри самого класса, код внутри классов в том же пакете.

Подклассы не могут получить доступ к методам и переменным – членам суперкласса, если они объявлены как <strong>default</strong>, если подкласс не находится в том же пакете, что и суперкласс. 

<strong>protected</strong>

Модификатор <strong>protected</strong> работает так же, как и <strong>default</strong>, за исключением того, что подклассы так же могут получить доступ к защищенным методам и переменным суперкласса. Данное утверждение является верным, даже если подкласс не находится в том же пакете, что и суперкласс.

<strong>public</strong>

Модификатор доступа <strong>public</strong> означает, что весь код может получить доступ к классу, его переменным, конструкторам или методам, независимо от того, где расположен этот код. 
<img data-id="e5c27468-c562-4184-af75-b075049e657f" data-max-width="420" alt="Java Core. Вопросы к собеседованию, ч. 3 - 2" src="https://cdn.javarush.com/images/article/e5c27468-c562-4184-af75-b075049e657f/1024.jpeg"><h2>Что такое сборщик мусора? Можем ли мы вызвать его?</h2>Сбор мусора является функцией автоматического управления памятью во многих современных языках программирования, таких как Java и языков в NET.Framework. Языки, которые используют сбор мусора, часто интерпретируют сбор мусора в виртуальной машине, такой как JVM. Сбор мусора имеет две цели: любая неиспользованная памяти должна быть освобождены, и память не должна быть освобождены, если программа еще будет ее использовать.

Можете ли вы запустить сбор мусора вручную? Нет, <code>System.gc()</code> предоставляет вам настолько большой доступ, насколько можно. Лучшим вариантом является вызов метода <code>System.gc()</code>, который намекнет сборщику мусора про необходимость запуска. Нет никакого способа запустить его немедленно, так как сборщик мусора является недетерминированным. Кроме того, согласно документации, <code>OutOfMemoryError</code> не будет проброшена, если виртуальной машине не удалось освободить память после полной сборки мусора. 

<a href="https://howtodoinjava.com/java/garbage-collection/revisiting-memory-management-and-garbage-collection-mechanisms-in-java/" rel="nofollow" >Узнайте больше о сборщике мусора здесь.</a>
<h2>Что означает ключевое слово native? Объясните в деталях</h2>Ключевое слово <strong>native</strong> применяется, чтобы указать, что метод реализован не в файле Java, а на другом языке программирования.

<strong>Native</strong> методы использовались в прошлом. В текущих версиях Java это нужно реже. В настоящее время, native методы необходимы, когда:
<ol>
<li>Вы должны вызвать библиотеку из Java, которая написана на другом языке.</li>
 <li>Вам нужен доступ к системным или аппаратным ресурсам, к которым можно получить доступ только используя другой язык (как правило, С). На самом деле, многие системные функции, которые взаимодействуют с реальным компьютером (например диски или сетевые данные) могут быть вызваны только native методом.</li>
</ol>Недостатки использования библиотек <strong>native</strong> методов тоже значительны:
<ol>
<li>JNI/JNA могут дестабилизировать JVM, особенно если вы попытаетесь сделать что-то сложное. Если ваш native метод делает что-то неправильно, есть вероятность аварийного завершения JVM. Также, неприятные вещи могут произойти, если ваш native метод вызывается из нескольких нитей. И так далее. </li>
<li>Программу с <strong>native</strong> кодом сложнее дэбажить.</li>
<li>Native код требует отдельного построения фрэймворков, что может создать проблемы с переносом на другие платформы.</li>
</ol>
<h2>Что такое сериализация?</h2> В компьютерных науках, в контексте хранения и передачи данных, сериализация – это процесс перевода структуры данных или состояния объекта в формат, который может быть сохранен и восстановлен потом в другой компьютерной среде. После приема серии битов, они пересчитываются в соответствии с форматом сериализации, и могут быть использованы для создания семантически идентичного клона исходного объекта.

Java предоставляет автоматическую сериализацию, которая требует, чтобы объект реализовал интерфейс <code>java.io.Serializable</code>. Реализация интерфейса помечает класс как «сериализуемый». В интерфейсе java.io.Serializable нет методов сериализации, но сериализуемый класс может дополнительно определить методы, которые будут вызваны как часть процесса сериализации/дисериализации. 

При внесении изменений в классы, необходимо учитывать, какие из них будут совместимы и не совместимы с сериализацией. Вы можете прочитать полную инструкцию здесь. Самые главные пункты я приведу:

<strong>Несовместимые изменения:</strong>
<ol>
<li>Удаление поля;</li>
<li>Перемещение класса вверх или вниз по иерархии;</li>
<li>Изменение non-static поля на static или non-transient на transient;</li>
<li>Изменение объявленного типа примитивный данных;</li>
<li>Изменение метода <code>WriteObject</code> или <code>ReadObject</code> так, что они больше не пишут или не читают поля по умолчанию;</li>
<li>Изменение класса <code>Serializable</code> на <code>Externalizable</code> или наоборот;</li>
<li>Изменение класса <strong>enum</strong> на <strong>non-enum</strong> или наоборот;</li>
<li>Удаление <code>Serializable</code> или <code>Externalizable</code>;</li>
<li>Добавление <code>writeReplace</code> или <code>readResolve</code> метода к классу.</li>
</ol>	
<strong>Совместимые изменения:</strong>
<ol>
<li>Добавление полей;</li>
<li>Добавление/удаление классов;</li>
<li>Добавление методов <code>WriteObject/ReadObject</code> [методы <code>defaultReadObject</code> или <code>defaultWriteObject</code> должны быть вызваны в начале];</li>
<li>Удаление методов <code>WriteObject/ReadObject</code>;</li>
<li>Добавление <code>java.io.Serializable</code>;</li>
<li>Изменение доступа к полю;</li>
<li>Изменение <strong>static</strong> поля на <strong>non-static</strong> или <strong>transient </strong>на <strong>non-transient</strong>.</li>
</ol>Ссылки на предыдущие части:

<a href="https://javarush.com/groups/posts/765-java-core-voprosih-k-sobesedovaniju-ch-1" target="_blank">Java Core. Вопросы к собеседованию, ч. 1</a>
<a href="https://javarush.com/groups/posts/764-java-core-voprosih-k-sobesedovaniju-ch-2" target="blank">Java Core. Вопросы к собеседованию, ч. 2</a>

<em><a href="https://howtodoinjava.com/interview-questions/core-java-interview-questions-series-part-3/" rel="nofollow" >Оригинал статьи</a>	
<strong>Счастливого обучения!</strong></em>