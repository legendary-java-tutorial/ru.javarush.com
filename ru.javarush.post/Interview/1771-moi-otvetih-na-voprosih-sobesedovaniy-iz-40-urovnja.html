Уровень 40. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
Собственно, такие вопросы были на этом уровне: Что такое IP-адрес? В чем отличие host и domain? Какие методы в HTTP вы знаете.Чем отличаются методы GET, POST и HEAD? Что такое REST? Зачем нужен класс Calendar...
<p>----------------------------------------</p>

<img data-id="fddb43a0-d92d-48c7-9fac-f0f94258b684" data-max-width="850" alt="Уровень 40. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/fddb43a0-d92d-48c7-9fac-f0f94258b684/1024.jpeg">Собственно, такие вопросы были на этом уровне:

<ol>
  <li>Что такое IP-адрес?</li>
  <li>В чем отличие host и domain?</li>
  <li>Какие методы в HTTP вы знаете</li>
  <li>Чем отличаются методы GET, POST и HEAD?</li>
  <li>Что такое REST?</li>
  <li>Зачем нужен класс Calendar в Java?</li>
  <li>Как преобразовать дату в Java к нужному формату?</li>
  <li>В чем отличие URI и URL?</li>
  <li>Что такое сокеты?</li>
  <li>Отличие классов Socket и URL?</li>
</ol><strong>А вот мои ответы:</strong>
<ol>
<li><p><strong>IP-адрес</strong> — это уникальный сетевой адрес узла в компьютерной сети, построенной на стеке протоколов TCP/IP. В сети Интернет требуется глобальная уникальность адреса; в случае работы в локальной сети требуется уникальность адреса в пределах сети. В версии протокола IPv4 IP-адрес имеет длину 4 байта, а в версии протокола IPv6 IP-адрес имеет длину 16 байт. Обычно IP-адрес в версии протокола IPv4 записывают в виде четырёх десятичных чисел со значениями от 0 до 255, разделённых точкой, например, 192.168.0.3.</p></li>
<li><p><strong>Домен</strong> — это адрес сайта или определённая зона, которая имеет своё имя, не похожее ни на какое другое имя в системе доменных имён. Домены бывают первого уровня, второго уровня, третьего уровня и т.д. Обычно домен первого уровня не доступен обычным пользователям для регистрации (примеры доменов первого уровня - ".ru", ".com", ".net"). Обычно домены третьего и следующих уровней называют субдоменами.<br />
<strong>Хост</strong> — это определённый компьютер или сервер, подключенный к локальной или глобальной сети. Хост обладает обладает уникальным адресом в среде сервисов TCP/IP (IP-адресом).</p></li>
<li><p>GET, POST, PUT, DELETE, OPTIONS, HEAD, PATCH, TRACE, LINK, UNLINK, CONNECT.</p></li>
<li>		                        
<table>
<tr><th></th><th>GET</th><th>POST</th><th>HEAD</th></tr>
<tr><td>Тело Запроса</td><td>Нет</td><td>Есть</td><td>Нет</td></tr>
<tr><td>Тело Ответа</td><td>Да</td><td>Да</td><td>Нет</td></tr>
<tr><td>Кеширование результата Запроса</td><td>Да</td><td>Нет</td><td>Да, заголовки</td></tr>	
<tr><td>Идемпотентность</td><td>Да</td><td>Нет</td><td>Да</td></tr></table>
<p>Метод <strong>GET</strong> используется для запроса содержимого указанного ресурса. Метод <strong>POST</strong> применяется для передачи пользовательских данных заданному ресурсу. Метод <strong>HEAD</strong> обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. Метод HEAD аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.  Метода GET считает упрощённой версией POST, потому как метод GET не предполагает полноценного запроса, только URL в качестве такового.</p></li>
<li><p><strong>REST</strong> — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Термин был введён Роем Филдингом в 2000 году. Также им были введены требования, которым должно удовлетворять распределённое приложение, чтобы соответствовать архитектуре REST (такие приложения ещё называют RESTful). Вот эти требования:</p>
<ol>
<li>Модель "Клиент-Сервер" (означает, что сеть должна состоять из клиента и сервера; сервер - это тот, кто обладает ресурсами, клиент - тот, который их запрашивает))</li>
<li>Отсутствие состояния (означает, что ни клиент, ни сервер не отслеживают состояния друг друга)</li>
<li>Кеширование (клиенты и промежуточные узлы могут кешировать результаты запросов; сооответственно, ответы сервера должны иметь явное или неявное обозначение, что они кешируемые или некешируемые)</li>
<li>Единообразие интерфейса (означает, что между клиентами и серверами существует общий язык взаимодействия, который позволяет им быть заменяемыми или изменяемыми, без нарушения целостности системы):<ul>
<li>Определение ресурса (означает, что каждый ресурс должны быть обозначен постоянным идентефикатором)</li>
<li>Управление ресурсами через представление (означает, что клиент хранит ресурс в виде его представления, и при желании изменения ресурса он отправляет серверу информацию о том, в каком виде он хотел бы видеть этот ресурс; сервер же рассматривает этот как запрос как предложение, и сам решает, что делать ему с хранимым ресурсом)</li>
<li>Самодостаточные сообщения (каждое сообщение содержит достаточно информации, чтобы понять, как его обрабатывать)</li>
<li>Гипермедиа (означает, что клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервер)</li>
<li>Система слоёв (означает, что в системе может быть больше двух слоёв (клиент и сервер), и при этом каждый такой слой знает только о своих соседних слоях, и не знает об остальных слоях, и взаимодействует только с соседними слоями)</li>
<li>Код по требованию (означает, что функциональность клиента может быть расширения за счёт загрузки кода с сервера в виде апплетов  или сценариев)</li></ul><p>Удовлетворение этим требованиям позволяет добиться следующего:</p><ul>
<li>Надёжность</li>
<li>Производительность</li>
<li>Масштабируемость</li>
<li>Прозрачность взаимодействия</li>
<li>Простота интерфейсов</li>
<li>Портативность компонентов</li>
<li>Лёгкость внесения изменений</li>
<li>Способность эволюционировать, приспосабливаясь к новым требованиям</li></ul></li></ol></li>
<li>Он нужен для более удобной работы с датой и временем. Он позволяет  работать с датой в рамках календаря, то есть позволяет прибавлять и отнимать дни от какой-то конкретной даты, причём будут учитывать и високосные года. Кроме того, он позволяет представить время миллисекундах в удобном виде - год, месяц, день, часы, минуты, секунды. Также есть много методов для установки и получения разных параметров даты и времени, например: день недели, день месяца, день в году, номер недели в месяце, номер недели в году.</li>
<li><p>Для этого существует удобный класс <code>SimpleDateFormat</code>. Экземпляру этого класс можно передать шаблон представления даты, и тогда он в таком виде будет возвращать дату (в формате строки <code>String</code>), либо считывать дату (из строки <code>String</code>). Выглядит это всё следующим образом:</p>
<pre class='lang-java line-numbers'><code>
Date date = new Date(); // получаем текущую дату
SimpleDateFormat formatter = new SimpleDateFormat("d-MM-yy HH:mm:ss"); //создаём экземпляр класса SimpleDateFormat
         								//и передаём ему шаблон представления даты и времени
String dateAsString = formatter.format(date); //преобразуем дату в строку заданного формата

Date dateAfterConversion = formatter.parse(dateAsString); //преобразуем строку обратно в дату
</code></pre></li>
<li><p><strong>URI</strong> расшифровывается как Uniform Resource Identifier и переводится как "унифицированный идентификатор ресурса". URI — это последовательность символов, идентифицирующая абстрактный или физический ресурс. URL расшифровывается как Uniform Resource Locator. То есть это некий унифицированный указатель на ресурс, однозначно определяющий его месторасположение. URL служит стандартизированным способом записи адреса ресурса в сети Интернет.<br />
Их отличия в том, что <strong>URI</strong> — это некоторый идентификатор ресурса, который позволяет этот ресурс как-то идентифицировать, а <strong>URL</strong> — это указатель на ресурс, он даёт информацию о том, где находится ресурс. Таким образом URL — это URI, который помимо идентификации ресурса, даёт информацию о его местонахождении.</p></li>
<li><p><strong>Сокеты</strong> — это связка <em>IP-адрес + порт</em>, позволяющая из внешней сети однозначно идентифицировать программу на компьютере или сервере. В Java для работы с сокетами есть два класса <code>Socket</code> и <code>ServerSocket</code>. Экземпляры первого класса играют роль клиента, экземпляры второго — роль сервера. Клиент может отправлять и принимать сообщения через сокет. Сервер же постоянно отслеживает запросы пользователей и отвечает на них. <br />
Для того, чтобы отправить данные через сокет, в классе <code>Socket</code> существует класс <code>getOutnputStream()</code>, возвращающий исходящий поток, с которым уже можно работать как обычно. Для приёма информацию нужно воспользоваться методом <code>getInputStream()</code>, который возвращает входящий поток. Дальше с этим потоком можно работать как с обычно потом ввода. Также стоит отметить, что при создании клиентского сокета (экземпляра класса <code>Socket</code>) в конструктор нужно передать ip-адрес сервера и порт, на котором он работает принимающая программа-сервер.<br />
При создании серверного сокета (экземпляра класса <code>ServerSocket</code>) нужно указывать только порт, через который будет работать программа. После этого вызывается метод <code>accept()</code>. Этот метод ожидание подключение клиента, а после этого возвращает экземпляр класса <code>Socket</code>, необходимый для взаимодействия с этим клиентом. Дальше работать идёт с экземпляром класса <code>Socket</code>, как в первом случае (в случае клиента).</p></li>
<li>Главное отличие в том, что класс <strong>URL</strong> предназначен для работы с URL-строкой (парсинг URL-строки), а <strong>Socket</strong> используется для соединения с удалённым сервером и отправки информации на сервер и/или приёма информации от сервера (хотя, используя класс URL, можно получить доступ к ресурсу, на который указывает сам URL; но делается это не напрямую, а через объект класса URLConnection). Также, если смотреть в общем, то Socket используется для связи с сервером (другой программой), а URL — для доступа к ресурсу (например, к файлу). Кроме того, URL и URLConnection ориентированы в основном на работу с HTTP, тогда как Socket может работать с любыми протоколами.</li></ol>