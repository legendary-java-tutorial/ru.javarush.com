Что могут спросить на собеседовании: структуры данных в Java. Часть 1
<p>----------------------------------------</p>
Привет! Как ни крути, вам не стать разработчиком без успешного прохождения входного технического собеседования. Технологий, связанных с Java, очень много, и выучить все невозможно...
<p>----------------------------------------</p>
Привет!

Как ни крути, вам не стать разработчиком без успешного прохождения входного технического собеседования.

<img data-max-width="800" data-id="0eecf617-65d6-4cec-a113-eb97bca478e3" src="/images/article/0eecf617-65d6-4cec-a113-eb97bca478e3/800.jpeg" alt="Что могут спросить на собеседовании: структуры данных в Java - 1">Технологий, связанных с Java, очень много, и выучить все невозможно.

Что-то специфическое, как правило, на собеседованиях спрашивают только в том случае, если ищут разработчика с хорошим опытом в каком-то важном для проекта фреймворке. Если это так, вас будут гонять по этому фреймворку во весь рост, вы уж не сомневайтесь.<img data-max-width="512" data-id="362c401b-e9b0-48f9-865f-ed54c64e3092" src="/images/article/362c401b-e9b0-48f9-865f-ed54c64e3092/512.jpeg" alt="Что могут спросить на собеседовании: структуры данных в Java - 2">Но мы сейчас говорим о базе, которую должен знать каждый Java developer. О тех классических знаниях, с которых все и начинается.

Сегодня хотелось бы затронуть одну из основополагающих тем любого собеседования — <span class="text-bold">структуры данных в Java</span>. Итак, вместо хождения вокруг да около, мы начнем. Ловите список вопросов, которые могут вам задать по этой теме на собеседовании.<h2>1. Расскажите немного о структурах данных</h2><span class="text-bold">Структура данных</span> — это хранилище данных, в котором лежит информация, структурированная определенным образом. Данные структуры заточены под эффективное выполнение определенных операций.

Типичными примерами структур данных являются:<ul>
<li>массивы,</li>
<li>стеки,</li>
<li>очереди,</li>
<li>связанные списки,</li>
<li>графы,</li>
<li>деревья,</li>
<li>префиксные деревья,</li>
<li>хэш таблицы.</li>
</ul>Подробнее с ними можно ознакомиться <a href="https://javarush.com/quests/lectures/questharvardcs50.level05.lecture06" target="_blank">тут</a> и <a href="https://javarush.com/quests/lectures/questharvardcs50.level05.lecture03" target="_blank">тут</a>.

Данные являются ключевой составляющей в программе, структуры же позволяют хранить эти данные в определенном, четко структурированном виде.

Чем бы ни занималось ваше приложение, этот аспект всегда будет присутствовать в нем: если это веб-магазин, то будет храниться информация о товарах, если социальная сеть — данные о пользователях и файлах, и так далее.<h2>2. Что вы знаете о Массивах?</h2>Массив  — это контейнер для хранения однотипных значений, количество которых было задано заранее.

Пример создания массива со строковыми значениями:

<pre class="language-java line-numbers"><code>
String[] strArray = {"Java","is","the","best","language"};
</code></pre>
При создании массива выделяется память под все его элементы: чем больше ячеек под элементы задано изначально, тем больше будет выделено памяти.

Если создается пустой массив с некоторым количеством ячеек, то всем элементам массива будут присваиваться значения по умолчанию. Например:

<pre class="language-java line-numbers"><code>
int[] arr = new int[10];
</code></pre>
Так, для массива с элементами типа <span class="text-bold">boolean</span> начальные (<span class="text-bold">default</span>) значения будут равны <span class="text-bold"><em>false</em></span>, для массивов с числовыми значениями — 0, с элементами типа <span class="text-bold">char</span> — <span class="code">\u0000</span>. Для массива типа класса (объекты) — <span class="text-bold">null</span> (не пустые строки — <span class="code">“”</span>  а именно <span class="text-bold">null</span>).

То есть, в примере выше все значения массива <span class="code">arr</span> будут равны 0 до тех пор, пока они не будут непосредственно заданы. В отличие от коллекций, массивы не являются динамическими.

После объявления массива определенного размера сам размер нельзя изменить. Чтобы добавить новый элемент в массив, необходимо создать новый массив большего размера и скопировать в него все элементы со старого (это принцип работы ArrayList).

Есть один момент, который знают не все и на котором вас могут неплохо подловить. В Java есть два вида переменных — <a href="https://javarush.com/groups/posts/2630-prostihe-peremennihe-v-java-i-konstantih" target="_blank">простые типы</a> и <a href="https://javarush.com/groups/posts/2642-ssihlochnihe-tipih-dannihkh-v-java" target="_blank">ссылки</a> на полноценные объекты. К какому из них относятся массивы?

Например, вот:

<pre class="language-java line-numbers"><code>
 int[] arr = new int[10];
</code></pre>
Вроде бы все просто — это 10 элементов <span class="text-bold">int</span>. Получается, можно сказать, что это простой тип?

Как бы не так.

<span class="text-bold">В Java массивы являются объектами, динамически создаются и могут быть назначены переменным типа Object. </span>

Все методы класса Object можно вызвать в массиве. Поэтому мы можем даже написать:

<pre class="language-java line-numbers"><code>
Object arr = new int[]{7,5,4,3};
System.out.println(arr.toString());
</code></pre>
При выводе в консоли можно получить что-то вроде:

<div class="terminal">[I@4769b07b</div>
Подробнее об особенностях массивов в Java рассказывается в <a href="https://javarush.com/groups/posts/massivy-java" target="_blank">этой статье o Java Array</a>. Чтобы закрепить знания, можно решить несколько задач из <a href="https://javarush.com/groups/posts/2669-reshaem-zadachi-na-odnomernihe-i-dvumernihe-massivih" target="_blank">этой подборки</a>.<h2>3. Расскажите об иерархии коллекций</h2>Коллекции используются в ситуациях, когда нужна гибкость при работе с данными. Коллекции могут добавлять элемент, удалять элемент и выполнять множество других операций. 

В Java есть множество различных реализаций, а нам нужно всего лишь выбрать правильную коллекцию для текущей ситуации.

Как правило, когда вы упоминаете интерфейс <span class="text-bold">Collection</span>, вас просят перечислить некоторые его реализации и отношение с <span class="text-bold">Map</span>. Что ж, давайте разбираться.

Итак, <span class="text-bold">Collection</span> и <span class="text-bold">Map</span> — это две разные иерархии для структур данных. 

Как выглядит иерархия <span class="text-bold">Collection</span>:<img data-max-width="800" data-id="eae23ccc-7029-44ad-8b2b-3ae9ac2c39e6" src="/images/article/eae23ccc-7029-44ad-8b2b-3ae9ac2c39e6/800.jpeg" alt="Что могут спросить на собеседовании: структуры данных в Java - 3">Интерфейс <span class="text-bold">Collection</span> является ключевым верховным звеном с перечнем базовых методов, от которого и берут начало три базовых вида структур данных — <span class="text-bold">Set</span>, <span class="text-bold">List</span>, <span class="text-bold">Queue</span>. 

<span class="text-bold">Set&lt;T&gt;</span> — интерфейс, представляющий собой совокупность объектов, в которой каждый объект является уникальным.

<span class="text-bold">List&lt;T&gt;</span> — интерфейс, представляющий упорядоченную последовательность объектов, которая называется списком. 

<span class="text-bold">Queue&lt;T&gt;</span> — интерфейс, отвечающий за структуры, которые организованы в виде очереди (последовательное хранение элементов). 

Как говорилось раньше, <span class="text-bold">Map</span> является отдельной иерархией:<img data-max-width="800" data-id="bba4b588-f78a-4b8b-9a84-e0a3d5d4bb86" src="/images/article/bba4b588-f78a-4b8b-9a84-e0a3d5d4bb86/800.jpeg" alt="Что могут спросить на собеседовании: структуры данных в Java - 4"><span class="text-bold">Map&lt;K, V&gt;</span> — интерфейс, представляющий словарь, в котором элементы содержатся в виде пар "ключ-значение". При этом все ключи (K) уникальные в пределах объекта <span class="text-bold">Map</span>. Данный вид коллекции облегчает поиск элемента, если нам известен ключ — уникальный идентификатор объекта.<h2>4. Что вы знаете о Set?</h2>Как говорилось ранее, данная коллекция представляет множество уникальных элементов. Иначе говоря, один и тот же объект не может встречаться в Java <span class="text-bold">Set</span> более одного раза. Также хотелось бы обозначить, что из <span class="text-bold">Set</span> мы не можем вытащить элемент по номеру (индексу) — только перебором.

Важно то, что разные реализации <span class="text-bold">Set</span> имеют разный способ структуризации данных. Конкретные реализации мы и рассмотрим далее.

Итак, основные реализации <span class="text-bold">Set</span>:

<span class="text-bold">HashSet</span> — множество, которое основано на хеш-таблице, что в свою очередь помогает при поиске. 

Использует хеш-функцию, которая улучшает производительно при поиске и вставке. Независимо от количества элементов, в основном, вставка и поиск (иногда и удаление) выполняются за время, близкое к постоянному — O(1). Подробнее с хеш-функцией мы ознакомимся чуть позже.

Также хотелось бы отметить, что <span class="text-bold">HashSet</span> содержит в себе <span class="text-bold">HashMap</span>, в котором и происходит вся магия. Вот подробная <a href="https://javarush.com/groups/posts/2147-hashset-v-java" target="_blank">статья о HashSet в Java</a>.

<span class="text-bold">LinkedHashSet</span> — данный класс расширяет <span class="text-bold">HashSet</span>, при этом не добавляя никаких новых методов. Как и <span class="text-bold">LinkedList</span>, данный класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать необходимый порядок в данной реализации <span class="text-bold">Set</span>.

Класс <span class="text-bold">TreeSet</span> создает множество, которое для организации структуры хранения элементов основано на красно-черном дереве. Другими словами, в данном множестве мы можем сортировать элементы в возрастающем порядке.

Если мы используем некоторые стандартные объекты из “коробки”, например, <span class="text-bold">Integer</span>, то для выстраивания множества Integer в возрастающем порядке нам ничего и не нужно делать:

<pre class="language-java line-numbers"><code>
TreeSet<integer> set = new TreeSet&lt;&gt;();
set.add(4);
set.add(2);
set.add(3);
set.add(1);

System.out.println(set);</integer></code></pre>
И в консоли мы получим вывод:

<div class="terminal">[1, 2, 3, 4]</div>
То есть, в данном <span class="code">set</span> числа хранятся в отсортированном виде. Если мы будем использовать элементы <span class="text-bold">String</span> в <span class="code">TreeSet</span>, они будут отсортированы, но по алфавиту.

Ну а что если у нас есть некоторый стандартный (пользовательский) класс? Каким образом объекты данного класса будет структуризировать <span class="text-bold">TreeSet</span>? Если мы попробуем задать произвольный объект в данный <span class="text-bold">Set</span>:

<pre class="language-java line-numbers"><code>
TreeSet<cat> set = new TreeSet&lt;&gt;();
set.add(new Cat(4, "Мурзик"));
set.add(new Cat(2, "Барсик"));
set.add(new Cat(3, "Гарфилд"));

System.out.println(set);
</cat></code></pre>
Мы получим <span class="code">ClassCastException</span>, так как <span class="text-bold">TreeSet</span> не знает, как сортировать объекты данного типа.

В таком случае нужно, чтобы наш кастомный объект реализовал интерфейс <span class="text-bold">Comparable</span>, и его метод <span class="code">compareTo</span>:

<pre class="language-java line-numbers"><code>
public class Cat implements Comparable<cat> {
    int age;
    String name;

   public Cat(int age, String name) {
       this.age = age;
       this.name = name;
   }

   @Override
   public int compareTo(Cat cat) {
       return age &gt; cat.age ? 1 : -1;
   }

   @Override
   public String toString() {
       return "Cat{" +
               "age=" + age +
               ", name='" + name + '\'' +
               '}';
   }
}
</cat></code></pre>
Как вы заметили, метод <span class="code">compareTo</span> возвращает <span class="text-bold">int</span>:<ul>

<li>1, если текущий (this) объект считается большим;</li>
<li>-1, если текущий объект считается меньшим, чем тот, который пришел аргументом;</li>
<li>0, если объекты равны (в данном случае мы это не используем).</li>

</ul>В таком случае наш <span class="text-bold">TreeSet</span> отработает корректно и выведет результат:

<div class="terminal">[Cat{age=2, name='Барсик'}, Cat{age=3, name='Гарфилд'}, Cat{age=4, name='Мурзик'}]</div>
Другой способ — создание отдельного класса, ответственного за сортировку, который реализует интерфейс <span class="text-bold">comparator</span> и его метод <span class="code">compare</span>:

<pre class="language-java line-numbers"><code>
public class CatComparator implements Comparator<cat> {

   @Override
   public int compare(Cat o1, Cat o2) {
       return o1.age &gt; o2.age ? 1 : -1;
   }
}
</cat></code></pre>
В таком случае для его использования мы должны задать объект данного класса в конструктор <span class="code">TreeSet</span>:

<pre class="language-java line-numbers"><code>
TreeSet<cat> set = new TreeSet&lt;&gt;(new CatComparator());
</cat></code></pre>
После этого все объекты класса <span class="code">Cat</span>, попавшие в <span class="code">TreeSet</span>, будут отсортированы с помощью класса <span class="code">Cat Comparator</span>.

Больше о <span class="text-bold">Comparator</span> и <span class="text-bold">Comparable</span> в Java можно узнать из <a href="https://javarush.com/groups/posts/1939-comparator-v-java" target="_blank">этой статьи</a>.<h2>5. Расскажите о Queue</h2><span class="text-bold">Queue</span> — интерфейс, отвечающий за структуры, которые организованы в виде очереди — структуры данных, которая хранит элементы последовательно. 

Например, из очереди людей первым зайдет человек, пришедший раньше других, последним — тот, кто пришел позже всех.

Этот способ называется — <span class="text-bold">FIFO</span>, то есть <span class="text-bold">First in First Out</span>.

Уникальные методы <span class="text-bold">Queue</span> направлены на работу с первым или последним элементом, например:<ul>

<li><span class="text-bold">add</span> и <span class="text-bold">offer</span> — вставляет элемент в конец очереди,</li>
<li><span class="text-bold">remove</span> — извлекает и удаляет заголовок этой очереди,</li>
<li><span class="text-bold">peek — извлекает, но не удаляет заголовок очереди.</span></li></ul><a href="https://javarush.com/groups/posts/2988-chto-mogut-sprositjh-na-sobesedovanii-strukturih-dannihkh-v-java-chastjh-2" target="_blank">ЧАСТЬ 2</a>