Уровень 32. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
RandomAccessFile — класс пакета Java IO API, он позволяет перемещаться по файлу, читать из него или писать в него, как вам будет угодно. Вы также сможете заменить существующие части файла, речь идет о обновлении содержимого файла, а точней о обновлении фрагмента файла ...
<p>----------------------------------------</p>

<img data-id="631dc277-e224-4765-a807-e68aa22362ea" data-max-width="850" alt="Уровень 32. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/631dc277-e224-4765-a807-e68aa22362ea/1024.jpeg"><ol>
<li><p><strong>Зачем нужен <code>RandomAccessFile</code>?</strong></p>
<p><code>RandomAccessFile</code> — класс пакета Java IO API, он позволяет перемещаться по файлу, читать из него или писать в него, как вам будет угодно. Вы также сможете заменить существующие части файла, речь идет о обновлении содержимого файла, а точней о обновлении фрагмента файла. Это невозможно сделать с помощью <code>FileInputStream</code> или <code>FileOutputStream</code>, но <code>RandomAccessFile</code> даст вам эту возможность.</p>
<p>Ссылка: <a href='https://devcolibri.com/%D1%83%D1%80%D0%BE%D0%BA-4-randomaccessfile-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8/' rel='nofollow' target='_blank'>RandomAccessFile и его возможности</a></p></li>
<li><p><strong>Что будет если файл, откуда читает <code>RandomAccessFile</code>, не существует?</strong></p>
<p>Будет <code>FileNotFoundException</code></p></li>
<li><p><strong>Что будет если файл, куда пишет <code>RandomAccessFile</code>, не существует?</strong></p>
<p>Создаст новый и запишет в него.</p></li>
<li><p><strong>Зачем нужен класс <code>StringReader</code>?</strong></p>
<p>The Java.io.StringReader class is a character stream whose source is a string.</p>
<p>Представляет собой поток символов, чей источник называется строкой</p></li>
<li><p><strong>Зачем нужен класс <code>StringWriter</code>?</strong></p>
<p><code>public class StringWriter</code><br />
<code>extends Writer</code></p>
<p>A character stream that collects its output in a string buffer, which can then be used to construct a string.</p>
<p>Closing a StringWriter has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.</p>
<p>Поток символов, собирающий свой поток в буфер строк, которые затем могут быть использованы для создания строки.</p></li>
<li><p><strong>Зачем нужен класс <code>ByteArrayStream</code>?</strong></p>
<p>Итак, <code>ByteArrayInputStream</code> и <code>ByteArrayOutputStream</code>.</p>
<p>Эти классы по сути чем-то похожи на <code>StringReader</code> и <code.StringWriter</code>. Только <code>StringReader</code> читал символы (char) из строки (String), а <code>ByteArrayInputStream</code> читает байты из массива байт (ByteArray).</p>
<p><code>StringWriter</code> писал символы (char) в строку, а <code>ByteArrayOutputStream</codE> пишет байты в массив байт у него внутри. При записи в <code>StringWriter</code> строка внутри него удлинялась, а при записи в <code>ByteArrayOutputStream</code> его внутренний массив байт тоже динамически расширяется.</p></li>
<li><p><strong>Зачем нужен класс <code>PrintStream</code>? Назовите места, где он используется?</strong></p>
<p>Класс <code>PrintStream</code> был придуман для читабельного вывода информации. Он практически весь состоит из методов <code>print</code> и <code>println</code>.</p></li>
<li><p><strong>Зачем нужен <code>DynamicProxy</code>?</strong></p>
<p>В Java есть специальный класс (java.lang.reflect.Proxy), с помощью которого фактическиможно сконструировать объект во время исполнения программы (динамически), не создавая для него отдельного класса.</p></li>
<li><p><strong>Как работает RMI?</strong></p>
<p>RMI расшифровывается Remote Method Invokation – удаленный вызов методов. Или другими словами RMI – это механизм, который позволяет объекту в одной Java-машине вызывать методы объекта в другой Java-машине, даже если они находятся на разных компьютерах, в разных странах, на разных сторонах земного шара.</p>
<p>Традиционный подход к выполнению кода на других машинах, разнесенных по сети может смутить из-за своей нудной и склонной к ошибкам реализации. Лучший способ рассмотреть эту проблему состоит в предположении, что некоторые объекты располагаются на другой машине, и что вы можете посылать сообщения этим удаленным объектам и получать результат, как будто они располагаются на вашей локальной машине. Это упрощение в точности является тем, что позволяет делать Удаленный Вызов Методов (RMI) в Java.</p>
<p>Вот статья по созданию собственной реализации RMI: <a href='http://javatutor.net/books/tiej/rmi' rel='nofollow' target='_blank'>Удаленный вызов методов (RMI)</a></p></li>
<li><p><strong>Объекты каких типов можно передавать по RMI?</strong></p>
<p>Объекты должны имплементировать интерфейс <code>Serializable</code></p>
<p>Remote method Invocation — механизм, который позволяет вызывать метод удалённого объекта. Согласно ему, все операции по подготовке и передаче данных инкапсулируются в вызываемом методе клиентского объекта-заглушки (stub). Сам же вызов метода ничем не отличается от вызова метода обычного локального объекта, за небольшим исключением:</p><ul><li>локальные объекты передаются по значению (копии);</li>
<li>при передаче удалённого (<code>Remote</code>) объекта, если он экспортирован, передаётся stub этого объекта;</li>
<li>передаваемые объекты должны быть <code>Serializable</code>;</li>
<li>кроме всех прочих исключительных ситуаций, при вызове удалённого метода может возбуждаться исключение <code>RemoteException</code> (ошибки маршализации/демаршализации, передачи данных и другие возможные ошибки протокола);</li></ul>
<p>Так же нужно отметить, что при вызове метода мы работаем с удалённым интерфейсом, а не с удалённым классом.</p></li></ol>