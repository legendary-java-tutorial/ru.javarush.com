Хитрые вопросы по Java, которые часто задают на собеседованиях 
<p>----------------------------------------</p>
Если вы хоть раз готовились к собеседованию на должность Java-программиста или сдавали любой экзамен (не обязательно по программированию) для получения сертификата, то, скорее всего ...
<p>----------------------------------------</p>
Если вы хоть раз готовились к собеседованию на должность <span class="text-bold">Java-программиста</span> или сдавали любой экзамен (не обязательно по программированию) для получения сертификата, то, скорее всего, уже успели заметить, что вопросы, которые там задают, весьма специфичны. Многие из них заставляют подумать над архитектурой языка, некоторые рассчитаны на глубокие знания. Есть и те, что больше похожи на головоломки или касаются нюансов, которые прочувствовать без практики очень тяжело. В этой статье разработчик <span class="text-bold">Саранс Синг</span> (Saraans Singh) приводит несколько таких вопросов по Java. С ответами, разумеется.  
<img data-max-width="850" alt="Хитрые вопросы по Java, которые часто задают на собеседованиях  - 1" src="https://cdn.javarush.com/images/article/801ca927-4a0d-474f-a9d9-72c4243440e4/original.jpeg"><span class="text-bold">1. Что произойдет, если поместить оператор return или System.exit () в блок try/catch?</span>

Это очень популярный вопрос "на засыпку" по Java. Хитрость его в том, что многие программисты считают, что блок <code>finally</code> выполнится в любом случае. Данный вопрос ставит эту концепцию под сомнение, путем помещения оператора <code>return</code> в блок <code>try/catch</code> или вызова из блока <code>try/catch</code> оператора <code>System.exit ()</code>.

<span class="text-bold">Ответ на этот каверзный вопрос:</span> блок <code>finally</code> будет выполняться при помещении оператора <code>return</code> в блок <code>try/catch</code>, и не будет выполняться при вызове из блока <code>try/catch</code> оператора <code>System.exit ()</code>.

<span class="text-bold">2. Поддерживает ли язык Java множественное наследование?</span>

Это очень хитрый вопрос. Интервьюеры часто говорят: если язык C++ может поддерживать непосредственное множественное наследование, то почему Java не может? 

<span class="text-bold">Ответ</span> несколько более сложен, чем может показаться, поскольку Java поддерживает множественное наследование типов, ведь интерфейс в нём может расширять другие интерфейсы. Но множественное наследование реализаций язык Java не поддерживает.

<span class="text-bold">3. В случае, когда метод генерирует исключение </span><span class="text-bold"><code>NullPointerException</code> в родительском классе, можно ли его переопределить методом, генерирующим <code>RuntimeException</code>?</span>

Еще один каверзный вопрос, связанный с концепциями перегрузки и переопределения.

<span class="text-bold">Ответ:</span> в переопределенном методе можно спокойно генерировать родительский класс исключения <code>NullPointerException – RuntimeException</code>, но нельзя сделать то же самое с проверяемым исключением типа <code>Exception</code>.

<span class="text-bold">4. Как гарантировать возможность обращения <code>N</code> нитей к <code>N</code> ресурсам без взаимной блокировки?</span>

Если вы не слишком хорошо разбираетесь в написании многопоточного кода, этот вопрос будет для вас по-настоящему каверзным. Он может оказаться непростым даже для опытного программиста, не имевшего дела с взаимными блокировками и состояниями гонки.

Весь трюк тут в упорядочении: предотвратить взаимную блокировку можно благодаря освобождению ресурсов в порядке, обратном порядку их получения.

<span class="text-bold">5. В чем разница между классами <code>StringBuffer</code> и <code>StringBuilder</code> в языке Java?</span>

Классический вопрос по языку Java, который некоторые разработчики считают хитрым, а другие – очень простым. Класс <code>StringBuilder</code> появился в JDK 1.5 и единственное отличие между ними состоит в том, что методы класса <code>StringBuffer</code>, например, <code>length()</code>, <code>capacity()</code> или <code>append()</code> синхронизированы, в то время как соответствующие методы класса <code>StringBuilder</code> – нет.

В силу этого фундаментального отличия, конкатенация строк при помощи <code>StringBuilder</code> выполняется быстрее, чем с помощью <code>StringBuffer</code>. На самом деле, использовать <code>StringBuffer</code> не рекомендуется, поскольку в 99% сценариев использования, конкатенация строк производится в той же нити.

<span class="text-bold">6. Что вернет выражение 1.0/0.0? Приведет ли оно к генерации исключения или ошибке при компиляции?</span>

Еще один каверзный вопрос насчет класса <code>Double</code>. Хотя разработчики Java знают о существовании простого типа данных double и класса <code>Double</code>, при выполнении операций с плавающей точкой они не уделяют достаточного внимания <code>Double.INFINITY</code>, <code>NaN</code>, <code>-0.0</code> и правилам, которым подчиняются связанные с ними арифметические вычисления. 

<span class="text-bold">Ответ на этот вопрос прост:</span> генерации исключения <code>ArithmeticException</code> не произойдет, будет возвращено значение <code>Double.INFINITY</code>.
<span class="text-bold">7. Что будет, если попытаться вставить в <code>HashMap</code> уже имеющийся в ней ключевой объект?</span>

Этот каверзный вопрос – часть другого часто задаваемого вопроса: как работают <code>HashMap</code> в языке Java? <code>HashMap</code> – популярная тема для запутанных и каверзных вопросов по языку Java.

<span class="text-bold">Ответ таков:</span> если попытаться повторно вставить ключ в <code>HashMap</code>, он заменит старый, поскольку класс <code>HashMap</code> не допускает дублирующихся ключей. А тот же ключ означает такой же хэш-код, так что он попадет в то же место в хэш-сегменте.

По материалам <a href="https://www.quora.com/What-are-the-trickiest-Java-questions" target="_blank">Quora</a><table>
<tbody><tr>
<th><p>Что еще почитать:</p></th></tr><tr>
<td><a href="https://javarush.com/groups/posts/292-kljevihe-optimizacii-sql-ne-zavisjajshie-ot-stoimostnoy-modeli" target="_blank">Клёвые оптимизации SQL, не зависящие от стоимостной модели. Часть 1</a><br><a href="https://javarush.com/groups/posts/382-kak-statjh-magom-v-intellij-idea-smotrite-besplatnihy-kurs-khaynca-kabuca-" target="_blank">Как стать магом в IntelliJ IDEA? Смотрите бесплатный курс Хайнца Кабуца</a>
</td>
</tr>
</tbody></table>