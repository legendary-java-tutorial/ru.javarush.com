Уровень 24. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
Анонимные внутренние классы компилируются в файлы внешнийКласс$n.class. На месте внешнего класса, соответственно, название обрамляющего класса, внутри которого описывается ...
<p>----------------------------------------</p>

<img data-id="a8fc2ee6-e95a-46fa-8226-1b2f1eab7af9" data-max-width="850" alt="Уровень 24. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/a8fc2ee6-e95a-46fa-8226-1b2f1eab7af9/1024.jpeg"><ol><li><p><strong>Во что компилируются анонимные внутренние классы?</strong></p><p>Анонимные внутренние классы компилируются в файлы <code>внешнийКласс$n.class</code>. На месте внешнего класса, соответственно, название обрамляющего класса, внутри которого описывается анонимный внутренний класс. На месте n число от 1 до количества анонимных классов.</p></li>
<li><p><strong>Можно ли наследовать внутренние классы?</strong></p><p>Наследовать внутренние классы от других — можно. </p>

<p>Наследование от внутреннего класса получается чуть сложнее, чем обычное, так как конструктор внутреннего класса связывается со ссылкой на окружающий внешний объект. Проблема состоит в том, что «скрытая» ссылка на объект объемлющего внешнего класса должна быть инициализирована, а в производном классе больше не существует объемлющего объекта по умолчанию. Для явного указания объемлющего внешнего объекта применяется специальный синтаксис:</p>

<pre class='lang-java line-numbers'><code>
//: innerclasses/InheritInner.java
// Наследование от внутреннего класса.
 
class WithInner {
  class Inner {}
}
 
public class InheritInner extends WithInner.Inner {
  //! InheritInner() {} // He компилируется 
  InheritInner(WithInner wi) {
    wi.super();
  }
  public static void main(String[] args) {
    WithInner wi = new WithInner();
    InheritInner ii = new InheritInner(wi);
  }
}
</code></pre>
<p>Здесь класс <code>InheritInner</code> расширяет только внутренний класс, а не внешний. Но когда дело доходит до создания конструктора, предлагаемый по умолчанию конструктор не подходит, и вы не можете просто передать ссылку на внешний объект. Необходимо включить в тело конструктора выражение <code>ссылкаНаОбъемлющийКласс.super();</code> в теле конструктора. Оно обеспечит недостающую ссылку, и программа откомпилируется.</p></li>
<li><p><strong>Можно ли наследовать анонимные внутренние классы?</strong></p><p>Описывая анонимный класс мы уже наследуемся от какого-то класса или реализуем какой-либо интерфейс. К анонимным классам напрямую нельзя применить слова extends или implements, но ведь никто не мешает заранее подготовиться и расширить нужный интерфейс, который будем реализовывать с помощью анонимного класса. Пример в коде ниже.</p>

<pre class='lang-java line-numbers'><code>
import java.awt.event.WindowListener;

public class TestExtendAnonym {
    private interface MyInterface extends Runnable, WindowListener {
    }

    Runnable r = new MyInterface() {
    ...
    //Пример того как реализовать 2 и более интерфейса в анонимном классе
    };
}
</code></pre>
<p>Наследоваться от анонимного класса нельзя.</p></li> 
<li><p><strong>Можно ли переопределять внутренние классы?</strong></p><p>Переопределение внутреннего класса, как если бы он был еще одним методом внешнего класса, фактически не имеет никакого эффекта:</p>

<pre class='lang-java line-numbers'><code>
//: innerclasses/BigEgg.java
// Внутренний класс нельзя переопределить 
// подобно обычному методу,
import static net.mindview.util.Print.*;
 
class Egg {
  private Yolk y;
  protected class Yolk {
    public Yolk() { print("Egg.Yolk()"); }
  }
  public Egg() {
    print("New Egg()");
    y = new Yolk();
  }
}	
 
public class BigEgg extends Egg {
  public class Yolk {
    public Yolk() { print("BigEgg.Yolk()"); }
  }
  public static void main(String[] args) {
    new BigEgg();
  }
}
</code></pre>
<p><strong>Вывод:</strong></p>

<pre class='lang-java line-numbers'><code>
New Egg()
Egg.Yolk()
</code></pre>
<p>Конструктор по умолчанию автоматически синтезируется компилятором, а в нем вызывается конструктор по умолчанию из базового класса. Можно подумать, что при создании объекта <code>BigEgg</code> должен использоваться «переопределенный» класс <code>Yolk</code>, но это отнюдь не так, как видно из результата работы программы.</p>

<p>Этот пример просто показывает, что при наследовании от внешнего класса ничего особенного с внутренними классами не происходит. Два внутренних класса — совершенно отдельные составляющие, с независимыми пространствами имен. Иными словами нельзя. </p></li>
<li><p><strong>Какие ограничения есть у локальных классов?</strong></p><p>Вначале вспомним что такое локальный класс. Это класс, описанный в блоке кода, то есть, по-простому — между кавычек <code>{}</code>. Наиболее часто эти кавычки являются телом метода. Но могут они быть и просто блоком, статическим блоком, телом <code>if</code>-ов, циклов и т.д.</p>

<p>Локальный класс наделён особенностями внутренних классов, но имеет отличительные черты, а именно:</p>
<ol>
    <li>он имеет доступ только к финальным полям и аргументам обрамляющего метода, а также ко всем полям обрамляющего класса, в том числе приватным и статическим;</li>
    <li>локальный класс виден и может создаваться только в блоке, в котором описан;</li>
    <li>у локального класса не ставится модификатор доступа;</li>
    <li>не может иметь статических полей, методов, классов (за исключением финальных);</li>
    <li>локальный класс, объявленный в статическом блоке может обращаться только к статическим полям внешнего класса.</li>
</ol><p>Но! Начиная с Java8 мы можем обращаться в локальных классах к не финальным локальным переменным, если они не были изменены до момента инициализации класса. Также теперь стало возможным обращение к не финальным параметрам метода.</p></li>
<li><p><strong>Может ли анонимный внутренний класс содержать статические методы?</strong></p><p>Нет. У Анонимных внутренних классов, как и у внутренних классов не может быть статических полей, методов.  (вспомним, что анонимные классы компилируются в обычные внутренние, а те, в свою очередь, связаны с объектом обрамляющего класса)</p></li>
<li><p><strong>Можно ли создать объект внутреннего класса, если у внешнего класса только <code>private</code> конструктор?</strong></p><p>Имея подобный код:</p>

<pre class='lang-java line-numbers'><code>
public class PrivateConst {
    private PrivateConst() {}
    public class InnerClass{
        public void f(){
            System.out.println("hello");
        }
   }
}
</code></pre>
<p>Напрямую, в другом классе (вне обрамляющего), конечно, создать объект <code>InnerClass</code> следующим способом не получится:</p>

<pre class='lang-java line-numbers'><code>
PrivateConst.InnerClass priv = new PrivateConst().new InnerClass();
</code></pre>
<p>Но! Что если у нас есть метод, возвращающий экземпляр</p>

<pre class='lang-java line-numbers'><code>
PrivateConst:public class PrivateConst {
    private static PrivateConst instance;
    private PrivateConst() {}

    public static PrivateConst getInstance(){
        instance = new PrivateConst();
        return instance;
    }

    public class InnerClass{}
}
</code></pre>
<p>В этом случае приватный конструктор нам не помеха для создания объекта <code>InnerClass</code>. Так же мы без проблем сможем создавать его в методах и в других внутренних классах, принадлежащих <code>PrivateConst</code>. Ответ — можно, если каким-либо способом нам удастся получить объект обрамляющего класса.</p></li>
<li><p><strong>Можно ли объявлять внутренние классы <code>private</code>?</strong></p><p>Да, можно.</p>

<p>PS Обоснования так и не нашел, но на философии java встречались подобные примеры. Плюс IDE не ругается. Буду признателен за обоснование, но предположу, что в этом плане внутренний класс ничем не отличается от обычного класса. </p></li>
<li><p><strong>Можно ли объявлять анонимные внутренние классы <code>private</code>?</strong></p><p>Аналогично (в плане не нашел обоснования). Можно объявить <code>private</code> переменную от типа которой наследуется наш анонимный класс.</p></li>
<li><p><strong>Сколько у класса максимально может быть внутренних классов?</strong></p><p>Сколь угодно много. Ограничение особенности ОС и длинны имени файлов.</p></li>
</ol>