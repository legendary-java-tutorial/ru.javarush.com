История одного собеседования: интересные вопросы
<p>----------------------------------------</p>
Это было моё первое IT-собеседование и, на мой взгляд, оно выдалось интересным. В общей сложности меня “допрашивали” больше 3 часов (этому предшествовали ещё домашние задания и тест в офисе на компьютере).  =Хочу отдать должное собеседующему, который ...
<p>----------------------------------------</p>
Недавно мне довелось посетить собеседование на позицию стажёра в одной из крупных IT-компаний.

<img data-id="0162d2fb-59d2-4c2f-980c-6e6f0f0a6920" data-max-width="850" alt="История одного собеседования: интересные вопросы - 1" src="https://cdn.javarush.com/images/article/0162d2fb-59d2-4c2f-980c-6e6f0f0a6920/1024.jpeg">Это было моё первое IT-собеседование и, на мой взгляд, оно выдалось интересным. В общей сложности меня “допрашивали” больше 3 часов (этому предшествовали ещё домашние задания и тест в офисе на компьютере). 

Хочу отдать должное собеседующему, который не ставил крест, когда я отвечал на вопрос неверно, а с помощью своих наводящих вопросов заставлял меня вдумываться и приходить к верному ответу. 

Ниже я представлю несколько “зарисовок” – на мой взгляд, достаточно интересных вопросов, некоторые из которых дали мне более глубокое понимание отдельных аспектов в Java. Возможно, кому-то эти вещи покажутся очевидными, но думаю, найдётся те, для кого это будет полезно.

Ниже фразы выделены следующими шрифтами:

<strong>Собеседующий — жирным шрифтом</strong>
<i>Закадровые пояснения и мои мысли — курсивом</i>
Мои ответы — обычным шрифтом

С предысторией закончили, перейдём к делу)
<h2>Зарисовка 1. “Казалось бы простой метод”</h2><strong>Напишите, как бы вы реализовали метод, возвращающий результат деления числа а на число b</strong>

<i>Собеседующий пишет на листочке</i>

<pre class='lang-java line-numbers'><code>
int divide(int a, int b) {
}
</code></pre>
<i>*Я недоверчиво покосился на листок с сигнатурой метода. В чём подвох?* Пишу: </i>

<pre class='lang-java line-numbers'><code>
int divide(int a, int b) {
    return a/b;
}
</code></pre>
<strong>А какие-нибудь проблемы могут быть с этим методом? </strong>

<i>*Ловлю дииииикий тупняк*</i>

Вроде нет..

<i>Далее следует законный вопрос:</i>

<strong>А если b=0?</strong>

<i>*Воу, меня сейчас выгонят из этого кабинета, если продолжу в том же духе!*</i>

Ах да, разумеется. Здесь у нас аргументы типа int, поэтому будет выброшен Arithmetic Exception. В случае, если бы аргументы были типа float или double, получилась бы Infinity.

<strong>А что с этим будем делать?</strong>

<i>Начинаю писать try/catch</i>

<pre class='lang-java line-numbers'><code>
int divide(int a, int b) {
    try {
        return a/b;
    } catch (Exception e) {
        e.printStackTrace();
        return ... // ??? what the hack?
    }
}
</code></pre>
<i>*Дохожу до return и подвисаю: что-то ведь надо вернуть в случае ошибки. Но как это “что-то” отличить от результата вычисления?*</i>

<strong>А что будем возвращать? </strong>

Гм… Я бы поменял тип возвращаемой переменной на Integer и в случае эксэпшна возвращал бы null.

<strong>Давайте представим, что не можем менять тип. Можем как-то выкрутиться? Может, можем ещё что-то сделать с эксэпшном?</strong>

<i>*Тут дошло*</i>

Можем ещё пробросить в вызывающий метод!

<strong>Верно. Как он будет выглядеть?</strong>

<pre class='lang-java line-numbers'><code>
int divide(int a, int b) throws ArithmeticException{
    return a/b;
}

void callDivide(int a, int b) {
    try {
        divide(a, b);
    } catch (ArithmeticException e) {
        e.printStackTrace();
    }
}
</code></pre>
<strong>А обрабатывать исключение обязательно?</strong>

Да, ведь мы явно пробрасываем его из метода divide. <i>(*Тут я ошибся! Далее следуют наводящие вопросы собеседующего, чтобы прийти к верному ответу*)</i>

<strong>А Arithmetic Exception - это какое исключение – checked или unchecked?</strong>

Это Runtime exception, значит unchecked.

<i>*Тут следует убийственный вопрос*</i>

<strong>То есть получается, с Ваших слов, если мы в сигнатуре метода указали throws Arithmetic Exception, то оно стало checked исключением?</strong>
<i>*Ух ё!*</i>

Наверное… нет.

<strong>Да, не стало. Если мы указали в сигнатуре throws /unchecked exception/ мы всего лишь предупреждаем, что метод может выбрасывать исключение, но обрабатывать его в вызывающем методе не обязательно. С этим разобрались. А ещё что-то можем сделать, чтобы избежать ошибки?</strong>

<i>*После некоторых раздумий*</i>

Да, можем ещё проверять, if (b==0). И выполнять какую-то логику.

<strong>Верно. Таким образом, мы можем пойти 3 путями: 
<ul>
<li>try/catch</li>
<li>throws – проброс в вызывающий метод</li>
<li>проверка аргументов</li>
</ul>В этом случае с <code>divide</code> какой из методов Вам кажется предпочтительнее?</strong>

Я бы выбрал проброс исключения в вызывающий метод, т.к. в методе divide не ясно, как этот эксэпшн обработать и какой результат типа <code>int</code> вернуть в случае ошибки. А в вызывающем методе использовал бы проверку аргумента b на равенство нулю.

<i>Вроде бы такой ответ удовлетворил собеседующего, но если честно, не уверен, что этот ответ однозначный))</i>

<h2>Зарисовка 2. “Кто быстрей?”</h2><i>После стандартного вопроса, чем ArrayList отличается от LinkedList, последовал такой:</i>

<strong>Что произойдёт быстрее — вставка элемента в середину <code>ArrayList</code> или в середину <code>LinkedList</code>?</strong>

<i>*Тут меня перемкнуло, я вспомнил, что везде читал что-то вроде “используйте <code>LinkedList</code> для вставки или удаления элементов в середину списка”. Дома даже перепроверил по лекциям JavaRush, там фраза: “если ты собираешься вставлять (или удалять) в середину коллекции много элементов, то тебе лучше использовать <code>LinkedList</code>. Во всех остальных случаях – <code>ArrayList</code>.” Ответил на автомате*</i>

Быстрее будет с <code>LinkedList</code>.

<strong>Поясните, пожалуйста</strong>
<ol>
<li>Для того чтобы вставить элемент в середину <code>ArrayList</code>, мы за константное время находим элемент в списке, а потом пересчитываем индексы элементов справа от вставляемого, за линейное время.</li>
<li>Для <code>LinkedList</code>.. Мы сначала за линейное время доходим до середины и затем за константное время вставляем элемент, меняя для соседних элементов ссылки.</li>
</ol><strong>Так получается, что быстрее?</strong>

Гм… Получается одинаково.

<strong>А когда <code>LinkedList</code> всё же быстрее?</strong>

Получается, что когда вставляем в первую половину списка. Например, если вставлять в самое начало, в <code>ArrayList</code> придётся пересчитать все индексы до самого хвоста, а в <code>LinkedList</code> всего лишь поменять ссылку у первого элемента.

<i>Мораль: не верьте дословно всему что написано, даже на JavaRush!)</i>

<h2>Зарисовка 3. “Куда же без equals и hashcode!”</h2><i>Разговор об equals и hashcode был очень долгий – как переопределяем, какая реализация в <code>Object</code>, что происходит под капотом, когда вставляется элемент в <code>HashMap</code> и т.д. Приведу только ряд интересных на мой взгляд моментов*</i>

<strong>Представьте, что мы создали класс</strong>

<pre class='lang-java line-numbers'><code>
public class A {
    int id;

    public A(int id) {
        this.id = id;
    }
}
</code></pre>
<strong>И не переопределили <code>equals</code> и <code>hashcode</code>. Опишите, что произойдёт при выполнении кода </strong>

<pre class='lang-java line-numbers'><code>
A a1 = new A(1);
A a2 = new A(1);
Map&lt;A, String&gt; hash = new HashMap&lt;&gt;();
hash.put(a1, "1");
hash.get(a2);
</code></pre>
<i>*Хорошо что перед собеседованием специально уделил пару дней на понимание основных алгоритмов, их сложности и структур данных – очень помогло, спасибо CS50!*</i>
<ol>
<li><p>Создаём два экземпляра класса A</p></li>
<li><p>Создаём пустую мапу, по умолчанию имеющую 16 корзин. В качестве ключа выступает объект класса A, в котором не переопределены методы <code>equals</code> и <code>hashcode</code>.</p></li>
<li><p>Кладём <code>a1</code> в мапу. Для этого сначала вычисляем хэш <code>a1</code>.</p>
<p><strong>Чему будет равен хэш?</strong></p>
<p>Адресу ячейки в памяти – это реализация метода из класса <code>Object</code></p></li>
<li><p>Исходя из хэша, вычисляем индекс корзины.</p>
<p><strong>А как мы можем его вычислить?</strong></p>
<p><i>*Тут к сожалению я не дал вразумительный ответ. У вас есть длинное число – хэш, и есть 16 корзин – как определить индекс, чтобы объекты с разным хэшем равномерно распределялись по корзинам? Я мог бы предположить, что индекс вычисляется так:</i></p>
<pre class='lang-java line-numbers'><code>
int index = hash % buckets.length
</code></pre>
<p><i>Уже дома посмотрел, что оригинальная реализация в исходниках несколько отличается:</i></p>
<pre class='lang-java line-numbers'><code>
static int indexFor(int h, int length)
{
    return h & (length - 1);
}
</code></pre></li>
<li><p>Проверяем, что не произошло коллизий и вставляем a1.</p></li>
<li><p>Переходим к методу <code>get</code>. Экземпляры a1 и a2 гарантированно имеют разный <code>hash</code> (разный адрес в памяти), поэтому мы ничего  не найдём по этому ключу</p>
<p><strong>А если переопределим только <code>hashcode</code> в классе A и попытаемся вставить в хэшмап сначала пару с ключом a1, а потом с a2?</strong></p>
<p>Тогда сначала найдём нужную корзину по <code>hashcode</code> – эта операция будет выполнена корректно. Далее начнём идти по объектам <code>Entry</code> в прикреплённом к корзине ЛинкедЛисту и сравнивать ключи по <code>equals</code>. Т.к. <code>equals</code> не переопределён, то берётся базовая реализация из класса <code>Object</code> – сравнение по ссылке. a1 и a2 гарантированно имеют разные ссылки, поэтому мы “промахнёмся” мимо вставленного элемента a1, и a2 будет помещён в ЛинкедЛист в качестве нового узла.</p>
<p><strong>Какой же вывод? Можно ли использовать в качестве ключа в <code>HashMap</code> объект с не переопределёнными <code>equals</code. и <code>hashcode</code>?</strong></p>
<p>Нет, нельзя.</p></li></ol><h2>Зарисовка 4. “Давайте нарочно сломаем!”</h2><i>После вопросов об Error и Exception последовал такой вопрос:</i>

<strong>Напишите простой пример, когда функция выкинет StackOverflow.</strong>

<i>*Тут я вспомнил, как меня кумарил этот эррор, когда я пытался написать какую-нибудь рекурсивную функцию*</i>

Наверное, это случится в случае рекурсивного вызова, если неверно указано условие выхода из рекурсии.

<i>*Дальше я стал что-то мудрить, в итоге собеседующий помог, всё оказалось просто*</i>

<pre class='lang-java line-numbers'><code>
void sof() {
    sof();
}
</code></pre>
<strong>А чем этот эррор отличается от <code>OutOfMemory</code>?</strong>

<i>*Тут я не ответил, уже потом понял, что это был вопрос на знание <code>Stack</code> и <code>Heap</code> памяти Java (в Stack хранятся вызовы и ссылки на объекты, а в Heap памяти – сами объекты). Соответственно, StackOverflow выкидывается, когда больше нет места в <code>Stack</code> памяти для очередного вызова метода, а <code>OutOfMemory</code> – место под объекты закончилось в <code>Heap</code> памяти*</i>
<hr />Вот такие моменты из собеседования мне запомнились. На стажировку в итоге меня взяли, так что впереди у меня 2,5 месяца обучения и, если всё сложится хорошо, работа в компании)

Если будет интересно, могу написать ещё одну статейку, уже поменьше, с разбором простой, но показательной задачки, которую мне дали на собеседовании в другую компанию. 

На этом у меня всё, надеюсь, кому-то эта статья поможет углубить или расставить по полочкам свои знания. Всем приятного обучения!