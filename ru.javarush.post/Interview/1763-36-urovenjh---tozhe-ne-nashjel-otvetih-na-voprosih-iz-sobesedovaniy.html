36 уровень. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
Опять-таки всё перерыл, ответов не нашёл. Что ж. Выложу свои, хотя я писал их чисто для себя, и по возможности — кратко. Но всё лучше, чем ничего. Итак, были такие вопросы ...
<p>----------------------------------------</p>
Опять-таки всё перерыл, ответов не нашёл. Что ж. Выложу свои, хотя я писал их чисто для себя, и по возможности — кратко. Но всё лучше, чем ничего. Итак, были такие вопросы:

<img data-id="48ab19be-883b-44ff-8073-e5021bbc4776" data-max-width="850" alt="36 уровень. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/48ab19be-883b-44ff-8073-e5021bbc4776/1024.jpeg"><strong>Вопросы к собеседованию:</strong>
<ol>
<li>Что такое <strong>MVC</strong>?</li>
<li>Что такое <strong>DAO</strong> и <strong>DTO</strong>?</li>
<li>Что такое <strong>POJO</strong>?</li>
<li>Что такое<strong> Entity</strong>?</li>
<li>Какие <strong>коллекции-списки</strong> вы знаете?</li>
<li>Какие<strong> коллекции-множества</strong> вы знаете?</li>
<li>Что такое <strong>map</strong>, чем он отличается от «<strong>словаря</strong>»?</li>
<li>Что такое <strong>Queue</strong> и <strong>Dequeue</strong>?</li>
<li>Какие классы, реализующие <strong>интерфейс Queeue</strong> вы знаете?</li>
<li>Что такое <strong>дерево</strong>?</li></ol>
А теперь мои ответы:
<ol>
<li><p><strong>MVC</strong> — это такой паттерн проектирования приложение, при котором приложение разделяется на три отдельные части: модель (model), представление (view) и контроллер (controller). Модель предоставляет данные и реагируется на команды контроллера, изменяя своё состояние. Представление отвечает за отображение данных модели пользователю, реагируя на изменения модели. А контроллер интерпретирует действия пользователя, оповещая модель о необходимости изменений. Таким образом каждый из компонентов этой схемы слабо связан с другими компонентами, за счёт чего достигается гибкость программы. Чаще всего вся бизнес-логика размещается в модели, хотя иногда она содержится и в контроллере. В первом случае модель называют тонкой, в последнем — толстой.</p></li>
<li><p><strong>DAO </strong>(Data Access Object) — это объект, основная задача которого сохранять данные в базу данные, а также извлекать их из неё. DTO (Data Transfer Object) - это объект, предназначенный для транспортировки данных. Поэтому его основная задача — хранить эти данные. Никакой логики он не содержится. Кроме того, он должен быть сериализуемым, так как транспортировка объектов обычно происходит с помощью сериализации-десериализации.</p></li>
<li><p><strong>POJO</strong> переводится как "объект Java в старом стиле". Их противопоставляют EJB-объектами. Последние следуют специальной конвенции и обычно жёстко привязаны к какому-то конкретному enterprise-фреймворку (например, у них должен быть публичный конструктор без параметров, должен быть геттеры и сеттеры для полей, они должны быть сериализуемыми и т.д.). POJO — это, соответственно, обычный класс, не наследующий ни от каких специальных классов и не реализующий никаких специальных библиотек. Обычно POJO ничего особенного не делает, и содержит только состояние.</p></li>
<li><p><strong>Entity Bean</strong> — это бин, цель которого хранить некоторые данные. В логику такого бина встроен механизм сохранения себя и своих полей в базу данных. Такой объект может быть уничтожен, а потом воссоздан из базы заново. Но кроме хранения данных у него нет никакой логики. А бин в свою очередь — это особый класс, которые должен выполнять следующие правила:</p>
<ul  style="list-style-type:lower-alpha"><li>Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.</li>
<li>Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов. Многие инструменты даже имеют специализированные редакторы для различных типов свойств.</li>
<li>Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.</li>
<li>Класс должен иметь переопределенные методы equals(), hashCode() и toString().</li>
</ul></li>
<li><p>Все <strong>коллекции-списки</strong> реализуют интерфейс List&lt;E&gt; и наследуются от абстрактного класса AbstractList&lt;E&gt;. Среди них можно выделить ArrayList&lt;E&gt; и LinkedList&lt;E7gt;. ArrayList7lt;E&gt; — это список, основаный на массиве, а LinkedList&lt;E&gt; — это классический двусвязный список.</p></li>
<li><p><strong>Коллекции-множества</strong> в Java реализуют интерфейс Set&lt;E&gt; и наследуются от AbstractSet&lt;E&gt;. Множества — это такие наборы данных, в которых все элементы уникальны. Среди них в Java есть HashSet, LinkedHashSet и TreeSet. Первая коллекция хранит свои объекты на основе хеш-кодов. Вторая — это модифицированная первая, в ней элементы ещё к тому же располагаются в связном списке, поэтому они все расположены в порядке добавления. Третья коллекция обеспечивает сортировку своих элементов.</p></li>
<li><p><strong>Map</strong> — это вид коллекций, хранящих свои элементы в виде пар "ключ-значения". Причём все ключи должны быть уникальными. Среди реализаций есть HashMap и TreeMap. Первая реализация хранит элементы с использованием хэш-кодов. Вторая - хранит элементы в отсортированном по ключу порядке.</p></li>
<li><p><strong>Очередь (Queue)</strong> — это структура данных, работающая по принципу "Первый вошёл — первый вышел". То есть элементы в очередь добавляются с одного конца, а извлекаются — с другого.<strong> Deque</strong> — это двусторонняя очередь. В этой очереди элементы можно добавлять как в начало, так и в конец, а также брать элементы тоже можно и из начала, и из конца очереди. Соответственно есть методы, которые позволяю положить элемент (это методы add(e) и offer(e)), и есть методы, позволяющие извлечь элемент из очереди (это такие методы, как remove() и poll()). Кроме того, есть методы, которые позволяют просто получить элемент из очереди без его удаления оттуда (это методы element() и peek()). В интерфейсе Deque дополнительно есть методы для добавления элементов в начало и конец очереди, извлечения элементов из начала или конца, а также получения элементов из начала или конца очереди (без их удаления из очереди).</p></li>
<li><p>Среди простых реализаций можно отметить<strong> ArrayDeque</strong>, <strong>LinkedList</strong> и <strong>PriorityQueue</strong>. Также существуют много классов в Concurrent Collections, которые реализуют эти два интерфейса (оба сразу или только один из них).</p></li>
<li><p><strong>Дерево </strong>— это связный граф без петель и кратных рёбер. Обычно, если в дереве N вершин, то количество рёбер как минимум— N-1. Также одну вершину в дереве выбирают в качестве корня. Остальные вершины объявляют ветвями. Ветви, у которых нет своих ветвей, называются листьями дерева.<br />
В программировании деревья используются довольно широко, и придумано уже много видов этого дерева. Одно из самых широкоприменяемых деревьев - это бинарное дерево. В этом дереве у каждого элемента имеется не больше двух потомков (то есть может быть от 0 до 2). Одной из разновидностью двоичного дерева является BST — бинарное дерево поиска. В этом дереве на элементы накладывается правило: левый потомок элемента должны быть по значению меньше его, а правый — по значению больше его или равен ему.<br />
Также ещё существуют красно-чёрные деревья. Это разновидность двоичных деревьев поиска. В красно-чёрных деревьх вводится ещё одно свойство элемента — цвет. Цвет может быть чёрный или красный. Также каждое красно-чёрное дерево должно удовлетворять следующим требованиям:</p><ol>
<li>корень дерева — чёрный;</li>
<li>узел либо красный, либо чёрный;</li>
<li>все листья дерева — чёрные;</li>
<li>оба потомка красно узла - чёрные;</li>
<li>всякий путь от данного узла до любого листового узла, являющегося его потомка, содержит одинаковое количество чёрных узлов.</li></ol></li></ol>Эти правила позволяют добиться сбалансированности дерева. Дерево сбалансированно, когда длина пути от корня до любого листового узла отличается не более, чем на 1. (То есть по-простому, в дереве нет перекосов и длинных ветвей.)