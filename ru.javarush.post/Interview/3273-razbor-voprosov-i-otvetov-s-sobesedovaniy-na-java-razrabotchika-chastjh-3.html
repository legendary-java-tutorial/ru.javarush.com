Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3
<p>----------------------------------------</p>
Как невозможно научиться управлять самолетом без специального обучения, так и невозможно стать Java-разработчиком, не потратив долгие часы на изучение необходимой теоретической базы...
<p>----------------------------------------</p>
Привет!
 
Как невозможно научиться управлять самолетом без специального обучения, так и невозможно стать Java-разработчиком, не потратив долгие часы на изучение необходимой теоретической базы.
 
Сегодня мы поработаем именно над этим: продолжим разбор <a href="https://dou.ua/lenta/articles/interview-questions-java-developer/" rel="nofollow" target="_blank">250+ вопросов</a> на собеседованиях для Java-разработчиков и, соответственно, ответов на них.
 
Здесь — <a href="https://javarush.com/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">первая</a> и <a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">вторая</a> часть разбора. 
 
Да несомненно, можно стать хорошим Java-разработчиком и без всех этих вопросов. Тем не менее, если вы хорошо разберётесь во всех тонкостях языка Java, это даст вам преимущество, сделав более желанным кандидатом в глазах вашего будущего работодателя.<img data-max-width="800" data-id="cfa85174-fdf4-4be9-b7f0-1cb5a4408d6f" src="https://cdn.javarush.com/images/article/cfa85174-fdf4-4be9-b7f0-1cb5a4408d6f/800.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3 - 1"><h4>20. Какие элементы языка отвечают за инкапсуляцию?</h4>Как мы помним, инкапсуляция — это сокрытие деталей реализации класса. То есть, когда наш класс используется извне, внутренняя начинка и логика не очевидны. И какие же элементы языка отвечают за это? Естественно, <span class="text-bold">модификаторы доступа</span>!
 
То, что нам необходимо скрыть, мы отмечаем модификатором <span class="code">private</span>. Например, приватные поля класса или какие-нибудь внутренние методы, помогающие реализовать некий внутренний функционал.
 
А к тому, к чему мы хотим предоставить внешний доступ, добавляем модификатор доступа <span class="code">public</span>. Например, метод, отвечающий за предоставление какой-то функциональности (внутри которого может использоваться множество приватных методов) или те же геттеры и сеттеры для доступа к приватным полям класса.
 
Ах, да у нас еще есть модификаторы <span class="code">default</span> и <span class="code">protected</span>, которые можно использовать для более гибкой и специфической настройки доступов к избранным частям класса.<h4>21. Какие элементы языка отвечают за наследование?</h4>Наследование — это механизм, который позволяет создавать классы на основе другого класса.

В Java для этих целей используют ключевое слово <span class="code">extends</span>. Например, у нас есть некий класс <span class="code">Cat</span>, и мы хотим создать его наследника — <span class="code">Lion</span>. В коде это будет выглядеть как-то так:
 
<pre class="language-java line-numbers"><code>
public class Lion extends Cat
</code></pre>
И это значит, что класс <span class="code">Lion</span> наследует все методы и переменные класса <span class="code">Cat</span>, кроме статических.
 
Также к элементам языка, отвечающим за наследование, можно отнести <span class="code">super</span>. Это ссылка, аналогичная <span class="code">this</span>, но если <span class="code">this</span> ссылается на объект, в котором ее вызвали, то <span class="code">super</span> ссылается на текущий объект родителя.
 
Как правило <span class="code">super</span> используется:<ol>

<li><p>Для вызова конструктора суперкласса: например, у класса <span class="code">Cat</span> есть внутренняя переменная <span class="code">name</span>, которую нужно проинициализировать в конструкторе. В конструкторе класса <span class="code">Lion</span> это будет выглядеть так:</p>

<pre class="language-java line-numbers"><code>
public Lion(final String name) {
   super(name);
}
</code></pre></li>
 
<li><p>Для обращения к полям и методам родителя: например, в классе <span class="code">Cat</span> у нас есть проинициализированное поле <span class="code">age</span>:</p>

<pre class="language-java line-numbers"><code>
public class Cat {
   int age = 10;
</code></pre></li>
 
</ol>В то же время у нас есть такое же проинициализированное поле в <span class="code">Lion</span>:

<pre class="language-java line-numbers"><code>
public class Lion extends Cat {
   int age = 15;
</code></pre>
И если мы хотим обратиться из объекта <span class="code">Lion</span> к переменной <span class="code">age</span> родительского объекта, это нужно делать через <span class="code">super</span>:

<pre class="language-java line-numbers"><code>
super.name
</code></pre><h4>22. Какие элементы языка отвечают за полиморфизм?</h4>Полиморфизм — это способность объекта одной сигнатуры принимать множество форм (множество реализаций).<img data-max-width="512" data-id="63a06bdc-3f15-466a-b6aa-751b667961ea" src="https://cdn.javarush.com/images/article/63a06bdc-3f15-466a-b6aa-751b667961ea/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3 - 2">Можно смело сказать, что в Java за полиморфизм отвечают ключевые слова <span class="code">implements</span> и <span class="code">extends</span>. 
 
<span class="code">implements</span> — когда мы создаем наш интерфейс, мы реализуем в каком-то классе одну из его возможных форм, но ведь она не единственная форма, не так ли? 
 
Вспомним, как выглядит применение <span class="code">implements</span>:

<pre class="language-java line-numbers"><code>
public class Cat implements Animal
</code></pre>
И в <span class="code">Cat</span> классе мы должны реализовать все абстрактные методы, представленные в интерфейсе <span class="code">Animal</span>.
 
Так же и наследование: в классе-наследнике мы можем переопределить уже существующую реализацию метода. Например: несколько наследников -&gt; несколько различных переопределений одного и того же метода.

Ну либо суперкласс был абстрактным и у него есть некий метод, который нужно реализовывать по-особому для каждого его наследника. То есть, можно сказать, что метод будет принимать множество форм.
 
Также в этом нам может помочь аннотация <span class="text-bold">@Override</span>, которая ставится над реализуемыми методами и обозначает, что мы хотим реализовать или переопределить (если реализация уже существует в суперклассе) тот или иной  метод суперкласса или интерфейса. 
 
Она не обязательна и используется для более легкого обнаружения ошибок. Этой аннотацией вы показываете компилятору, что хотите переопределить/имплементировать метод суперкласса/интерфейса, и он будет следить, чтобы вы не сделали ошибок в сигнатуре метода.<h4>23. Что такое SOLID? Приведите примеры</h4><span class="text-bold">SOLID</span> — акроним из названий пяти основных принципов дизайна для ООП, придуманных Робертом Мартином.
 
<span class="text-bold">S — Single-responsibility principle</span> — принцип единой ответственности, который гласит, что у класса должна быть только одна цель и единственное назначение. 
 
То есть, не стоит создавать классы, которые делают все. В этом случае можно воспроизвести антипаттерн “Божественный объект”.
 
Если у вас есть объект <span class="code">Cat</span>, в нем должны находиться методы, взаимодействующие только с его внутренней функциональностью, но никак не бизнес-логика, которая не имеет отношения к этому инстансу. Например, какое-нибудь сохранение объектов данного типа куда-либо. 
 
Этот внешний функционал (относительно <span class="code">Cat</span>), нужно выносить в другие классы, какие-нибудь сервисы, задача которых — обеспечить бизнес-логику для объектов данного типа.
 
<span class="text-bold">O — Open-closed principle</span> — принцип открытости/закрытости. Он означает, что программные сущности (классы, интерфейсы) должны быть открыты для расширения, но закрыты для модификации.
 
Например, нам понадобился функционал, схожий с функционалом уже существующего класса <span class="code">Cat</span>, но немного другой. Вместо того, чтобы изменять функционал класса <span class="code">Cat</span>, при этом ломая те места, в которых он уже задействован, мы используем <a href="https://javarush.com/groups/posts/853-nasledovanie-protiv-kompozicii-v-java" target="_blank">наследование или композицию</a>. Как итог — мы добились своей цели с модифицированным функционалом класса <span class="code">Cat</span>, но при этом мы не изменили его и ничего не сломали.
 
<span class="text-bold">L — Liskov substitution principle</span> — принцип подстановки Барбары Лисков.
 
Принцип гласит, что функция, использующая базовый тип, должна иметь возможность использовать подтипы базового типа, не зная об этом.
 
Например, наш класс <span class="code">Cat</span> должен быть заменяемым любым его наследником, скажем, <span class="code">Lion</span>, без кардинального изменения поведения. Общая логика (поведение) остается такой же, но меняются детали самой реализации того или иного функционала.
 
<span class="text-bold">I — Interface segregation principle</span> — принцип разделения интерфейса. Данный принцип гласит, что лучше иметь множество специализированных (узконаправленных) интерфейсов, чем один универсальный.
 
Например, пользователь реализует некоторый интерфейс, из которого ему нужен лишь он метод, но при этом у данного интерфейса есть еще девять методов, которые никак не относятся к логике нужного метода. В таком случае пользователю нужно будет реализовать десять методов интерфейса, девять из которых лишние для него!
 
Вместо этого лучше сделать десять различных интерфейсов которые можно реализовать при необходимости. Ну или не десять, а несколько, у которых будут методы, тесно связанные единой целью интерфейса. 
 
<span class="text-bold">D — Dependency Inversion Principle</span> — принцип инверсии зависимостей. Принцип говорит о том, что модули верхних уровней не должны зависеть от модулей нижних уровней. 
 
Ещё этот принцип описывают как “абстракция не должна зависеть от деталей, детали должны зависеть от абстракции”. 
 
То есть, мы должны строить нашу логику, ссылаясь на интерфейсы, и уже потом в этот функционал передавать конкретные объекты, классы которых и реализуют необходимый интерфейс.
 
Например, если у нас есть интерфейс <span class="code">Cat</span> и некоторые его реализации, скажем, <span class="code">Lion</span> и <span class="code">HomeCat</span>, мы строим нашу логику взаимодействия именно с типом интерфейса <span class="code">Cat</span>, и уже потом подставляем конкретную реализацию <span class="code">Lion</span> или <span class="code">HomeCat</span>, но никак не наоборот.<h4>24. Что такое класс, объект, интерфейс?</h4>Как мы помним, Java — это ООП язык. То есть, программы на Java построены на взаимодействии между объектами. Получается, программа — это такой себе муравейник, где каждый муравей это — объект.<img data-max-width="512" data-id="72606348-fc4d-4d43-8882-3b3411ec61ac" src="https://cdn.javarush.com/images/article/72606348-fc4d-4d43-8882-3b3411ec61ac/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3 - 3"><span class="text-bold">Объекты</span> — это некоторые сгруппированные данные, в которых содержатся различные методы (функции) для взаимодействия с этими внутренними данными.
 
А <span class="text-bold">классы</span> — это инструкции, шаблоны для создания объектов. То есть, может быть множество объектов, построенных по одной и той же инструкции, наполненных разными или одинаковыми значениями данных. Если приводить пример из жизни, можно сказать, что класс — это чертеж здания, а объект — конкретно созданное здание по этому чертежу.   
 
<span class="text-bold">Интерфейсы</span> — это аналоги классов с той разницей, что по ним нельзя создать объекты. Их цель — добавить элемент абстракции в Java. Точнее, добавить гибкость во взаимоотношениях классов и объектов.
Под гибкостью имеем в виду описанные ранее полиморфизм и абстракцию, которые в свою очередь открывают множество возможностей для построения внутренней архитектуры приложения.<h4>25. Что такое класс POJO? Приведите пример такого класса</h4><img data-max-width="512" data-id="33efc3c8-7dd4-4d61-846c-46f88829ed65" src="https://cdn.javarush.com/images/article/33efc3c8-7dd4-4d61-846c-46f88829ed65/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3 - 4"><span class="text-bold">POJO — Plain Old Java Object</span> — старый добрый Java-объект: простой объект, класса, который не унаследован от какого-то специфического класса и не реализует никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.
 
Другими словами <span class="text-bold">POJO</span> класс — это просто класс без особых требований. Единственное требование — отсутствие различных наворотов, завязанных на определенном фреймворке.

Как правило такие классы не наследуют от других классов (кроме классов <span class="text-bold">POJO</span> из того же пакета), не реализуют интерфейсов — иногда делается исключение для маркерных интерфейсов из стандартной библиотеки типа <span class="text-bold">Serializable</span> или <span class="text-bold">Cloneable</span> — не используют аннотаций и не зависят от сторонних библиотек. 
 
Но отмечу, что у <span class="text-bold">POJO</span> могут быть и методы с бизнес-логикой, и произвольного вида конструкторы.
 
Если разрешить аннотации, не вносящие изменения в семантику класса (без которых назначение объекта и логика его работы не изменятся), к <span class="text-bold">POJO</span> также можно отнести <span class="text-bold">Entity</span> сущности <span class="text-bold">JPA</span> и объекты <span class="text-bold">DTO</span>, десериализуемые из <span class="text-bold">XML</span> или <span class="text-bold">JSON</span>, правила для которых заданы в аннотациях.
 
Также для <span class="text-bold">POJO</span> классов желательно переопределить <span class="code">equals</span> и <span class="code">hashCode</span>, ведь это может помочь им лучше выполнять свою роль.
 
Пример <span class="text-bold">POJO</span> класса:
 
<pre class="language-java line-numbers"><code>
public class User {
   private Long id;
   private String firstName;
   private String lastName;
   private Long age;
 
   public User(final Long id, final String firstName, final String lastName, final long age) {
       this.id = id;
       this.firstName = firstName;
       this.lastName = lastName;
       this.age = age;
   }
 
   public Long getId() {
       return this.id;
   }
 
   public String getFirstName() {
       return this.firstName;
   }
 
   public String getLastName() {
       return this.lastName;
   }
 
   public Long getAge() {
       return this.age;
   }
 
   @Override
   public boolean equals(final Object o) {
       if (this == o) return true;
       if (o == null || this.getClass() != o.getClass()) return false;
       final User user = (User) o;
       return Objects.equals(this.id, user.id) &amp;&amp;
               Objects.equals(this.firstName, user.firstName) &amp;&amp;
               Objects.equals(this.lastName, user.lastName) &amp;&amp;
               Objects.equals(this.age, user.age);
   }
 
   @Override
   public int hashCode() {
       return Objects.hash(this.id, this.firstName, this.lastName, this.age);
   }
}
</code></pre><h4>26. Какие элементы может содержать класс?</h4>Класс может содержать такие элементы:<ul>

<li>поля класса;</li>
<li>статические поля класса;</li>
<li>блок инициализации;</li>
<li>статический блок инициализации;</li>
<li>конструкторы (пустой всегда определен по умолчанию);</li>
<li>методы;</li>
<li>статические методы;</li>
<li>различные аннотации (которые могут висеть над самим классом или его составляющими);</li>
<li><a href="https://javarush.com/groups/posts/2004-teorija-dzhenerikov-v-java-ili-gde-na-praktike-stavitjh-skobki" target="_blank">дженерики</a>;</li>
<li>наследования от других классов (<span class="code">extends</span>) или имплементации от интерфейсов (<span class="code">implements</span>).</li>
 
</ul><h4>27. Расскажите о наследовании в Java. Каковы особенности использования ключевого слова super?</h4>Выше я уже рассказал о наследовании и ключевом слове <span class="code">super</span> в Java. Упомяну еще несколько важных моментов:<ol>

<li>Возможно наследование лишь одного класса: множественное наследование в Java отсутствует (но с появлением дефолтных методов в Java 8 это утверждение станет весьма спорным).</li>
<li>Приватные методы и поля наследуются тоже, просто к ним не будет доступа с наследника (но если у нас, к примеру, приватное поле и к нему есть <span class="code">public</span> или <span class="code">protected</span> — геттеры и сеттеры, с полем можно работать через них).</li>
<li><span class="code">final</span> классы не наследуются.</li>
<li><span class="code">final</span> методы не переопределяются (но их можно наследовать и перегружать).</li>
<li><span class="code">static</span> методы и переменные не наследуются (т. к. они привязаны не к объектам, а к классам).</li>
<li>При наследовании от абстрактных классов, обязательна реализация их абстрактных методов, либо текущий класс тоже нужно объявить абстрактным.</li>
<li>При наличии не дефолтных конструкторов в родителе, в классе потомке их обязательно нужно переопределять (но <span class="text-bold">@Override</span> над ними не пишется).</li>
<li>Переопределенным методам в наследнике можно расширять модификатор доступа: <span class="code">private</span> -&gt; <span class="code">default</span> -&gt; <span class="code">protected</span> -&gt; <span class="code">public</span>.</li>
<li>Переопределенным методам в наследнике можно сужать прописываемые исключения, например: Exception -&gt; IOException -&gt; FileNotFoundException.</li>

</ol><img data-max-width="512" data-id="e42d844f-3be1-4162-b629-7ab4322de4f2" src="https://cdn.javarush.com/images/article/e42d844f-3be1-4162-b629-7ab4322de4f2/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3 - 5"><h4>28. Что такое сигнатура метода? Приведите примеры правильных и неправильных сигнатур</h4><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html" rel="nofollow" target="_blank">Сигнатура метода</a> — это имя метода плюс типы входящих параметров (причем порядок параметров имеет значение). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.
 
Пример правильной сигнатуры:

<pre class="language-java line-numbers"><code>
doSomething(int, double, double)
</code></pre>
 Пример неправильной сигнатуры:

<pre class="language-java line-numbers"><code>
void doSomething(int firstArg, int secondArg) throws Exception
</code></pre>
Сигнатура метода в сочетании с типом возвращаемого значения и перечнем бросаемых исключений называется <span class="text-bold">контрактом метода</span>.

На сегодня это все.

See you later!<img data-max-width="512" data-id="b12db89b-35b3-44cd-bf8f-369aba8905d9" src="https://cdn.javarush.com/images/article/b12db89b-35b3-44cd-bf8f-369aba8905d9/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3 - 6"><table><tbody>
<tr><th>
Другие материалы серии:
</th></tr><tr><td>
<ul><li><a href="https://javarush.com/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 1</a></li>
<li><a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 2</a></li>
<li><a href="https://javarush.com/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 4</a></li>
<li><a href="https://javarush.com/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5</a></li>
<li><a href="https://javarush.com/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6</a></li>
<li><a href="https://javarush.com/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 7</a></li>
<li><a href="https://javarush.com/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 8</a></li>
<li><a href="https://javarush.com/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 9</a></li>
<li><a href="https://javarush.com/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10</a></li>
<li><a href="https://javarush.com/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 11</a></li>
<li><a href="https://javarush.com/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 12</a></li>
<li><a href="https://javarush.com/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 13</a></li>
<li><a href="https://javarush.com/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 14</a></li>
<li><a href="https://javarush.com/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 15</a></li>
<li><a href="https://javarush.com/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 16</a></li>
</ul>
</td></tr></tbody></table>