Уровень 21. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
1. Перечислите методы класса Object: equals(), hashCode(), toString(), getClass(), notify(), notifyAll(), wait(), wait(long timeOut), wait(long timeOut, int nanos) Зачем нужны методы equals &amp; hashCode? используются ...
<p>----------------------------------------</p>

<img data-id="eec1534d-954b-4400-80fe-d2851c225f2f" data-max-width="850" alt="Уровень 21. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/eec1534d-954b-4400-80fe-d2851c225f2f/1024.jpeg"><ol>
<li><p><strong>Перечислите методы класса <code>Object</code></strong></p><ul>
<li><code>equals()</code></li>
<li><code>hashCode()</code></li>
<li><code>toString()</code></li>
<li><code>getClass()</code></li>
<li><code>notify()</code></li>
<li><code>notifyAll()</code></li>
<li><code>wait()</code></li>
<li><code>wait(long timeOut)</code></li>
<li><code>wait(long timeOut, int nanos)</code></li>
</ul>
<li><p><strong>Зачем нужны методы <code>equals</code> & <code>hashCode</code>?</strong></p>
<p>Используются для сравнения объектов.</p>

<p>Цель метода <code>equals</code> – определить идентичны ли объекты внутри, сравнив внутреннее содержание объектов. Так <code>equals</code> работает медленно, сначала сравниваются хэш коды объектов, и, в том случае, если хэш коды равны, идет проверка по <code>equals</code></p></li>
<li><p><strong>Что будет, если переопределить equals, но не переопределить <code>hashCode</code>?</strong></p>
<p>Изначально <code>hashCode</code> — случайное число.</p>

<p>Коллекции в Java перед тем как сравнить объекты с помощью <code>equals</code> всегда ищут/сравнивают их с помощью метода <code>hashCode()</code>. И если у одинаковых объектов будут разные <code>hashCode</code>, то объекты будут считаться разными — до сравнения с помощью <code>equals</code> просто не дойдет.</p></li>
<li><p><strong>Зачем нужны методы <code>wait</code>, <code>notify</code>, <code>notifyAll</code>?</strong></p>
<p>Иногда в программе может оказаться такая ситуация, что нить вошла в блок кода <code>synchronized</code>, заблокировала монитор и не может работать дальше, т.к. каких-то данных еще не хватает: например, файл который она должна обработать еще не загрузился или что-нибудь в таком духе. Для решения этой проблемы и был придуман метод <code>wait()</code>. Вызов этого метода приводит к тому, что нить освобождает монитор и «становится на паузу».</p>

<p>Для снятия с паузы используются методы <code>notify</code>, <code>notifyAll</code>. Метод <code>notify</code> «размораживает» одну случайную нить, метод <code>notifyAll</code> – все «замороженные» нити данного монитора.</p></li>
<li><p><strong>Как правильно клонировать объект?</strong></p>
<p>Два типа клонирования.</p>

<p>Для клонирования объекта по умолчанию нужно:</p>
<ul style="list-style-type:lower-alpha;">
<li>Добавить интерфейс <code>Cloneable</code> своему классу</li>
<li>Переопределить метод <code>clone</code> и вызвать в нем базовую реализацию:</li></ul><pre class='lang-java line-numbers'><code>
class Point implements Cloneable
{
 int x;
 int y;

 public Object clone()
 {
  return super.clone();
 }
}
</code></pre>
<p>Или можно написать реализацию метода <code>clone</code> самому:</p>

<pre class='lang-java line-numbers'><code>
class Point 
{
 int x;
 int y;

 public Object clone()
 {
  Point point = new Point();
  point.x = this.x;
  point.y = this.y;
  return point;
 }
}
</code></pre></li>
<li><p><strong>Зачем нужен метод <code>finalize()</code> и как он работает?</strong></p>
<p>Если ты помнишь, то <code>finalize()</code> – это специальный метод, который вызывается у объекта перед тем, как сборщик мусора его уничтожит.</p>

<p>Основная цель этого метода – освободить используемые внешние не-Java ресурсы: закрыть файлы, потоки ввода-вывода и т.п.</p>

<p><code>finalize()</code> работает нестабильно.</p>

<p>Этот метод не оправдывает возложенных на него надежд. Java-машина может отложить уничтожение объекта, как и вызов метода <code>finalize</code> на сколько угодно. Более того, она вообще не гарантирует, что этот метод будет вызван. В куче ситуаций ради «оптимизации» он не вызывается.</p></li>
<li><p><strong>В чем отличие <code>final</code>, <code>finally</code>, <code>finalize</code>?</strong></p>
<ul>
<li><code>final</code> — модификатор</li>
<li>Поля не могут быть изменены, методы переопределены</li> 
<li>Классы нельзя наследовать</li> 
<li>Этот модификатор применяется только к классам, методам и переменным (также и к локальным переменным)</li> 
<li>Аргументы методов, обозначенные как <code>final</code>, предназначены только для чтения, при попытке изменения будет ошибка компиляции</li> 
<li>Переменные <code>final</code> не инициализируются по умолчанию, им необходимо явно присвоить значение при объявлении или в конструкторе, иначе – ошибка компиляции</li> 
<li>Если final переменная содержит ссылку на объект, объект может быть изменен, но переменная всегда будет ссылаться на тот же самый объект</li> 
<li>Также это справедливо и для массивов, потому что массивы являются объектами, – массив может быть изменен, а переменная всегда будет ссылаться на тот же самый массив</li> 
<li>Если класс объявлен <code>final</code> и <code>abstract</code> (взаимоисключающие понятия), произойдет ошибка компиляции</li> 
<li>Так как <code>final</code> класс не может наследоваться, его методы никогда не могут быть переопределены</li>
</ul><p><code>finally</code> — блок в связке <code>try-catch-finally</code>, код в котором выполнится независимо от того вылетело ли исключение в блоке <code>try</code> или нет. Используется для освобождения ресурсов.</p>

<p><code>finalize</code> — метод в классе <code>Object</code> см 6.</p></li>
<li><p><strong>Что такое <code>try-with-resources</code>?</strong></p>
<p>Это специальная конструкция <code>try</code>, называемая <code>try-with-resources</code>, в которой Обрати внимание – после <code>try</code> следуют круглые скобки, где объявляются переменные и создаются объекты. Эти объекты можно использовать внутри блока <code>try</code>, обозначенного скобками <code>{}</code>. Когда выполнение команд блока <code>try</code> закончится, независимо от того – нормально оно закончилось или было исключение, для объекта, созданного внутри круглых скобок <code>()</code>, будет вызван метод <code>close()</code>;</p></li>
<li><p><strong>Чем отличаются методы <code>wait(1000)</code> и <code>sleep(1000)</code>?</strong></p>
<p><code>sleep()</code> приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению — RUNNABLE</p>

<p><code>wait()</code> меняет состояние потока на WAITING</p>

<p>может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется исключение<em> IllegalMonitorStateException</em>. при срабатывании метода блокировка отпускается, что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку . в случае <code>wait(int)</code> с аргументом состояние будет TIMED_WAITING</p></li>
<li><p><strong>В чем отличие <code>i++</code> и <code>++i</code>?</strong></p>
<ul>
<li><code>++i</code>, <code>i</code> сначала увеличивается на 1, затем участвует в выражении.</li>
<li><code>i++</code>, <code>i</code> сначала участвует в выражении, затем увеличивается на 1.</li>
</ul></li>
</ol>