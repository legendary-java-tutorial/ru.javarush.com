Вопросы на собеседование Hibernate
<p>----------------------------------------</p>
Данная статья является переводом и улучшением зарубежных статей (список ресурсов перечислен в конце статьи). Ответы на некоторые вопросы расширены, представлены
<p>----------------------------------------</p>
Данная статья является переводом и улучшением зарубежных статей (список ресурсов перечислен в конце статьи). Ответы на некоторые вопросы расширены, представлены ссылки на сторонние ресурсы которые содержат ответы которые могут возникнуть в процессе чтения.

1) Что такое Hibernate?

Это фреймворк для объектно-реляционного отображения сущностей в традиционные реляционные базу данных.
Основные возможности фреймворка:
1) Автоматическая генерация и обновление таблиц в базах данных;
2) Поскольку основные запросы к базе данных (сохранение, обновление, удаление и поиск) представлены как методы фрейморка, то значительно сокращается код, который пишется разработчиком ;
3) Обеспечивает использование SQL подобного языка (HQL — hibernate query language). Запросы HQL могут быть записаны рядом объектами данных (POJO классы подготовленные для работы с базой данных).

2) Как <a href='https://javarush.com/groups/posts/520-vashe-pervoe-prilozhenie-na-hibernate' target='_blank'>Hibernate</a> помогает в программировании?

Hibernate реализует ряд фичь которые значительно упрощают работу разработчика.
— Одной из таких фичь является то, что hibernate позволяет разработчику избежать написания большинства SQL запросов (они уже реализованы , вам надо просто использовать методы которые предоставляет фреймворк).
— Под бортом у Hibernate есть куча полезных инструментов которые значительно ускоряют работу приложения, самыми примечательными из них являются двухуровневое кэширования и тонкие настройки lazy и fetch изъятия.
— Сам генерирует таблицы в базу данных.

3) Способы конфигурации работы с Hibernate.

Существует четыре способа конфигурации работы с Hibernate :
— используя аннотации;
— hibernate.cfg.xml;
— hibernate.properties;
— persistence.xml.
Самый частый способ конфигурации : через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла, то принимаются настройки из файла hibernate.cfg.xml). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для разных баз данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.

4) Какие ключевые интерфейсы использует Hibernate?

Существует пять ключевых интерфейсов которые используются в каждом приложении связанном с Hibernate:
— Session interface;
— SessionFactory interface;
— Configuration interface;
— Transaction interface;
— Query and Criteria interfaces.

5) Какая роль интерфейса Session в Hibernate?

Session — это основной интерфейс, который отвечает за связь с базой данных. Так же, он помогает создавать объекты запросов для получение персистентных объектов. (персистентный объект — объект который уже находится в базе данных; объект запроса — объект который получается когда мы получаем результат запроса в базу данных, именно с ним работает приложение). Обьект Session можно получить из SessionFactory :
Session session = sessionFactory.openSession();
Роль интерфейса Session:
— является оберткой для jdbc подключения к базе данных; (https://ru.wikipedia.org/wiki/Java_Database_Connectiv..)
— является фабрикой для транзакций (согласно официальной документации transaction — аllows the application to define units of work, что , по сути, означает что транзакция определяет границы операций связанных с базой данных).
— является хранителем обязательного кэша первого уровня.

6) Какая роль интерфейса SessionFactory в Hibernate?

Именно из объекта SessionFactory мы получаем объекты типа Session. На все приложение существует только одна SessionFactory и она инициализируеться вместе со стартом приложения. SessionFactory кэширует мета-дату и SQL запросы которые часто используются приложением во время работы. Так же оно кэширует информацию которая была получена в одной из транзакций и может быть использована и в других транзакциях.
Обьект SessionFactory можно получить следующим обращением:
SessionFactory sessionFactory = configuration.buildSessionFactory();

7) Какие типы коллекций представлены в Hibernate?

Bag, Set, List, Map, Array.

8) Что собой являет коллекция типа Bag и зачем она используется?

Своей реализации тип коллекции Bag очень напоминает Set, разница состоит в том, что Bag может хранить повторяющиеся значения. Bag хранит непроиндексированный список элементов. Большинство таблиц в базе данных имеют индексы отображающие положение элемента данных один относительно другого, данные индексы имеют представление в таблице в виде отдельной колонки. При объектно-реляционном маппинге, значения колонки индексов мапится на индекс в Array, на индекс в List или на key в Map. Если вам надо получить коллекцию объектов не содержащих данные индексы, то вы можете воспользоваться коллекциями типа Bag или Set (коллекции содержат данные в неотсортированном виде, но могут быть отсортированы согласно запросу).

9) Какая разница в работе методов load(); и get();?

Метод load(); обычно используется когда в не уверен что запрашиваемый объект уже находится в базе данных. Если объект не найден, то метод кидает исключение Если объект найден — метод возвращает прокси объект, который является ссылкой на объект находящийся в базе данных (запрос в базу данных еще не был осуществлен, своего рода lazy изъятие), непосредственный запрос к базе данных когда мы непосредственно обращаемся к необходимому объекту через прокси объект.
Метод get(); используется тогда, вы на 100 процентов не уверены есть ли запрашиваемый объект в базе данных. В случае обращение к несуществующему объекту, метод get(); вернет null. В случае нахождения объект, метод get(); вернет сам объект и запрос в базу данных будет произведен немедленно.

10) Что такое Lazy fetching(изъятие) в Hibernate?

Тип изьятия Lazy, в Hibernate, связан с листовыми(дочерними) сущностями и определяют политику совместного изъятия, если идет запрос на изъятие сущности родителя.
Простой пример:
Есть сущность Дом. Он хранит информацию о своем номере, улице, количество квартир и информацию о семьях которые живут в квартирах, эти семьи формируют дочернюю сущность относительно сущности Дом. Когда мы запрашиваем информацию о Доме, нам может быть совершенно ненужным знать информацию семьях которые в нем проживают, тут нам на помощь приходит lazy(ленивое) изъятие(fetching) которая позволяет сконфигурировать сущность Дом, чтобы информацию о семьях подавалась только по востребованию, это значительно облачает запрос и ускоряет работу приложения.

©dev-bay