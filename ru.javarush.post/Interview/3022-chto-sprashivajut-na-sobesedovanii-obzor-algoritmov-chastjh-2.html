Что спрашивают на собеседовании: обзор алгоритмов, часть 2
<p>----------------------------------------</p>
Ранее мы рассматривали различные алгоритмы сортировки массивов и так называемый жадный алгоритм. Сегодня же мы поговорим о графах и алгоритмах, связанных с ними. Граф — одна из самых гибких и универсальных структур в программировании...
<p>----------------------------------------</p>
<em>Данная статья является продолжением моего небольшого обзора по алгоритмам. Вот ссылка на <a href="https://javarush.com/groups/posts/3021-chto-sprashivajut-na-sobesedovanii-obzor-algoritmov-chastjh-1" target="_blank" rel="nofollow">первую часть</a>. </em>

Ранее мы рассматривали различные алгоритмы сортировки массивов и так называемый <span>жадный алгоритм</span>.

Сегодня же мы поговорим о графах и алгоритмах, связанных с ними.<img data-max-width="512" data-id="32cd1a77-95cd-4cf6-9164-c08710b702d2" src="/images/article/32cd1a77-95cd-4cf6-9164-c08710b702d2/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 1"><span>Граф</span> — одна из самых гибких и универсальных структур в программировании. 

<span>Граф G</span> обычно задается при помощи пары множеств <span>G = (V, R)</span>, где:<ul>
<li><span>V</span> — множество вершин;</li>
<li><span>R</span> — множество линий, соединяющих пары вершин.</li>

</ul>Обычные соединяющие линии называют <span>ребрами</span>:<img data-max-width="512" data-id="4fbf1771-712f-4693-8a9c-089650322f76" src="/images/article/4fbf1771-712f-4693-8a9c-089650322f76/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 2">Линии со стрелками — <span>дугами</span>:<img data-max-width="512" data-id="4420b613-cb5d-4114-a817-290561c0568c" src="/images/article/4420b613-cb5d-4114-a817-290561c0568c/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 3">Как правило граф представляют с помощью схемы, на которой некоторые вершины соединены ребрами (дугами).

Графы, связанные между собой дугами, непосредственно указывающими направление, называют <span>направленными</span>. Если же графы соединены ребрами, то есть без указания направления возможного движения, они становятся <span>ненаправленными</span>. Это значит, что перемещения по ним возможны в обоих направлениях: как от вершины А к В, так и от В к А.

<span>Связный граф</span> — граф, в котором от каждой вершины к любой другой вершине ведёт хотя бы один путь (как на примере выше).

Если это не так, граф становится <span>несвязным</span>:<img data-max-width="512" data-id="6c57e29e-e44a-457f-97e3-60886104512b" src="/images/article/6c57e29e-e44a-457f-97e3-60886104512b/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 4">Также ребрам (дугам) могут присваиваться веса — числа, представляющие физическое расстояние между двумя вершинами (или относительное время перехода между двумя вершинами). Такие графы и называют <span>взвешенными</span>:<img data-max-width="512" data-id="70fa888a-c27e-409d-a7c6-7c38ddde2568" src="/images/article/70fa888a-c27e-409d-a7c6-7c38ddde2568/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 5"><h2>3. Алгоритмы поиска пути (глубина, ширина)</h2>Одна из основных операций, которые выполняются с графами, — это определение  всех вершин, достижимых от заданной вершины. Представьте, что вы пытаетесь определить, как можно добраться от одного города в другой с возможными пересадками. К одним городам можно добраться напрямую, к другим нужно ехать в обход через другие города. Существует много других ситуаций, в которых может понадобиться нахождение всех вершин, к которым можно найти путь от заданной вершины.

Так вот, существует два основных способа обхода графов: <span>обход в глубину</span> и <span>обход в ширину</span>, которые мы и рассмотрим. Оба способа обеспечат перебор всех связных вершин.

Для дальнейшего рассмотрения алгоритмов в <span>глубину</span> и <span>ширину</span> возьмем следующий граф:<img data-max-width="512" data-id="3f47ef62-59fa-4c33-b527-eb225fb670c1" src="/images/article/3f47ef62-59fa-4c33-b527-eb225fb670c1/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 6"><h3>Обход в глубину</h3>Это один из наиболее распространенных методов обхода графа. Данная стратегия поиска в <span>глубину</span> состоит в том, чтобы идти <span>«вглубь»</span> графа насколько это возможно, а достигнув тупика, возвращаться к ближайшей вершине, у которой есть смежные ранее не посещенные вершины.

Этот алгоритм хранит в стеке информацию о том, куда следует вернуться при достижении “тупика”.

Правила обхода в глубину:<ol>

<li>Посетить смежную, ранее не посещенную вершину, пометить её и занести в стек.</li>
<li>Перейти на данную вершину.</li>
<li>Повторить этап 1.</li>
<li>Если выполнение пункта 1 невозможно, вернуться к предыдущей вершины и попытаться повторить правило 1. Если это невозможно — вернуться к вершине до нее, и так далее, пока не найдем вершину, с которой можно продолжить обход.</li>
<li>Продолжать до тех пор, пока все вершины не окажутся в стеке.</li></ol><img data-max-width="512" data-id="055f7f7c-ccf8-49ac-aa68-7500b3429c8d" src="/images/article/055f7f7c-ccf8-49ac-aa68-7500b3429c8d/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 7">Давайте взглянем, как может выглядеть код для данного алгоритма в Java:

<pre class="language-java line-numbers"><code>
public class Graph {
  private final int MAX_VERTS = 10;
  private Vertex vertexArray[]; //массив вершин
  private int adjMat[][]; // матрица смежности
  private int nVerts; // текущее количество вершин
  private Stack&lt;integer&gt; stack;
 
  public Graph() { // инициализация внутрених полей
     vertexArray = new Vertex[MAX_VERTS];
     adjMat = new int[MAX_VERTS][MAX_VERTS];
     nVerts = 0;
     for (int j = 0; j &lt; MAX_VERTS; j++) {
        for (int k = 0; k &lt; MAX_VERTS; k++) {
           adjMat[j][k] = 0;
        }
     }
     stack = new Stack&lt;&gt;();
  }
 
  public void addVertex(char lab) {
     vertexArray[nVerts++] = new Vertex(lab);
  }
 
  public void addEdge(int start, int end) {
     adjMat[start][end] = 1;
     adjMat[end][start] = 1;
  }
 
  public void displayVertex(int v) {
     System.out.println(vertexArray[v].getLabel());
  }
 
  public void dfs() { // обход в глубину
     vertexArray[0].setWasVisited(true); // берётся первая вершина
     displayVertex(0);
     stack.push(0);
    
     while (!stack.empty()) {
        int v = getAdjUnvisitedVertex(stack.peek()); // вынуть индекс смежной веришины, еckи есть 1, нету -1
        if (v == -1) { // если непройденных смежных вершин нету
           stack.pop(); // элемент извлекается из стека
        }
        else {
           vertexArray[v].setWasVisited(true);
           displayVertex(v);
           stack.push(v); // элемент попадает на вершину стека
        }
     }
    
     for (int j = 0; j &lt; nVerts; j++) {  // сброс флагов
        vertexArray[j].wasVisited = false;
     }
    
  }
 
  private int getAdjUnvisitedVertex(int v) {
     for (int j = 0; j &lt; nVerts; j++) {
        if (adjMat[v][j] == 1 &amp;&amp; vertexArray[j].wasVisited == false) {
           return j; //возвращает первую найденную вершину
        }
     }
     return -1;
  }
}
&lt;/integer&gt;</code></pre>
Вершина имеет вид:

<pre class="language-java line-numbers"><code>
public class Vertex {
  private char label;  // метка А например
  public boolean wasVisited;
 
  public Vertex(final char label) {
     this.label = label;
     wasVisited = false;
  }
 
  public char getLabel() {
     return this.label;
  }
 
  public boolean isWasVisited() {
     return this.wasVisited;
  }
 
  public void setWasVisited(final boolean wasVisited) {
     this.wasVisited = wasVisited;
  }
}
</code></pre>
Запустим данный алгоритм с конкретными вершинами и посмотрим на корректность работы:

<pre class="language-java line-numbers"><code>
public class Solution {
  public static void main(String[] args) {
     Graph graph = new Graph();
     graph.addVertex('A'); //0
     graph.addVertex('B'); //1
     graph.addVertex('C'); //2
     graph.addVertex('D'); //3
     graph.addVertex('E'); //4
     graph.addVertex('F'); //5
     graph.addVertex('G'); //6
    
     graph.addEdge(0,1);
     graph.addEdge(0,2);
     graph.addEdge(0,3);
     graph.addEdge(1,4);
     graph.addEdge(3,5);
     graph.addEdge(5,6);
    
     System.out.println("Visits: ");
     graph.dfs();
  }
}
</code></pre>

Вывод в консоли:
<div class="terminal">Visits:
A
B
E
C
D
F
G</div>
Так как у нас есть матрица смежности и в методе прохода мы используем цикл, вложенный в цикл, то временная сложность будет <span>O(N²)</span>.<h3>Обход в ширину</h3>Данный алгоритм, как и обход в глубину, является одним наиболее простых и базовых методов обхода графа. Его суть в том, что у нас есть некоторая текущая вершина, с которой мы все смежные, непройденные вершины, заносим в очередь и выбираем следующий элемент (который хранится первым в очереди), чтобы его сделать текущим…<img data-max-width="512" data-id="8b57bfac-8da4-4898-a138-dc7559ba1250" src="/images/article/8b57bfac-8da4-4898-a138-dc7559ba1250/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 8">Если разбить данный алгоритм на этапы, можно выделить следующие правила:<ol>
<li>Посетить следующую, ранее не посещенную вершину, смежную с текущей вершиной, пометить её заранее и занести в очередь.</li>
<li>Если выполнение правила #1 невозможно — извлечь вершину из очереди и сделать её текущей вершиной.</li>
<li>Если правило #1 и #2 невозможно, обход закончен, а все вершины пройдены (если граф у нас связный). </li></ol><img data-max-width="512" data-id="03c96dee-7cea-4357-9c99-7dd6111620f6" src="/images/article/03c96dee-7cea-4357-9c99-7dd6111620f6/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 9">Класс графа практически идентичен аналогичному классу из алгоритма поиска в глубину, за исключением метода, обрабатывающего алгоритм и замены внутреннего стека на очередь:

<pre class="language-java line-numbers"><code>
public class Graph {
  private final int MAX_VERTS = 10;
  private Vertex vertexList[]; //массив вершин
  private int adjMat[][]; // матрица смежности
  private int nVerts; // текущее количество вершин
  private Queue&lt;integer&gt; queue;
 
  public Graph() {
     vertexList = new Vertex[MAX_VERTS];
     adjMat = new int[MAX_VERTS][MAX_VERTS];
     nVerts = 0;
     for (int j = 0; j &lt; MAX_VERTS; j++) {
        for (int k = 0; k &lt; MAX_VERTS; k++) {  // заполнение матрицы смежности нулями
           adjMat[j][k] = 0;
        }
     }
     queue = new PriorityQueue&lt;&gt;();
  }
 
  public void addVertex(char lab) {
     vertexList[nVerts++] = new Vertex(lab);
  }
 
  public void addEdge(int start, int end) {
     adjMat[start][end] = 1;
     adjMat[end][start] = 1;
  }
 
  public void displayVertex(int v) {
     System.out.println(vertexList[v].getLabel());
  }
 
  public void bfc() { // обход в глубину
     vertexList[0].setWasVisited(true);
     displayVertex(0);
     queue.add(0);
     int v2;
    
     while (!queue.isEmpty()) {
        int v = queue.remove();
 
        while((v2 = getAdjUnvisitedVertex(v))!=-1) {// цикл будет работать, пока все смежные вершины не будут найденны, и не будут добавлены в очередь
           vertexList[v2].wasVisited =true;
           displayVertex(v2);
           queue.add(v2);
        }
     }
    
     for (int j = 0; j &lt; nVerts; j++) {  // сброс флагов
        vertexList[j].wasVisited = false;
     }
    
  }
 
  private int getAdjUnvisitedVertex(int v) {
     for (int j = 0; j &lt; nVerts; j++) {
        if (adjMat[v][j] == 1 &amp;&amp; vertexList[j].wasVisited == false) {
           return j; //возвращает первую найденную вершину
        }
     }
     return -1;
  }
}
&lt;/integer&gt;</code></pre>
Класс <span>Vertex</span> идентичен классу из алгоритма про <span>поиск в глубину</span>.

Давайте приведем данный алгоритм в действие:

<pre class="language-java line-numbers"><code>
public class Solution {
  public static void main(String[] args) {
     Graph graph = new Graph();
     graph.addVertex('A'); //0
     graph.addVertex('B'); //1
     graph.addVertex('C'); //2
     graph.addVertex('D'); //3
     graph.addVertex('E'); //4
     graph.addVertex('F'); //5
     graph.addVertex('G'); //6
    
     graph.addEdge(0,1);
     graph.addEdge(0,2);
     graph.addEdge(0,3);
     graph.addEdge(1,4);
     graph.addEdge(3,5);
     graph.addEdge(5,6);
    
     System.out.println("Visits: ");
     graph.bfc();
  }
}
</code></pre>
Вывод в консоль:

<div class="terminal">Visits:
A
B
C
D
E
F
G</div>
Опять же: мы имеем матрицу смежности и используем цикл, вложенный в цикл, поэтому <span>O(N²)</span> — временная сложность приведенного алгоритма.<h2>4. Алгоритм Дейкстры</h2>Как говорилось ранее, графы могут быть <span>направленными</span> и <span>ненаправленными</span>. И как вы помните, они ещё могут быть <span>взвешенными</span>.

Взвешенные, направленные графы часто встречаются и в реальной жизни: например, карта городов, где города — вершины, пути между ними — дороги, дороги могут иметь одностороннее движение — направление графа.

Допустим, вы занимаетесь грузоперевозками и нужно составить кратчайший путь между двумя отдаленными городами. Каким образом вы это сделаете? 

Одной из самых распространённых задач, связанной со взвешенными графами, является задача выбора кратчайшего пути между двумя вершинами.

Для решения данной задачи мы и используем <span>алгоритм Дейкстры</span>.

Хотелось бы сразу отметить, что выполнив алгоритм Дейкстры мы узнаем кратчайшие пути ко всем вершинам от заданной начальной. 

Какие же этапы имеет данный алгоритм? Попытаюсь ответить на данный вопрос.

<span>Этапы алгоритма Дейкстры:</span><ul>

<li><span>Этап 1</span>: поиск узла, переход к которому будет составлять наименьшую стоимость. Вы стоите в самом начале и думаете, куда направиться: к узлу <span>А</span> или к узлу <span>В</span>. Сколько времени понадобится, чтобы добраться до каждого из этих узлов?</li>
<li><span>Этап 2</span>: вычисление, сколько времени нужно, чтобы добраться до всех ещё не затронутых алгоритмом соседей <span>В</span> при переходе по ребру из <span>В</span>. Если же это новое время окажется меньше старого, путь через ребро B и станет новым кратчайшим путём для этой вершины.</li>
<li><span>Этап 3</span>: помечаем вершину B как пройденную.</li>
<li><span>Этап 4</span>: перейти к этапу 1.</li>

</ul>Цикл этих этапов мы будем повторять до тех пор, пока все вершины не будут пройдены.

Давайте рассмотрим следующий взвешенный направленный граф:<img data-max-width="512" data-id="eaa11712-9e85-4611-aeff-6ce28101f067" src="/images/article/eaa11712-9e85-4611-aeff-6ce28101f067/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 10">Итак, с помощью вышеприведенного алгоритма мы определим кратчайший путь от A до G:<ol>
<li>Для вершины <span>A</span> есть три возможных пути: к <span>B</span> с весом 3, к <span>С</span> с весом 5 и к <span>D</span> с весом 7. Согласно первому пункту алгоритма выбираем узел с наименьшей стоимостью перехода — то есть к <span>B</span>.</li>
<li>Так как единственной непройденной вершиной-соседом для <span>B</span> будет вершина <span>Е</span>, мы проверяем, каков будет путь при прохождении через эту вершину. 3(<span>AB</span>) + 6(<span>BE</span>) = 9.
<p>Таким образом, мы отмечаем что текущий кратчайший путь до AE = 9.</p></li>
<li>Так как наша работа с вершиной <span>B</span> уже закончена, переходим к выбору следующей вершины с минимальным весом ребра до неё.
<p>С вершин <span>A</span> и <span>B</span> это могут быть вершины <span>D</span>(7), <span>C</span>(5), <span>E</span>(6).</p>
<p>Наименьший вес ребра имеет <span>С</span>, поэтому к этой вершине и перейдем.</p></li>
<li>Далее, как и раньше, выясняем кратчайший путь к соседним вершинам при проходе через С:<ul>
<li><span>AD</span> = 5(<span>AC</span>) + 3(<span>CD</span>) = 8, но так как предыдущий кратчайший путь <span>AC</span> = 7, то есть меньше, чем этот через <span>С</span>, мы так и оставляем кратчайший путь <span>AD</span> = 7, без изменений.</li>
<li><span>CE</span> = 5(<span>AC</span>) + 4(<span>CE</span>) = 9, этот новый кратчайший путь равен прежнему поэтому мы оставляем его без изменения тоже.</li></ul></li>
<li>Из ближайших доступных вершин, <span>E</span> и <span>D</span>, выбираем вершину с наименьшим весом ребра, то есть <span>D</span>(3).</li>
<li>Выясняем кратчайший путь до его соседа — <span>F</span>.
<p><span>AF</span> = 7(<span>AD</span>) + 3(<span>DF</span>)  = 10</p></li>
<li>Из ближайших доступных вершин <span>E</span> и <span>F</span>, выбираем вершину с наименьшим весом ребра к ней, то есть <span>F</span>(3).</li>
<li>Выясняем кратчайший путь до его соседа — <span>G</span>.
<p><span>AG</span> = 7(<span>AD</span>) + 3(<span>DF</span>) + 4(<span>FG</span>) = 14</p>
<p>Собственно, вот мы и нашли путь от <span>A</span> до <span>G</span>.</p>
<p>Но чтобы убедиться в том, что он кратчайший, мы должны прогнать наши этапы и для вершины <span>E</span>.</p></li>
<li>Так как у вершины <span>G</span> нет соседних вершин, к которым вел бы направленный путь, у нас остаётся только вершина <span>E</span>: выбираем ее.</li>
<li>Выясняем кратчайший путь до соседа — <span>G</span>.
<p><span>AG</span> = 3(<span>AB</span>) + 6(<span>BE</span>) + 6(<span>EG</span>) = 15, этот путь длиннее прежнего кратчайшего AG(14), поэтому данный путь мы оставляем без изменений.</p>
<p>Так как вершин, ведущих от <span>G</span>, нет, прогонять этапы для данной вершины не имеет смысла. Поэтому работу алгоритма можно считать законченной.</p></li>

</ol>Как я и говорил ранее, помимо выяснения кратчайшего пути для <span>AG</span>, мы получили кратчайшие пути до всех вершин от вершины <span>A (AB, AC, AD, AE, AF)</span>.

Что ж, пришло время взглянуть, каким образом это возможно реализовать на Java.

Для начала рассмотрим класс вершины:

<pre class="language-java line-numbers"><code>
public class Vertex {
   private char label;
   private boolean isInTree;

   public Vertex(char label) {
       this.label = label;
       this.isInTree = false;
   }

   public char getLabel() {
       return label;
   }

   public void setLabel(char label) {
       this.label = label;
   }

   public boolean isInTree() {
       return isInTree;
   }

   public void setInTree(boolean inTree) {
       isInTree = inTree;
   }
}
</code></pre>
Класс вершины фактически идентичен классу вершины из поиска в глубину и ширину.
 
Чтобы отобразить кратчайшие пути, нам понадобится новый класс, который будет содержать необходимые нам данные:

<pre class="language-java line-numbers"><code>
public class Path { // объект данного класса содержащий расстояние и предыдущие и пройденные вершины
   private int distance; // текущая дистанция от начальной вершины
   private List&lt;integer&gt; parentVertices; // текущий родитель вершины

   public Path(int distance) {
       this.distance = distance;
       this.parentVertices = new ArrayList&lt;&gt;();
   }

   public int getDistance() {
       return distance;
   }

   public void setDistance(int distance) {
       this.distance = distance;
   }

   public List&lt;integer&gt; getParentVertices() {
       return parentVertices;
   }

   public void setParentVertices(List&lt;integer&gt; parentVertices) {
       this.parentVertices = parentVertices;
   }
}
&lt;/integer&gt;&lt;/integer&gt;&lt;/integer&gt;</code></pre>
В данном классе мы можем видеть общую дистанцию пути и вершины, которые будут пройдены при проходе по найкрайчайшему пути.

А сейчас хотелось бы рассмотреть класс в котором, собственно, и происходит кратчайший обход графа.

Итак, класс графа:

<pre class="language-java line-numbers"><code>
public class Graph {
   private final int MAX_VERTS = 10;// максимальное количество вершин
   private final int INFINITY = 100000000; // это число у нас будет служить в качестве "бесконечности"
   private Vertex vertexList[]; // список вершин
   private int relationMatrix[][]; // матрица связей вершин
   private int countOfVertices; // текущее количество вершин
   private int countOfVertexInTree; // количество рассмотренных вершин в дереве
   private List&lt;path&gt; shortestPaths; // список данных кратчайших путей
   private int currentVertex; // текущая вершина
   private int startToCurrent; //расстояние до currentVertex

   public Graph() {
       vertexList = new Vertex[MAX_VERTS]; // матрица смежности
       relationMatrix = new int[MAX_VERTS][MAX_VERTS];
       countOfVertices = 0;
       countOfVertexInTree = 0;
       for (int i = 0; i &lt; MAX_VERTS; i++) {// матрица смежности заполняется
           for (int k = 0; k &lt; MAX_VERTS; k++) { // бесконечными расстояниями
               relationMatrix[i][k] = INFINITY; // задания значений по умолчанию
               shortestPaths = new ArrayList&lt;&gt;();// задается пустым
           }
       }
   }

   public void addVertex(char lab) {// задание новых вершин
       vertexList[countOfVertices++] = new Vertex(lab);
   }

   public void addEdge(int start, int end, int weight) {
       relationMatrix[start][end] = weight; // задание ребер между вершинами, с весом между ними
   }

   public void path() { // выбор кратчайшего пути
       //  задание данных для стартовой вершины
       int startTree = 0; // стартуем с вершины 0
       vertexList[startTree].setInTree(true); // включение в состав дерева первого элемента
       countOfVertexInTree = 1;

       // заполнение коротких путей для вершин смежных с стартовой
       for (int i = 0; i &lt; countOfVertices; i++) {
           int tempDist = relationMatrix[startTree][i];
           Path path = new Path(tempDist);
           path.getParentVertices().add(0);// первым родительским элементом, будет всегда стартовая вершина
           shortestPaths.add(path);
       }
       // пока все вершины не окажутся в дереве
       while (countOfVertexInTree &lt; countOfVertices) { // выполняем, пока количество вершин в дереве не сравняется с общим количеством вершин
           int indexMin = getMin();//получаем индекс вершины с наименшей дистанцией, из вершин еще не входящих в дерево
           int minDist = shortestPaths.get(indexMin).getDistance();// минимальная дистанция вершины, из тек которые ещё не в дереве

           if (minDist == INFINITY) {
               System.out.println("В графе пристувствуют недостижимые вершины");
               break;// в случае если остались непройденными только недостижимые вершины, мы выходим из цикла
           } else {
               currentVertex = indexMin; // переводим указатель currentVert к текущей вершине
               startToCurrent = shortestPaths.get(indexMin).getDistance();// задаем дистанцию к текущей вершине
           }

           vertexList[currentVertex].setInTree(true);  //включение текущей вершины в дерево
           countOfVertexInTree++; // увеличиваем счетчик вершин в дереве
           updateShortestPaths(); // обновление списка кратчайших путей
       }

       displayPaths(); // выводим в консоль результаты
   }

   public void clean() { // очиска дерева
       countOfVertexInTree = 0;
       for (int i = 0; i &lt; countOfVertices; i++) {
           vertexList[i].setInTree(false);
       }
   }

   private int getMin() {
       int minDist = INFINITY; // за точку старта взята "бесконечная" длина
       int indexMin = 0;
       for (int i = 1; i &lt; countOfVertices; i++) {// для каждой вершины
           if (!vertexList[i].isInTree() &amp;&amp; shortestPaths.get(i).getDistance() &lt; minDist) { // если вершина ещё не ве дереве и её растояние меньше старого минимума
               minDist = shortestPaths.get(i).getDistance(); // задаётся новый минимум
               indexMin = i; // обновление индекса вершины содержащую минимаьную дистанцию
           }
       }
       return indexMin; //возвращает индекс вершины с наименшей дистанцией, из вершин еще не входящих в дерево
   }

   private void updateShortestPaths() {
       int vertexIndex = 1; // стартовая вершина пропускается
       while (vertexIndex &lt; countOfVertices) { // перебор столбцов

           if (vertexList[vertexIndex].isInTree()) { // если вершина column уже включена в дерево, она пропускается
               vertexIndex++;
               continue;
           }
           // вычисление расстояния для одного элемента sPath
           // получение ребра от currentVert к column
           int currentToFringe = relationMatrix[currentVertex][vertexIndex];
           // суммирование всех расстояний
           int startToFringe = startToCurrent + currentToFringe;
           // определение расстояния текущего элемента vertexIndex
           int shortPathDistance = shortestPaths.get(vertexIndex).getDistance();

           // сравнение расстояния через currentVertex с текущим расстоянием в вершине с индексом vertexIndex
           if (startToFringe &lt; shortPathDistance) {// если меньше, то у вершины под индексом vertexIndex будет задан новый кратчайший путь
               List&lt;integer&gt; newParents = new ArrayList&lt;&gt;(shortestPaths.get(currentVertex).getParentVertices());//создаём копию списка родителей вершины currentVert
               newParents.add(currentVertex);// задаём в него и currentVertex как предыдущий
               shortestPaths.get(vertexIndex).setParentVertices(newParents); // соохраняем новый маршут
               shortestPaths.get(vertexIndex).setDistance(startToFringe); // соохраняем новую дистанцию
           }
           vertexIndex++;
       }
   }

   private void displayPaths() { // метод для вывода кратчайших путей на экран
       for (int i = 0; i &lt; countOfVertices; i++) {
           System.out.print(vertexList[i].getLabel() + " = ");
           if (shortestPaths.get(i).getDistance() == INFINITY) {
               System.out.println("0");
           } else {
               String result = shortestPaths.get(i).getDistance() + " (";
               List&lt;integer&gt; parents = shortestPaths.get(i).getParentVertices();
               for (int j = 0; j &lt; parents.size(); j++) {
                   result += vertexList[parents.get(j)].getLabel() + " -&gt; ";
               }
               System.out.println(result + vertexList[i].getLabel() + ")");
           }
       }
   }
}
&lt;/integer&gt;&lt;/integer&gt;&lt;/path&gt;</code></pre>
Собственно, вот и вся магия =)

Ну а теперь, давайте взглянем на данный алгоритм в действии:

<pre class="language-java line-numbers"><code>
public class Solution {

   public static void main(String[] args) {
       Graph graph = new Graph();
       graph.addVertex('A');
       graph.addVertex('B');
       graph.addVertex('C');
       graph.addVertex('D');
       graph.addVertex('E');
       graph.addVertex('F');
       graph.addVertex('G');

       graph.addEdge(0, 1, 3);
       graph.addEdge(0, 2, 5);
       graph.addEdge(0, 3, 7);
       graph.addEdge(1, 4, 6);
       graph.addEdge(2, 4, 4);
       graph.addEdge(2, 3, 3);
       graph.addEdge(3, 5, 3);
       graph.addEdge(4, 6, 6);
       graph.addEdge(5, 6, 4);

       System.out.println("Элементы имеют кратчайшие пути из точки A: ");
       graph.path();
       graph.clean();
   }
}
</code></pre>
И вывод в консоли:

<div class="terminal">Элементы имеют кратчайшие пути из точки A: 
A = 0
B = 3 (A -&gt; B)
C = 5 (A -&gt; C)
D = 7 (A -&gt; D)
E = 9 (A -&gt; B -&gt; E)
F = 10 (A -&gt; D -&gt; F)
G = 14 (A -&gt; D -&gt; F -&gt; G)</div>
Временная сложность данного алгоритма — ничто иное как <span>O(N²)</span>, так как у нас есть циклы, вложенные в цикл.

Что же, на этом у меня сегодня всё, спасибо за внимание!<img data-max-width="512" data-id="28f57f69-68b4-4c60-bbd3-6a0036519b97" src="/images/article/28f57f69-68b4-4c60-bbd3-6a0036519b97/512.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 11"><a href="https://javarush.com/welcome" target="_blank" rel="nofollow"><img data-max-width="1080" data-id="a27b7388-7969-4bc1-92e2-b779b65c64cf" src="/images/article/a27b7388-7969-4bc1-92e2-b779b65c64cf/1080.jpeg" alt="Что спрашивают на собеседовании: обзор алгоритмов, часть 2 - 12"></a>