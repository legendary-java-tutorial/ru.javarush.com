Java Core. Вопросы к собеседованию, ч. 1
<p>----------------------------------------</p>
ля тех, кто впервые слышит слово Java Core — это фундаментальные основы языка. С этими знаниями уже смело можно идти на стажировку/интернатуру. Приведенные вопросы помогут вам освежить знания перед собеседованием, или почерпнуть для себя что-то новое ...
<p>----------------------------------------</p>
Для тех, кто впервые слышит слово Java Core — это фундаментальные основы языка. С этими знаниями уже смело можно идти на стажировку/интернатуру.

<img data-id="0b093b06-fd08-4a1e-ac64-27de5ce85159" data-max-width="850" alt="Java Core. Вопросы к собеседованию, ч. 1 - 1" src="https://cdn.javarush.com/images/article/0b093b06-fd08-4a1e-ac64-27de5ce85159/1024.jpeg">Приведенные вопросы помогут вам освежить знания перед собеседованием, или почерпнуть для себя что-то новое. Для получения практических навыков занимайтесь на <a href="https://javarush.com/" target="_blank">JavaRush</a>.
<ol><li><p><strong>Как создать неизменяемый объект в Java? Перечислите все преимущества</strong></p>
<p>Неизменяемый класс – это класс, состояние которого не может быть изменено после создания. Здесь состоянием объекта по существу считаются значения, хранимые в экземпляре класса, будь то примитивные типы или ссылочные типы.</p>

<p>Для того чтобы сделать класс неизменяемым, необходимо выполнить следующие условия:</p>
<ol>
    <li>Не предоставляйте сеттеры или методы, которые изменяют поля или объекты, ссылающиеся на поля. Сеттеры подразумевают изменение состояния объекта а это то, чего мы хотим тут избежать.</li>
    <li>Сделайте все поля <code>final</code> и <code>private</code>. Поля, обозначенные <code>private</code>, будут недоступными снаружи класса, а обозначение их <code>final</code> гарантирует, что вы не измените их даже случайно.</li>
    <li>Не разрешайте субклассам переопределять методы. Самый простой способ это сделать – объявить класс как <code>final</code>. Финализированные классы в Java не могут быть переопределены.</li>
    <li>Всегда помните, что ваши экземпляры переменных могут быть либо изменяемыми, либо неизменяемыми. Определите их и возвращайте новые объекты со скопированным содержимым для всех изменяемых объектов (ссылочные типы). Неизменяемые переменные (примитивные типы) могут быть безопасно возвращены без дополнительных усилий.</li>
</ol>
<p>Также, вам необходимо помнить последующие преимущества неизменяемых классов. Возможно они понадобятся вас на собеседовании. Неизменяемые классы:</p>
<ul>
    <li>легко конструировать, тестировать и использовать</li>
    <li>автоматически потокобезопасны и не имеют проблем синхронизации</li>
    <li>не требуют конструктора копирования</li>
    <li>позволяют выполнить «ленивую инициализацию» хэшкода и кэшировать возвращаемое значение</li>
    <li>не требуют защищенного копирования, когда используются как поле</li>
    <li>делают хорошие <code>Map</code> ключи и <code>Set</code> элементы (эти объекты не должны менять состояние, когда находятся в коллекции)</li>
    <li>делают свой класс постоянным, единожды создав его, а он не нуждается в повторной проверке</li>
    <li>всегда имеют «атомарность по отношению к сбою» (failure atomicity, термин применил Джошуа Блох): если неизменяемый объект бросает исключение, он никогда не останется в нежелательном или неопределенном состоянии.</li>
</ul><p>Посмотрите на пример, написанный в <a href="https://howtodoinjava.com/java/basics/how-to-make-a-java-class-immutable/" rel="nofollow" target="_blank">этом посте</a>.</p></li>
<li><p><strong>В Java передача по значению или по ссылке?</strong></p>
<p>Java спецификация гласит, что все в Java передается по значению. Нет такого понятия, как «передача по ссылке» в Java. Эти условия связаны с вызовом методов и передачей переменных, как параметров метода. Хорошо, примитивные типы всегда передаются по значению без какой-либо путаницы. Но, концепция должна быть понятна в контексте параметра метода сложных типов.</p>

<p>В Java, когда мы передает ссылку сложного типа как любой параметр метода, всегда адрес памяти копируется в новую ссылочную переменную шаг за шагом. Посмотрите на изображение:</p>
<img data-id="d2e6c1a0-7c9c-4b64-904c-f88dcfc77b09" data-max-width="570" alt="Java Core. Вопросы к собеседованию, ч. 1 - 2" src="https://cdn.javarush.com/images/article/d2e6c1a0-7c9c-4b64-904c-f88dcfc77b09/1024.jpeg"><p>В приведенном примере, биты адреса первого экземпляра копируются другой ссылочной переменной, в результате чего обе ссылки указывают на один участок памяти, где хранится объект. Помните, что присвоив второй ссылке null, вы не присвоите null первой ссылке. Но изменение состояния объекта с одной ссылающейся переменной, будет отображено и в другой ссылке.</p>

<p>Подробности смотрите <a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" rel="nofollow" target="_blank">тут</a>.</p></li>
<li><p><strong>Какое применение блока <code>finally</code>? Гарантирует этот блок выполнение своего кода? Когда <code>finally</code> блок не вызывается?</strong></p>
<p>Блок <code>finally</code> всегда вызывается, если блок <code>try</code> существует. Это гарантирует, что блок <code>finally</code> вызывается даже, если случается неожиданное исключение. Но <code>finally</code> является более полезным, чем просто для обработки исключений – этот блок позволяет выполнить чистку кода, случайно обошедшего через <code>return</code>, <code>continue</code> или <code>break</code>. Размещение очищающего кода в блок <code>finally</code> всегда является хорошей практикой, даже когда не ожидается никаких исключений.</p>

<p>Если виртуальная машина завершает работу во время выполнения блока <code>try</code> или <code>catch</code>, тогда блок <code>finally</code> не будет выполнен. Аналогично, если нить, выполняя блок <code>try</code> или <code>catch</code>, будет прервана или убита, блок <code>finally</code> не будет выполнен, даже не смотря на то, что приложение продолжает работать.</p></li>
<li><p><strong>Почему существует два класса <code>Date</code>, один в <code>java.util package</code> а другой в <code>java.sql</code>?</strong></p><p><code>java.util.Date</code> представляет дату и время, а  <code>java.sql.Date</code> представляет только дату. Дополнением к <code>java.sql.Date</code> является класс <code>java.sql.Time</code>, который представляет только время.</p>

<p>Класс <code>java.sql.Date</code> является субклассом (расширением) класса <code>java.util.Date</code>. Итак, что изменилось в <code>java.sql.Date</code>:</p>
<ul>
    <li><code>toString()</code> формирует другое представление строки: yyyy-mm-dd</li>
    <li>статический метод <code>valueOf(String)</code> создает дату из строки с вышеуказанным представлением</li>
    <li>исключены геттеры и сеттеры для часов, минут и секунд</li>
</ul><p>Класс <code>java.sql.Date</code> используется в JDBC и предназначен, чтобы не иметь составляющую времени, то есть часы, минуты, секунды и миллисекунды должны быть нулю… но это не является обязательным для класса.</p></li>
<li><p><strong>Разъясните интерфейсы-маркеры.</strong></p>
<p>Шаблон интерфейса-маркера – это шаблон проектирования в компьютерных науках, используемый языками программирования, которые <strong>предоставляют информацию об объектах во время выполнения</strong>. Это <strong>предоставляет способ ассоциации метаданных класса, где язык не имеет явной поддержки таких метаданных</strong>. В Java для этого используются интерфейсы без указания методов.</p>

<p>Хорошим примером применения интерфейса-маркера в Java является интерфейс <code>Serializable</code>. Класс реализует этот интерфейс для указания, что его не <code>transient</code> данные могут быть записаны в поток байтов или на файловую систему.</p>

<p><em>Главной проблемой</em> интерфейса-маркера является то, что интерфейс определяет соглашение для реализующих его классов, и это соглашение наследуется всеми субклассами. Это значит, что вы не сможете «де-реализовать» маркер. В приведенном примере, если вы создадите субкласс, который вы бы не хотели сериализовать (возможно потому, что он находится в преходящем (transient) состоянии), вы должны прибегнуть к явному бросанию <code>NotSerializableException</code>.</p></li>
<li><p><strong>Почему метод <code>main()</code> объявлен как <code>public static void</code>?</strong></p>
<p><em>Почему public?</em> Метод <code>main</code> имеет модификатор доступа <code>public</code>, поэтому он может быть доступен везде и для любого объекта, который захочет использовать этот метод для запуска приложения. Тут я не говорю, что JDK/JRE имеют подобный повод, поскольку java.exe или javaw.exe (для windows) используют Java Native Interface (JNI) вызов для запуска метода, поэтому они могут вызвать его в любом случае, независимо от модификатора доступа.</p>

<p><em>Почему static?</em> Давайте предположим, что у нас метод <code>main</code> не статический. Теперь, для вызова любого метода вам необходим экземпляр класса. Верно? Java разрешает иметь перегруженные конструкторы, это мы все знаем. Тогда который из них должен быть использован, и откуда возьмутся параметры для перегруженного конструктора?</p>

<p><em>Почему void?</em> Нет применения для возвращаемого значения в виртуальной машине, которая фактически вызывает этот метод. Единственное, что приложение захочет сообщить вызвавшему процессу – это нормальное или ненормальное завершение. Это уже возможно используя <code>System.exit(int)</code>. Не нулевое значение подразумевает ненормальное завершение, иначе все в порядке.</p></li>
<li><p><strong>В чем разница между созданием строки как <code>new()</code> и литералом (при помощи двойных кавычек)?</strong></p>
<p>Когда мы создаем строку используя <code>new()</code>, она создается в хипе и также добавляется в пул строк, в то же время строка, созданная при помощи литерала, создается только в пуле строк.</p>

<p>Вам необходимо ознакомиться с понятием пула строк глубже, чтобы ответить на этот или подобные вопросы. Мой совет – как следует выучите <a href="https://howtodoinjava.com/interview-questions/interview-stuff-about-string-class-in-java/" rel="nofollow" target="_blank">класс String и пул строк</a>.</p>
<table>
<tbody><tr>
<td>
У нас в переводах уже есть хорошая статья о строках и строковом пуле: <a href="https://javarush.com/groups/posts/759-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch1" target="_blank">Часть 1</a>, <a href="https://javarush.com/groups/posts/760-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch2" target="_blank">Часть 2</a>.
</td>
</tr>
</tbody></table></li><li><p><strong>Как работает метод <code>substring()</code> класса <code>String</code>?</strong></p>
<p>Как и в других языках программирования, строки в Java являются последовательностью символов. Этот класс больше похож на служебный класс для работы с этой последовательностью. Последовательность символов обеспечивается следующей переменной:</p>

<pre class="lang-java line-numbers"><code>
/** The value is used for character storage. */ 
/** Значение используется для хранения символов */
private final char value[];</code>
Для доступа к этому массиву в различных сценариях используются следующие переменные
<code>/** The offset is the first index of the storage that is used. */
/** Смещение – это первый индекс используемого хранилища. */
private final int offset;

/** The count is the number of characters in the String. */
/** Счет – это количество символов в строке. */
private final int count;
</code></pre>
<p>Каждый раз, когда мы создаем подстроку от существующего экземпляра строки, метод <code>substring()</code> только устанавливает новые значения переменных <code>offset</code> и <code>count</code>. Внутренний массив символов не изменяется. Это возможный источник утечки памяти, если метод <code>substring()</code> использовать неосторожно:</p>

<p>Первоначальное значение <code>value[]</code> не изменяется. Поэтому если вы создадите строку длиной 10000 символов и создадите 100 подстрок с 5-10 символами в каждой, все 101 объекты будут содержать один и тот же символьный массив длиной 10000 символов. Это без сомнения расточительство памяти.</p>

<p>Этого можно избежать, изменив код следующим образом:</p>

<p>заменить <code><strong>original.substring(beginIndex)</strong></code> на <code><strong>new String(original.substring(beginIndex))</strong></code>, 
где <code>original</code> – исходная строка.</p>
<table>
<tbody><tr>
<td>Примечание переводчика: я затрудняюсь сказать к какой версии Java это применимо, но на данный момент в Java 7 этот пункт статьи не актуален. Метод <code>substring()</code> вызывает конструктор класса <code>new String(value, beginIndex, subLen)</code>, который в свою очередь обращается к методу <code>Arrays.copyOfRange(value, offset, offset+count)</code>. Это значит, что у нас будет каждый раз новое значение переменной <code>value[]</code>, содержащее наше новое количество символов.
</td>
</tr>
</tbody></table></li><li><p><strong>Объясните работу <code>HashMap</code>. Как решена проблема дубликатов?</strong></p><p>Большинство из вас наверняка согласится, что <code>HashMap</code> наиболее любимая тема для дискуссий на интервью в настоящее время. Если кто-нибудь попросит меня рассказать «Как работает <code>HashMap</code>?», я просто отвечу: «По принципу хэширования». Так просто, как это есть.</p>

<p>Итак, хеширование по сути является способом назначить уникальный код для любой переменной/объекта после применения любой формулы/алгоритма к своим свойствам.</p>

<p>Определение карты (<code>Map</code>) таково: «Объект, который привязывает ключи к значениям». Очень просто, верно? Итак, <code>HashMap</code> содержит собственный внутренний класс <code>Entry</code>, который имеет вид:</p>

<pre class="lang-java line-numbers"><code>
static class Entry implements Map.Entry
{
final K key;
V value;
Entry next;
final int hash;
…//More code goes here
}
</code></pre>
<p>Когда кто-либо пытается поместить пару ключ-значение в <code>HashMap</code>, происходит следующее:</p>
<ul>
    <li>В первую очередь, объект ключа проверяется на <code>null</code>. Если ключ <code>null</code>, значение сохраняется в позицию <code>table[0]</code>. Потому что хэшкод для <code>null</code> всегда 0.</li>
    <li>Затем, следующим шагом вычисляется хэш значение вызывая у переменной-ключа свой метод <code>hashCode()</code>. Этот хэш используется для вычисления индекса в массиве для хранение объекта <code>Entry</code>. Разработчики JDK прекрасно понимали, что метод <code>hashCode()</code> может быть плохо написан и может возвращать очень большое или очень маленькое значение. Для решения этой проблемы они ввели другой <code>hash()</code> метод, и передают хэшкод объекта этому методу для приведения этого значения к диапазону размера индекса массива.</li>
    <li>Теперь вызывается метод <code>indexFor(hash, table.length)</code> для вычисления точной позиции для хранения объекта <code>Entry</code>.</li>
    <li>Теперь главная часть. Как мы знаем, два неодинаковых объекта могут иметь одинаковое значение хэшкода, как два разных объекта будет храниться в одинаковом расположении в архиве [называется корзиной]?</li>
</ul><p>Ответ – <code>LinkedList</code>. Если вы помните, класс <code>Entry</code> имеет свойство “next”. Это свойство всегда указывает на следующий объект в цепи. Такое поведение очень похоже на <code>LinkedList</code>.</p>

<p>Итак, в случае совпадений хэшкодов, объекты Entry хранятся в форме <code>LinkedList</code>. Когда объект <code>Entry</code> необходимо разместить на конкретном индексе, <code>HashMap</code> проверяет, существует ли на этом месте другой объект <code>Entry</code>? Если там нет записи, наш объект сохранится в этом месте.</p>

<p>Если на нашем индексе уже находится другой объект, проверяется его поле <code>next</code>. Если оно равно <code>null</code>, наш объект становится следующим узлом в <code>LinkedList</code>. Если next не равно <code>null</code>, эта процедура повторяется, пока не будет найдено поле <code>next</code> равное <code>null</code>.</p>

<p>Что будет, если мы добавим другое значение ключа, равное добавленному ранее? Логично, что оно должно заменить старое значение. Как это происходит? После определения индекса позиции для объекта <code>Entry</code>, пробегая по <code>LinkedList</code>, расположенному на нашем индексе, <code>HashMap</code> вызывает метод <code>equals()</code> для значения ключа для каждого объекта <code>Entry</code>. Все эти объекты <code>Entry</code> в <code>LinkedList</code> имеют одинаковое значение хэшкода, но метод <code>equals()</code> будет проверять на настоящее равенство. Если ключ.<code>equals(k)</code> будет <em>true</em>, тогда оба будут восприниматься как одинаковый объект. Это вызовет замену только объекта-значение внутри объекта <code>Entry</code>.</p>

<p>Таким образом <code>HashMap</code> обеспечивает уникальность ключей.</p></li>
<li><p><strong>Различия между интерфейсами и абстрактными классами?</strong></p>
<p>Это очень распространенный вопрос, если вы проходите собеседование на программиста уровня junior. Наиболее значимые различия приведены ниже:</p>
<ul>
    <li>В интерфейсах Java переменные априори <code>final</code>. Абстрактные классы могут содержать не <code>final</code> переменные.</li>
    <li>Интерфейс в Java безоговорочно не может иметь реализации. Абстрактный класс может иметь экземпляры методов, которые реализуют базовое поведение.</li>
    <li>Составляющие интерфейса должны быть <code>public</code>. Абстрактный класс может иметь модификаторы доступа на любой вкус.</li>
    <li>Интерфейс должен быть реализован ключевым словом <code>implements</code>. Абстрактный класс должен быть расширен при помощи ключевого слова <em>extends</em>.</li>
    <li>В Java класс может реализовывать множество интерфейсов, но может унаследоваться только от одного абстрактного класса.</li>
    <li>Интерфейс полностью абстрактный и не может иметь экземпляров. Абстрактный класс также не может иметь экземпляров класса, но может быть вызван, если существует метод <code>main()</code>.</li>
    <li>Абстрактный класс слегка быстрее интерфейса, потому что интерфейс предполагает поиск перед вызовом любого переопределенного метода в Java. В большинстве случаев это незначительное различие, но если вы пишите критичное по времени приложение, вам необходимо учесть и этот факт.</li>
</ul></li><div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><li><p><strong>Когда вы переопределяете методы <code>hashCode()</code> и <code>equals()</code>?</strong></p><p>Методы <code>hashCode()</code> и <code>equals()</code> определены у класса <code>Object</code>, который является родительским классом для всех объектов Java. По этой причине, все объекты Java наследуют базовую реализацию этих методов.</p>

<p>Метод <code>hashCode()</code> используется для получения уникального значения integer для данного объекта. Это значение используется для определения расположения корзины, когда объект необходимо хранить в структуре данных наподобие <code>HashTable</code>. По умолчанию метод <code>hashCode()</code> возвращает целочисленное представление адреса памяти, где хранится объект.</p>

<p>Метод <code>equals()</code>, как предполагает название, используется для простой эквивалентности объектов. Базовая реализация метода заключается в проверке ссылок двух объектов для проверки их эквивалентности.</p>

<p>Обратите внимание, что обычно необходимо переопределять метод <code>hashCode()</code> всякий раз, когда переопределен метод <code>equals()</code>. Это необходимо для поддержки общего соглашения метода <code>hashCode</code>, в котором говорится что равные объекты должны иметь равные хэшкоды.</p>

<p>Метод equals() должен определять равенство отношений (он должен быть возвратным, симметричным и транзитивным). В дополнение, он должен быть устойчивым (если объект не изменялся, метод должен возвращать то же самое значение). Кроме того, <code>o.equals(null)</code> всегда должно возвращать <em>false</em>.</p>

<p><code>hashCode()</code> должен быть также устойчивым (если объект не изменялся по условиям метода <code>equals()</code>, он должен продолжать возвращать то же самое значение.</p>

<p>Отношение между двумя методами такое: всегда, если <code>a.equals(b)</code>, тогда <code>a.hashCode()</code> должно быть таким же, как и <code>b.hashCode()</code>.</p></li></ol><em>Удачи в обучении!!</em>
<em>Автор статьи <a href="https://plus.google.com/+LokeshGupta" rel="nofollow" target="_blank">Lokesh Gupta</a></em>
<em><a href="https://howtodoinjava.com/interview-questions/core-java-interview-questions-series-part-1/" rel="nofollow" target="_blank">Оригинал статьи</a></em>

Ссылки на остальные части:
<a href="https://javarush.com/groups/posts/764-java-core-voprosih-k-sobesedovaniju-ch-2" target="_blank">Java Core. Вопросы к собеседованию, ч. 2</a>
<a href="https://javarush.com/groups/posts/780-java-core-voprosih-k-sobesedovaniju-ch-3" target="_blank">Java Core. Вопросы к собеседованию, ч. 3</a>