Уровень 25. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
Назовите все состояния объекта Thread? NEW, RUNNABLE,  BLOCKED, WAITING, TIMED_WAITING, TERMINATED.  В какие состояния может перейти нить, при входе в блок synchronized? RUNNABLE, BLOCKED ...
<p>----------------------------------------</p>

<img data-id="c8d74bcb-483d-446b-9898-88ff8b9d2cea" data-max-width="850" alt="Уровень 25. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/c8d74bcb-483d-446b-9898-88ff8b9d2cea/1024.jpeg"><ol>
<li><p><strong>Назовите все состояния объекта <code>Thread</code>?</strong></p>
<ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>BLOCKED</li>
<li>WAITING</li>
<li>TIMED_WAITING</li>
<li>TERMINATED</li></ul></li>
<li><p><strong>В какие состояния может перейти нить, при входе в блок <code>synchronized</code>?</strong></p>
<ul>
<li>RUNNABLE</li>
<li>BLOCKED</li>
</ul><p>В RUNNABLE, если блок кода, помеченный <code>synchronized</code>, не занят другой нитью. Иначе наша нить получит состояние BLOCKED и будет ждать освобождения объекта-мютекса.</p></li>
<li><strong>В какое состояние перейдет нить, при вызове метода <code>wait()</code>?</strong></p>
<p>Вызов этого метода переводит нить в состояние WAITING.<br />
Метод <code>wait()</code> можно вызвать только внутри блока <code>synchronized</code> у объекта-мютекса, который был «залочен (заблокирован)» текущей нитью, в противном случае метод выкинет исключение <em>IllegalMonitorStateException</em>.<br />
<pre class='lang-java line-numbers'><code>
Object monitor = getMonitor();
synchronized(monitor)
{
 …
 monitor.wait();
 …
}
</code></pre><br />
При вызове метода <code>wait()</code>, текущая нить снимает блокировку с объекта <code>monitor</code>, и переходит в состояние WAITING, ожидая вызова метода <code>monitor.notify()</code> или <code>monitor.notifyAll()</code> другой нитью. Как только это произойдет, нить проснется и если монитор не был занят, то захватит его и продолжит работу.<br />
Если монитор окажется занят другой нитью, текущая нить перейдет в состояние BLOCKED.</p></li>
<li><p><strong>В какое состояние перейдет нить, при вызове метода <code>wait(500)</code>?</strong></p>
Вызов этого метода переводит нить в состояние TIMED_WAITING.<br />
По аналогии с методом <code>wait()</code>, <code>wait(timeout)</code> можно вызвать только внутри блока <code>synchronized</code> у объекта-мютекса, который был «залочен (заблокирован)» текущей нитью.</p>
<pre class='lang-java line-numbers'><code>
Object monitor = getMonitor();
synchronized(monitor)
{
 …
 monitor.wait(500);
 …
}
</code></pre><br />
<p>При вызове метода <code>wait()</code>, текущая нить снимает блокировку с объекта <code>monitor</code>, и засыпает на 500 миллисекунд. Объект <code>monitor</code> может быть захвачен другой нитью.<br />
Через 500 миллисекунд нить проснется и если <code>monitor</code> не был занят, то захватит его и продолжит работу.<br />
Если монитор окажется занят другой нитью, текущая нить перейдет в состояние BLOCKED.</p>
<p><strong>В какое состояние перейдет нить, при вызове метода <code>notify()</code>?</strong></p>
<pre class='lang-java line-numbers'><code>
Object monitor = getMonitor();
synchronized(monitor)
{
 …
 monitor.wait();
 …
}
</code></pre><br />
После  <code>monitor.wait()</code>, нить перейдет в состояние WAITING. Метод <code>notify()</code>, вызванный другой нитью у объекта <code>monitor</code> переведет нить из состояния WAITING в состояние RUNNABLE, если объект monitor не будет захвачен другой нитью, иначе в состояние BLOCKED.</p></li>
<li><p><strong>В какое состояние перейдет нить, при вызове метода <code>notifyAll()</code>?</strong></p>
<code>notifyAll()</code> "пробудет" все нити. Одна из всех "спящих" (WAITING) нитей перейдет в состояние RUNNABLE, захватит монитор используемого объекта и продолжит свою работу. Остальные окажутся в состоянии BLOCKED. Как только первая "проснувшаяся" нить отпустит монитор, который все остальные ожидают, её участь повторит следующая нить (произвольная нить из состояния BLOCKED перейдет в состояние RUNNABLE). Это будет продолжаться до тех пор, пока все "пробужденные" нити не покинут состояния BLOCKED.</p></li>
<li><p><strong>Три нити в блоке synchronized вызвали <code>wait()</code> у объекта-мютекса. В какое состояние перейдут эти нити, если четвертая нить вызовет <code>notifyAll()</code>?</strong></p>
Две из них перейдут в состояние BLOCKED, одна в состояние RUNNABLE</p></li>
<li><p><strong>Чем отличается <code>join(500)</code> от <code>wait(500)</code>?</strong></p>
Несмотря на то, что и <code>join(500)</code> и <code>wait(500)</code> переведут текущую нить в состояние TIMED_WAITING, между ними существенные различия:<br />
<code>join(500)</code> вызывается у нити, <code>wait(500)</code> вызывается внутри синхронизированного блока у объекта, по которому данный блок синхронизирован.<br />
При вызове <code>join(500)</code> текущая нить будет ожидать 500 миллисекунд завершения нити, чей метод <code>join()</code> был вызван. <br />
При вызове <code>wait(500)</code> текущая нить снимет блокировку с синхронизированного объекта, и засыпает на 500 миллисекунд. <br />
Через 500 миллисекунд  в обоих случаях нити продолжат работу.</p></li>
<li><p><strong>Чем отличается <code>wait(500)</code> от <code>sleep(500)</code>?</strong></p>
<code>sleep(500)</code> вызывается у нити, <code>wait(500)</code> вызывается внутри синхронизированного блока у объекта, по которому данный блок синхронизирован. <br />
При вызове <code>sleep(500)</code> текущая нить будет ожидать 500 милисекунд, затем продолжит свою работу.<br />
При вызове <code>wait(500)</code> текущая нить снимет блокировку с синхронизированного объекта, и засыпает на 500 миллисекунд. </p></li>
<li><p><strong>В какое состояние перейдет нить при вызове метода <code>yield()</code>?</strong></p>
При вызове метода <code>yield()</code> – текущая нить «пропускает свой ход» и java сразу переключается на выполнение следующей нити. Нить из состояния <code>running</code> переходит в состояние <code>ready</code>. Состояния running & ready – это подсостояния состояния RUNNABLE.</p></li></ol>
<strong>PS</strong> Комментарии, дополнения, исправления, замечания - приветствуются =)