Часто задаваемые на собеседованиях вопросы по классам коллекциям в Java (Часть 2)
<p>----------------------------------------</p>
Назовите различия между Set и List? Список ключевых различий: множества — неупорядоченные коллекции, тогда как списки — упорядоченные, где каждый элемент имеет индекс начинающийся с нуля...
<p>----------------------------------------</p>

<img data-id="488299e9-ba6c-425b-aefa-6695638f1641" data-max-width="850" alt="Часто задаваемые на собеседованиях вопросы по классам коллекциям в Java (Часть 2) - 1" src="https://cdn.javarush.com/images/article/488299e9-ba6c-425b-aefa-6695638f1641/1024.jpeg"><strong>Вопросы о различиях разных коллекций</strong><ol>
<li value="18">Назовите различия между <code>Set</code> и <code>List</code>?</li>
<li>Назовите различия между <code>List</code> и <code>Map</code>?</li>
<li>Назовите различия между <code>HashMap</code> и <code>HashTable?</code></li>
<li>Назовите различия между <code>Vector</code> и <code>ArrayList</code>?</li>
<li>Назовите различия между <code>Iterator</code> и <code>Enumeration</code>?</li>
<li>Назовите различия между <code>HashMap</code> и <code>HashSet</code>?</li>
<li>Назовите различия между <code>Iterator</code> и <code>ListIterator</code>?</li>
<li>Назовите различия между <code>TreeSet</code> и <code>SortedSet</code>?</li>
<li>Назовите различия между <code>ArrayList</code> и <code>LinkedList</code>?</li></ol><strong>И еще вопросы</strong><ol>
<li value="27">Как сделать коллекцию только для чтения?</li>
<li>Как сделать потокобезопасную коллекцию?</li>
<li>Почему не существует метода <code>Iterator.add()</code> для добавления элементов в коллекцию?</li>
<li>Какие существуют способы перебирать элементы списка?</li>
<li>Как вы понимаете работу свойства итератора <code>fail-fast</code>?</li>
<li>Какая разница между <code>fail-fast</code> и <code>fail-safe</code>?</li>
<li>Как избежать <code>ConcurrentModificationException</code> во время перебора коллекции?</li>
<li>Что такое <code>UnsupportedOperationException</code>?</li>
<li>Какие классы коллекций дают доступ к любому элементу?</li>
<li>Что такое <code>BlockingQueue</code>?</li>
<li>Что такое очередь и стэк, перечислите различия между ними?</li>
<li>Что такое интерфейсы <code>Comparable</code> и <code>Comparator</code>?</li>
<li>Что такое классы <code>Collections</code> и <code>Arrays</code>?</li>
<li>Список использованной литературы</li>
</ol>Не тратя зря время, приступим к объяснениям
<h2>Вопросы о различиях разных коллекций</h2><ol>
<li value="18"><p><strong>Назовите различия между <code>Set</code> и <code>List</code>?</strong></p>
<p>Список ключевых различий:<br />
Множества — неупорядоченные коллекции, тогда как списки — упорядоченные, где каждый элемент имеет индекс начинающийся с нуля. Списки могут содержать два и более одинаковых элемента, а множества не могут. В списке может содержаться сколько угодно элементов <code>null</code>, в множестве — только один.</p></li>
<li><p><strong>Назовите различия между <code>List</code> и <code>Map</code>?</strong></p>
<p>Самый легкий вопрос. Список это коллекция элементов, а словарь это коллекция пар ключ/значение. Есть еще множество изменений, но все они являются следствием данного. У них разный интерфейс верхнего уровня, разный набор методов и разные представления данных. В большинстве случаев достаточно только первого ответа.</p></li>
<li><p><strong>Назовите различия между <code>HashMap</code> и <code>HashTable</code>?</strong></p>
<p>Есть несколько различий между <code>HashMap</code> и <code>HashTable</code> в Java:
<ul>
    <li><code>HashTable</code> потокобезопасна, а <code>HashMap</code> нет</li>
    <li><code>HashTable</code> не может содержать элементы <code>null</code>, тогда как <code>HashMap</code> может содержать один ключ <code>null</code> и любое количество значений <code>null</code></li>
    <li>Третье ключевое отличие между ними — итератор у <code>HashMap</code>, в отличие от перечислителя <code>HashTable</code>, работает по принципу <code>fail-fast</code> (выдает исключение при любой несогласованности данных)</li></ul></p></li>
<li><p><strong>Назовите различия между <code>Vector</code> и <code>ArrayList</code>?</strong></p>
<p>Отметим некоторые различия:
<ul>
    <li>Все методы <code>Vector</code> потокобезопасны, а у <code>ArrayList</code> — нет</li>
    <li><code>Vector</code> это устаревший класс добавленный в первом релизе JDK. <code>ArrayList</code> появился в JDK 1.2, вместе с остальными классами фреймворка <code>Collection</code></li>
    <li>По умолчанию, <code>Vector</code> удваивает свой размер когда заканчивается выделенная под элементы память. <code>ArrayList</code> же увеличивает свой размер только на половину</li>
</ul></p></li>
<li><p><strong>Назовите различия между <code>Iterator</code> и <code>Enumeration</code>?</strong></p>
<p>Итераторы отличаются от перечислителей по трем признакам:
<ul>
    <li>Существуют итераторы, которые позволяют удалять элементы из своей коллекции во время перебора, с использованием метода <code>remove()</code>. Класс <code>Iterator</code> данного функционала не поддерживает. С помощью перечислителя нельзя добавлять/удалять элементы</li>
    <li>Перечислители присутствуют в устаревших классах, таких как <code>Vector/Stack</code>, тогда как итераторы есть во всех современных классах-коллекциях</li>
    <li>Еще небольшое отличие в том, что у итераторов и перечислителей различается наименование методов, то есть <code>Enumeration.hasMoreElements()</code> соответствует <code>Iterator.hasNext()</code> и<code> Enumeration.nextElement()</code> соответствует <code>Iterator.next()</code> и т.д.</li></ul></p></li>
<li><p><strong>Назовите различия между <code>HashMap</code> и <code>HashSet</code>?</strong>
<p><code>HashMap</code> — коллекция пар ключ/значение, тогда как <code>HashSet</code> это упорядоченная коллекция уникальных элементов. И это все, не требуется больше никаких объяснений.</p></li>
<li><p><strong>Назовите различия между <code>Iterator</code> и <code>ListIterator</code>?</strong></p>
<p>Есть три различия:
<ul>
    <li><code>Iterator</code> может использоваться для перебора элементов <code>Set</code>, <code>List</code> и <a href='https://javarush.com/groups/posts/763-9-glavnihkh-voprosov-o-map-v-java' target='_blank'>Map</a>. В отличие от него, <code>ListIterator</code> может быть использован только для перебора элементов коллекции <code>List</code></li>
    <li><code>Iterator</code> позволяет перебирать элементы только в одном направлении, при помощи метода <code>next()</code>. Тогда как <code>ListIterator</code> позволяет перебирать список в обоих направлениях, при помощи методов <code>next()</code> и <code>previous()</code></li>
    <li>При помощи <code>ListIterator</code> вы можете модифицировать список, добавляя/удаляя элементы с помощью методов <code>add()</code> и <code>remove()</code>. <code>Iterator</code> не поддерживает данного функционала</li></ul></p></li>
<li><p><strong>Назовите различия между TreeSet и SortedSet?</strong></p>
<p><code>SortedSet</code> это интерфейс, реализуемый классом <code>TreeSet</code>. Вот и все!</p></li>
<li><strong>Назовите различия между <code>ArrayList</code> и <code>LinkedList</code>?</strong><ul>
    <li><code>LinkedList</code> хранит элементы в двусвязном списке, тогда как <code>ArrayList</code> хранит их в массиве, размер которого может динамически меняться</li>
    <li><code>LinkedList</code> поддерживает добавление/удаление элементов за фиксированное время, но только последовательный доступ к элементам. То есть, вы можете перебрать список с начала в конец и с конца в начало, но получение элемента в середине списка займет время пропорциональное размеру списка. <code>ArrayList</code> же позволяет получить любой элемент по его индексу за фиксированное время. Но добавление/удаление элементов туда требует затрат времени пропорциональных размеру, потому что нужно подвинуть все элементы с места вставки/удаления и до конца списка, либо чтобы освободить место для вставляемого либо чтобы убрать пропуск на месте удаленного</li>
    <li><code>LinkedList</code> требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в <code>ArrayList</code> элементы просто идут по порядку</li>
</ul></li></ol><h2>И еще вопросы</h2><ol>
<li value="27"><p><strong>Как сделать коллекцию только для чтения?</strong></p>
<p>Используйте следующие методы:
<ul>
    <li><code>Collections.unmodifiableList(list)</code>;</li>
    <li><code>Collections.unmodifiableSet(set)</code>;</li>
    <li><code>Collections.unmodifiableMap(map)</code>;</li>
</ul><p>Все они принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.</p></li>
<li><p><strong>Как сделать потокобезопасную коллекцию?</strong></p>
<p>Используйте следующие методы:
<ul>
    <li><code>Collections.synchronizedList(list)</code>;</li>
    <li><code>Collections.synchronizedSet(set)</code>;</li>
    <li><code>Collections.synchronizedMap(map)</code>;</li>
</ul><p>Все они принимают коллекцию в качестве параметра, и возвращают потокобезопасную коллекцию с теми же элементами внутри.</p></li>
<li><p><strong>Почему не существует метода <code>Iterator.add()</code> для добавления элементов в коллекцию?</strong></p>
<p>Единственная задача итератора это перебор коллекции. Каждая коллекция имеет метод <code>add()</code> которым вы можете воспользоваться. Нет смысла добавлять этот метод в итератор, потому что коллекции могут быть упорядоченными и неупорядоченными, и метод <code>add()</code> при этом должен быть устроен по разному.</p></li>
<li><p><strong>Какие существуют способы перебирать элементы списка?</strong></p>
<p>Есть 4 способа:
<ul>
    <li>Цикл с итератором</li>
    <li>Цикл <code>for</code></li>
    <li>Расширенный цикл for</li>
    <li>Цикл <code>while</code></li>
</ul>
Читайте <a href='http://www.mkyong.com/java/how-do-loop-iterate-a-list-in-java/' rel='nofollow' target='_blank'>статью</a>.</p></li>
<li><p>Как вы понимаете работу свойства итератора <code>fail-fast</code>?</p>
<p>Итератор <code>fail-fast</code> вызывает исключение сразу как обнаружит что структура коллекции была изменена после начала перебора. Под изменением структуры мы понимаем добавление/удаление/изменение элемента коллекции, в то время как другой поток перебирает эту коллекцию.</p></li>
<li><p><strong>Какая разница между <code>fail-fast</code> и <code>fail-safe</code>?</strong></p>
<p>В противоположность <code>fail-fast</code>, итераторы <code>fail-safe</code> не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.</p>
<p>Итератор коллекции <code>CopyOnWriteArrayList</code> и итератор представления <code>keySet</code> коллекции <code>ConcurrentHashMap</code> являются примерами итераторов <code>fail-safe</code>.</p></li>
<li><p><strong>Как избежать <code>ConcurrentModificationException</code> во время перебора коллекции?</strong></p>
<p>Первым делом, можно подобрать другой итератор, работающий по принципу <code>fail-safe</code>. К примеру, если вы используете <code>List</code>, то можете взять <code>ListIterator</code>. Если же вам нужна устаревшая коллекция — то используйте перечислители.</p>
<p>В том случае, когда вышеизложенное вам не подходит, у вас есть три варианта:
<ul>
    <li>При использовании JDK 1.5 или выше, вам подойдут классы <code>ConcurrentHashMap</code> и <code>CopyOnWriteArrayList</code>. Это самый лучший вариант</li>
    <li>Вы можете преобразовать список в массив и перебирать массив</li>
    <li>Вы можете блокировать изменения списка на время перебора с помощью блока <code>synchronized</code></li></ul><p>Обратите внимание, что последние два варианта негативно скажутся на производительности.</p></li>
<li><p><strong>Что такое <code>UnsupportedOperationException</code>?</strong></p>
<p>Это исключение возникает при вызове метода, который не поддерживается данной коллекцией. К примеру, если вы создадите список только для чтения с помощью <code>Collections.unmodifiableList(list)</code>, а потом у него вызовете метод <code>add()</code> или <code>remove()</code>, вы точно получите это исключение.</p></li>
<li><p><strong>Какие классы коллекций позволяют доступ к любому элементу?</strong></p>
<p>Классы <code>ArrayList</code>, <code>HashMap</code>, <code>TreeMap</code>, <code>Hashtable</code> позволяют доступ к любому элементу.</p></li>
<li><p><strong>Что такое <code>BlockingQueue</code>?</strong></p>
<p>Это очередь, которая позволяет обрабатывать ситуации, когда из пустой очереди пытаются получить элемент, или когда пытаются добавить элемент в очередь, а место в ней закончилось. Методы блокирующей очереди могут быть четырех типов: Первые вызывают исключение, вторые возвращают специальные значения (<code>null</code> или <code>false</code>, в зависимости от операции), третьи блокируют текущий поток до тех пор пока операция не может быть выполнена, и четвертые блокируют поток только на определенный промежуток времени.</p>
<p>Примеры можно посмотреть в этой <a href='https://howtodoinjava.com/java/multi-threading/how-to-use-blockingqueue-and-threadpoolexecutor-in-java/' rel='nofollow' target='_blank'>статье</a>.</p></li>
<li><p><strong>Что такое очередь и стэк, перечислите разницу между ними?</strong></p>
<p>Коллекции, созданные для того чтобы хранить элементы для дальнейшей обработки. Кроме базовых операций интерфейса <code>Collection</code>, очереди поддерживают дополнительные операции добавления, удаления и проверки состояния элемента. Обычно, но не обязательно очереди работают по принципу FIFO — первым пришел, первым ушел. Стэк — почти как очередь, но работает по принципу LIFO — последним пришел, первым ушел.</p>
Независимо от порядка добавления/удаления, голова очереди это элемент, который будет удален при вызове методов <code>remove()</code> или <code>poll()</code>. Также обратите внимание на то, что <code>Stack</code> и <code>Vector</code> оба потокобезопасны.</p>
<p><strong>Использование:</strong> Используйте очередь если вы хотите обрабатывать поток элементов в том же порядке в котором они поступают. Хорошо для списка заданий и обработки запросов. Используйте стэк если вы хотите класть и удалять элементы только с вершины стэка, что полезно в рекурсивных алгоритмах.</p>
<p>(А теперь отвлечемся и объясним все чуть иначе. Итак, представьте обойму автомата. Вы вставляете туда патроны по одному, только с одного конца. И с этого же конца, по одному их будет забирать затворный механизм при стрельбе. Это — стэк, положить элемент можно только на его вершину, снять оттуда же и больше ниоткуда. Последний положенный элемент будет снят первым.</p>
<p>Очередь — как трубка, в которую вы можете закатывать шарики, и с другого конца их забирать. Очередь позволяет класть элементы только в свой хвост, а забирать только с головы. Тот элемент который был первым положен, первым же будет и забран. </p>
<p>Общее у очереди и стэка только то, что у них обоих есть фиксированное место куда можно положить элемент, и фиксированное место откуда его можно забрать - все остальные элементы недоступны.(Прим. пер.))</p></li>
<li><p><strong>Что такое интерфейсы <code>Comparable</code> и <code>Comparator</code>?</strong></p>
<p>В Java, все коллекции поддерживающие автоматическую сортировку, используют методы сравнения для того чтобы правильно рассортировать элементы. В качестве примера таких классов мы можем указать <code>TreeSet</code>, <code>TreeMap</codE> и т.д. Для того чтобы рассортировать элементы, класс должен реализовать интерфейсы <code>Comparator</code> или <code>Comparable</code>. Именно поэтому классы-обертки как <code>Integer</code>, <code>Double</code> и <code>String</code> реализуют интерфейс <code>Comparable</code>. Интерфейс <code>Comparable</code> помогает сохранять естественную сортировку, тогда как <code>Comparator</code> позволяет сортировать элементы по разным особым шаблонам. Экземпляр компаратора обычно передается конструктору коллекции, если коллекция это поддерживает.</p>
<p>(Снова объясняю по другому. Интерфейс <code>Comparator</code> описывает метод  <code>int compare(T o1, T o2)</code>, то есть объект реализующий этот интерфейс может быть использован для сравнения двух других объектов одного класса. Если данный метод вернет 0 — объекты равны, +1 и -1 говорят о том что первый объект "больше" второго или наоборот. Какой смысл вы вложите в понятие "больше" и "меньше" применительно к вашим объектам — исключительно ваше дело. То есть — вы описываете класс, реализующий интерфейс <code>Сomparator</code>, и в данном методе определяете как вы хотите сравнивать ваши объекты. Потом передаете объект этого класса конструктору коллекции, в которой хранятся объекты сравниваемые данным методом, и коллекция сможет их сортировать по возрастанию/убыванию. Повторяю — у вас есть коллекция в которой хранятся объекты класса T, и есть еще один объект, другого класса, реализующего интерфейс <code>Comparator</code>, вся суть которого в том что он умеет сравнивать эти объекты класса <code>T</code>, больше он ни для чего не нужен.</p>
<p>Интерфейс <code>Comparable</code> описывает метод <code>int compareTo(T o)</code>, то есть вызывается он не для сравнения двух других объектов, а для сравнения себя самого с кем-то еще. То есть, вам не нужен отдельный объект-сравниватель, вы закладываете механизм сравнения в сам элемент хранящийся в коллекции. Что и в какой ситуации удобнее – решать вам.(Прим. пер.))</p></li>
<li><strong>Что такое классы <code>Collections</code> и <code>Arrays</code>?</strong></p>
<p>Классы <code>Collections</code> и <code>Arrays</code> это специальные служебные классы, для работы с классами-коллекциями. Они позволяют преобразовывать коллекции, делать их защищенными от записи или потокобезопасными, сортировать их разными способами и т.д.</p></li>
<li><strong>Список использованной литературы</strong></p>
<p>Ну, это не вопрос для собеседования. Чисто по приколу. (Но для достижения нирваны вы должны читать как можно больше статей, ваши волосы станут шелковистыми и вьющимися и карма очистится.(Прим. пер.))</p></li></ol>Надеюсь эти вопросы помогут вам на следующем собеседовании. В дальнейшем, я советую вам почитать что-нибудь дополнительно. Чем больше вы знаете, тем вам лучше!

Хорошей учебы!

<a href='https://howtodoinjava.com/interview-questions/useful-java-collection-interview-questions/#difference_set_and_list' rel='nofollow' target='_blank'><em>Оригинал статьи</em></a>