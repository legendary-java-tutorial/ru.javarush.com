Java-задачи с подвохом: привет, собеседования!
<p>----------------------------------------</p>
Для студентов JavaRush задачи по программированию, Java и валидатор — лучшие друзья. Тем не менее, у каждого падавана-разработчика наступает момент, когда нужно начинать иногда сходить с проторенной дорожки, придумывать себе мини-проекты и готовиться к ...
<p>----------------------------------------</p>
Для студентов <a href="https://javarush.com" target="_blank">JavaRush</a> задачи по программированию, Java и валидатор — лучшие друзья. Тем не менее, у каждого падавана-разработчика наступает момент, когда нужно начинать иногда сходить с проторенной дорожки, придумывать себе мини-проекты и готовиться к собеседованиям. На интервью, казалось бы, должны встречаться точно такие же практические задачи по Java, что и в курсе. В большинстве случаев так и есть, но некоторые компании любят задавать вопросы с подвохом или что-то непривычное. Чтобы не быть сбитым с толку в стрессовый момент собеседования, полезно пробовать решать такие Java-задачи самостоятельно, в домашних условиях.  
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="a812ac48-7f2b-4e60-9cbd-dbd82a38dcb7" data-max-width="710" alt="Java-задачи с подвохом: привет, собеседования! - 1" src="https://cdn.javarush.com/images/article/a812ac48-7f2b-4e60-9cbd-dbd82a38dcb7/1024.jpeg"></div></div>В этой статье мы рассмотрим полдесятка таких хитрых задач. Рекомендуем сначала прочитать условие и попробовать решить самостоятельно. И ещё: не забывайте решать задачи по Java из курса каждый день!  
<ul>
<li><a href="https://javarush.com/groups/posts/549-java-zadachi-s-podvokhom-privet-sobesedovanija#zadacha1">Задача-1: Создание бесконечного цикла на пустом месте</a></li>
<li><a href="https://javarush.com/groups/posts/549-java-zadachi-s-podvokhom-privet-sobesedovanija#zadacha2">Задача-2. Создайте комментарий, который будет выполнятся</a></li>
<li><a href="https://javarush.com/groups/posts/549-java-zadachi-s-podvokhom-privet-sobesedovanija#zadacha3">Задача-3: создать именованный цикл</a></li>
<li><a href="https://javarush.com/groups/posts/549-java-zadachi-s-podvokhom-privet-sobesedovanija#zadacha4">Задача-4. О единственном дубликате в массиве целых чисел</a></li>
<li><a href="https://javarush.com/groups/posts/549-java-zadachi-s-podvokhom-privet-sobesedovanija#zadacha5">Задача-5. О неединственном дубликате в массиве целых чисел</a></li>
</ul><h2 id="zadacha1">Задача по Java - 1: Создание бесконечного цикла на пустом месте</h2>Дан блок кода. Дополните его так, чтобы цикл стал бесконечным.  

<pre class="lang-java line-numbers"><code>
class ToInfinity {
    public static void main(String[] args) {

//впишите код сюда

        for (int i = start; i &lt;= start + 1; i++) {
             /* тут должен быть бесконечный цикл, менять ничего нельзя*/
        }
    }
}

</code></pre>
«Ничего сложного», — скажете вы. Скорее всего, вы не раз попадали в такую историю: решая задачи по Java, вы создавали бесконечный цикл и думали, как от него избавиться. Тут же наоборот. Хитрость в том, что сам цикл и условия выхода из него менять нельзя. Есть только две итерации. Тем не менее, их вполне достаточно, чтобы создать бесконечный цикл. 

Похоже, что он должен работать только для двух итераций, но его можно сделать бесконечным, за счет использования переполнения. Уже догадались, как? 
<h3>Решение</h3>За счёт переполнения. <code>Integer.MAX_VALUE</code> — максимальное значение, которое <code>int</code> может хранить в Java. Если вы достигаете <code>Integer.MAX_VALUE</code> и инкрементируете это значение, то скатываетесь к <code>Integer.MIN_VALUE</code>, то есть, к минимальному значению <code>Integer</code>. Таким образом, для решения этой Java-задачи нам достаточно присвоить переменной <code>start</code> значение на 1 меньшее, чем максимальное для типа данных <code>int</code>. 

<strong>Код задачи на Java: </strong>

<pre class="lang-java line-numbers"><code>
class ToInfinity {
    public static void main(String[] args) {
        int start = Integer.MAX_VALUE - 1;
        for (int i = start; i &lt;= start + 1; i++) {
            //бесконечный цикл
            System.out.println(i); //убеждаемся в бесконечности цикла
        }
    }
}
</code></pre>
Что получается? Мы начинаем со start=2147483645 (Integer.MAX_VALUE-1), на следующей итерации значение становится 2147483645, потом 2147483646, затем -2147483648, -2147483647… и так далее. 
<h2 id="zadacha2">Задача по Java- 2. Создайте комментарий, который будет выполнятся</h2>Ну вот, приехали! С самых первых лекций мы слышали о том, что комментарии не выполняются. На то они и комментарии. Думаем, решение этой задачи для Java-программиста, даже опытного, — не всегда очевидно. Тем не менее, есть один хитрый способ, как заставить Java-машину «легально» запустить комментарий на выполнение. Чувствуете, откуда ветер дует? Попробуйте предположить! 
<h3>Решение</h3><strong>Код решения задачи на Java:</strong>

<pre class="lang-java line-numbers"><code>
public class ExecutableComment {
    public static void main(String[] args) {
        // комментарий ниже будет выполнен! 
        // \u000d System.out.println("выполняемый комментарий");
    }
}
</code></pre>
Если набрать код этой задачи по джава в IDE, вот что мы получим: 

<pre class="lang-java line-numbers"><code>
выполняемый комментарий
</code></pre>
Причина в том, что компилятор Java считывает Unicod-символ  <code>\u000d</code> как новую строку, и читает наш код следующим образом: 

<strong>Расшифрованный компилятором код решения задачи на Java:</strong> 

<pre class="lang-java line-numbers"><code>
public class ExecutableComment {
    public static void main(String[] args) {
        // the line below this gives an output
        // \u000d
        System.out.println("comment executed");
    }
}
</code></pre>
<h2 id="zadacha3">Задача по Java - 3: создать именованный цикл</h2>Ещё один представитель серии «практические задачи по программированию, Java в сферическом вакууме». В том смысле, что непонятно, зачем это нужно, вряд ли цикл чувствует обиду от того, что он обезличен. Ну да ладно, важно другое: язык позволяет дать циклу имя.
<h3>Решение</h3>Примечание: кому-то такие "имена" известны как "метки", которые не рекомендуется использовать на практике.

<strong>Код решения задачи по джава, демонстрирующий именованный цикл</strong>

<pre class="lang-java line-numbers"><code>
public class NamedLoop {
    public static void main(String[] args) {
        loop1:
        for (int i = 0; i &lt; 5; i++) {
            for (int j = 0; j &lt; 5; j++) {
                if (i == 3)
                    break loop1;
                System.out.println("i = " + i + " j = " + j);
            }
        }
    }
} 
</code></pre>
Вот что будет на выходе, если запустить программу: 

<pre class="lang-java line-numbers"><code>
i = 0 j = 0
i = 0 j = 1
i = 0 j = 2
i = 0 j = 3
i = 0 j = 4
i = 1 j = 0
i = 1 j = 1
i = 1 j = 2
i = 1 j = 3
i = 1 j = 4
i = 2 j = 0
i = 2 j = 1
i = 2 j = 2
i = 2 j = 3
i = 2 j = 4
</code></pre>
Тут также можно использовать continue для перехода к началу именованного цикла.

А ещё при надобности получится использовать <code>break</code> (или <code>continue</code>) во вложенном <code>if-else</code> с <code>for</code>-циклом, чтобы разбить несколько циклов с помощью <code>if-else</code>. Это поможет избежать установки большого количества флагов и тестирования их в <code>if-else</code> чтобы понять, продолжать или выходить из внутреннего цикла.

<h2 id="zadacha4">Задача по Java - 4. О единственном дубликате в массиве целых чисел</h2>Задан массив (или <code>ArrayList</code>, как вам больше нравится) целых чисел, в котором содержатся элементы <code>Integer</code> от 1 до 100. В этом массиве есть один и только один продублированный элемент. Как его найти?

Такие задачи для Java-программиста привычнее, чем предыдущие три. Потому что она не о знании тонкостей языка, которые почти никогда не используются, а о логике. 

Первый необузданный порыв — решать перебором — пропадает довольно быстро, когда включается голова или там установка «я же программист, я же умный». Плохо только, что на собеседовании, в условиях стресса, этого может и не произойти. Так что думайте сейчас, прежде, чем заглядывать в решение! 
<h3>Алгоритм решения следующий:</h3>Посчитайте сумму всех чисел от 1 до 100. Думаем, вы знаете, как это можно сделать (например, с помощью знаменитого метода Гаусса)

Теперь считаете сумму элементов вашего массива или <code>ArrayList’а</code>.

И… вычитаете первую сумму из второй. 

Бинго! Полученное число — и есть значение дублирующегося элемента.

<strong>Код решения java-задачи для <code>ArrayList</code>.</strong>  

<pre class="lang-java line-numbers"><code>
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class FindDuplicate {
    private static void findDuplicate(List&lt;Integer&gt; elements) {
//находим сумму всех уникальных элементов списка  
        int distinctSum = elements.stream().distinct().mapToInt(e -&gt; e).sum();
//находим сумму всех элементов списка 
        int totalSum = elements.stream().mapToInt(e -&gt; e).sum();
        System.out.println("Элемент, который повторяется : " + (totalSum - distinctSum));
    }

    public static void main(String[] args) {
//создаем список последовательных элементов на промежутке [1..101). 
        List &lt;Integer&gt; elements = IntStream.range(1, 101).boxed().collect(Collectors.toList());
//устанавливаем элементу с индексом 53 значение 23          
        elements.set(53, 23);
        findDuplicate(elements);
    }
}
</code></pre>
<strong>Другое решение </strong>

<pre class="lang-java line-numbers"><code>
import java.util.List;
import java.util.ArrayList;

public class Duplicate {

    public int findDuplicateNumber(List&lt;Integer&gt; numbers) {

        int highestNumber = numbers.size() - 1;
        int total = getSum(numbers);
        int duplicate = total - (highestNumber * (highestNumber + 1) / 2);
        return duplicate;
    }

    public int getSum(List&lt;Integer&gt; numbers) {

        int sum = 0;
        for (int num : numbers) {
            sum = sum + num;
        }
        return sum;
    }

    public static void main(String a[]) {
        List &lt;Integer&gt; numbers = new ArrayList &lt;Integer&gt;();
        for (int i = 1; i &lt; 100; i++) {
            numbers.add(i);
        }
        //добавляем дубликат в список
        numbers.add(25);
        Duplicate dn = new Duplicate();
        System.out.println("Элемент, который повторяется: " + dn.findDuplicateNumber(numbers));
    }
}
</code></pre>
<h2 id="zadacha5">Задача по Java - 5. О неединственном дубликате в массиве целых чисел</h2>Если предыдущая задачка показалась вам слишком лёгкой, то попробуйте решить следующую: дан лист целых чисел от 1 до 100. В нём есть дубликаты (больше одного). Как найти элементы, которые встречаются больше одного раза (найти сам элемент и указать, сколько раз он встречается)?
<h3>Решение</h3>Тут логичнее всего для решения использовать такую структуру, как <code>HashMap</code>, поскольку она хранит данные парами «ключ-значение».
 
<strong>Код решения Java-задачи:</strong> 
  
<pre class="lang-java line-numbers"><code>
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class SomeDuplicates {
    private static void findDuplicates(List&lt;Integer&gt; elements) {
        HashMap &lt;Integer, Integer &gt; duplicates = new HashMap &lt; &gt;();
//заполняем Map duplicates значениями по принципу:
// ключ – значение элемента, значение – сколько раз он встречается
        elements.forEach(e -&gt; duplicates.put(e, duplicates.get(e) == null ? 1 : duplicates.get(e) + 1));
//из duplicates убираем все элементы, которые встретились не более 1 раза, 
//и сохраняем //результат в список (для удобства обработки на следующем шаге)         
        List &lt;Map.Entry &lt;Integer, Integer&gt; &gt;
        result = duplicates.entrySet().stream().filter(d -&gt; d.getValue() &gt; 1).collect(Collectors.toList());
//выводим результат для всех элементов в списке result          
        result.forEach(e -&gt; System.out.println(String.format("Элемент %d  встречается %d раз", e.getKey(), e.getValue())));
    }

    public static void main(String[] args) {
        List &lt;Integer&gt; elements = IntStream.range(1, 101).boxed().collect(Collectors.toList());
        elements.set(97, 23);
        elements.set(27, 51);
        elements.set(99, 23);
        findDuplicates(elements);
    }
}
</code></pre>
<big><small><h3>Заключение</h3></small></big>Практические задачи по Java бывают очень разные, и неизвестно, какую неведомую головоломку вам решит подсунуть интервьюер. Тем не менее, любой адекватный работодатель понимает, что намного важнее умения решать задачи по Java с подвохом будет ваше умение решать <strong>реальные практические задачи</strong>, такие, которые вам встретятся во время работы. Так что решайте их как можно больше. Для этого и был создан JavaRush.    

При подготовке статьи использованы материалы <a href="https://www.geeksforgeeks.org/few-tricky-programs-in-java/" target="_blank" rel="nofollow">geeksforgeeks</a>

<table>
<tbody><tr><th>Что еще почитать?</th>
</tr>
<tr>
<td>
<p><a href="https://javarush.com/groups/posts/538-kakie-bihvajut-zadachi-po-java--tipih-zadach-po-java" target="_blank">Какие бывают задачи по Java</a></p>
<p><a href="https://javarush.com/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java" target="_blank">10 вопросов по абстрактным классам и интерфейсам с собеседований по Java</a></p>
<p><a href="https://javarush.com/groups/posts/458-key-khorstmann-i-ego-1500-slov-o-tom-kak-statjh-luchshim-java-programmistom--" target="_blank">Кей Хорстманн и его 1500 слов о том, как стать лучшим Java-программистом</a></p>
</td>
</tr>
</tbody></table>