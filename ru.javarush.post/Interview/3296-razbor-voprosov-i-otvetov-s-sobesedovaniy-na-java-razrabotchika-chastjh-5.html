Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5
<p>----------------------------------------</p>
Hello, hello! Сегодня Java-разработчики очень востребованы. Обеспечить вакансией я вас, конечно, не могу, но немного помочь в том, чтобы вы обрели новые знания...
<p>----------------------------------------</p>
Hello, hello!
 
Сегодня Java-разработчики очень востребованы. Обеспечить вакансией я вас, конечно, не могу, но немного помочь в том, чтобы вы обрели новые знания и закрыли некоторые пробелы, попытаюсь.
 
Так что продолжаем разбор <a href="https://dou.ua/lenta/articles/interview-questions-java-developer/" rel="nofollow" target="_blank">250+ вопросов</a> с собеседований на Java-разработчика. 

Ссылки на предыдущие части разбора — в конце статьи.<img data-max-width="800" data-id="7b40e358-1302-418c-ad84-36034057f486" src="https://cdn.javarush.com/images/article/7b40e358-1302-418c-ad84-36034057f486/800.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 1"><h4>39. Что такое модификаторы доступа в Java? Назовите их. Для чего они используются?</h4>Ранее я уже описывал модификаторы доступа в вопросе об элементах Java, отвечающих за инкапсуляцию. Но все же напомню.
 
Модификаторы доступа в Java — это ключевые слова, которые описывают предоставляемый уровень доступа к определенному компоненту Java.
 
Модификаторы доступа могут быть:<ul>

<li><span class="code">public</span> — элемент с данным модификатором будет общедоступным. Т.е. поля и методы, классы, объявленные с модификатором public, видны другим классам как из текущего пакета, так и из внешних пакетов;</li>
<li><span class="code">protected</span> — элемент с данным модификатором будет доступен из любого места в текущем классе текущего пакета или в классах-наследниках, даже если они находятся в других пакетах;</li>
<li><span class="code">default</span>, или отсутствующий модификатор — данный модификатор используется неявно, когда модификатор доступа не указывается вовсе. Он похож на предыдущий, кроме допустимости видимости в классах-наследниках, которые находятся в других пакетах;</li>
<li><span class="code">private</span> — самый закрытый из всех модификаторов, который допускает доступ к элементу только в пределах текущего класса.</li>

</ul><img data-max-width="512" data-id="29e0c7a1-ea94-4400-989d-a628537afd5d" src="https://cdn.javarush.com/images/article/29e0c7a1-ea94-4400-989d-a628537afd5d/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 2"><h4>40. Назовите основную особенность статических и переменных методов</h4>Весьма странная формулировка — “переменные методы”. Наверняка здесь имеются в виду обычные, нестатические методы.
 
Так вот, основная разница в том, что статические методы принадлежат классу и, собственно, для них не нужно создавать экземпляр данного класса: его можно вызывать лишь используя тип класса.
 
Например, у нас есть статический метод, чтобы погладить кота:
 
<pre class="language-java line-numbers"><code>
public class CatService {
   public static void petTheCat(Cat cat) {
       System.out.println("Погладить кота - " + cat.getName());
   }
</code></pre>
 Для его вызова нам не нужен экземпляр класса <span class="code">CatService</span>:
 
<pre class="language-java line-numbers"><code>
Cat cat = new Cat(7, "Bobi");
CatService.petTheCat(cat);
</code></pre>
 
В то время как обычные методы привязаны (принадлежат) объекту, и чтобы их вызвать, необходимо иметь экземпляр (объект), у которого и будет вызван метод.
 
Например, у кота есть нестатический метод — мяукать:
 
<pre class="language-java line-numbers"><code>
class Cat {
   public void mew() {
       System.out.println("Meow! Meow! Meow!");
   }
</code></pre>
 Для вызова этого метода нам понадобится конкретный экземпляр кота:
 
<pre class="language-java line-numbers"><code>
Cat cat = new Cat(7, "Bobi");
cat.mew();
</code></pre><h4>41. Какие основные ограничения действуют на статические и “переменные” методы?</h4>Как я и сказал ранее, основное ограничение обычного метода в том, что всегда должен быть некоторый экземпляр, у которого данный метод будет вызываться. А вот статический метод этого не требует, но он и не может ссылаться на ссылку <span class="code">this</span> — на элементы текущего объекта — поскольку текущего объекта для него не существует.<h4>42. Что значит ключевое слово static? Может ли статический метод быть переопределен или перегружен?</h4>Элемент, обозначенный ключевым словом <span class="code">static</span>, принадлежит не объекту класса, а именно классу, и он загружается при загрузке самого класса.
 
Статические элементы — единственные на всю программу, а обычные — единственные на конкретный объект.
 
Статическими могут быть:<ul>

<li>поля класса;</li>
<li>блок инициализации класса;</li>
<li>метод класса;</li>
<li>внутренние классы класса (однако, та ещё тавтология).</li>

</ul>Статический метод нельзя переопределить: он принадлежит классу и не наследуется, но в то же время его можно перегрузить.<h4>43. Может ли метод быть статическим и абстрактным одновременно?</h4>В предыдущей статье я это уже упоминал: метод не может быть абстрактным и статическим одновременно. Абстрактность метода подразумевает, что он должен быть переопределен в наследнике. 
 
В то же время статический метод принадлежит классу, и его нельзя переопределить: это вызовет противоречие, которое увидит компилятор и начнет ругаться. Если у вас возникла такая ситуация, стоит всерьёз задуматься о правильности построения архитектуры вашего приложения (ведь с ней явно что-то не так).<img data-max-width="512" data-id="a52bee87-4d5c-495a-b054-3ab83c453d72" src="https://cdn.javarush.com/images/article/a52bee87-4d5c-495a-b054-3ab83c453d72/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 3"><h4>44. Можно ли использовать статические методы в середине обычных? Наоборот? Почему?</h4>Статические методы можно использовать в обычных, так как этому ничего не препятствует.
 
В то же время обратная ситуация невозможна: статический метод не может использовать обычный метод, не имея ссылки на конкретный экземпляр данного класса. А как мы помним, для статических членов класса ссылка <span class="code">this</span> недоступна: конкретных объектов класса может быть сколько угодно, и у каждого из них внутри будет ссылка на самого себя — <span class="code">this</span>.
 
И как тогда понять, какую именно ссылку <span class="code">this</span> нужно взять? А никак.

Поэтому и статические элементы не могут ссылаться на нестатические, без ссылки на конкретный объект.

Собственно, статический метод может использовать не статический, только если имеет ссылку на конкретный объект. Например ту, которая пришла в качестве аргумента:
 
<pre class="language-java line-numbers"><code>
public static void petTheCat(Cat cat) {
   System.out.println("Погладить кота - " + cat.getName());
}
</code></pre>
 Тут мы видим, что в статическом методе <span class="code">petTheCat</span> вызывается обычный, нестатический метод объекта <span class="code">Cat</span> — <span class="code">getName</span>.<h4>45. Что такое interface? Может ли быть final interface?</h4>Как мы помним, в Java нет множественного наследования. Интерфейсы — это что-то вроде его альтернативы. 
 
Интерфейс похож на очень урезанный класс. Они определяют функционал без конкретной реализации, который реализуют классы, имплементирующие (реализующие) эти интерфейсы.
 
Пример интерфейса:
 
<pre class="language-java line-numbers"><code>
public interface Animal {
    void voice();
}
</code></pre>
 Пример реализации интерфейса классом:
 
<pre class="language-java line-numbers"><code>
class Cat implements Animal {
 
   @Override
   public void voice() {
       System.out.println("Meow! Meow! Meow!");
   }
}
</code></pre>
 Главное, что нужно знать об использовании интерфейсов:<ol>

<li>Методы интерфейса должны содержать только заголовок, без конкретного тела метода, т.е. должны быть абстрактными (но без применения ключевого слова <span class="code">abstract</span>). Исключение из этого — статические и дефолтные методы, для которых необходимо иметь тело метода.</li>
<li>Класс может реализовывать множество интерфейсов (как и говорил, это альтернатива множественному наследованию), которые прописываются через запятую: <span class="code">class Lion implements Animal, Wild</span>.</li>
<li>Интерфейсы создаются при помощи ключевого слова — <span class="code">interface</span>.</li>
<li>При реализации интерфейса классом используется ключевое слово — <span class="code">implements</span>.</li>
<li>Класс, который реализует определенный интерфейс, обязан реализовать все его абстрактные методы, либо должен объявить себя абстрактным.</li>
<li>Основная цель использования интерфейсов — реализация полиморфизма (способность объектов принимать множество форм).</li>
<li>В интерфейсе, как правило, не пишут модификаторы доступа для методов: они по умолчанию <span class="code">public</span>, и другие модификаторы, отличные от <span class="code">public</span>, задавать нельзя. Начиная с Java 9 можно использовать <span class="code">private</span> модификаторы для методов.</li>
<li>Переменные интерфейсов по умолчанию <span class="code">static final</span>, иначе говоря — константы: их всегда нужно проинициализировать непосредственно в интерфейсе.</li>
<li>Нельзя создать объект интерфейса.</li>

</ol>Ответ на вопрос, могут ли быть интерфейсы финальными — конечно же, нет.
 
Ведь сама суть интерфейсов в том, чтобы их реализовывали. А как мы все прекрасно помним, <span class="code">final</span> на уровне класса делает его не наследуемым, и в случае с интерфейсом — не реализуемым. 
 
А зачем нам интерфейс, который нельзя реализовать и использовать? 

Верно — незачем! И компилятор так считает))<img data-max-width="512" data-id="a58b0173-64ea-4538-bdc5-c32f2c25cf24" src="https://cdn.javarush.com/images/article/a58b0173-64ea-4538-bdc5-c32f2c25cf24/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 4">Смысл разве что появился с введением статических методов в интерфейсы с Java 8, но это не изменило того факта, что интерфейс не может быть финальным.
 
Про интерфейсы я рассказал, очень поверхностно, т.к. это обширная тема. Подробнее об этом — в статьях об <a href="https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih" target="_blank">интерфейсах в Java</a> и <a href="https://javarush.com/groups/posts/1985-raznica-mezhdu-abstraktnihmi-klassami-i-interfeysami" target="_blank">разнице между абстрактными классами и интерфейсами</a>.<h4>46. Где можно инициализировать статические поля?</h4>Статические поля можно инициализировать:<ul>

<li>непосредственно при объявлении, через знак равенства <span class="code">=</span>;</li>
<li>в статическом блоке инициализации;</li>
<li>в нестатическом блоке инициализации, но при этом вы должны понимать что при каждом создании объекта данное поле будет перезаписываться этим блоком инициализации;</li>
<li>в конструкторе класса. При каждом вызове данного конструктора (т.е. при создании объекта через этот конструктор) данное поле будет перезаписываться;</li>
<li>в статических методах;</li>
<li>в нестатических методах;</li>
<li>во внутренних статических и нестатических, локальных и анонимных классах.</li>
 
</ul><h4>47. Что такое анонимные классы?</h4>Анонимные классы — это классы, у которых нет собственного типа. 

О чем это я?
 
Когда мы говорили об интерфейсах, я упомянул, что нельзя создать объект интерфейса: можно лишь создать объект класса, который реализует интерфейс.
 
А что если вы не хотите реализовывать интерфейс в каком-то классе, но при этом вам нужен объект типа интерфейса? И скорее всего, это будет единичный случай использования данного объекта. И у вас нет нужды создавать полноценный класс реализацию.
 
Как вы это сделаете? Правильно! Через анонимный класс!<img data-max-width="512" data-id="0ee0881d-5805-4d8b-bcec-1fe686ff85b0" src="https://cdn.javarush.com/images/article/0ee0881d-5805-4d8b-bcec-1fe686ff85b0/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 5">Предположим, у нас есть некоторый интерфейс <span class="code">Animal</span>:
 
<pre class="language-java line-numbers"><code>
public final interface Animal {
   public void voice();
}
</code></pre>
 Если мы хотим создать экземпляр данного интерфейса через анонимный класс:
 
<pre class="language-java line-numbers"><code>
Animal cat = new Animal() {
   @Override
   public void voice() {
       System.out.println("Meow! Meow! Meow!");
   }
};
</code></pre>
И далее вы можете спокойной использовать данный объект и его реализованный метод — <span class="code">voice</span>.
 
То есть анонимный класс реализует данный интерфейс и все его абстрактные методы прямо здесь и сейчас. Иначе нам не создать объект интерфейса/абстрактного класса,  так как присутствуют не реализованные/абстрактные методы.
 
Как я упомянул, анонимные классы используются не только для реализации абстрактных методов интерфейса, но и для реализации абстрактных методов абстрактного класса.
 
Данный подход хорош для ситуаций, когда объект используется разово или данная реализация методов нужна только единожды, и нет нужды создавать отдельный класс, который будет реализовывать необходимый абстрактный класс/интерфейс. 
 
Но также отмечу, что использование анонимных классов — редкое явление в работе: как правило предпочтение все же отдается обычным классам.  
 
Подробнее об анонимных классах можно почитать <a href="https://javarush.com/groups/posts/2193-anonimnihe-klassih" target="_blank">вот в этой статье</a>.<h4>48. Что такое примитивные классы?</h4>Как по мне, это весьма странный вопрос и, возможно, это такой вопрос-ловушка, ведь в Java нет такого понятия как примитивные классы: разве что есть понятие примитивные типы, которое мы уже рассматривали ранее.
 
Как мы помним, в Java есть 8 примитивных типов — <span class="code">byte</span>, <span class="code">short</span>, <span class="code">int</span>, <span class="code">long</span>, <span class="code">float</span>, <span class="code">double</span>, <span class="code">char</span>, <span class="code">boolean</span>.<img data-max-width="512" data-id="6353785e-032a-40c8-ab27-5628b2718b74" src="https://cdn.javarush.com/images/article/6353785e-032a-40c8-ab27-5628b2718b74/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 6"><h4>49. Что такое класс «обертка» (wrapper)?</h4>Главная проблема использования примитивных типов в Java — это то, что они все же не классы, а Java — всё же ООП язык. То есть программы, написанные на этом языке, сводятся к взаимодействию между объектами. 
 
Ну а примитивы — это не объекты. У них нет методов, даже стандартных от класса <span class="code">Object</span>. Ну а если нам понадобилось использовать примитив как ключ в <span class="code">Map</span>? Тогда у него нужно вызвать метод <span class="code">hashCode</span>. Также там можно вызвать метод <span class="code">equals</span>. Что тогда?
 
Моментов, где должен быть именно класс, а не примитив, может быть очень и очень много, что делает примитивы неиспользуемыми и нежелательными элементами в программе, ведь это рушит саму идею ООП.
 
Но не всё так плохо, как кажется. Ведь в Java есть понятие обертки примитивов. У каждого примитивного типа есть класс-аналог:<ul>

<li><span class="code">byte</span> -&gt; <span class="code">Byte.class</span></li>
<li><span class="code">short</span> -&gt; <span class="code">Short.class</span></li>
<li><span class="code">int</span>  -&gt; <span class="code">Integer.class</span></li>
<li><span class="code">long</span> -&gt; <span class="code">Long.class</span></li>
<li><span class="code">float</span> -&gt; <span class="code">Float.class</span></li>
<li><span class="code">double</span> -&gt; <span class="code">Double.class</span></li>
<li><span class="code">char</span> -&gt; <span class="code">Character.class</span></li>
<li><span class="code">boolean</span> -&gt; <span class="code">Boolean.class</span></li>

</ul>Это представление простых типов, но в виде полноценных классов с кучей разнообразных и функциональных методов.

Для удобного использования этих классов ввели понятия autoboxing и unboxing.

<span class="text-bold">Autoboxing</span> — автоматическое преобразование примитивного типа в класс-аналог при надобности (например, <span class="code">int</span> в <span class="code">Integer</span>).

<span class="text-bold">Unboxing</span> — процесс, обратный предыдущему: автоматическое преобразование класса-обертки примитива к примитивному типу (например, <span class="code">Integer</span> к <span class="code">int</span>).

Благодаря введению классов-оберток примитивов и процессов <span class="text-bold">autoboxing</span>-а и <span class="text-bold">unboxing</span>-а, примитивные типы смогли стать полноценными членами ООП языка — Java.<img data-max-width="512" data-id="26effbd3-eb9c-4b45-b8f5-3a67203c1a4f" src="https://cdn.javarush.com/images/article/26effbd3-eb9c-4b45-b8f5-3a67203c1a4f/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 7">Чтобы ознакомиться с этой темой подробнее, настойчиво рекомендую почитать <a href="https://javarush.com/groups/posts/1948-objertki-raspakovka-i-zapakovka" target="_blank">вот эту статью</a>.<h4>50. Что такое Nested class? Когда он используется?</h4>Nested class — внутренний класс, который является членом другого класса. В Java существует 4 вида таких внутренних классов:

<span class="text-bold">1. Внутренний класс</span>

Данный вид классов объявляется непосредственно в теле другого класса. Вложенный внутренний класс может получить доступ к любому приватному полю или методу экземпляра внешнего класса.
 
В качестве примера, создадим зоопарк, в котором у нас будет животное — зебра:
 
<pre class="language-java line-numbers"><code>
public class Zoo {
   class Zebra {
       public void toFeed(String food) {
           System.out.println("Дать зебре - " + food);
       }
   }
}
</code></pre>
Ничего сложного, не так ли?
 
Давайте взглянем на пример создания объекта внутреннего класса:
 
<pre class="language-java line-numbers"><code>
Zoo.Zebra zebra = new Zoo().new Zebra();
zebra.toFeed("яблоко");
</code></pre>
Как вы уже увидели, обязательно нужно создавать объект обрамляющего класса, на основе ссылки которого можно создать объект внутреннего класса.
 
Также хотелось бы отметить, что вложенный внутренний класс <span class="text-bold">не может иметь в себе статических методов</span> или статических полей. Именно потому, что внутренний класс неявно связан с объектом своего внешнего класса, и он не может объявлять никаких статических методов внутри себя.
 
<span class="text-bold">2. Статические вложенные классы</span>

Данный класс схож с предыдущим, только у него модификатор доступа <span class="code">static</span> возле объявления класса.
 
Так как у этого вида классов нет доступа к не статическим полям внешнего класса, он больше похож на статическую часть внешнего класса, чем на внутренний класс.
 
При этом у данных класса есть доступ ко всем статическим членам внешнего класса, даже к приватным.
 
Пример статического вложенного класса:
 
<pre class="language-java line-numbers"><code>
public class Zoo {
   static class Zebra {
       public void toFeed(String food) {
           System.out.println("Дать зебре - " + food);
       }
   }
}
</code></pre> 
Способ создания немного отличается от предыдущего:
 
<pre class="language-java line-numbers"><code>
Zoo.Zebra zebra = new Zoo.Zebra();
zebra.toFeed("яблоко");
</code></pre>
Тут нам не нужен объект внешнего класса для создания объекта вложенного статического класса. От внешнего класса нам нужен только его тип, чтобы можно было найти расположение вложенного класса.
 
<span class="text-bold">3. Локальные классы</span>

Локальные классы — это классы, объявленные внутри тела метода, при этом создание и использование объекта локального класса возможно исключительно в пределах этого метода.
 
Пример:
 
<pre class="language-java line-numbers"><code>
public class Zoo {
   public void toFeed(String animal, String food) {
       switch(animal){
           case "зебра":
               class Zebra {
                   void toFeedZebra(String food) {
                       System.out.println("Дать зебре - " + food);
                   }
               }
               Zebra zebra = new Zebra();
               zebra.toFeedZebra(food);
               ...
</code></pre> 
Пример использования:
 
<pre class="language-java line-numbers"><code>
Zoo zoo = new Zoo();
zoo.toFeed("зебра", "яблоко");
</code></pre>
Не видя код метода <span class="code">toFeed</span>, вы бы и не заподозрили о существовании локального класса, не так ли?
 
Локальный класс не может быть <span class="code">static</span> или <span class="code">transient</span>, но его можно пометить как <span class="code">abstract</span> или <span class="code">final</span> (только ИЛИ, т.к. использование этих двух модификаторов приведет к конфликту).
 
<span class="text-bold">4. Анонимные классы</span>

Про анонимные классы мы уже говорили выше, и как вы помните, их можно создать из двух источников — интерфейсы и классы.
 
<span class="text-bold">Причины использования</span>
 
Внутренние статические и не статические классы используют потому, что иногда лучше встроить небольшие классы в более общие и хранить их вместе: так у них будет более высокая связанность и общая цель. Собственно, использование вложенных классов увеличивает инкапсуляцию кода.
 
Причиной выбора локальных классов может послужить то, что данный класс используется исключительно в пределах одного метода. Нужно ли в таком случае размазывать код по приложению? Нет. Но при этом добавлю, что в своей практике я ни разу не видел использование локальных классов, т.к. потребность в них весьма спорная.
 
Ну а причиной использования анонимных классов может быть то, что конкретная реализация интерфейса или абстрактного класса будет необходима лишь единожды, поэтому нет нужды создавать под это отдельный, полноценный класс с реализацией. Взамен — по-простому — реализовали нужный нам метод(ы) через анонимный класс, использовали этот объект и забыли о нем (ну а Garbage collector о нем вспомнил).<img data-max-width="512" data-id="dff3ed7a-a39f-4cfe-8c5a-94e41fb0ce36" src="https://cdn.javarush.com/images/article/dff3ed7a-a39f-4cfe-8c5a-94e41fb0ce36/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 8">Изучить внутренние классы подробнее вам помогут <a href="https://javarush.com/groups/posts/2181-vlozhennihe-vnutrennie-klassih" target="_blank">эта</a> и <a href="https://javarush.com/quests/lectures/questmultithreading.level03.lecture03" target="_blank">эта</a> статьи.<h4>51. Какие модификаторы доступа могут быть у класса?</h4>Как мы помним, существуют разные виды классов и для них применимы разные модификаторы доступа:<ul>

<li><span class="text-bold">внешний класс</span> может иметь модификатор доступа <span class="code">public</span> или быть без модификатора (модификатор по умолчанию);</li>
<li><span class="text-bold">внутренний класс</span> поддерживает все 4 модификатора доступа; </li>
<li><span class="text-bold">вложенный статический класс</span> поддерживает все модификаторы доступа, кроме <span class="code">protected</span>, т.к. данный модификатор подразумевает наследование, что противоречит статическому члену класса (статические элементы не наследуются);</li>
<li><span class="text-bold">локальный класс</span> может быть только с модификатором по умолчанию (т.е. без модификатора вовсе);</li>
<li><span class="text-bold">анонимный класс</span>: отсутствует объявление типа класса, то и модификаторы доступа отсутствуют вовсе.</li>

</ul>На этом мы сегодня и сделаем остановочку. <span class="text-bold">See you soon!</span><img data-max-width="512" data-id="54b4e25c-cc75-4fb7-8cdf-c42a19787cba" src="https://cdn.javarush.com/images/article/54b4e25c-cc75-4fb7-8cdf-c42a19787cba/512.jpeg" alt="Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 5 - 9"><table><tbody>
<tr><th>
Другие материалы серии:
</th></tr><tr><td>
<ul><li><a href="https://javarush.com/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 1</a></li>
<li><a href="https://javarush.com/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 2</a></li>
<li><a href="https://javarush.com/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 3</a></li>
<li><a href="https://javarush.com/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 4</a></li>
<li><a href="https://javarush.com/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 6</a></li>
<li><a href="https://javarush.com/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 7</a></li>
<li><a href="https://javarush.com/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 8</a></li>
<li><a href="https://javarush.com/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 9</a></li>
<li><a href="https://javarush.com/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 10</a></li>
<li><a href="https://javarush.com/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 11</a></li>
<li><a href="https://javarush.com/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 12</a></li>
<li><a href="https://javarush.com/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 13</a></li>
<li><a href="https://javarush.com/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 14</a></li>
<li><a href="https://javarush.com/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 15</a></li>
<li><a href="https://javarush.com/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Разбор вопросов и ответов с собеседований на Java-разработчика. Часть 16</a></li>
</ul>
</td></tr></tbody></table>