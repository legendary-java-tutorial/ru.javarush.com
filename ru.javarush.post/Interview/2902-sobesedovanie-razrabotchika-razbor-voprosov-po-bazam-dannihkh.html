Собеседование разработчика: разбор вопросов по базам данных
<p>----------------------------------------</p>
Всем привет! Все мы здесь бьемся над одной целью — стать Java Developer-ами. Пожалуй, самый важный из этапов на пути становления — техническое собеседование...
<p>----------------------------------------</p>
Всем привет! Все мы здесь бьемся над одной целью — стать <span class="text-bold">Java Developer</span>-ами.

Пожалуй, самый важный из этапов на пути становления — техническое собеседование. Как правило собеседующий проходится по основным темам, задавая по паре вопросов.

В этой статье мы поговорим об одной из таких ключевых тем — <span class="text-bold">базы данных</span>. Рассмотрим наиболее частые вопросы и попытаемся ответить на них без глубокого погружения в материал, ведь в таком случае нам и объема книги не хватит!

Итак, поехали.<img data-max-width="800" data-id="5dcc2bb3-08f0-447a-a77f-83c55b370b79" src="/images/article/5dcc2bb3-08f0-447a-a77f-83c55b370b79/800.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 1"><h2>1. Что такое базы данных? На какие типы они делятся?</h2><h4>Что подразумевается под СУБД?</h4><img data-max-width="512" data-id="a52210bf-cabd-4bad-a879-afa5f2777567" src="/images/article/a52210bf-cabd-4bad-a879-afa5f2777567/512.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 2"><span class="text-bold">База данных (БД)</span> — это организованная структура, предназначенная для хранения, изменения и обработки взаимосвязанной информации преимущественно больших объемов. Иными словами, БД — это  структурированное хранилище данных. Например, телефонная книга.<h4>Типы БД</h4><ol><li><span class="text-bold">Реляционная база данных</span> — это набор данных с предопределенными связями между ними. Данные хранятся в виде набора таблиц, состоящих из столбцов и строк. В таблицах хранится информация об объектах, представленных в базе данных. В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке — значение атрибута.</li>
<li><span class="text-bold">Нереляционные системы (NoSQL)</span> — системы, созданные для определенных моделей данных, обладающие гибкими схемами. Иначе говоря, это БД, которые хранят данные не в виде табличных схем, строк и столбцов, а в иных форматах.</li></ol>Подробнее о нереляционных базах данных можно прочесть в этой статье: <a href="https://javarush.com/groups/posts/467-rukovodstvo-po-nosql-dlja-razrabotchikov-" target="_blank">Руководство по NoSQL для разработчиков</a>.
 
<span class="text-bold">Система управления базами данных (СУБД)</span> — это совокупность программного обеспечения, при помощи которого пользователь может создавать базы данных (БД) и проводить над ними различные операции: дополнять, обновлять, удалять, выбирать, и т. д. 

СУБД гарантирует сохранность, целостность, безопасность хранения данных и позволяет выдавать доступ к администрированию БД.

В качестве примера можно привести MySql — это СУБД, предоставляющая доступ к реляционной базе данных или MongoDB для нереляционной.<h2>2. Что такое нормализация? Нормализованная форма? Сколько форм нормализации существует? Назовите первые три.</h2><span class="text-bold">Нормализация</span> — это процесс организации, структуризации данных в базе, который обеспечивает большую гибкость базы данных за счет исключения избыточности и несогласованности зависимостей.

<span class="text-bold">Нормальная форма</span> — свойство таблицы, рассматриваемое в контексте нормализации, которое характерезует таблицу с точки зрения простоты и правильности построения структуры. Нормальная форма определяется как совокупность требований, которым должна удовлетворять таблица. 

Всего существует шесть нормальных форм, но на практике применяются не более первых трех:<ol><li>Первая нормальная форма:
<ul><li>Все атрибуты простые (то есть атомарные и неделимые);</li>
<li>Все данные скалярные (то есть положительные);</li>
<li>Нет повторяющихся строк (для этого для каждой строки создается первичный ключ).</li></ul></li>
<li>Вторая нормальная форма:
<ul><li>Соблюдены условия первой нормальной формы;</li>
<li>Каждый неключевой атрибут ссылается на первичный ключ.</li></ul></li>
<li>Третья нормальная форма:
<ul><li>Соблюдены условия  второй нормальной группы;</li>
<li>Неключевые поля не зависят от других неключевых полей: они могут быть связаны лишь с первичным ключом.</li></ul></li></ol><h2>3. Денормализация</h2><span class="text-bold">Денормализация</span> — намеренное снижение или нарушение форм  нормализации базы данных, обычно — чтобы ускорить чтение из базы за счет добавления избыточных данных. В общем, это процесс, обратный к нормализации.
Так происходит потому, что теория нормальных форм не всегда применима на практике.

К примеру, не атомарные значения — не всегда «зло»: иногда даже наоборот. В некоторых случаях необходимо дополнительное объединение при выполнении запросов, особенно при обработке большого массива информации. В итоге это может улучшить производительность. 

Для баз данных, предназначенных для аналитики, часто выполняют денормализацию, чтобы ускорить выполнение запросов.

Например, у вас часто будет производиться выборка некоторых данных для отчетов, где неключевые колонки будут связаны между собой. Вы намеренно убираете третью форму нормализации и объединяете все в одной таблице для удобства выборки — чтобы не пришлось делать дополнительные запросы в другие таблицы.<h2>4. Индексы</h2><span class="text-bold">Индекс</span> — отсортированный набор значений, связанных с таблицей или представлением с конкретной колонкой, который ускоряет получение данных. 

То есть это такой себе указатель: как алфавит в телефонной книге, который помогает нам при поиске по фамилии.   

Если использовать эту возможность правильно, можно сильно повысить производительность при работе с большими базами данных. А можно и сильно понизить.

Чтобы ускорить поиск, эти ключи хранятся в виде структуры сбалансированного дерева, по которому выполняется поиск.

Как правило индексы нужно вводить на поля, по которым наиболее часто ведется поиск. Задумываться о создании индекса нужно не ранее, чем когда у вас появится хотя бы 10 тысяч записей. В ином случае заметного результата вы не увидите, ибо преждевременная оптимизация — <span class="text-bold">ЗЛО</span>.

И как же индекс может ударить по производительности системы, спросите вы?

При вставке новых данных или удалении старых структура сбалансированного дерева будет заново пересчитываться. Собственно, чем больше данных и индексов, тем больше деревьев нужно пересчитать.

Представьте ситуацию: у вас есть порядка 20 000 записей и 7 индексов на эту таблицу. То есть, при вставке данных нужно заново пересчитать 7 деревьев, в каждом из которых — по 20 000 записей.

Строго говоря, использовать индексы для таблиц, в которые будут часто добавляться/удаляться данные, и вовсе не рекомендуется.

Напоследок отмечу то, что индексы для столбцов, в которых часто встречается значение <code>null</code>, будут не так эффективны, поэтому не стоить их добавлять на такие колонки.<h2>В чем разница между кластеризованным и некластеризованным индексами в SQL?</h2><h4>Кластеризованный:</h4><ul><li>Обеспечивает физический порядок по выбранному полю;</li>
<li>Если у таблицы есть кластеризованный индекс, она называется кластеризованной;</li>
<li>Нужно не более одного индекса на таблицу;</li>
<li>В MySQL кластеризованный индекс не задается явно пользователем, так как если вы не определяете PRIMARY KEY для своей таблицы, MySQL находит первый индекс <code>UNIQUE</code>, где все ключевые столбцы — <code>NOT NULL</code>, и InnoDB использует его в качестве кластеризованного индекса.</li></ul><h4>Некластеризованный:</h4><ul><li>В одной таблице возможно до 999 некластеризованных индексов;</li>
<li>Содержит указатель на строки с реальными данными в таблице;</li>
<li>Не обеспечивает физический порядок;</li>
<li>Для некластеризованных индексов присутствуют отдельные таблицы с отсортированными данными, а именно — одна таблица для одного столбца, на котором индекс, поэтому при запросе данных, не входящих в состав данного поля, будет сначала выполняться запрос к полю в данной таблице, а только затем — дополнительный запрос к строке в изначальной таблице.</li></ul>Создание некластеризованного индекса:

<pre class="lang-java line-numbers"><code>
CREATE INDEX index_name ON table_name(column_name)
</code></pre><h2>6. Что такое составной индекс?</h2><span class="text-bold">Составной индекс</span> — построенный с посыланием на несколько колонок одновременно. Иначе говоря, это комплексный индекс, состоящий из нескольких колонок.

Такие индексы используют, когда в одном запросе фигурирует более одной колонки. 

Создание составного индекса:

<pre class="lang-java line-numbers"><code>
CREATE INDEX index_name ON table_name(first_column_name, second_column_name, third_column_name)
</code></pre>
Как правило эти индексы используются, когда данные в нескольких столбцах логически взаимосвязаны.<h2>7. Что такое покрывающий индекс? Уникальный индекс?</h2><span class="text-bold">Покрывающий индекс</span> — это индекс, которого вполне достаточно для ответа на запрос без обращения к самой таблице. По этому индексу можно достать всю строку данных, но по факту это просто не нужно.

Благодаря тому, что не нужно ходить непосредственно в исходную таблицу, а ответить можно, используя только индекс, покрывающие индексы немного быстрее в использовании. При этом не стоит забывать, что чем больше колонок, тем более громоздким и медленным становится сам индекс. Так что злоупотреблять этим не стоит.

Выше мы говорили о кластеризованных и некластеризованных индексах, которые могут быть <span class="text-bold">уникальными</span>.

Это означает, что никакие две поля не имеют одинаковое значение для ключа индекса. В ином же случае индекс не будет уникальным, ведь несколько строк могут содержать одно и то же значение.

Пример создания уникального некластеризованного индекса:

<pre class="lang-java line-numbers"><code>
CREATE UNIQUE INDEX index_name ON table_name(column_name)
</code></pre><h2>8. Что такое первичный ключ</h2><span class="text-bold">Первичный ключ (Primary key)</span> — поле в таблице для идентификации каждой строки в таблице базы данных.

В таблице может быть только одно такое поле, и все значения должны быть уникальными.

Ничего не напомнило?<img data-max-width="512" data-id="20a8ee18-58e1-4013-ac6e-e8c2698f5e1a" src="/images/article/20a8ee18-58e1-4013-ac6e-e8c2698f5e1a/512.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 3">Ведь первичный ключ — ничто иное, как <span class="text-bold">уникальный, кластеризованный</span> индекс.

Как правило, первичные ключи создаются, при заведении таблицы:

<pre class="lang-java line-numbers"><code>
CREATE TABLE table_name(
column_name int PRIMARY KEY,
…..)
</code></pre>
К данной колонке автоматически добавится ограничение — <code>NOT NULL</code>.

Также можно задать ключ и для уже созданной таблицы:

<pre class="lang-java line-numbers"><code>
ALTER TABLE table_name ADD PRIMARY KEY (column_name);
</code></pre>
Если первичный ключ добавляется способом, описанным выше, то значения полей, задаваемых как первичный ключ (<code>column_name</code>), проверяются на отсутствие нулевых (также будет добавлено ограничение — <code>NOT NULL</code>).<h2>Что такое внешний ключ?</h2><span class="text-bold">Внешний ключ (Foreign key)</span> — это свойство, создаваемое для того, чтобы обеспечить связь между таблицами.

Как правило, внешний ключ устанавливается для столбцов в подчиненной таблице и указывает на один из столбцов из главной таблицы.

Может задаваться как при создании таблицы:

<pre class="lang-java line-numbers"><code>
CREATE TABLE table_name{
column_name int,
…..
FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name) }
</code></pre>
Так и после создания таблицы:

<pre class="lang-java line-numbers"><code>
ALTER TABLE table_name
ADD FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name));
</code></pre>
Можно задать поведение внешнего ключа при манипуляциях с полем, на которое он ссылается. 

Манипуляции могут быть вида <code>ON DELETE</code> и <code>ON UPDATE</code>.

Возможные варианты поведения:<ul><li><code>CASCADE</code> — с этим свойством будут автоматически удалены или изменены строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице;</li>
<li><code>SET NULL</code> — при данном свойстве, когда происходит  удаление или обновление связанной строки из главной таблицы, будет устанавливаться значение <code>NULL</code> для столбца внешнего ключа;</li>
<li><code>NO ACTION</code> — отклоняет попытки удалить или изменить строки в главной таблице, если присутствуют связанные строки в зависимой таблице;</li>
<li><code>RESTRICT</code> — эквивалентно <code>NO ACTION</code>;</li>
<code>SET DEFAULT</code> — при данном свойстве, когда происходит удаление или обновление связанной строки из главной таблицы, будет устанавливаться значение по умолчанию (если оно есть) для столбца внешнего ключа.</ul>Пример использования:

<pre class="lang-java line-numbers"><code>
 CREATE TABLE table_name{
column_name int,
…..
FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name) ON UPDATE CASCADE ON DELETE CASCADE }
</code></pre>
Если не будет явно задано поведение для <code>ON DELETE</code> и <code>ON UPDATE</code>, то будет устанавливаться поведение <code>RESTRICT</code>.<h2>10. Типы соединений между таблицами (Join)</h2>Связь между таблицами обеспечивается на основе общих данных (полей).

Это происходит с помощью оператора <code>JOIN</code> — операции, которая сопоставляет строки из одной таблицы со строками в другой. 

Сопоставление выполняется так, чтобы столбцы обеих таблиц располагались рядом, хотя их можно получить из отдельных таблиц. И если у нас есть общие поля для трех таблиц, мы можем вывести их данные в виде одной общей таблицы.

Тем не менее, стоит учитывать, что чем меньше таблиц объединяется, тем быстрее будет выполняться запрос.

Итак, виды <code>JOIN</code>:<ul><li><code>INNER JOIN</code> — соединение, которое показывает только те данные из первой таблицы, которым соответствуют некоторые данные из второй таблицы. Остальные — опускаются.<img data-max-width="512" data-id="925b9b60-f8f3-424f-8414-55db2ae0b857" src="/images/article/925b9b60-f8f3-424f-8414-55db2ae0b857/512.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 4"></li>
<li><code>LEFT JOIN</code> — соединение, которое показывает все данные из первой таблицы и соответствующие данные из второй, если они есть. Если же соответствующих данных нет, поля для данных из второй таблицы будут пустыми.<img data-max-width="512" data-id="437072f8-77ca-4917-9bce-d93b2a31346c" src="/images/article/437072f8-77ca-4917-9bce-d93b2a31346c/512.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 5"></li>
<li><code>RIGHT JOIN</code> — соединение, которое показывает все данные из второй таблицы и соответствующие данные из первой, если они есть. Если же соответствующих данных нет, поля для данных из первой таблицы будут пустыми.<img data-max-width="512" data-id="7ac00cb1-70a1-4ec0-bb99-e326e1b9b2f4" src="/images/article/7ac00cb1-70a1-4ec0-bb99-e326e1b9b2f4/512.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 6"></li>
<li><code>FULL JOIN</code> — соединение, которое показывает все данные из первой и второй таблицы. Если связанных данных в другой таблице нет, поля для этих данных будут пустыми.<img data-max-width="512" data-id="72c19e8c-0685-4275-bbea-2f8d8f31515c" src="/images/article/72c19e8c-0685-4275-bbea-2f8d8f31515c/512.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 7"></li>
<li><code>CROSS JOIN</code> — перекрестное соединение, при котором каждая строка первой таблицы соединяется с каждой строкой второй таблицы (каждая с каждой). То есть, если в двух таблицах по 3 строки, после данного соединения мы получим результат из 9 строк.<img data-max-width="512" data-id="6afa166b-058d-4389-ba72-037af308b714" src="/images/article/6afa166b-058d-4389-ba72-037af308b714/512.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 8"></li></ul>Пример <code>Join(inner)</code>:

<pre class="lang-java line-numbers"><code>
SELECT *
FROM first_table
INNER JOIN second_table ON first_table.some_column = second_table.some_column
</code></pre><h2>11. Что такое свойство ACID в базе данных?</h2><span class="text-bold">A — Атомарность</span>, гарантирует, что никакая транзакция не фиксируется в системе частично. Выполняются либо все её подоперации, либо ни одной.

К примеру, перевод денег в банке на другой счет — это две операции:<ol><li>Перевести деньги на счет банка.</li>
<li>Перевести деньги со счета банка на конкретный счет.</li></ol>Но может всякое случиться. Например, поступят в банк, а дальше выпадет какая-то ошибка и вторая операция не выполнится. Или наоборот: выполнится только вторая операция. Поэтому эти действия осуществляются в рамках одной транзакции, и в результате либо всё, либо ничего.

<span class="text-bold">С — Согласованность</span>: каждая успешная транзакция всегда фиксирует только разрешаемые результаты.

Это гарантирует, что все ограничения будут соблюдены (например, <code>NOT NULL</code>), иначе — транзакция откатится. 

<span class="text-bold">И — изолированность</span>: во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат.

Это дает нам возможность скрывать от всех не конечные состояния данных. Собственно, поэтому неуспешные транзакции не могут ничего сломать.

Немного ниже мы ознакомимся с уровнями изолированности транзакций.

<span class="text-bold">Д — долговечность</span>: если транзакция выполнена, то можно быть уверенным, что внесенные ею изменения не отменятся из-за какого-либо сбоя.<h2>12. Уровни изолированности транзакций</h2>Каждый уровень изолированности разрешает/запрещает определенные действия (возможности):<ul><li><span class="text-bold">фантомное чтение</span> — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за добавления данных другой (параллельной) транзакцией.</li>
<li><span class="text-bold">неповторяющееся чтение</span> — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за изменения или удаления данных другой (параллельной) транзакцией.</li>
<li><span class="text-bold">«грязное» чтение</span> — чтение данных, добавленных или измененных транзакцией, которая впоследствии не откатится;</li>
<li><span class="text-bold">потерянное обновление</span> — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего (похоже на “состояние гонки” в многопоточности).</li></ul>Для удобства, рассмотрим уровни изоляций и их возможности в таблице:<table>
<tbody><tr align="center">
<td>Уровни изоляций</td>
<td>Фантомное чтение</td>
<td>Неповторяющееся чтение</td>
<td>“грязное” чтение</td>
<td>потерянное обновление</td>
</tr>
<tr align="center">
<td>SERIALIZABLE</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr align="center">
<td>REPEATABLE_READ</td>
<td>-</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr align="center">
<td>READ_COMMITTED</td>
<td>-</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr align="center">
<td>READ_UNCOMMITTED</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>+</td>
</tr></tbody></table><h2>13. Что такое SQL-инъекция?</h2><span class="text-bold">SQL-инъекция</span> — один из способов взлома сайта, суть которого — внедрение в данные через <code>GET</code>, <code>POST</code> запросы или Cookie некоторого SQL кода. Если веб-сайт выполняет такие инъекции, можно получить доступ к БД и взломать приложение.

Например, мы знаем имя некоторой переменной. Допустим, <code>column_name</code> с типом <code>boolean</code>. Если система восприимчива к инъекциям, можно добавить <code>OR column_name=true</code> и после этого писать всё, что нам нужно от БД. <code>OR</code> создаст условие ИЛИ, и наше выражение после него будет всегда <code>true</code>, что и пропустит нас дальше.

Атака на сайт вроде инъекции SQL возможна из-за неправильной обработки входящих данных, используемых в SQL-запросах.

При соединении с базой данных при помощи <a href="https://javarush.com/groups/posts/2172-jdbc-ili-s-chego-vsje-nachinaetsja" target="_blank">JDBC</a> вы используете различные <code>Statements</code>. Для повышения безопасности необходимо использовать <code>PreparedStatement</code> вместо обычного <code>Statement</code>, так как при использовании <code>Statement</code> строки запроса и значений просто складываются, делая возможными инъекции. 

В свою очередь, в <code>PreparedStatement</code> есть конкретный шаблон запроса, и данные в него вставляются с отражением кавычек. В итоге SQL-инъекции будут восприниматься только как строковое представление какого-то поля.

Для защиты от SQL-инъекций можно использовать проверку на основе регулярных выражений (подробнее о регулярных выражениях можно почитать <a href="https://javarush.com/groups/posts/regulyarnye-vyrazheniya-v-java" target="_blank">в этой статье</a>).<img data-max-width="1024" data-id="355cb1cd-e787-4995-8d5f-008f4800fffe" src="/images/article/355cb1cd-e787-4995-8d5f-008f4800fffe/1024.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 9">Ещё вариант — установить ограничение на количество символов входящих параметров: например, если вам должно приходить число не более 9999, подойдет ограничение в четыре входящих символа. Оно снизит риск взлома с помощью SQL-инъекций.<a href="https://javarush.com/welcome" target="_blank"><img id="click_banner3_1_articles" data-max-width="1080" data-id="b9898661-622a-4fc6-a614-96edeb9ee766" src="/images/article/b9898661-622a-4fc6-a614-96edeb9ee766/1080.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 10"></a>Подробнее о безопасности в Java можно узнать из статьи <a href="https://javarush.com/groups/posts/2713-bezopasnostjh-v-java-best-practices" target="_blank">“Безопасность в Java: best practices”</a>.<h2>14. Что такое хранимые процедуры? Хранимые функции? Триггер?</h2><span class="text-bold">Хранимые процедуры в SQL</span> — сущность в БД, представляющая собой набор SQL-инструкций, который компилируется один раз и хранится на сервере. Словом, это аналог методов в Java.

Хранимые процедуры могут выполнять действия над данными как обычные запросы, так и некоторые действия, недоступные для обычных запросов.

Процедура является сущностью SQL, которую создают один раз, а затем вызывают, передавая аргументы. 
Плюс этого подхода состоит в том, что данные инструкции можно переиспользовать не единожды.

Хранимые процедуры увеличивают производительность, расширяют возможности программирования и поддерживают функции безопасности данных.

Рассмотрим создание процедуры:

<pre class="lang-java line-numbers"><code>
CREATE PROCEDURE procedure_name (first_param some_type, second_param some_type..)
 begin
……...
 end
</code></pre>
Вызов процедуры:

<pre class="lang-java line-numbers"><code>
CALL procedure_name (first_param, second_param…..);
</code></pre>
<span class="text-bold">Хранимая функция</span> — это разновидность хранимой процедуры. Отличие функции состоит в том, что она всегда возвращает только единичное значение, а процедура — набор значений.

Хранимые процедуры нельзя смешивать с обычным SQL, в то время как с сохраненной функцией это можно — и это ее преимущество. С другой стороны, у хранимых функций гораздо больше ограничений, нежели у процедур.

Создание хранимой функции:

<pre class="lang-java line-numbers"><code>
CREATE FUNCTION function_name (first_param, second_param…..)
RETURNS some_type
 begin
……...
RETURN some_value; 
end
</code></pre>
Вызов хранимой функции:

<pre class="lang-java line-numbers"><code>
SELECT function_name(first_param, second_param…..);
</code></pre>
<span class="text-bold">Триггер</span> — еще одна разновидность хранимой процедуры, которая вызывается не непосредственно пользователем, а ее активация происходит при модификации данных. То есть эта процедура активируется при выполнении некоторых условий, как, например, <code>INSERT</code> или <code>DELETE</code>, или <code>UPDATE</code> данных в определенном столбце данной таблицы.

Момент запуска триггера определяется с помощью ключевых слов <code>BEFORE</code> (триггер запускается до связанного события) или <code>AFTER</code> (после события).

<pre class="lang-java line-numbers"><code>
CREATE TRIGGER trigger_name
ON table_name
AFTER INSERT
 begin
……...
 end
</code></pre><h2>15. Практика</h2>Как бы то ни было, самым частым SQL-вопросом на собеседовании будет практика — решение задач. 

Пытаться угадать, какие именно вам попадутся задачи, бессмысленно, ведь все зависит от изощренности фантазии человека напротив. 

Поэтому единственным рабочим вариантом будет набивание руки на SQL-запросах разной сложности. 

В качестве ресурса для практики на различных задачах может послужить <a href="https://www.sql-ex.ru/">sql-ex.ru</a>.

Уже после первых двадцати выполненных тасков вашему собеседнику будет довольно сложно напугать вас какой либо SQL-задачей.<img data-max-width="1024" data-id="df78001b-c3b9-4efb-93e3-3c2797c37a9f" src="/images/article/df78001b-c3b9-4efb-93e3-3c2797c37a9f/1024.jpeg" alt="Собеседование разработчика: разбор вопросов по базам данных - 11">На этом сегодня все: надеюсь, после прочтения данной статьи вопросы по базам данных не вызовут никаких сложностей и проблем.

Спасибо за внимание и до новых встреч!