Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1
<p>----------------------------------------</p>
Всем привет, дамы и господа Software Engineers! Давайте поговорим о вопросах на собеседовании. О том, к чему нужно готовиться и что нужно знать. Это отличный повод для того, чтобы повторить или же изучить...
<p>----------------------------------------</p>
Всем привет, дамы и господа Software Engineers! Давайте поговорим о вопросах на собеседовании. О том, к чему нужно готовиться и что нужно знать. Это отличный повод для того, чтобы повторить или же изучить с нуля эти моменты.

<img src="/images/article/b13b769a-d001-4e48-83ab-8647ef3f1189/original.png" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 1">У меня получилась довольно объемная подборка часто задаваемых вопросов об ООП, Java Syntax, исключениях в Java, коллекциях и многопоточности, которую для удобства я разобью на несколько частей. 

<mark>Важно:</mark> мы будем говорить только о версии Java до 8. Все нововведения с 9, 10, 11, 12, 13 не будут учитываться здесь. Любые идеи/замечания, как улучшить ответы, <span>приветствуются</span>.

Приятного прочтения, поехали!
<h2>Java собеседование: вопросы по ООП</h2><h3>1. Какие особенности есть у Java?</h3>Ответ:
<ol>
<li><p><span>ООП концепты:</span></p><ol>
<li>объектная ориентированность;</li>
<li>наследование;</li>
<li>инкапсуляция;</li>
<li>полиморфизм;</li>
<li>абстракция.</li></ol></li>
<li><p><span>Кроссплатформенность:</span> программа на Java может быть запущена на любой платформе без каких-либо изменений. Единственное, что нужно — установленная JVM (java virtual machine).</p></li>
<li><p><span>Высокая производительность:</span> JIT(Just In Time compiler) позволяет высокую производительность. JIT конвертирует байт-код в машинный код и потом JVM стартует выполнение.</p></li>
<li><span>Мультипоточность:</span> поток выполнения, известный как <code>Thread</code>. JVM создает thread,  который называется <code>main thread</code>. Программист может создать несколько потоков наследованием от класса Thread или реализуя интерфейс <code>Runnable</code>.<p></p></li>
</ol><h3>2. Что такое наследование?</h3>Под наследованием подразумевается, что один класс может наследовать("<span>extends</span>") другой класс.

Таким образом можно переиспользовать код с класса, от которого наследуются.

Существующий класс известен как <code>superclass</code>, а создаваемый — <code>subclass</code>. Также еще говорят <code>parent</code> и <code>child</code>.

<pre class="lang-java line-numbers"><code>
public class Animal {
   private int age;
}

public class Dog extends Animal {

}
</code></pre>
где <code>Animal</code> — это <code>parent</code>, а <code>Dog</code> — <code>child</code>.
<h3>3. Что такое инкапсуляция?</h3>Такой вопрос часто встречается на собеседовании Java-разработчика. <span>Инкапсуляция</span> — это сокрытие реализации при помощи модификаторов доступа, при помощи геттеров и сеттеров. Это делается для того, чтобы закрыть доступ для внешнего использования в тех местах, где разработчики считают нужным.

Доступный пример из жизни — это автомобиль. У нас нет прямого доступа к работе двигателя. Для нас работа заключается в том, чтобы вставить ключ в зажигание и включить двигатель. А какие уже процессы будут происходить под капотом — не наше дело.

Даже более того, наше вмешательство в эту деятельность может привести к непредсказуемой ситуации, из-за которой можно и машину сломать, и себе навредить. Ровно то же самое происходит и в программировании.

Хорошо описано в <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#Java" target="_blank" rel="nofollow">википедии</a>.
Статья об инкапсуляции есть и на <a href="https://javarush.com/groups/posts/1969-principih-inkapsuljacii" target="_blank" rel="nofollow">JavaRush</a>.
<h3>4. Что такое полиморфизм?</h3><span>Полиморфизм</span> — это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта. Как говорится, один интерфейс — множество реализаций.

При помощи полиморфизма можно объединять и использовать разные типы объектов по их общему поведению.

Например, есть у нас класс Animal, у которого есть два наследника — Dog  и Cat. У общего класса Animal есть общее поведение для всех — издавать звук. В случае, когда нужно собрать воедино всех наследников класса Animal и выполнить метод "издавать звук", используем возможности полиморфизма. Вот как будет это выглядеть:

<pre class="lang-java line-numbers"><code>
List&lt;Animal&gt; animals = Arrays.asList(new Cat(), new Dog(), new Cat());
animals.forEach(animal -&gt; animal.makeSound());
</code></pre>
Таким образом, полиморфизм помогает нам. Причем это относится и к полиморфным (перегруженным) методам.

<a href="https://javarush.com/groups/posts/1974-praktika-ispoljhzovanija-polimorfizma" target="_blank" rel="nofollow">Практика использования полиморфизма</a><p></p><h2>Вопросы на собеседовании — Java Syntax</h2><h3>5. Что такое конструктор в Java?</h3>Следующие характеристики являются валидными:
<ol>
<li>Когда новый объект создается, программа использует для этого соответствующий конструктор.</li>
<li>Конструктор похож на метод. Его особенность заключается в том, что нет возвращающего элемента (в том числе и void), а его имя совпадает с именем класса.</li>
<li>Если не пишется никакого конструктора явно, пустой конструктор будет создан автоматически.</li>
<li>Конструктор может быть переопределен.</li>
<li>Если был создан конструктор с параметрами, а нужен еще и без параметров, его нужно писать отдельно, так как он не создается автоматически.</li>
</ol><h3>6. Какие два класса не наследуются от Object?</h3>Не ведитесь на провокации, нет таких классов: все классы прямо или через предков наследуются от класса Object!
<h3>7. Что такое Local Variable?</h3>Еще один из популярных вопросов на собеседовании Java-разработчика. Local variable — это переменная, которая определена внутри метода и существует вплоть до того момента, пока выполняется этот метод. Как только выполнение закончится, локальная переменная перестанет существовать.

Вот программа, которая использует локальную переменную helloMessage в методе main():

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
   String helloMessage;
   helloMessage = "Hello, World!";
   System.out.println(helloMessage);
}
</code></pre><h3>8. Что такое Instance Variable?</h3>Instance Variable — переменная, которая определена внутри класса, и она существует вплоть до того момента, пока существует объект.

Пример — класс Bee, в котором есть две переменные nectarCapacity и maxNectarCapacity:

<pre class="lang-java line-numbers"><code>
public class Bee {

   /**
    * Current nectar capacity
    */
   private double nectarCapacity;

   /**
    * Maximal nectar that can take bee.
    */
   private double maxNectarCapacity = 20.0;
 
  ...
}
</code></pre><h3>9. Что такое модификаторы доступа?</h3>Модификаторы доступа — это инструмент, при помощи которого можно настроить доступ к классам, методам и переменным.

Бывают следующие модификаторы, упорядоченные в порядке повышения доступа:
<ol>
<li><code>private</code> — используется для методов, полей и конструкторов. Уровень доступа — только класс, внутри которого он объявлен.</li>
<li><code>package-private(default)</code> — может использоваться для классов. Доступ только в конкретном пакете (package), в котором объявлен класс, метод, переменная, конструктор.</li>
<li><code>protected</code> — такой же доступ, как и <code>package-private</code> + для тех классов, которые наследуются от класса с модификатором <code>protected</code>.</li>
<li><code>public</code> — используется и для классов. Полноценный доступ во всем приложении.</li><img src="/images/article/d2b3ff04-dcb6-41d6-aaf0-ae5f199416c7/original.png" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 2">
</ol><h3>10. Что такое переопределение (overriding) методов?</h3>Переопределение методов происходит, когда child хочет изменить поведение parent класса. Если нужно, чтоб выполнилось-таки то, что есть в методе parent, можно использовать в child конструкцию вида super.methodName(), что выполнит работу parent метода, а уже потом добавить логику.

Требования, которые нужно соблюдать:<ul>
<li>сигнатура метода должна быть такая же;</li>
<li>возвращаемое значение должно быть таким же.</li>
</ul><h3>11. Что такое сигнатура метода?</h3><img src="/images/article/c24cf22b-73a1-412f-b208-feb5f34fe31b/original.png" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 3">Сигнатура метода — это набор из названия метода и аргументов, какие принимает метод.

Сигнатура метода является уникальным идентификатором для метода при перегрузке методов.
<h3>12. Что такое перегрузка методов?</h3>Перегрузка методов — это свойство полиморфизма, в котором при помощи изменения сигнатуры метода можно создать разные методы для одних действий:
<ul>
<li>одно и то же имя метода;</li>
<li>разные аргументы;</li>
<li>может быть разный возвращаемый тип.</li></ul>Например, один и тот же <code>add()</code> из <code>ArrayList</code> может быть перегружен следующим образом и будет выполнять добавление разным способом, в зависимости от входящих аргументов:
<ul>
<li><code>add(Object o)</code> — просто добавляет объект;</li>
<li><code>add(int index, Object o)</code> — добавляет объект в определенный индекс;</li>
<li><code>add(Collection&lt;Object&gt; c)</code> — добавляет список объектов;</li>
<li><code>add(int index, Collection&lt;Object&gt; c)</code> — добавляет список объектов, начиная с определенного индекса.</li>
</ul><h3>13. Что такое Interface?</h3><p>Множественное наследование не реализовано в джаве, поэтому чтобы преодолеть эту проблему, были добавлены интерфейсы в том виде, в котором мы их знаем ;)

Долгое время у интерфейсов были только методы без их реализации. В рамках этого ответа поговорим именно о них.

Например:

</p><pre class="lang-java line-numbers"><code>
public interface Animal {
   void makeSound();
   void eat();
   void sleep();
}
</code></pre>
Из этого вытекают некоторые нюансы:
<ul>
  <li>все методы в интерфейсе — публичные и абстрактные;</li>
  <li>все переменные — public static final;</li>
  <li>классы не наследуют их (extends), реализовывают (implements). Причем реализовывать можно сколь угодно много интерфейсов.</li>
  <li>классы, которые реализуют интерфейс, должны предоставить реализацию всех методов, которые есть в интерфейсе.</li>
</ul>Вот так:

<pre class="lang-java line-numbers"><code>
public class Cat implements Animal {
   public void makeSound() {
       // реализация метода
   }

   public void eat() {
       // реализация
   }

   public void sleep() {
       // реализация
   }
}
</code></pre><h3>14. Что такое default method в Interface?</h3>Теперь поговорим о дефолтных методах. Для чего, для кого? Эти методы добавили, чтобы все сделать "и вашим, и нашим".

О чем это я? Да о том, что с одной стороны нужно было добавить новую функциональность: лямбды, Stream API, с другой стороны, нужно было оставить то, чем славится джава — обратную совместимость. Для этого нужно было ввести уже готовые решения в интерфейсы. Так к нам и пришли дефолтные методы.

То есть, дефолтный метод — это реализованный метод в интерфейсе, у которого есть ключевое слово <code>default</code>.

Например, всем известный метод <code>stream()</code> в интерфейсе <code>Collection</code>. Проверьте, этот интерфейс вовсе не так прост как кажется ;).

Или также не менее известный метод <code>forEach()</code> из интерфейса <code>Iterable</code>. Его также не было до тех пор, пока не добавили дефолтные методы.

Кстати, еще можно почитать на <a href="https://javarush.com/groups/posts/1984-defoltnihe-metodih-v-interfeysakh" target="_blank" rel="nofollow">JavaRush</a> об этом.
<h3>15. А как тогда наследовать два одинаковых дефолтных метода?</h3>Исходя из предыдущего ответа на то, что такое дефолтный метод, можно задать другой вопрос.

Если можно реализовать методы в интерфейсах, то теоретически можно реализовать два интерфейса с одинаковым методом, и как такое делать?

Есть два разных интерфейса с одинаковым методом:

<pre class="lang-java line-numbers"><code>
interface A {
   default void foo() {
       System.out.println("Foo A");
   }
}

interface B {
   default void foo() {
       System.out.println("Foo B");
   }
}
</code></pre>
И есть класс, который реализует эти два интерфейса. Чтобы не было неопределенности и скомпилировался код, нам нужно переопределить метод <code>foo()</code> в классе <code>C</code>, причем можно просто вызвать в нем метод <code>foo()</code> любого из интерфейсов — <code>A</code> или <code>B</code>. Но только как выбрать специфический метод интерфейса <code>А</code> или <code>В</code>?

Для этого есть конструкция такого вида: <code>A.super.foo()</code>:

<pre class="lang-java line-numbers"><code>
public class C implements A, B {
   @Override
   public void foo() {
       A.super.foo();
   }
}
</code></pre>
или:<br>
<pre class="lang-java line-numbers"><code>
public class C implements A, B {
   @Override
   public void foo() {
       B.super.foo();
   }
}
</code></pre>
Таким образом, метод <code>foo()</code> класса <code>C</code> будет использовать либо дефолтный метод <code>foo()</code> из интерфейса <code>A</code>, либо метод <code>foo()</code> из интерфейса <code>B</code>.
<h3>16. Что такое абстрактные методы и классы?</h3>В джава есть зарезервированное слово <code>abstract</code>, которое используется для обозначения абстрактных классов и методов.
Для начала — определения.

Абстрактным методом называется метод, который создан без реализации с ключевым словом <code>abstract</code> в абстрактном классе. То есть, это метод как в интерфейсе, только с добавкой ключевого слова, например:

<pre class="lang-java line-numbers"><code>
public abstract void foo();
</code></pre>
Абстрактным классом называется класс, который имеет также <code>abstract</code> слово:

<pre class="lang-java line-numbers"><code>
public abstract class A {

}
</code></pre>
У абстрактного класса есть несколько особенностей:
<ul>
<li>на его основе нельзя создать объект;</li>
<li>он может иметь абстрактные методы;</li>
<li>он может и не иметь абстрактные методы.</li>
</ul>Абстрактные классы нужны для обобщения какой-то абстракции (сорян за тавтологию), которой в реальной жизни нет, но она содержит множество общих поведений и состояний (то есть, методов и переменных).

Примеров из жизни — хоть отбавляй. Всё вокруг нас. Это может быть "животное", "машина", "геометрическая фигура" и так далее.
<h3>17. Какая разница между String, String Builder и String Buffer?</h3>Значения <code>String</code> хранятся в пуле стрингов (constant string pool). Как только будет создана строка, она появится в этом пуле. И удалить ее будет нельзя.

Например:
 
<pre class="lang-java line-numbers"><code>
String name = "book";
</code></pre>
...переменная будет ссылаться на стринг пул

Constant string pool
<img src="/images/article/e687405b-4f98-421e-936f-7704ffd9b1ab/original.jpg" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 4">
Если задать переменной name другое значение, получится следующее:

<pre class="lang-java line-numbers"><code>
name = "pen";
</code></pre>
Constant string pool
<img src="/images/article/7145f59f-7ee1-4852-8df3-e7450e38bb79/original.jpg" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 5">Таким образом, эти два значения так и останутся там.

<span>String Buffer:</span>
<ul>
<li>значения <code>String</code> хранятся в стеке(Stack). Если значение изменено, значит новое значение будет заменено на старое;</li>
<li><code>String Buffer</code> синхронизирован, и поэтому он потокобезопасный;</li>
<li>из-за потокобезопасности скорость работы оставляет желать лучшего.</li>
</ul>
Пример:

<pre class="lang-java line-numbers"><code>
StringBuffer name = "book";
</code></pre><img src="/images/article/6a7f4993-0987-4da8-af7a-3b09bb4fbbd0/original.jpg" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 6">Как только значение name сменится, в стеке измениться значение:
<img src="/images/article/63e5f8ad-6e1a-4ef5-a641-7567e0dd26f0/original.jpg" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 7"><span>StringBuilder</span>

Точно такой же, как и <code>StringBuffer</code>, только он не потокобезопасный. Поэтому скорость его явно выше, чем в <code>StringBuffer</code>.
<h3>18. Какая разница между абстрактным классом и интерфейсом?</h3><span>Абстрактный класс:</span>
<ul>
<li>абстрактные классы имеют дефолтный конструктор; он вызывается каждый раз, когда создается потомок этого абстрактного класса;</li>
<li>содержит как абстрактные методы, так и не абстрактные. По большому счету может и не содержать абстрактных методов, но все равно быть абстрактным классом;</li>
<li>класс, который наследуется от абстрактного, должен реализовать только абстрактные методы;</li>
<li>абстрактный класс может содержать Instance Variable(смотри вопрос №5).</li>
</ul><span>Интерфейс:</span>
<ul>
<li>не имеет никакого конструктора и не может быть инициализирован;</li>
<li>только абстрактные методы должны быть добавлены (не считая default methods);</li>
<li>классы, реализующие интерфейс, должны реализовать все методы (не считая default methods);</li>
<li>интерфейсы могут содержать только константы. </li>
</ul><h3>19. Почему доступ по элементу в массиве происходит за O(1)?</h3>Это вопрос буквально с последнего собеседования. Как я узнал позже, это вопрос задается для того, чтобы увидеть, как человек мыслит. Ясно, что практического смысла в этих знаниях немного: хватает только лишь знания этого факта.

Для начала нужно уточнить, что O(1) — это обозначение <a href="https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0" target="_blank" rel="nofollow">временной сложности алгоритма</a>, когда операция проходит за константное время. То есть это обозначение самого быстрого выполнения.

Чтобы ответить на этот вопрос, нужно понять, что мы знаем о массивах?

Чтоб создать массив <code>int</code>, мы должны написать следующее:

<pre class="lang-java line-numbers"><code>
int[] intArray = new int[100];
</code></pre>
Из этой записи можно сделать несколько выводов:
<ol>
<li>При создании массива известен его тип.Если известен тип, то понятно, какого размера будет каждая ячейка массива.</li>
<li>Известно, какого размера будет массив.</li>
</ol>Из этого следует: чтобы понять, в какую ячейку записать, нужно просто вычислить, в какую область памяти записать.

Для машины это проще простого. У машины есть начало выделенной памяти, количество элементов и размер одной ячейки.

Из этого понятно, что место для записи будет равно начальному месту массива + размер ячейки, умноженный на ее размер.
<h3>А как получается О(1) в доступе к объектам в ArrayList?</h3>Это вопрос сразу же идет за предыдущим. Ведь правда, когда мы работаем с массивом и там примитивы, то нам известно заранее, какой размер этого типа, при его создании.

А что делать, если есть такая схема, как на картинке:
<img src="/images/article/53380258-c307-4cb6-837a-73e1095a658d/original.png" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1 - 8">и мы хотим создать коллекцию с элементами, у которых тип A, и добавить разные реализации — B, C, D:

<pre class="lang-java line-numbers"><code>
List&lt;A&gt; list = new ArrayList();
list.add(new B());
list.add(new C());
list.add(new D());
list.add(new B());
</code></pre>
Как в этой ситуации понять, какой будет размер у каждой ячейки, ведь каждый объект будет разным и может иметь разные дополнительные поля (или быть полностью различными). Что делать?

Здесь вопрос ставится так, чтобы запутать и сбить с толку.

Мы же знаем, что на самом деле в коллекции хранятся не объекты, а лишь ссылки на эти объекты. А у всех ссылок размер один и тот же, и он известен. Поэтому здесь работает подсчет места так же, как и в предыдущем вопросе.
<h3>21. Автоупаковка (autoboxing) и Автораспаковка (unboxing)</h3><span>Историческая справка:</span> автоупаковка и автораспаковка - одно из главных нововведений JDK 5. 

<span>Автоупаковка (autoboxing)</span> - процесс автоматического преобразования из примитивного типа в соответствующий класс обертку.

<span>Автораспаковка (unboxing)</span> - делает ровно обратное к автоупаковке - преобразует класс обертку в примитив. А вот если окажется значение обертки <code>null</code>, то при распаковке будет выброшено исключение <code>NullPointerException</code>.
<h4>Соответствие примитив - обертка</h4><table>
<tbody><tr>
<th>Примитив</th>
<th>Класс обертка</th>
</tr>
  <tr>
    <td>boolean</td>
    <td>Boolean</td>
  </tr>
  <tr>
    <td>int</td>
    <td>Integer</td>
  </tr>
  <tr>
    <td>byte</td>
    <td>Byte</td>
  </tr>
  <tr>
    <td>char</td>
    <td>Character</td>
  </tr>
  <tr>
    <td>float</td>
    <td>Float</td>
  </tr>
  <tr>
    <td>long</td>
    <td>Long</td>
  </tr>
  <tr>
    <td>short</td>
    <td>Short</td>
  </tr>
  <tr>
    <td>double</td>
    <td>Double</td>
  </tr>
</tbody></table><h4>Автоупаковка происходит:</h4><ul>
<li><p>когда присваивают примитиву ссылку на класс обертку:</p>
<p>ДО Java 5:</p>
<pre class="lang-java line-numbers"><code>
//ручная упаковка или как это было ДО Java 5.
public void boxingBeforeJava5() {
   Boolean booleanBox = new Boolean(true);
   Integer intBox = new Integer(3);
   // и так далее к другим типам
}

после Java 5:
//автоматическая упаковка или как это стало в Java 5.
public void boxingJava5() {
   Boolean booleanBox = true;
   Integer intBox = 3;
   // и так далее к другим типам
}
</code></pre></li>
<li><p>когда передают примитив в аргумент метода, который ожидает обертку:</p>
<pre class="lang-java line-numbers"><code>
public void exampleOfAutoboxing() {
   long age = 3;
   setAge(age);
}

public void setAge(Long age) {
   this.age = age;
}
</code></pre></li></ul><h4>Автораспаковка происходит:</h4><ul>
<li><p>когда присваиваем классу обертке примитивную переменную:</p>
<pre class="lang-java line-numbers"><code>
//до Java 5:
int intValue = new Integer(4).intValue();
double doubleValue = new Double(2.3).doubleValue();
char c = new Character((char) 3).charValue();
boolean b = Boolean.TRUE.booleanValue();

//и после JDK 5:
int intValue = new Integer(4);
double doubleValue = new Double(2.3);
char c = new Character((char) 3);
boolean b = Boolean.TRUE;
</code></pre></li>
<li><p>В случаях с арифметическими операциями. Они применяются только к примитивным типам, для этого нужно делать распаковку к примитиву.</p>
<pre class="lang-java line-numbers"><code>
// До Java 5
Integer integerBox1 = new Integer(1);
Integer integerBox2 = new Integer(2);

// для сравнения нужно было делать так:
integerBox1.intValue() &gt; integerBox2.intValue()
      
//в Java 5
integerBox1 &gt; integerBox2
</code></pre></li>
<li><p>когда передают в обертку в метод, который принимает соответствующий примитив:</p>
<pre class="lang-java line-numbers"><code>
public void exampleOfAutoboxing() {
   Long age = new Long(3);
   setAge(age);
}

public void setAge(long age) {
   this.age = age;
}
</code></pre></li></ul><h3>22. Что такое ключевое слово final и где его использовать?</h3>Ключевое слово <code>final</code> можно использовать для переменных, методов и классов.
<ol>
<li>final переменную нельзя переназначить на другой объект.</li>
<li>final класс бесплоден)) у него не может быть наследников.</li>
<li>final метод не может быть переопределен у предка.</li>
</ol>Пробежали по верхам, теперь обсудим более подробно.
<h4>final переменные</h4>;Java дает нам два способа создать переменную и присвоить ей некоторое значение:
<ol>
<li>Можно объявить переменную и инициализировать ее позже.</li>
<li>Можно объявить переменную и сразу же назначить ее.</li>
</ol>Пример с использованием final переменной для этих случаев:  

<pre class="lang-java line-numbers"><code>
public class FinalExample {

   //статическая переменная final, которая сразу же инициализируется:
   final static String FINAL_EXAMPLE_NAME = "I'm likely final one";

   //final переменная, которая не инициализирована, но работать будет только если
   //инициализировать это в конструкторе:
   final long creationTime;

   public FinalExample() {
       this.creationTime = System.currentTimeMillis();
   }

   public static void main(String[] args) {
       FinalExample finalExample = new FinalExample();
       System.out.println(finalExample.creationTime);

       // final поле FinalExample.FINAL_EXAMPLE_NAME не может быть заасайнено
//    FinalExample.FINAL_EXAMPLE_NAME = "Not you're not!";

       // final поле Config.creationTime не может быть заасайнено
//    finalExample.creationTime = 1L;
   }
}
</code></pre><h4>Можно ли считать Final переменную константой?</h4>Поскольку у нас не получится присвоить новое значение для final переменной, кажется, что это переменные константы. Но это только на первый взгляд.

Если тип данных, на который ссылается переменная —  <code>immutable</code>, то да, это константа.

А если тип данных <code>mutable</code>, то есть изменяемый, при помощи методов и переменных можно будет изменить значение объекта, на который ссылается <code>final</code> переменная, и в таком случае назвать ее константой нельзя.

Так вот, на примере видно, что часть финальных переменных действительно константы, а часть — нет, и их можно изменить.

<pre class="lang-java line-numbers"><code>
public class FinalExample {

   //неизменяемые финальные переменные:
   final static String FINAL_EXAMPLE_NAME = "I'm likely final one";
   final static Integer FINAL_EXAMPLE_COUNT  = 10;

   //изменяемые фильнаные переменные
   final List&lt;String&gt; addresses = new ArrayList();
   final StringBuilder finalStringBuilder = new StringBuilder("constant?");
}
</code></pre><h4>Local final переменные</h4>Когда <code>final</code> переменная создается внутри метода, ее называют <code>local final</code> переменная:

<pre class="lang-java line-numbers"><code>
public class FinalExample {

   public static void main(String[] args) {
       // Вот так можно
       final int minAgeForDriveCar = 18;

       // а можно и так, в цикле foreach:
       for (final String arg : args) {
           System.out.println(arg);
       }
   }

}
</code></pre>
Мы можем использовать ключевое слово <code>final</code> в расширенном цикле <code>for</code>, потому что после завершения итерации цикла <code>for</code> каждый раз создается новая переменная. Только это все не относится к нормальному циклу for, поэтому приведенный ниже код выдаст ошибку времени компиляции.

<pre class="lang-java line-numbers"><code>
// final local переиенная j не может быть назначена
for (final int i = 0; i &lt; args.length; i ++) {
   System.out.println(args[i]);
}
</code></pre><h4>Final класс</h4>Нельзя расширять класс, объявленный как <code>final</code>. Проще говоря, никакой класс не может наследоваться от данного. Прекрасным примером <code>final</code> класса в JDK является <code>String</code>. 

Первый шаг к созданию неизменяемого класса — пометить его как <code>final</code>, и тогда нельзя будет его расширить:

<pre class="lang-java line-numbers"><code>
public final class FinalExample {
}

// Здесь будет ошибка компиляции
class WantsToInheritFinalClass extends FinalExample {
}
</code></pre><h4>Final методы</h4>Когда метод маркирован как final, его называют final метод (логично, правда?). Final метод нельзя переопределять у класса наследника. 

К слову, методы в классе Object — wait() и notify() — это final, поэтому у нас нет возможность их переопределять.

<pre class="lang-java line-numbers"><code>
public class FinalExample {
   public final String generateAddress() {
       return "Some address";
   }
}

class ChildOfFinalExample extends FinalExample {

   // здесь будет ошибка компиляции
   @Override
   public String generateAddress() {
       return "My OWN Address";
   }
}
</code></pre><h4>Как и где использовать final в Java</h4><ul>
<li>использовать ключевое слово final, чтобы определить некоторые константы уровня класса;</li>
<li>создавать final переменные для объектов, когда вы не хотите, чтобы они были изменены. Например, специфичные для объекта свойства, которые мы можем использовать для целей логирования;</li>
<li>если не нужно, чтобы класс был расширен, отметить его как окончательный;</li>
<li>если нужно создать immutable&lt; класс, нужно сделать его финальным;</li>
<li>если нужно, чтоб реализация метода не менялась в наследниках, обозначить метод как <code>final</code>. Это очень важно, чтобы быть уверенным, что реализация не изменится.</li>
</ul><div class="email-subscription"><iframe src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" scrolling="no" width="100%" height="200" frameborder="0"></iframe></div><h3>23. Что такое mutable immutable?</h3><h4>Mutable</h4>Mutable называются объекты, чьи состояния и переменные можно изменить после создания. Например такие классы, как StringBuilder, StringBuffer.

Пример:

<pre class="lang-java line-numbers"><code>
public class MutableExample {

   private String address;

   public MutableExample(String address) {
       this.address = address;
   }

   public String getAddress() {
       return address;
   }

   // этот сеттер может изменить поле name
   public void setAddress(String address) {
       this.address = address;
   }

   public static void main(String[] args) {

       MutableExample obj = new MutableExample("first address");
       System.out.println(obj.getAddress());

       // обновляем поле name, значит это mutable объект
       obj.setAddress("Updated address");
       System.out.println(obj.getAddress());
   }
}
</code></pre><h4>Immutable</h4>Immutable называются объекты, состояния и переменные которых нельзя изменить после создания объекта. Чем не отличный ключ для HashMap, да?) Например, String, Integer, Double и так далее.

Пример:

<pre class="lang-java line-numbers"><code>
// сделаем этот класс финальным, чтобы никто не мог его изменить
public final class ImmutableExample {

   private String address;

   ImmutableExample (String address) {
       this.address = address;
   }

   public String getAddress() {
       return address;
   }

   //удаляем сеттер

   public static void main(String[] args) {

       ImmutableExample obj = new ImmutableExample("old address");
       System.out.println(obj.getAddress());

       // Поэтому никак не изменить это поле, значит это immutable объект
       // obj.setName("new address");
       // System.out.println(obj.getName());

   }
}
</code></pre><h3>24. Как написать immutable класс?</h3>После того, как выясните, что такое mutable и immutable объекты, следующий вопрос будет закономерный — как написать его?

Чтоб написать immutable неизменяемый класс, нужно следовать простым пунктам:
<ul>
<li>сделать класс финальным.</li>
<li>сделать все поля приватными и создать только геттеры к ним. Сеттеры, разумеется, не нужно.</li>
<li>Сделать все mutable поля final, чтобы установить значение можно было только один раз.</li>
<li>инициализировать все поля через конструктор, выполняя глубокое копирование (то есть, копируя и сам объект, и его переменные, и переменные переменных, и так далее)</li>
<li>клонировать объекты mutable переменных в геттерах, чтобы возвращать только копии значений, а не ссылки на актуальные объекты.</li>
</ul>Пример:

<pre class="lang-java line-numbers"><code>
/**
* Пример по созданию immutable объекта.
*/
public final class FinalClassExample {

   private final int age;

   private final String name;

   private final HashMap&lt;String, String&gt; addresses;

   public int getAge() {
       return age;
   }


   public String getName() {
       return name;
   }

   /**
    * Клонируем объект перед тем, как вернуть его.
    */
   public HashMap&lt;String, String&gt; getAddresses() {
       return (HashMap&lt;String, String&gt;) addresses.clone();
   }

   /**
    * В конструкторе выполняем глубокое копирование для mutable объектов.
    */
   public FinalClassExample(int age, String name, HashMap&lt;String, String&gt; addresses) {
       System.out.println("Выполняем глубокое копирование в конструкторе");
       this.age = age;
       this.name = name;
       HashMap&lt;String, String&gt; temporaryMap = new HashMap&lt;&gt;();
       String key;
       Iterator&lt;String&gt; iterator = addresses.keySet().iterator();
       while (iterator.hasNext()) {
           key = iterator.next();
           temporaryMap.put(key, addresses.get(key));
       }
       this.addresses = temporaryMap;
   }
}</code></pre>
<ul><li><a href="https://github.com/romankh3" rel="nofollow" target="_blank">Мой профиль на GitHub</a></li>
<li><a href="https://javarush.com/groups/posts/2592-top-50-java-core-voprosov-iotvetov-na-sobesedovanii-chastjh-2" target="_blank">Топ-50 Java Core вопросов и ответов на собеседовании. Часть 2</a></li>
<li></li></ul>