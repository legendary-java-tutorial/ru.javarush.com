Топ-50 Java Core вопросов и ответов на собеседовании. Часть 2
<p>----------------------------------------</p>
Что имеется в виду под Collections в Java? Collection — это фреймворк, который создан для сохранения и манипуляции объектами. Используется для выполнения следующих операций: поиск, сортировка, манипуляция...
<p>----------------------------------------</p>
<a href="https://javarush.com/groups/posts/2590-top-50-java-core-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Топ-50 Java Core вопросов и ответов на собеседовании. Часть 1</a>
<img data-max-width="800" src="/images/article/df9cb13d-af13-4cca-8bf2-730d36b621ba/800.webp" class="img-fluid" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 2 - 1"><h2>Collections</h2><h3>25. Что имеется в виду под Collections в Java?</h3>Collection — это фреймворк, который создан для сохранения и манипуляции объектами.

Используется для выполнения следующих операций:
<ul>
<li>поиск;</li>
<li>сортировка;</li>
<li>манипуляция;</li>
<li>добавление;</li>
<li>удаление.</li>
</ul>Все классы и интерфейсы для Collection фреймворка находятся в <code>java.util</code> пакете.
<h3>26. Какие классы и интерфейсы доступны в Collection фреймворке?</h3>Интерфейсы:
<ul>
<li>Collection;</li>
<li>List;</li>
<li>Set;</li>
<li>Map;</li>
<li>Sorted Set;</li>
<li>Sorted Map;</li>
<li>Queue.</li>
</ul>Классы:
<ul>
<li>Lists:
<ol type="a">
<li>ArrayList;</li>
<li>LinkedList;</li>
<li>Vector(deprecated).</li></ol></li>
<li>Sets:<ol type="a">
<li>HashSet;</li>
<li>LinkedHashSet;</li>
<li>TreeSet.</li></ol></li>
<li>Maps:<ol type="a">
<li>HashMap</li>
<li>TreeMap</li>
<li>HashTable (deprecated)</li>
<li>LinkedHashMap</li></ol></li>
<li>Queue<ol type="a">
<li>Priority Queue.</li>
</ol></li></ul><h3>27. Что подразумевается под sorted и ordered в коллекциях?</h3><h4>Ordered (упорядочивание):</h4>Это означает, что элементы, которые хранятся в коллекции, основаны на значениях, добавленных в коллекцию. 

Таким образом, мы можем перебирать значения из коллекции в определенном порядке. Другими словами это значит, что у элементов коллекции есть свой специфический порядок, согласно которому они расположены.

Для лучшего понимания, коллекция, которая не упорядочена (ordered), хранит элементы в произвольном порядке. Например, Set.
<h4>Sorted (отсортированный):</h4>Это значит, что группа элементов отсортирована в коллекции на основе данных элемента коллекции. То есть не только коллекция упорядочена (ordered), но еще и порядок элементов зависит от их значений. Этот порядок может меняться, если отсортировать по другому значению элемента.
<h3>28. Какие есть коллекции с List интерфейсом? Как происходит работа с List?</h3>Значения элементов в лист базируются на их индексе — они упорядочены по индексу. Повторения элементов разрешены (то есть можно добавить один и тот же объект в коллекцию несколько раз, и это будет нормально).
<h4>ArrayList:</h4>Самая распространенная коллекция. По сути, это массив с динамически расширяемым размером. Работа по управлению размером массива лежит на коллекции.

Для нас важно понять, что в большинстве случаев это то, что нам нужно использовать. 

Особенности:
<ul>
<li>быстрый перебор и быстрый поиск по индексу;</li>
<li>коллекция упорядочена по индексу, но не сортирована;</li>
<li>реализует RandomAccess интерфейс;</li>
<li>медленное добавление в середину списка.</li>
</ul>Пример:

<pre class="lang-java line-numbers"><code>
public class A {

   public static void main(String[] args) {
       ArrayList<string> names = new ArrayList&lt;&gt;();
       names.add("John");
       names.add("John");
       names.add("Roman");
       names.add("Ivan");
   }
  
}
</string></code></pre>
&gt;&gt; output
<pre><code>
   [John, John, Roman, Ivan]
</code></pre>
В выводе видно, что это повторяемые элементы. Они выведены в порядке, в котором их записали.

Что еще почитать? Да море информации, даже выходить из JavaRush не нужно:
<ul>
<li><a href="https://javarush.com/groups/posts/2472-podrobnihy-razbor-klassa-arraylist" target="_blank">Подробный разбор класса ArrayList</a></li>
<li><a href="https://javarush.com/groups/posts/klass-arraylist" target="_blank">Класс ArrayList</a></li>
<li><a href="https://javarush.com/groups/posts/1936-rabota-arraylist-v-kartinkakh--" target="_blank">Работа ArrayList в картинках</a></li>
<li><a href="https://javarush.com/groups/posts/2354-arraylist-v-java" target="_blank">ArrayList в Java</a></li>
</ul><h4>Linked List:</h4>Это коллекция, в которой каждый элемент имеет ссылку на предыдущий и следующий элементы. По этим ссылкам можно переходить от одного элемента к другому.

При добавлении элемента просто меняются ссылки на предыдущий и следующий элементы:
<img data-max-width="256" src="/images/article/1bb1695e-b343-451c-81d1-383ab9c6d203/256.webp" class="img-fluid" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 2 - 2"><ul>
<li>элементы связаны друг с другом, то есть реализован двусвязный список;</li>
<li>общая скорость работы заметно ниже, чем в ArrayList;</li>
<li>отличный выбор для большого количества вставок и удалений в середину массива;</li>
<li>реализует интерфейсы списков Queue и Deque, поэтому и имеет их методы для работы.</li></ul>Пример:

<pre class="lang-java line-numbers"><code>
LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();
linkedList.add("One");
linkedList.add("Two");
linkedList.add("Three");
</code></pre><h3>29. Расскажите о коллекции Map и ее реализациях?</h3>Map — это коллекция ключ-значение (key-value). Есть уникальный ключ и значение, которое соответствует этому значению. Используется <code>equals()</code> и <code>hashcode()</code> методы для определения уникальности ключа.
<h4>HashMap:</h4><ul>
<li>не отсортирован и не упорядочен;</li>
<li>используют если не важны порядок и сортировка;</li>
<li>поддерживает null ключ.</li></ul>Пример:

<pre class="lang-java line-numbers"><code>
public class CollectionExample {

   public static void main(String[] args) {
       HashMap<string, string=""> positions = new HashMap&lt;&gt;();
       positions.put("junior", "Ivan");
       positions.put("middle", "Roman");
       positions.put("senior", "Vasily");
       positions.put("team lead", "Anton");
       positions.put("arthitect", "Andrew");
       positions.put("senior", "John");
       System.out.println(positions);
   }
}

// вывод в консоль
// {junior=Ivan, middle=Roman, senior=John, team lead=Anton, arthitect=Andrew}
</string,></code></pre>
Ключи всегда уникальны, поэтому записан только один senior.
<h4>LinkedHashMap:</h4><ul>
<li>поддерживает порядок вставки;</li>
<li>медленнее, чем HashMap;</li>
<li>ожидается, что итерация быстрее, чем в HashMap.</li>
</ul>Пример:

<pre class="lang-java line-numbers"><code>
public class CollectionExample {

   public static void main(String[] args) {
       LinkedHashMap&lt;String, String&gt; positions = new LinkedHashMap&lt;&gt;();
       positions.put("junior", "Ivan");
       positions.put("middle", "Roman");
       positions.put("senior", "Vasily");
       positions.put("team lead", "Anton");
       positions.put("arthitect", "Andrew");
       positions.put("senior", "John");
       System.out.println(positions);
   }
}

// вывод в консоль
// {junior=Ivan, middle=Roman, senior=John, team lead=Anton, arthitect=Andrew}
</code></pre><h4>TreeMap:</h4>Реализация мапы, которая сохраняет записи отсортированными в соответствии с естественным порядком их ключей или, что еще лучше, с использованием компаратора, если он предоставляется в конструкторе при создании мапы.

Пример:
<ol><li><p>Без компаратора</p>
<pre class="lang-java line-numbers"><code>
public class CollectionExample {

   public static void main(String[] args) {
       TreeMap&lt;Integer, String&gt; positions = new TreeMap&lt;&gt;();
       positions.put(1, "Ivan");
       positions.put(3, "Roman");
       positions.put(2, "Vasily");
       positions.put(10, "Anton");
       positions.put(7, "Andrew");
       positions.put(1, "John");
       System.out.println(positions);
   }
}

// вывод в консоль
// {1=John, 2=Vasily, 3=Roman, 7=Andrew, 10=Anton}
</code></pre></li>
<li><p>С компаратором</p>
<pre class="lang-java line-numbers"><code>
public class CollectionExample {

   public static void main(String[] args) {
       //используем реализацию Strategy Pattern'a и добавим компаратор:
       TreeMap&lt;Integer, String&gt; positions = new TreeMap&lt;&gt;(Comparator.reverseOrder());
       positions.put(1, "Ivan");
       positions.put(3, "Roman");
       positions.put(2, "Vasily");
       positions.put(10, "Anton");
       positions.put(7, "Andrew");
       positions.put(1, "John");
       System.out.println(positions);
   }
}

// вывод в консоль
// {10=Anton, 7=Andrew, 3=Roman, 2=Vasily, 1=John}
</code></pre></li></ol>
Видим, что стандартно реализована сортировка в порядке возрастания, но это можно изменить, добавив компаратор в конструктор.

Хорошо описана TreeMap <a href="https://www.codeflow.site/ru/article/java-treemap" rel="nofollow" target="_blank">здесь</a>.
<h3>30. Расскажите о коллекции Set и ее реализациях?</h3>Set — это множество уникальных элементов, и это ее главная особенность. То есть Set не допускает повторения одних и тех же элементов. 

<em>Здесь важно, чтобы у объектов, которые добавляются, был реализован метод</em> <code>equals</code>. 
<h4>HashSet:</h4><ul>
<li>не отсортирован и не упорядочен. Под капотом там HashMap с заглушкой для значения. Посмотрите сами ;)</li>
<li>использует hashCode для добавления объектов;</li>
<li>стоит использовать, когда нужно иметь уникальные объекты и их порядок не важен.</li>
</ul>Пример:

<pre class="lang-java line-numbers"><code>
public class CollectionExample {

   public static void main(String[] args) {
       HashSet&lt;String&gt; positions = new HashSet&lt;&gt;();
       positions.add("junior");
       positions.add("junior");
       positions.add("middle");
       positions.add("senior");
       positions.add("team lead");
       positions.add("architect");
       System.out.println(positions);
   }
}

// вывод в консоль
// [senior, middle, team lead, architect, junior]
</code></pre>
Здесь видно, что элемент “junior”, который дважды добавлен, присутствует только в единичном экземпляре. И порядок не такой же, как при добавлении.
<h4>LinkedHashSet:</h4><ul>
<li>упорядоченная версия HashSet;</li>
<li>поддерживает двусвязный список для всех элементов;</li>
<li>использовать его, когда требуется упорядоченность при итерации.</li>
</ul>Пример:

<pre class="lang-java line-numbers"><code>
public class CollectionExample {

   public static void main(String[] args) {
       LinkedHashSet&lt;String&gt; positions = new LinkedHashSet&lt;&gt;();
       positions.add("junior");
       positions.add("junior");
       positions.add("middle");
       positions.add("senior");
       positions.add("team lead");
       positions.add("architect");
       System.out.println(positions);
   }
}

// вывод в консоль
// [senior, middle, team lead, architect, junior]
</code></pre>
<h4>TreeSet:</h4><ul>
<li>одна из двух сортированных коллекций;</li>
<li>использует структуру <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE" rel="nofollow" target="_blank">красно-черного дерева</a> и гарантирует, что элементы будут в возрастающем порядке;</li>
<li>под капотом это TreeMap с заглушкой на значениях. А элементами TreeSet являются ключи к TreeMap (также посмотрите ;)).</li>
</ul>Пример:

<pre class="lang-java line-numbers"><code>
public class CollectionExample {

   public static void main(String[] args) {
       TreeSet&lt;String&gt; positions = new TreeSet&lt;&gt;();
       positions.add("junior");
       positions.add("junior");
       positions.add("middle");
       positions.add("senior");
       positions.add("team lead");
       positions.add("architect");
       System.out.println(positions);
   }
}

// вывод в консоль
// [architect, junior, middle, senior, team lead]
</code></pre><h2>Exceptions</h2><h3>31. Что такое Exception?</h3><span class="text-bold">Exception</span> — это проблема, которая может возникнуть в runtime. Это <span class="text-bold">исключительная</span> ситуация, которая возникает из-за каких-то причин. 

Диаграмма наследования исключений выглядит так (нужно знать ее назубок ;) ):
<img data-max-width="512" src="/images/article/273e683e-f4a7-472e-9d61-566ae1f6f4ab/512.webp" class="img-fluid" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 2 - 3">На диаграмме видно, что в целом все исключения делятся на две группы — <span class="text-bold">exceptions</span> и <span class="text-bold">error.</span>

<span class="text-bold">Error</span> — используются JVM для отображения ошибок, после которых работа приложения уже не имеет смысла. Например StackOverFlowError, которая говорит, что стек заполнен и программа уже не может работать.

<span class="text-bold">Exception</span> — исключения, которые генерируются программно в коде. Есть разные исключения, проверяемые и непроверяемые, но главное, что они есть, и их можно перехватить и продолжить работу приложения.

Exceptions, в свою очередь, еще делятся на тех, кто наследуется от RuntimeException и других наследников Exception. 

В рамках этого вопроса информации достаточно. О том, что такое проверяемые / непроверяемые исключения, поговорим ниже.
<h3>32. Как JVM обрабатывает исключения?</h3>Как это работает? Как только где-то создается исключение, runtime создает Exception Object (обозначим как ExcObj). В нем хранится вся необходимая для работы информация — само исключение, которое вызывалось и место, где это произошло.

Создание <code>ExcObj</code> и передача в runtime есть ничто иное как “выбрасывание исключения”.

<code>ExcObj</code> содержит методы, по которым можно дойти до место создания исключения. Это множество методов называется Call Stack.

Далее, runtime система ищет метод в Call Stack, который сможет обработать наше исключение. 

Если он таки находит соответствующий обработчик, то есть тип исключения совпадает с типом в обработчике, все хорошо. 

Если не находит, то runtime передает всё в default exception handler, который подготавливает ответ и завершает работу.

Как это выглядит наглядно:

<pre class="lang-java line-numbers"><code>
/**
* Пример, в котором показываются две опции — когда находится обработчик для исключения и когда нет.
*/
class ThrowerExceptionExample {

   public static void main(String[] args) throws IllegalAccessException {

       ThrowerExceptionExample example = new ThrowerExceptionExample();

       System.out.println(example.populateString());
   }

   /**
    * Здесь происходит перехват одного из возможных исключений — {@link IOException}.
    * А вот второй будет пробрасываться дальше вверх по вызову.
    */
   private String populateString() throws IllegalAccessException {
       try {
           return randomThrower();
       } catch (IOException e) {
           return "Caught IOException";
       }
   }

   /**
    * Здесь две опции: или бросается {@link IOException} или {@link IllegalAccessException}.
    * Выбирается случайным образом.
    */
   private String randomThrower() throws IOException, IllegalAccessException {
       if (new Random().nextBoolean()) {
           throw new IOException();
       } else {
           throw new IllegalAccessException();
       }
   }
}
</code></pre>
В нашем случае CallStack схематично будет иметь вид: 

<pre><code>
randomThrower() =&gt; populateString() =&gt; main(String[] args)
</code></pre>
Есть две опции: случайным образом будет выброшено одно или другое исключение. Для IOException все ок, если будет сгенерировано оно, то результатом работы будет: <code>"Caught IOException"</code>.

А вот если будет второе исключение, обработчика на которого нет, программа будет остановлена с таким выводом:

<pre><code>
Exception in thread "main" java.lang.IllegalAccessException
  at ThrowerExceptionExample.randomThrower(CollectionExample.java:38)
  at ThrowerExceptionExample.populateString(CollectionExample.java:24)
  at ThrowerExceptionExample.main(CollectionExample.java:15)
</code></pre><h3>33. Как программистам обрабатывать исключения?</h3>В вопросах выше уже использовались те или иные ключевые слова для работы с исключениями, теперь нужно поговорить о них более подробно.

Какие есть ключевые слова? 
<ul>
<li>try</li>
<li>catch</li>
<li>throw</li>
<li>throws</li>
<li>finally</li>
</ul>Важно отметить, что catch, throw и throws можно использовать только с java.lang.Throwable. С другими типами работать это не будет.

Сейчас обсудим именно try, catch и finally.
<ul>
<li><code>try-catch-finally</code> — это конструкция, при помощи которой можно правильным образом перехватить и обработать исключение.</li>
<li><code>try</code> — может быть только один раз, в нем и происходит логика;</li>
<li><code>catch</code> — блок, который принимает какой-то тип исключения, их может быть множество. Например, в блоке try будет генерироваться несколько исключений, которые никак друг с другом не связаны;</li>
<li><code>finally</code> — “наконец-то” и этот блок. Это блок, который выполнится в любом случае, независимо от того, что делается в try, catch.</li>
</ul>Вот как это выглядит:

<pre class="lang-java line-numbers"><code>
try {
   // сюда передают тот код, который может вызвать исключение.
} catch (IOException e) {
   // первый catch блок, который принимает IOException и все его подтипы(потомки).
   // Например, нет файла при чтении, выпадает FileNotFoundException, и мы уже соответствующе
   // обрабатываем это.
} catch (IllegalAccessException e) {
   // если нужно, можно добавить больше одного catch блока, в этом нет проблем.
} catch (OneException | TwoException e) {
   // можно даже объединять несколько в один блок
} catch (Throwable t) {
   // а можно сказать, что мы принимаем ВСЁ))))
} finally {
   // этот блок может быть, а может и не быть.
   // и он точно выполнится.
}
</code></pre>
Внимательно вчитайтесь в описание примера и будет всё ясно)
<h3>34. throw и throws в Java</h3><h4>throw</h4><code>throw</code> используют в случае, когда нужно явно создать новое исключение. Применяют его для создания и выбрасывания пользовательских исключений. 

Например, исключения, связанные с валидацией. Обычно для валидации наследуются от <code>RuntimeException</code>.

Пример:

<pre class="lang-java line-numbers"><code>
// пример пробрасывания исключения
throw new RuntimeException("because I can :D");
</code></pre>
Важно, что использовать эту конструкцию можно только тем, что наследуется от <code>Throwable</code>. То есть, нельзя сказать так:

<pre class="lang-java line-numbers"><code>
throw new String("как тебе такое, Илон Маск?");
</code></pre>
Далее, работа потока обрывается и начинается поиск обработчика, который смог бы обработать его. Когда не находит, идет к методу, который вызвал его, и так поиск будет идти наверх по строке вызовов пока либо не найдет соответствующий обработчик, либо оставит работу приложения.

Смотрим:

<pre class="lang-java line-numbers"><code>
// Пример, который демонстрирует работу throw
class ThrowExample {

   void willThrow() throws IOException {
       throw new IOException("Because I Can!");
   }

   void doSomething() {
       System.out.println("Doing something");
       try {
           willThrow();
       } catch (IOException e) {
           System.out.println("IOException was successfully handled.");
       }
   }

   public static void main(String args[]) {
       ThrowExample throwExample = new ThrowExample();
       throwExample.doSomething();
   }
}
</code></pre>
Если запустить программу, получим такой результат:

<pre><code>
Doing something
IOException was successfully handled.
</code></pre><h4>throws</h4><code>throws</code> — механизм, при помощи которого метод может выбрасывать одно или более исключений. Добавляются они через запятую. 

Смотрим как это легко и просто:

<pre class="lang-java line-numbers"><code>
private Object willThrow() throws RuntimeException, IOException, FileNotFoundException
</code></pre>
Причем важно отметить, что могут быть как проверяемые таки непроверяемые исключения. 

Разумеется, что непроверяемые исключения можно и не добавлять в <code>throws</code>, но правила хорошего тона говорят об обратном.

Если это проверяемые, то используя метод, который их генерирует, нужно как-то его обработать. Есть два варианта:
<ol>
<li>Написать <code>try-catch</code> с соответствующим и выше по наследованию исключением.</li>
<li>Использовать <code>throws</code> точно так же, чтобы эта проблема была уже у кого-то другого :D</li>
</ol><h3>35. Checked и Unchecked исключения в Java</h3>B Java есть два типа исключений — checked и unchecked.
<h4>Checked исключения:</h4>Это исключения, которые проверяются во время компиляции. Если какой-то код в методе во время исключения выдает checked исключение, метод обязан либо обработать его при помощи <code>try-catch</code>, либо пробросить его дальше

На примере, который считывает картинку из пути "/users/romankh3/image.png", обновляет ее каким-то образом(для нас это не важно) и сохраняет ее обратно. 

<pre class="lang-java line-numbers"><code>
class CheckedImageExample {
   public static void main(String[] args) {
       File imageFile = new File("/users/romankh3/image.png");
       BufferedImage image = ImageIO.read(imageFile);
       updateAndSaveImage(image, imageFile);
   }

   private static void updateAndSaveImage(BufferedImage image, File imageFile) {
       ImageIO.write(image, "png", imageFile);
   }
}
</code></pre>
Такой код компилироваться не будет, так как статические методы <code>ImageIO.read()</code> и <code>ImageIO.write()</code> выбрасывают исключение IOException, которое является checked (проверяемым) и должно соответственно быть обработанным.

Здесь две опции, которые мы уже обсудили выше: или использовать <code>try-catch</code>, или пробросить дальше. Для лучшего усвоения сделаем и так, и эдак.

То есть в методе <code>updateAndSave</code> просто пробросим, а уже в главном методе воспользуемся <code>try-catch</code>:

<pre class="lang-java line-numbers"><code>
class CheckedImageExample {
   public static void main(String[] args) {
       File imageFile = new File("/users/romankh3/image.png");
       try {
           BufferedImage image = ImageIO.read(imageFile);
           updateAndSaveImage(image, imageFile);
       } catch (IOException e) {
           e.printStackTrace();
       }
   }

   private static void updateAndSaveImage(BufferedImage image, File imageFile) throws IOException {
       ImageIO.write(image, "png", imageFile);
   }
}
</code></pre><h4>Unchecked исключения:</h4>Это те исключения, которые на этапе компиляции не проверяются. То есть метод может генерировать RuntimeException, а компилятор не напомнит каким-то образом это обработать.

Как показано ниже, у нас все, кто наследуются от RuntimeException и Error являются непроверяемыми.
<img data-max-width="512" src="/images/article/114eb6e8-44e3-4681-aec1-e4a7bcdd0695/512.webp" class="img-fluid" alt="Топ-50 Java Core вопросов и ответов на собеседовании. Часть 2 - 4">Рассмотрим следующую Java-программу. Код прекрасно компилируется, но при запуске выдает исключение <code>ArrayIndexOutOfBoundsException</code>. Компилятор позволяет его компилировать, потому что <code>ArrayIndexOutOfBoundsException</code> является непроверенным исключением. 

Обычная ситуация с массивом, которая может быть:

<pre class="lang-java line-numbers"><code>
class CheckedImageExample {
   public static void main(String[] args) {
       int[] array = new int[3];
       array[5] = 12;
   }
}
</code></pre>
Результатом будет:

<pre class="lang-java line-numbers"><code>
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
  at main(CheckedImageExample.java:12)
</code></pre>
Кстати, вы уже заметили, что в Java короткие имена никто не дает? Чем больше, тем лучше. Он, Spring Framework, в этом при успел очень сильно: возьми только какой-нибудь <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/AbstractDependsOnBeanFactoryPostProcessor.html" rel="nofollow" target="_blank">BeanFactoryPostProcessor</a> класс)))

<div class="email-subscription"><iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no"></iframe></div><h3>36. Что такое try-with-resources?</h3>Это механизм, при помощи которого нужно правильно закрывать все ресурсы.

Как-то не понятно, да?) 

Для начала, что такое ресурс...

Ресурс — это объект, после работы с которым нужно закрыть его, то есть вызвать метод <code>close()</code>. Ресурсом называются все объекты, которые реализуют интерфейс <code>AutoClosable</code>, который, в свою очередь реализует интерфейс <code>Closeable</code>. 

Для нас важно понять, что все <code>InputStream</code>, <code>OutpuStream</code> являются ресурсами и их нужно правильно и успешно высвобождать. Вот как раз для этого и нужно нам использовать <code>try-with-resource</code> конструкцию. 

Вот как она выглядит:

<pre class="lang-java line-numbers"><code>
private void unzipFile(File zipFile) throws IOException {
   try(ZipInputStream zipOutputStream = new ZipInputStream(new FileInputStream(zipFile))) {
       ZipEntry zipEntry = zipOutputStream.getNextEntry();
       while (zipEntry != null) {
          
       }
   }
}

private void saveZipEntry(ZipEntry zipEntry) {
   // логика сохранения
}
</code></pre>
Вот этом примере ресурс — это <code>ZipInputStream</code>, после работы с которым нужно будет закрыть его. И чтоб не думать о том, что нужно вызвать метод <code>close()</code>, мы просто определяем эту переменную в блоке try, как показано в примере и в рамках этого блока выполняем все необходимое. Что делает пример? Он разархивирует zip архив. Для этого нужно воспользоваться <code>InputStream</code>’ом.

Определять можно больше одной переменной, разделяют их точкой с запятой.

А в чем проблема? Но ведь можно использовать <code>finally</code> блок, — возможно, скажете вы. Вот <a href="https://habr.com/ru/post/178405/" rel="nofollow" target="_blank">статья</a>, в которой подробно описываются проблемы с этим подходом. Также в ней описывается весь перечень неудач, которые могут постигнуть того, кто пренебрежет использованием этой конструкции. Рекомендую к прочтению ;)

В <a href="https://javarush.com/groups/posts/2597-top-50-java-core-voprosov-i-otvetov-na-sobesedovanii-chastjh-3" target="_blank">завершающей части</a> — вопросы/ответы по теме Multithreading.

<a href="https://github.com/romankh3" rel="nofollow" target="_blank">Мой профиль на GitHub</a>