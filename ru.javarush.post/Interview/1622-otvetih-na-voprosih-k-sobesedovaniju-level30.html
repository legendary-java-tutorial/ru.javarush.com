Уровень 30. Ответы на вопросы к собеседованию по теме уровня
<p>----------------------------------------</p>
NaN (англ. Not-a-Number) — одно из особых состояний числа с плавающей запятой. Используется во многих математических библиотеках и математических сопроцессорах. Данное состояние может возникнуть...
<p>----------------------------------------</p>

<img data-id="763f25d4-4ead-4029-8dca-a0c06cb75d82" data-max-width="850" alt="Уровень 30. Ответы на вопросы к собеседованию по теме уровня - 1" src="https://cdn.javarush.com/images/article/763f25d4-4ead-4029-8dca-a0c06cb75d82/1024.jpeg"><ol><li><p><strong>Что такое NaN?</strong></p><p><strong>NaN</strong> (англ. Not-a-Number) — одно из особых состояний числа с плавающей запятой. Используется во многих математических библиотеках и математических сопроцессорах. Данное состояние может возникнуть в различных случаях, например, когда предыдущая математическая операция завершилась с неопределённым результатом, или если в ячейку памяти попало не удовлетворяющее условиям число.</p>

<p>В соответствии с IEEE 754, такое состояние задаётся через установку показателя степени в зарезервированное значение 11…11, а мантиссы — во что угодно, кроме 0 (зарезервированное значение для машинной бесконечности). Знак и мантисса могут нести какую-то дополнительную информацию: многие библиотеки «отрицательный» NaN выводят как -NaN.</p>

<p>К операциям, приводящим к появлению NaN в качестве ответа, относятся:</p><ul>
<li>все математические операции, содержащие NaN в качестве одного из операндов;</li>
<li>деление нуля на нуль;</li>
<li>деление бесконечности на бесконечность;</li>
<li>умножение нуля на бесконечность;</li>
<li>сложение бесконечности с бесконечностью противоположного знака;</li>
<li>вычисление квадратного корня отрицательного числа[1];</li>
<li>логарифмирование отрицательного числа.</li>
</ul><p>В некоторых языках программирования есть «тихий» и «сигнальный» NaN: первый, попав в любую операцию, возвращает NaN, второй — вызывает аварийную ситуацию. Обычно «тихий» или «сигнальный» определяется старшим битом мантиссы.</p>

<p>NaN не равен ни одному другому значению (даже самому себе[2]); соответственно, самый простой метод проверки результата на NaN — это сравнение полученной величины с самой собой.</p>

<p>Поведение других операций сравнения зависит от языка. Одни языки дают ложь[3] (так что a < b и b > a по-разному ведут себя с NaN), другие — выбрасывают аварию даже для «тихого» NaN.</p>

<p>Любая нетривиальная операция, принимающая «тихий» NaN как аргумент, всегда возвращает NaN вне зависимости от значения других аргументов. Единственными исключениями из этого правила являются функции max и min, которые возвращают значение «второго» аргумента (отличного от NaN).
Тривиальные операции, являющиеся тождеством, обрабатываются особо: так, например, 1NaN равно 1.</p></li>
<li><p><strong>Как получить бесконечность в Java?</strong></p><p>В Java тип <code>double</code> имеет специальные значения для понятий «плюс бесконечность» и «минус бесконечность». Положительное число, разделенное на 0.0, дает «плюс бесконечность», а отрицательное – «минус бесконечность».
Этим понятиям соответствуют специальные константы типа <code>Double</code>:</p>
<table>
<tr>
<th>Код</th><th>Описание</th>
</tr>
<tr><td><code>public static final double POSITIVE_INFINITY = 1.0 / 0.0;</code></td><td>плюс бесконечность</td></tr>
<tr><td><code>public static final double NEGATIVE_INFINITY = -1.0 / 0.0;</code></td><td>минус бесконечность</td></tr>
</table><ol>
<li>Строку конвертируем в число, а в ней есть буквы. Ответ — NaN</li>
<li>Бесконечность минус бесконечность. Ответ — NaN</li>
<li>Многие другие ситуации, где в ответе ждут число, а получается неизвестно что.</li>
</ol>
<p>Любая операция, где есть NaN, дает в результате NaN.</p>
<table>
<tr><th colspan="2">Действия с бесконечностью:</th><tr>
<tr><td>Выражение</td><td>Результат</td></tr>
<tr><td>n ÷ ±Infinity</td><td>0</td></tr>
<tr><td>±Infinity × ±Infinity</td><td>±Infinity</td></tr>
<tr><td>±(не ноль) ÷ </td><td>±Infinity</td></tr>
<tr><td>Infinity + Infinity</td><td>Infinity</td></tr>
<tr><td>±0 ÷ ±0</td><td>NaN</td></tr>
<tr><td>Infinity - Infinity</td><td>NaN</td></tr>
<tr><td>±Infinity ÷ ±Infinity</td><td>NaN</td></tr>
<tr><td>±Infinity × 0</td><td>NaN</td></tr></table></li><li><p><strong>Как проверить, что в результате вычисления получилась бесконечность?</strong></p><p>Есть ответ на <a href='http://stackoverflow.com/questions/12952024/how-to-implement-infinity-in-java' rel='nofollow' target='_blank'>StackOverFlow</a>. </p>

<p>Все сводится к выводу <code>System.out.println()</code></p></li>
<li><p><strong>Что такое битовая маска?</strong></p><p><strong>Битовая маска</strong> — это когда хранится много различных логических значений (true/false) в виде одного целого числа. При этом каждому boolean-значению соответствует определенный бит.</p></li>
<li><p><strong>Где применяют битовые маски?</strong></p><p>В основном там, где надо компактно хранить много информации об объектах. Когда хранишь много информации об объекте, всегда наберется пара десятков логических переменных. Вот их всех удобно хранить в одном числе. Именно хранить. Т.к. пользоваться им в работе не так уж удобно.</p></li>
<li><p><strong>Как установить бит в единицу в битовой маске?</strong></p><p>Опираясь на лекции можно ответить таким кодом:</p>

<p>Здесь использовал метод <code>Integer.toBinaryString()</code>, дабы проверить себя, а вдруг)</p>

<pre class='lang-java line-numbers'><code>
public class BitMask {

    public static void main(String[] args) {
        int a = 9;

       a |= (1<<2); // установить в 1 бит 2


        System.out.println(Integer.toBinaryString(a) + " "+ a);
    }
}
</code></pre>
<p><strong>Вывод такой:</strong><br />
<br />
<code>1101 13</code></p></li>
<li><p><strong>Как установить бит в ноль в битовой маске?</strong></p>
<pre class='lang-java line-numbers'><code>
public class BitMask {

public static void main(String[] args) {
int a = 15;

a &= ~(1<<2); // установить в 0 бит 2
System.out.println(Integer.toBinaryString(a) + " "+ a);

    }
}
</code></pre>
<p><strong>Вывод:</strong><br />
<br />
<code>1011 11</code></p>

<p>Я взял число 15, так как на нем более наглядно видно, куда устанавливается 0.</p></li>
<li><p><strong>Как получить значение определенного бита в битовой маске?</strong></p>
<pre class='lang-java line-numbers'><code>
public class BitMask {

public static void main(String[] args) {
     int a = 15;

     a &= ~(1<<2); // установить в 0 бит 2

     int c = a & (1<<2); // узнаем про 2 бит
     int d = a & (1<<3); // узнаем про 3 бит
    System.out.println(Integer.toBinaryString(a) + " "+ a + " " + c +" "+ d);

    }
}
</code></pre>
<p><strong>Вывод: </strong><br />
<br />
<code>1011 11 0 8</code></p>

<p>C 0 все понятно, на том месте и вправду 0. А переменная d возвращает значение запрашиваемого бита (в 10-ой системе).</p></li>
<li><p><strong>Что такое ленивое вычисление выражения?</strong></p><p>Статья: <a href='https://www.ibm.com/developerworks/ru/library/l-lazyprog/' rel='nofollow' target='_blank'>Ленивое программирование и ленивые вычисления</a></p>

<p>Это ленивые вычисления (lazy evaluation). В ленивых вычислениях ни один параметр не вычисляется, пока в нем нет необходимости. Программы фактически начинаются с конца и работают от конца к началу. Программа вычисляет, что должно быть возвращено, и продолжает движение назад, чтобы определить, какое значение для этого требуется. В сущности каждая функция вызывается с promise'ами для каждого параметра. Когда для вычисления необходимо значение, тогда выполняется promise. Поскольку код выполняется только тогда, когда необходимо значение, это называется вызов по необходимости (call-by-need). В традиционных языках программирования вместо promise'ов передаются значения, это называется вызов по значению(call-by-value).</p>

<p>Технология программирования "вызов по необходимости" имеет ряд преимуществ. Потоки имплементируются автоматически. Ненужные значения никогда не вычисляются. Однако, поведение ленивых программ часто трудно предсказать. В программах типа "вызов по значению" порядок вычисления довольно предсказуем, поэтому любые time- или sequence-based вычисления относительно легко имплемнтировать. В ленивых языках, где специальные конструкции, например, monads, необходимы для описания явно упорядоченных событий, это намного труднее. Все это также делает связь с другими языками более трудной.</p>

<p>Существуют языки программирования, например, Haskell и Clean, использующие ленивое программирование по умолчанию. Кроме того, для некоторых языков, таких как Scheme, ML и другие, существуют ленивые версии.</p>

<p>Иногда, откладывая вычисления до тех пор, пока не понадобится их значение, вы можете оптимизировать скорость выполнения программы или реструктурировать программу в более понятную форму. Несмотря на свою ценность, методы ленивого программирования не слишком широко используются или даже не очень известны. Подумайте о том, чтобы добавить их в ваш арсенал.</p></li>
<li><p><strong>Чем отличается использование <code>&&</code> и <code>&</code> для типа <code>boolean</code>?</strong></p><p><code>&&</code> — это логическое «и». (В этом случае имеют место ленивые вычисления: некоторые вычисления опускаются, когда результат и так ясен)</p>

<p><code>&</code> — это побитовое «и» (Если применить этот оператор к переменным типа Boolean,  то ленивых вычислений происходить не будет)</p></li>
</ol>