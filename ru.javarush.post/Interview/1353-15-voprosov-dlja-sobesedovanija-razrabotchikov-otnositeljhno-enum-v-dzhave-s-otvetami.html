15 вопросов для собеседования разработчиков, относительно Enum в Джаве (с ответами!)
<p>----------------------------------------</p>
Перечисление (Enum) было введено в Java 5 и с тех пор оно стало весьма популярно среди разработчиков Java. Оно широко используется в различных Java-приложениях.
<p>----------------------------------------</p>
Перечисление (<strong>Enum</strong>) было введено в <em>Java 5</em> и с тех пор оно стало весьма популярно среди разработчиков Java. Оно широко используется в различных Java-приложениях. Поскольку Enum в Java намного универсальнее, чем в C или C ++, оно также представляет множество интересных вариантов использования, пару из которых, вы видели в статье <a href="http://javarevisited.blogspot.com/2011/08/enum-in-java-example-tutorial.html" rel="nofollow" >10 способов использовать Enum в Java</a>. 

Но, несмотря на такую популярность, многие Java-программисты по-прежнему не знают о функциональности, предоставляемой Enum и тонкостей использования Enum в Java коде.<cut> Это стало  понятно из вопросов нескольких читателей, спрашивающих, например, о <em>возможности Enum реализовать интерфейс в Java</em> или <em>Почему мы не можем создать экземпляры Enum за пределами Enum</em>, отметив, что об этом их спрашивали на собеседовании. Это подвигло на сбор <strong>списка часто задаваемых вопросов в Java Enum</strong>, которые не только помогают преуспеть в интервью, но и открыть новые пути для обучения. Как говорилось раньше, часто вопросы на собеседовании заставляют вас воспринимать тему более серьёзно, что не так уж плохо, и, учитывая мощь и полезность Enum, пора уже вам стать мастером перечислений.

Ниже список вопросов, основанный на различном функционале и свойствах Enum. Вы можете использовать его как подготовительный материал к собеседованию или просто справочник по перечислениям. Ежели вы новичок в Java, то почерпнёте для себя много нового и полезного о Enum.<cut>

<strong>1) Может ли  Enum наследовать (implement) интерфейс в Java?</strong>
Да, <u>Enum может наследовать интерфейсы</u>. Поскольку Enum тип схож с <em>классом</em> и <em>интерфейсом</em>, он может наследовать интерфейс. Это даёт поразительную гибкость в использовании Enum в качестве специальной реализации в некоторых случаях. <a href="http://javarevisited.blogspot.com/2011/08/enum-in-java-example-tutorial.html" rel="nofollow" >Вот</a> неплохой пример использования Enum в таком качестве.

<strong>2) Может ли Enum наследовать (extends) класс?</strong>
Нет, не может! Неожиданно, поскольку ранее говорилось что Enum тип похож на класс или интерфейс в Java. Ну, это главная причина, почему такой вопрос задают сразу за предыдущим. Поскольку <u>Enum уже наследуется от абстрактного класса</u> <em>java.lang.Enum</em>, понятно, что другой класс наследовать не удастся, поскольку Java не поддерживает множественное наследование классов. Благодаря наследованию от <em>java.lang.Enum</em>, все перечисления имеют методы <em>ordinal()</em>, <em>values()</em> или <em>valueOf()</em>.

<strong>3) Как создать Enum без экземпляров объектов? Возможно ли это без ошибки компиляции?</strong>
Это один из тех <em>хитрых вопросов</em>, которые так любят интервьюеры. Поскольку Enum видится коллекцией определённого количества объектов, как <em>дни недели</em> или <em>месяцы в году</em> получить <em>Enum без ничего</em> кажется подозрительным. Но да, вы <u>можете создать Enum без экземпляров</u>, например создавая утилитарный класс. Это ещё один инновационный способ использовать Enum:
<code>public enum MessageUtil{
;  // required to avoid compiler error, also signifies no instance

public static boolean isValid() {
        throw new UnsupportedOperationException("Not supported yet.");
}

}
</code>
<strong>4) Можем ли мы переопределить метод toString() для Enum? Что будет, если не будем переопределять?</strong>
Конечно вы можете переопределить метод <strong>toString()</strong>  у Enum, как и любого класса, наследующего <em>java.lang.Object</em> и имеющего  метод <em>toString()</em> в доступности, и даже если вы не станете этого делать, ничего не потеряете, поскольку абстрактная основа класса  Enum сделает это за вас, и вернёт имя, являющееся именем экземпляра  Enum. Вот код метода <em>toString()</em> из класса  Enum:
<code>public String toString() {
        return name;
 }</code>

<em>name</em> задано, когда компилятор выделяет код для создания перечисления в ответ на создание экземпляра в самом классе Enum, наравне с созданием порядкового числительного в конструкторе из класса <em>java.lang.Enum</em>:
<code>protected Enum(String name, int ordinal) {
        this.name = name;
        this.ordinal = ordinal;
}</code>
Это <u>единственный конструктор для создания перечисления</u>, который вызывается компилятором в ответ на декларирование Enum в программе.

<strong>5) Можем ли мы создать экземпляр Enum вне Enum? Почему нет?</strong>
Вы <u>не можете создавать экземпляры Enum вне границ Enum</u>, поскольку у Enum нет <em>public</em> конструктора, и компилятор не позволит вам внести любой подобный конструктор. Так как компилятор генерирует большинство кода в ответ на декларацию Enum типа, он не допускает <em>public</em> конструкторов внутри Enum, что заставляет объявлять экземпляры Enum внутри себя.

<strong>6) Можем ли мы указать конструктор внутри Enum?</strong>
Этот вопрос часто следует за предыдущим. Да, вы можете, но помните, что подобное возможно лишь с указанием <em>private</em> или <em>package-private</em> конструкторов. Конструкторы с <em>public</em> и <em>protected</em> — не допустимы в Enum. Вот <a href="http://java67.blogspot.com/2012/11/java-enum-example-with-constructor.html" rel="nofollow" >тут</a> можно посмотреть пример.

<strong>7) Какая разница сравнивать Enum при помощи == или метода equals()?</strong>
Это очень обширный и хитрый вопрос, который рассматривается подробно <a href="http://javarevisited.blogspot.com/2013/04/how-to-compare-two-enum-in-java-equals.html" rel="nofollow" >здесь</a>.

<strong>8) Что делает метод ordinal() в Enum?</strong>
Метод <strong>ordinal()</strong> (порядковый) возвращает порядок, в котором экземпляры Enum обозначены внутри Enum. Например, в <em>DayOfWeek</em> Enum, вы можете указать дни по порядку:
<code>public enum DayOfWeek{
  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
}
</code>
и если мы вызовем метод <em>DayOfWeek.MONDAY.ordinal()</em>,  он вернёт 0 - что значит первый экземпляр. Этот метод весьма полезен для предоставления порядка в соответствии с реальным положением вещей: т. е. указывая, что <em>TUESDAY</em> (вторник) идёт после <em>MONDAY</em> (понедельника), и перед <em>WEDNESDAY</em> (средой). Точно так же вы можете использовать перечисление для представления месяцев года, где Февраль идёт после Января, но предшествует Марту. Все пользовательские перечисления наследуют этот метод из абстрактного класса <em>java.lang.Enum</em>, и они устанавливаются компилятором, вызывая <em>protected</em> конструктор из <em>java.lang.Enum</em>, который принимает имя и порядковый номер.

<strong>9) Можно использовать Enum с TreeSet или TreeMap в Java?</strong>
Это действительно интересный вопрос по Enum, и его любят задавать для проверки глубины знаний. Пока вы не загляните в код <em>java.lang.Enum</em>, вы скорей всего не будете знать, что <strong>Enum наследует интерфейс Comparable</strong>, который является главным требованием для использования в упорядоченных коллекциях, как <em>TreeSet</em> и <em>TreeMap</em>. Поскольку Enum по умолчанию наследует интерфейс <em>Comparable</em>, он может использоваться с <em>TreeSet</em> и <em>TreeMap</em>.

<strong>10) Какая разница между ordinal() и compareTo() в Enum?</strong>
Это прямое следование из предыдущего вопроса: на самом деле, <strong>compareTo()</strong> имитирует порядок, предоставляемый методом <strong>ordinal()</strong>, являющийся естественным порядком Enum. Если коротко, Enum ограничивает сравнения в порядке их объявления. Так же, стоит помнить, что данные константы сравнимы только с другими константами того же типа — сравнение разных типов констант может привести к ошибке компилятора.

<strong>11) Можно ли использовать Enum в switch case?</strong>
Да, вы можете. Мало того, это одна из главных полезностей использования Enum. Поскольку экземпляры Enum компилируют временную константу, вы можете без опаски внедрять их внутрь <a href='https://javarush.com/groups/posts/1832-operator-switch-v-java' target='_blank'>case и switch</a>. Вот например код с днями недели:
<code>public void developerState(DayOfWeek today){
        switch(today){
            case MONDAY:
                System.out.println("Hmmmmmmmm");
                break;
            case TUESDAY:
                System.out.println("Hmmmm");
                break;
            case FRIDAY :
                System.out.println("Yeahhhhhh");
                break;
        }     
}</code>

Enum и Switch отлично дополняют друг друга, в особенности если Enum содержит небольшое количество устойчивых констант, например, семь дней недели, 12 месяцев года и т. д. Посмотрите на другие примеры использования <a href="http://java67.blogspot.com/2012/09/how-to-use-java-enum-in-switch-case-example.html" rel="nofollow" ><em>swith case</em> с Enum</a>.

<strong>12) Как пройтись по всему экземпляру Enum?</strong>
Если вы открывали <em>java.lang.Enum</em>, то знаете, что метод <strong>values()</strong> возвращает массив всех констант Enum. Поскольку каждое перечисление наследует <em>java.lang.Enum</em>, они имеют метод <em>values()</em>. Используя его, вы можете пройтись по всем константам перечисления определённого типа. Посмотрите на <a href="http://java67.blogspot.com/2013/03/how-to-iterate-over-java-enum-using.html" rel="nofollow" >примеры</a> такого проходя с циклом <em>foreach</em> и методом <em>values()</em>.

<strong>13) Какие плюсы и минусы использования Enum в качестве синглтона?</strong>
Enum предоставляет <em>быстрый ярлык</em> для воплощения паттерна синглтона, и поскольку об этом сказано даже в книге «Эффективная Java», такой выбор весьма популярен. На первый взгляд, синглтон Enum многообещающ и весьма удобен, например  контролирует создание экземпляра, безопасно сериализуется и прежде всего, легко создать потокобезопасный синглтон с использованием Enum. Вам не нужно больше заботиться о двойной проверке волатильности переменных. Более подробно о плюсах и минусах использования такого подхода <a href="http://javarevisited.blogspot.com/2012/07/why-enum-singleton-are-better-in-java.html" rel="nofollow" >тут</a>.

<strong>14) Какая выгода использовать Enum вместо паттернов перечисления int и перечисления String?</strong>
Если вы программируете более 5 лет, и ещё застали JDK 1.3 или 1.4, вы будете на короткой ноге с <em>паттернами перечисления String и int</em>, где используется <em>public static final</em> префикс констант для представления коллекции общеизвестных фиксированных количеств вещей, как <em>Дни Недели</em>. Тут возникает множество проблем: у вас нет независимости типа Enum, поскольку переменная <em>String</em> отвечающая за день недели может принимать любое произвольное значение. Точно так же перечисляемый <em>int</em> может принимать любое значение, и компилятор спокойно проглотит это. А с использованием <em>Enum</em>, вы получаете безопасность типов, которые компилятор проверяет для вас. На эту тему есть несколько интересных мыслей в «Эффективная Java», которую рекомендуется прочитать всем разработчикам на Java.

<strong>15) Как преобразовать String в Enum?</strong>
Это ежедневный вопрос, встающий из-за популярности применения <em>String</em> и <em>Enum</em> в разработке приложений Java. Лучший способ преобразовать <u>Enum в String</u>, это определить фабричный метод в самом Enum, который будет брать аргументы <em>String</em> и возвращать в качестве <em>Enum</em>. Вы так же можете пожелать игнорировать регистр. Вот несколько <a href="http://java67.blogspot.com/2012/08/how-to-create-enum-from-string-in-java.html" rel="nofollow" >примеров</a> по превращению строк в перечисления.

Вот  и подошёл к концу наш список из 15 вопросов (<em>и ответов</em>) о Enum. <strong>Но помните:</strong> <u>чтения не достаточно для обучения, это только первый шаг</u>. Что бы получить выгоду от перечислений, попытайтесь найти, где можно использовать Enum в вашем проекте — это даст вам реальный опыт, и с этим опытом вы выучите больше, чем на примерах, поскольку встретите больше проблем, справляясь с которыми, обработаете более сложные и подробные требования. На эти <em>вопросы о Enum</em> стоит обратить внимание для тестирования ваших знаний, особенно если вы спешите на собеседование, и времени на детальное погружение во вселенную Enum просто нет.