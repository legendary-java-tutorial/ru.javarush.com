Java. Справочное руководство для интервью - Часть 1. (Перевод статьи)
<p>----------------------------------------</p>
Исходная статья находится по адресу:
http://www.javacodegeeks.com/2014/02/java-interview-reference-guide-part-1.html

Опубликовал: Nitin Kumar, в Core Java, 
<p>----------------------------------------</p>
Исходная статья находится по адресу:
<a href="http://www.javacodegeeks.com/2014/02/java-interview-reference-guide-part-1.html" rel="nofollow" >http://www.javacodegeeks.com/2014/02/java-interview-reference-guide-part-1.html</a>

Опубликовал: Nitin Kumar, в Core Java, 3 февраля 2014 г

<h4>Java. Объектно-Ориентированная концепция.</h4>

Java основывается на объектно-ориентированной концепции, которая дает более высокий уровень абстракции для решения любой проблемы реальным способом.


Объектно-Ориентированный подход концептуализирует решение проблемы в объектах реального мира, которые проще повторно использовать в приложениях. Например: стул, вентилятор, собака, компьютер и т.д.


В Java, класс - это документация, шаблон или прототип, который определяет общее поведение объектов того же вида. Экземпляр является реализацией определенного класса, и все экземпляры класса имеют аналогичные свойства, как представлено в описании класса. Например, вы можете определить класс, который называется Дом, с числом комнат, как атрибутом, и создать объекты: дом с 2 комнатами, дом с 3 комнатами и т.д.

<h6>Преимущества:</h6>

Ниже перечислено несколько преимуществ разработки объектно-ориентированного программного обеспечения:

<ul>
    <li>Меньше затрат на обслуживание, главным образом благодаря модульности.</li>
    <li>Код легче повторно использовать за счет таких функций, как наследование, что как следствие ускоряет разработку.</li>
    <li>Повышается надежность и гибкость кода.</li>
    <li>Код легче понять, это обусловлено моделированием реального мира.</li>
    <li>Лучшая абстракция на объектном уровне.</li>
    <li>Уменьшение сложности перехода от одной стадии разработки к другой.</li>
</ul>

<h5>Существуют четыре основных понятия ООП:</h5>

<ul>
    <li>Инкапсуляция</li>
    <li>Наследование</li>
    <li>Полиморфизм</li>
    <li>Абстракция</li>
</ul>

<h5>Инкапсуляция:</h5>

Инкапсуляция представляет собой правила для других объектов, которые указывают, какие элементы скрыты, а какие открыты для доступа другим объектам. В Java мы используем модификатор доступа private для того, чтобы скрыть метод и ограничить доступ к переменной из внешней среды. Java также предусматривает различные модификаторы доступа, такие как public, который устанавливается по-умолчанию, protected и private, которые используются для ограничения видимости на различных уровнях, но конечная цель инкапсуляции - это скрыть те элементы, которые не должны изменяться. На практике лучше всего, когда класс имеет только одну причину для изменения, и инкапсуляция реализует принципы проектирования этой <strong>"одной причины"</strong>.

На практике, в Инкапсуляции предполагается сокрытие методов, чтобы избежать нарушения работы других классов.

<h6>Преимущества:</h6><cut>

Ниже перечислены несколько преимуществ инкапсуляции:

<ul>
    <li>Вы можете защитить внутреннее состояние объекта, скрывая его атрибут.</li>
    <li>Это повышает модульность кода, предотвращая взаимодействия между объектами самым неожиданным образом.</li>
    <li>Увеличивается удобство использования.</li>
    <li>Поддерживаются условия конкретного объекта.</li>
    <li>Инкапсуляция облегчает поддержку ПО</li>
    <li>Изменения кода могут быть независимыми</li>
</ul>

<h5>Полиморфизм:</h5>

Полиморфизм - это способность (в программировании) представить тот же интерфейс для различных форм (типов данных), лежащих в основе. Это означает, что классы имеют различную функциональность, несмотря на то, что используют общий интерфейс и могут быть вызваны динамически через специальную ссылку класса. 

Классическим примером является класс Shape (фигура), и все классы, которые могут наследоваться от него (квадрат, круг, додекаэдр, неправильный многоугольник, знак и т.д.).


В этом примере, каждый класс будет иметь свою собственную функцию Draw() и клиентский код может выполнять следующие действия:

<code>Shape shape = new Square();
Shape.area()  чтобы получить корректное поведение для любой формы.
</code>

Прелесть полиморфизма в том что код работает с различными классами и нет необходимости знать какой класс его использует, т.к. все они работают по одному принципу.

Процесс, используемый Объектно-Ориентированными языками программирования, реализующий динамический полиморфизм, называется динамическим связыванием.

<strong>Примечание:</strong> Полиморфизм - это возможность выбора более специализированных методов в зависимости от выполнения вызванного объекта. Полиморфизм так же может использоваться без участия каких-либо абстрактных классов.

<h6>Преимущества:</h6>

<ul>
    <li>Создается код, используемый повторно: это значит, что если однажды созданы классы, реализованы и протестированы, то они могут быть легко использованы, не заботясь о том, что написано в классе.</li>
    <li>Это обеспечивает более общий и слабосвязанный код.</li>
    <li>Время компиляции значительно уменьшается, а разработка становится быстрее.</li>
    <li>Динамическое связывание: Один и тот же интерфейс может быть использован для создания методов с различными реализациями.</li>
    <li>Полная реализация может быть заменена с помощью сигнатуры метода.</li>
</ul>

<strong>Переопределение метода для достижения Полиморфизма:</strong> Переопределение интерфейсов с двумя методами: Один в родительском классе, а другой в дочернем классе с такими же именами и сигнатурами.

Переопределение позволяет определить ту же самую операцию по-разному для разных типов данных

Например:

<code>while(it.hasNext())
{
    Shape s = (Shape) it.next();
    totalArea += s.area(dim);  //полиморфический вызов метода. Будет вызван правильный объект. 
}
</code>

<img data-max-width="162" alt="Java. Справочное руководство для интервью - Часть 1. (Перевод статьи) - 1" src="https://cdn.javarush.com/images/article/a9c4239a-ed0d-4dd0-935b-be8f731aac56/original.jpeg">

<h5>Перегрузка метода или Специальный полиморфизм или статический полиморфизм:</h5>

Перегрузка интерфейсов с несколькими методами в том же классе с тем же именем, но с другим телом метода. Перегрузка метода позволяет определить ту же операцию по-разному для различных данных. Какое-то время она называлась статическим полиморфизмом, но на самом деле это не полиморфизм.

Перегрузка методов является не более чем двумя методами, с одинаковыми именами, но различными списками аргументов. Она не имеет ничего общего с наследованием и полиморфизмом. Перегруженный метод, это не то же самое, что и переопределенный метод. [Глава первая Java]

<h5>Параметрический полиморфизм с использованием дженериков в Java:</h5>

При объявлении класса, имя поля можно связать с различными типами и имя метода так же можно ассоциировать с различными параметрами и возвращаемыми типами. Java поддерживает параметрический полиморфизм с использованием дженериков.
 
Примером является список, который может принимать тип данных, содержащих дженереки.

<code>List<String> list = new ArrayList<String>();
</code>

<h5>Почему мы не можем переопределить статический метод в Java?</h5>


Переопределение зависит от наличия экземпляра класса. Смысл полиморфизма заключается в том, что вы можете создать подкласс класса и объект реализует этот подкласс, будет разное поведение одних и тех же методов, определенных в суперклассе (или переопределенных в подклассе). Статический метод не связан с каким-либо экземпляром класса, так что это понятие к нему не применяется.

Ранее выдвигались две основные идеи, продвижения разработки на Java, которые повлияли на неё. Одна из них - это отношение к производительности: было много критики со стороны Smalltalk о том, что JVM работала слишком медленно (из-за сбора мусора и полиморфных вызовов, которые были частью этой причины) и разработчики Java были вынуждены исправить это. Другая состояла в том, что целевая аудитория для Java - это были разработчики C++. Вызов статических методов устроен знакомым для программистов C++ образом и работает так же быстро, потому что нет пути вверх по иерархии классов, и чтобы выяснить, какой метод нужно вызвать, ты отправляешься прямо в класс и вызываешь указанный метод. [Stack overflow]

<h5>Наследование:</h5>

Оно включает поведения (т.е. методы) и состояния (т.е. переменные) базового класса в производный класс, таким образом, чтобы они были доступны в этом производном классе. Ключевое преимущество наследования состоит в том, что оно обеспечивает формальный механизм повторного использования кода и позволяет избежать дублирования.

Унаследованный класс расширяет функциональность приложения, повторно используя родительское поведение и добавляя новую функциональность. Это сделает проектирование плотно связанным, потому что если вы хотите изменить суперкласс, вы должны знать все детали подклассов, чтобы избежать поломки приложения.

Это форма повторного использования ПО, когда новый класс (подкласс) создается из уже существующего класса (суперкласса) и расширяет свою функциональность, при этом используя некоторые свойства суперкласса.

Итак, если у вас есть класс-родитель, а потом у вас появляется класс-наследник, то наследник наследует все сущности, которыми обладает родитель.

<h6>Преимущества:</h6>

<ul>
    <li>Легче повторно использовать код</li>
    <li>Устанавливается логическое отношение "Является кем-то", Например: Собака является животным.</li>
    <li>Код становится модульным</li>
    <li>Позволяет избегать дублирования</li>
</ul>

<h6>Недостатки:</h6>

<ul>
    <li><strong>Тесная связь:</strong> подкласс зависит от реализации родительского класса, что делает код тесно связанным.</li>
</ul>

<h5>Абстракция:</h5>

Абстракция представляет собой разработку класса из условий интерфейсов и их функциональности, не учитывая детали их реализации. Абстрактный класс включает интерфейсы без фактической реализации. Он отделяет реализацию объекта от поведения или реализации. Абстракция упрощает разработку, скрывая несущественные детали.

<h6>Преимущества:</h6>

<ul>
    <li>При использовании абстракции, мы можем выделить объекты, которые могут быть сгруппированы в другой тип.</li>
    <li>Часто изменения свойств или методов могут быть сгруппированы в отдельный тип, причем главный тип останется без изменений. Это усиливает принцип Объектно-Ориентированного Анализа и Дизайна - "Код должен быть открыт для расширения, но закрыт для модификации".</li>
    <li>Упрощает представление моделей предметной области.</li>
</ul>

<h5>Различия между абстракцией и инкапсуляцией</h5>

Инкапсуляция - это стратегия, используемая в рамках абстракции. Инкапсуляция относится к состоянию объектов - объекты инкапсулируют свое состояние и скрывают его от доступа извне; снаружи пользователи класса могут взаимодействовать с его методами, но не могут получить доступ к составляющим класса напрямую. Таким образом класс абстрагирует детали реализации, относящиеся к его состоянию.

Абстракция - это более общий термин; ее так же можно достигнуть путем использования подклассов (среди прочих). Например, список классов в стандартной библиотеке - это абстракция для последовательности элементов, проиндексированных по их позиции, конкретными примерами List'а будут ArrayList или LinkedList. Код, который взаимодействует со списком абстракций более детален, чем вид используемого списка. [Stack overflow]

Абстракция часто невозможна, без скрытия инкапсуляцией деталей, лежащих в основе - если класс предоставляет свое внутреннее состояние, он не может изменить свою внутреннюю работу, и, следовательно, не может абстрагироваться.

<h5>Что такое абстрактный класс и абстрактный метод?</h5>

В проектировании, вы хотите, чтобы базовый класс представлял только интерфейс для своих производных классов. Это значит, вы не хотите, чтобы кто-нибудь создавал экземпляр объекта этого класса. Вы только хотите, чтобы было приведение к типу (неявное приведение к базовому типу, которое дает вам полиморфное поведение), так что этот интерфейс может быть использован. Это достигается путем указания класса абстрактным, при этом используется ключевое слово abstract.

Существуют некоторые ограничения: нельзя создать экземпляр абстрактного класса, следует использовать только тот класс, который реализует абстрактные методы. И обеспечивает полиморфизм.

Абстрактный класс может содержать как абстрактные методы, так и конкретные методы. В классе, если один метод объявлен абстрактным, класс должен быть объявлен абстрактным. Однако, обратное не всегда верно. Если класс объявлен как абстрактный, он может не иметь абстрактных методов в нем.

Если метод не обеспечивает фактическую реализацию, но обеспечивает сигнатуру метода, он называется абстрактным методом. Фактическая реализация возлагается на подклассы, которые расширяют абстрактный класс.

Абстрактный метод не может быть реализован; только другой класс может наследоваться от него.

<h5>Когда используется абстрактный класс?</h5>

Абстрактные классы помогают определить некоторые типы поведения по умолчанию и обеспечить подклассам какое-то конкретное поведение.

Например: List - это интерфейс, в то время как AbstractList реализует поведение по умолчанию List'а, который может быть использован как есть или может быть реализован в подклассе, например как ArrayList.

<h5>Что такое Интерфейс?</h5>

Ключевое слово interface перенимает концепцию абстрактного класса дальше, препятствуя реализации любого метода или функции для всех. Вы можете только объявить метод или функцию, но не обеспечить реализацию. Класс, который реализует интерфейс, должен обеспечивать фактическую реализацию. Интерфейс является крайне эффективным и широко используемым аспектом в Объектно-Ориентированном проектировании, так как он обеспечивает <strong>разделение интерфейса и реализации, и позволяет:</strong>

<h6>Преимущества интерфейсов:</h6>

<ul>
    <li>Множественное наследование</li>
    <li>Свободные парно-определенные абстракции операций, как отдельный тип реализации, могут быть чем угодно: JDBC, JPA, JTA, и т.д.</li>
    <li>Интерфейс программы не реализуется.</li>
    <li>Полиморфизм с динамическим связыванием - выявляет объект программного интерфейса, не раскрывая его фактической реализации.</li>
    <li>Абстрактный уровень: Проблемы разделения</li>
</ul>

<h6>Разница между интерфейсом и абстрактным классом:</h6>

<ul>
    <li>Интерфейс представляет собой соглашение, по которому опрашиваются классы, реализующие интерфейс, как они определяют этот интерфейс. Это пустая оболочка с объявлением метода.</li>
    <li>Абстрактный класс определяет некоторое общее поведение и задает подклассу свойство определить редкое или специфичное поведение для этого класса.</li>
    <li>Методы и члены абстрактного класса могут быть определены с любым типом видимости, в то время как все методы интерфейсов должны быть определены как public.</li>
    <li>При наследовании от абстрактного класса, дочерний класс должен определить абстрактные методы, в то время как интерфейс может расширять другой интерфейс и методы не должны быть определены.</li>
    <li>Дочерний класс может наследоваться только от одного абстрактного (или любого другого) класса, в то время как интерфейс или класс может наследоваться от нескольких других интерфейсов.</li>
    <li>Дочерний класс может реализовать абстрактные методы с тем же самым или менее ограниченным уровнем видимости, в то время как класс, реализующий интерфейс должен определить методы с тем же уровнем видимости.</li>
    <li>Интерфейс не может содержать конструкторы, в отличии от Абстрактного класса.</li>
    <li>Переменные, объявленные в интерфейсе Java по умолчанию имеют модификатор доступа final. Абстрактный класс может содержать переменные не только с модификатором final.</li>
    <li>Методы интерфейса в Java имеют модификатор доступа public по умолчанию. Абстрактный класс в Java может иметь обычные модификаторы доступа, такие как private, protected и т.д.</li>
</ul>

<h5>Композиция:</h5>

Возможность многократного использования кода может быть достигнута благодаря реализации наследования или композиции, но композиционный подход к повторному использованию кода обеспечивает более сильную инкапсуляцию, чем наследование, потому что изменение back-end класса не должно разрушить код, который полагается только на front-end класс.

Композиция - это методика проектирования для реализации существующих связей в классах. Мы можем использовать наследование Java или композицию для повторного использования кода.

Композиция выражает связи между объектами. Например, представьте стул. Стул имеет сиденье. Стул имеет спинку. И имеет набор ножек. Фраза "имеет" подразумевает отношения, где стул владеет чем-либо, или как минимум, он использует другой предмет. Именно такие отношения вида "Имеет" и являются основой для составления композиции.

<h6>Преимущества:</h6>

<table>
<tr>
<th>   №   </th>
<th>Композиция (иметь)</th>
<th>Наследование (являться)</th>
</tr>
<tr>
<td>1</td>
<td>Поддерживает полиморфизм и повторное использование кода</td>
<td>Поддерживает полиморфизм и повторное использование кода</td>
</tr>
<tr>
<td>2</td>
<td>Объект создается во время работы</td>
<td>Объект создается динамически во время компиляции</td>
</tr>
<tr>
<td>3</td>
<td>Реализация может быть изменена во время выполнения</td>
<td>Реализация может быть изменена во время выполнения</td>
</tr>
<tr>
<td>4</td>
<td>Подкласс не зависит от родительского класса, что способствует ослаблению связей (в частности, в интерфейсе управления)</td>
<td>Подкласс зависит от реализации родительского класса, поэтому они плотно связаны</td>
</tr>
<tr>
<td>5</td>
<td>Используется, например, когда в Доме есть Ванная. Некорректно говорить, что Дом - это Ванная.</td>
<td>Наследование является однонаправленным. Например: Дом это Здание. Но Здание не обязательно является Домом.</td>
</tr>
</table>

<strong>Примечание:</strong> Не используйте наследование только для того, чтобы получить возможность повторно использовать код. Если нет отношения типа "являться" между классами, то нужно использовать композиция для повторного использования кода.

<h5>Различия между Композицией и Агрегацией в отношениях объектов</h5>

<strong>Агрегация:</strong> Агрегация представляет собой объединение, в котором один класс принадлежит коллекции. Он является частью целого в отношениях, где часть может существовать без целого. Это слабые отношения. Нет циклической зависимости. Например: заказ и продукт.

<strong>Композиция:</strong> Композиция представляет собой объединение, в котором один класс принадлежит коллекции. Он является частью целого, где часть не может существовать без целого. Если в целое удаляется, то и все части будут так же удалены. Эти отношения сильнее. Примером могут служить: Полигон и точки, заказ и порядок заказа.

<h6>Ссылки:</h6>
<ul>
    <li><a href="http://stackoverflow.com/" rel="nofollow" >http://stackoverflow.com/</a></li>
    <li><a href="http://en.wikipedia.org/" rel="nofollow" >http://en.wikipedia.org/</a></li>
    <li>Effective Java™</li>
</ul>