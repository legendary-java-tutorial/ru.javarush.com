Что могут спросить на собеседовании: структуры данных в Java. Часть 2
<p>----------------------------------------</p>
Сейчас говорим о базе, которую должен знать каждый Java developer. О тех классических знаниях, с которых все и начинается. Сегодня хотелось бы затронуть одну из основополагающих тем любого...
<p>----------------------------------------</p>
<a href="https://javarush.com/groups/posts/2985-chto-mogut-sprositjh-na-sobesedovanii-strukturih-dannihkh-v-java" target="_blank">ЧАСТЬ 1</a>

Сейчас говорим о базе, которую должен знать каждый Java developer. О тех классических знаниях, с которых все и начинается.

Сегодня хотелось бы затронуть одну из основополагающих тем любого собеседования — <span class="text-bold">структуры данных в Java</span>. Итак, вместо хождения вокруг да около, мы начнем. Ловите продолжение списка вопросов, которые могут вам задать по этой теме на собеседовании.<h2>6. Расскажите о List</h2><span class="text-bold">List</span> — это интерфейс, представляющий упорядоченную структуру объектов, которая и называется списком.<img data-max-width="800" data-id="602875a2-2229-4492-ab82-950f4512f307" src="/images/article/602875a2-2229-4492-ab82-950f4512f307/800.jpeg" alt="Что могут спросить на собеседовании: структуры данных в Java - 5">“Фишка” этой структуры — то, что элементы, содержащиеся в <span class="text-bold">List</span>, можно вставить, изменить или удалить по индексу, то есть внутреннему идентификатору <span class="text-bold">List</span>. 

Иными словами, индекс означает: «сколько элементов от начала списка». У первого элемента <span class="text-bold">List</span> индекс 0, у второго — 1, и так далее. 

Таким образом, пятый элемент находится на расстоянии четырех элементов от начала списка.

Как говорилось выше, в списке важен порядок добавления элементов. Поэтому структура данных и называется <em>списком</em>.

Перечислим уникальные для этой структуры методы, которые направлены на работу с элементами по индексу:<ul>
<li><span class="text-bold">get</span> — возвращает элемент в указанной позиции (по значению индекса),</li>
<li><span class="text-bold">remove</span> — удаляет элемент в указанной позиции,</li>
<li><span class="text-bold">set</span> — заменяет элемент в указанной позиции на указанный в методе элемент.</li>

</ul>Основные реализации — <span class="text-bold">ArrayList</span> и <span class="text-bold">LinkedList</span>. Подробнее о них поговорим немного позже.

<span class="text-bold">Vector</span> — список, который ориентирован на многопоточное использование, поэтому в данном классе каждый метод синхронизирован.

Но учтите, что если вы хотите обезопасить некоторые действия со списками, вы будете синхронизировать целую последовательность операций. А синхронизация отдельных операций и менее безопасна, и гораздо медленнее.

Конечно, <span class="text-bold">Vector</span> также имеет накладные расходы на блокировку, даже если вам эта блокировка и не нужна. Поэтому сейчас этот класс считается устаревшим и не используется.

Кстати: <span class="text-bold">ArrayList</span> является аналогом <span class="text-bold">Vector</span>, но не использует блокировку, поэтому используется повсеместно. 

<span class="text-bold">Stack</span> — это подкласс класса <span class="text-bold">Vector</span> с одним конструктором по умолчанию и всеми методами класса <span class="text-bold">Vector</span>, а также несколькими собственными (о них мы поговорим чуть ниже).

В качестве примера можно представить процесс в виде стопки папок с документами. Наверх стопки вы кладете по одной папке, и брать данные папки можно только в обратном порядке, начиная с верхней.

Собственно, это и есть механизм типа <span class="text-bold">LIFO</span>, то есть <span class="text-bold">Last In First Out</span>, последний пришел — первым ушел.

Стек реализует свои собственные методы:<ul>
<li><span class="text-bold">push</span> — добавляет переданный элемент на вершину стека;</li>
<li><span class="text-bold">peek</span> — возвращает  элемент, который находится на вершине стека;</li>
<li><span class="text-bold">pop</span> — также возвращает элемент, который находится на вершине стека, но при этом удаляет его;</li>
<li><span class="text-bold">empty</span> — проверяет, пуст ли стек — <span class="text-bold"><em>true</em></span>, или нет — <span class="text-bold"><em>false</em></span>;</li>
<li><span class="text-bold">search</span> — выполняет поиск заданного элемента в стеке. Если элемент найден, возвращается его порядковый номер относительно верхушки стека. Если же элемент не найден, возвращается значение -1.</li>
</ul>В данный момент подкласс <span class="text-bold">Stack</span> фактически не используется в силу своей простоты и негибкости, но, тем не менее, он может вам встретиться. Например, когда вы получаете некоторую ошибку, и в консоли видите стек сообщений о ней.

Подробнее о стеке и очереди можно почитать вот в <a href="https://javarush.com/groups/posts/2321-strukturih-dannihkh--stek-i-ocheredjh" target="_blank">этой статье</a>.<h2>7. Расскажите о Map</h2>Как сказано выше, <span class="text-bold">Map</span> — это коллекция имеющая отдельную структуру интерфейсов и их реализаций. Отдельная она потому, что здесь значения не хранятся по одному, а в паре “ключ – значение”.<img data-max-width="800" data-id="7c97a86a-19af-4e12-9460-60a92782546f" src="/images/article/7c97a86a-19af-4e12-9460-60a92782546f/800.jpeg" alt="Что могут спросить на собеседовании: структуры данных в Java - 6">Основные методы <span class="text-bold">Map</span>:<ul>

<li><span class="text-bold">put(K key, V value)</span> — добавление элемента в Map;</li>
<li><span class="text-bold">get(Object key)</span> — поиск значения по ключу;</li>
<li><span class="text-bold">containsKey(Object key)</span> — проверка Map на наличие данного ключа;</li>
<li><span class="text-bold">containsValue(Object value)</span> — проверка Map на наличие данного значения;</li>
<li><span class="text-bold">remove(Object key)</span> — удаление значения по его ключу.</li>
</ul>Как вы видите, большинство операций работает с помощью использования ключа. В качестве ключей, как правило, выбираются неизменные объекты (<span class="text-bold">immutable</span>). Типичный пример данного объекта — <a href="https://javarush.com/groups/posts/2347-klass-string-v-java" target="_blank">String</a>.

Основные реализации <span class="text-bold">Map</span>:<ol>

<li><span class="text-bold">HashMap</span> — предназначена для хранения значений в произвольном порядке, но позволяет быстро искать элементы карты. Позволяет задавать ключ ключевым словом <span class="text-bold">null</span>, но не более одного раза, т.к. пары с одинаковыми ключами записываются поверх друг друга. Главным условием является уникальность ключей: значения же могут повторяться (может быть несколько null значений).</li>
<li><span class="text-bold">LinkedHashMap</span> — аналог <span class="text-bold">HashMap</span>, который хранит значения в порядке добавления. Соответственно, как и <span class="text-bold">LinkedList</span>, у него есть <span class="text-bold">header</span> — голова двусвязного списка. При инициализации указывает сам на себя.
<p>Также у <span class="text-bold">LinkedHashMap</span> есть <span class="text-bold">accessOrder</span>, который указывает, каким образом будет осуществляться доступ к элементам во время использования итератора. При <span class="text-bold">accessOrder <em>false</em></span> доступ будет осуществляться в порядке вставки элементов. При значении <span class="text-bold">true</span> элементы будут в порядке последнего доступа (элемент, к которому было последнее обращение будет помещен в конец). </p></li>
<li><span class="text-bold">TreeMap</span> — это <span class="text-bold">Map</span>, сортирующая элементы по значениям ключа. Аналог <span class="text-bold">TreeSet</span>, но для пар с ориентировкой на значения ключей. Для задания правил сортировки <span class="text-bold">TreeMap</span> ключи должны реализовывать <span class="text-bold">Comparable</span> интерфейс. В ином случае должен быть <span class="text-bold">Comparator</span>, ориентированный на ключи (тот, который задается в конструктор <span class="text-bold">TreeMap</span>), TreeSet — реализован с объектом TreeMap внутри, в котором, собственно, и происходит вся магия.

<p>Подробнее про сортировку в TreeMap с помощью красно-черных деревьев можно почитать в статье <a href="https://javarush.com/groups/posts/2584-osobennosti-treemap" target="_blank">об особенностях TreeMap</a>.</p></li>

<li><span class="text-bold">Hashtable</span> — аналогичен <span class="text-bold">HashMap</span>, но но не позволяет хранить <span class="text-bold">null</span> ни в качестве ключей, ни в качестве значений. Он тщательно синхронизирован с точки зрения многопоточности, что в свою очередь означает, что он безопасен с точки зрения многопоточности. Но данная реализация устаревшая и медленная, поэтому сейчас вы и не встретите <span class="text-bold">Hashtable</span> в более-менее новых проектах.</li></ol><h2>8. ArrayList vs LinkedList.  Какой предпочтительней использовать?</h2>Этот вопрос, пожалуй, самый популярный по структурам данных и несет в себе некоторые подводные камни. Прежде чем отвечать на него, давайте узнаем подробнее об этих структурах данных.

<span class="text-bold">ArrayList</span> реализует интерфейс <span class="text-bold">List</span>, работает за счет внутреннего массива, который расширяется по мере необходимости.

Когда внутренний массив полностью заполняется, и при этом  нужно вставить новый элемент то создается новый массив, с размером (oldSize * 1,5) +1. После этого все данные из  старого массива копируются в новый +новый элемент, старый же будет удален <a href="https://javarush.com/groups/posts/917-sborka-musora" target="_blank">сборщиком мусора</a>.

Метод <span class="code">add</span> добавляет элемент в последнюю пустую ячейку массива. То есть, если у нас там уже есть 3 элемента, он добавит следующий в 4-ю ячейку.

Давайте пройдемся по производительности базовых методов:<ul>

<li><span class="code">get(int index)</span> — взятие элемента в массиве по индексу работает быстрее всего за <span class="text-bold">O(1)</span>;</li>
<li><span class="code">add(Object obj)</span> — если достаточно места во внутреннем массиве для нового элемента, то при обычной вставке будет затрачено время <span class="code">O(1)</span>, так как добавление идет целенаправленно в последнюю ячейку.
<p>Если же нужно создавать новый массив и копировать в него содержимое, то время у нас будет прямо пропорционально количеству элементов в массиве <span class="text-bold">O(n)</span>;</p></li>
<li><span class="code">remove(int index)</span> — при удалении элемента, к примеру, из середины, мы получим время O(n/2), так как нужно будет передвигать элементы справа от него на одну ячейку назад. Соответственно, если удаление с начала списка, то O(n), c конца — O(1);</li>
<li><span class="code">add(int index, Object obj)</span> — ситуация, схожая с удалением: при добавлении в середину нам нужно будет передвинуть элементы справа на одну ячейку вперед, поэтому время — O(n/2). Разумеется, с начала — O(n), с конца — O(1);</li>
<li><span class="code">set(int index, Object obj)</span> — тут ситуация иная, так как требуется только найти нужный элемент и записать поверх него, не передвигая остальные, поэтому O(1).</li>

</ul>Подробнее про <span class="text-bold">ArrayList</span> — в <a href="https://javarush.com/groups/posts/klass-arraylist" target="_blank">этой статье</a>.

<span class="text-bold">LinkedList</span> реализует сразу два интерфейса — <span class="text-bold">List</span> и <span class="text-bold">Queue</span>, поэтому и владеет свойствами и методами, присущими обоим структурам данных. От List он взял доступ к элементу по индексу, от Queue — наличие “головы” и “хвоста”.

Внутри он реализован как структура данных, представляющая двусвязный список. То есть, у каждого элемента есть ссылка на следующий и предыдущий, кроме “хвоста” и “головы”.<ul>

<li><span class="code">get(int index)</span> — при поиске элемента, который находится в середине списка, начинается перебор всех элементов по порядку, пока не будет найден нужный. По логике поиск должен занимать <span class="text-bold">O(n/2)</span>, но у LinkedList есть еще и хвост, поэтому перебор ведется одновременно с двух сторон. Соответственно, время уменьшается до <span class="text-bold">O(n/4)</span>.
<p>Если же элемент будет недалеко от начала списка или конца, то и время будет <span class="text-bold">O(1)</span>;</p></li>
<li><span class="code">add(Object obj)</span> — при добавлении нового элемента, у элемента-”хвоста” добавится ссылка на следующий элемент, а новый получит ссылку на этот предыдущий элемент и станет новым “хвостом”. Соответственно, время будет <span class="text-bold">O(1)</span>;</li>
<li><span class="code">remove(int index)</span> — логика, схожая с методом <span class="code">get(int index)</span>. Для удаления элемента из середины списка, его нужно сначала найти. Это опять же <span class="text-bold">O(n/4)</span>, в то время как само удаление фактически ничего не занимает, так как там только меняются указатель соседних объектов (они начинают ссылаться друг на друга). Если элемент в начале или в конце, то опять же — <span class="text-bold">O(1)</span>;</li>
<li><span class="code">add(int index, Object obj)</span> и <span class="code">set(int index, Object obj)</span> — у методов  временная сложность будет идентична <span class="code">get(int index)</span>, так как основное время занимает поиск элемента. Поэтому для середины списка — <span class="text-bold">O(n/4)</span>, для начала — <span class="text-bold">O(1).</span></li>
</ul>Больше о работе с <span class="text-bold">LinkedList</span> рассказано в <a href="https://javarush.com/groups/posts/1938-linkedlist" target="_blank">этой статье</a>.

Давайте все это рассмотрим в таблице:<table>
<tbody><tr><th>Операция</th>
<th>ArrayList</th>
<th>LinkedList</th></tr>
<tr><td><span class="text-bold">Взятие по индексу
get(index)</span></td>
<td>O(1)</td>
<td>В середине O(n/4)</td></tr>
<tr><td><span class="text-bold">Добавить новый
элемент add(obj)</span></td>
<td><p>O(1)</p>
<p>Если нужно скопировать массив то — O(n)</p></td>
<td>O(1)</td></tr>
<tr><td><span class="text-bold">Удалить элемент
remove(int index)</span></td>
<td><p>Из начала  — O(n)</p>
<p>Из середины — O(n/2)</p>
<p>Из конца — O(1)</p></td>
<td><p>В середине — O(n/4)</p>
<p>В конце или в начале — O(n)</p></td></tr>
<tr><td><span class="text-bold">Добавить элемент
add(int index, Object obj)</span></td>
<td><p>В начало — O(n)</p>
<p>В середину — O(n/2)</p>
<p>В конец — O(1)</p></td>
<td><p>В середине — O(n/4)</p>
<p>В конце или в начале — O(n)</p></td></tr>
<tr><td><span class="text-bold">Заменить элемент
set(index, obj)</span></td>
<td>O(1)</td>
<td><p>В середине — O(n/4)</p><p>В конце или в начале — O(n)</p></td></tr></tbody></table>Как вы уже наверное поняли, однозначно ответить на данный вопрос нельзя. Ведь при разных ситуациях они и работают с разной скоростью.

Поэтому, когда вам задают подобный вопрос, вы должны сразу спросить, на что будет ориентирован данный список и какие операции будут чаще всего производиться. Уже отталкиваясь от этого, давать ответ, но с пояснениями, почему именно так.

Подведем же небольшие итоги по нашему сравнению:

<span class="text-bold">ArrayList:</span><ul>
<li>лучший выбор, если наиболее частая операция — поиск элемента, перезапись элемента;</li>
<li>худший выбор, если операция — вставка и удаление в начале-середине, потому что будут проходить операции сдвига элементов справа.</li>
</ul><span class="text-bold">LinkedList:</span><ul>
<li>лучший выбор, если нашей частой операцией является вставка и удаление в начале-середине;</li>
<li>худший выбор, если наиболее частая операция — поиск.</li></ul><h2>9. Как хранятся элементы в HashMap?</h2>Коллекция <span class="text-bold">HashMap</span> содержит в себе внутренний массив <span class="text-bold">Node [] table</span>, ячейки которого еще называют <span class="text-bold">бакетами</span> (корзинами).

<span class="text-bold">Node</span> содержат в себе:<ul>
<li><span class="text-bold">key</span> — ссылку на ключ,</li>
<li><span class="text-bold">value</span> — ссылку на значение,</li>
<li><span class="text-bold">hash</span> — значение hash,</li>
<li><span class="text-bold">next</span> — ссылку на следующий <span class="text-bold">Node</span>.</li>

</ul>В одной ячейке массива <span class="text-bold">table[]</span> может содержаться ссылка на объект <span class="text-bold">Node</span> со ссылкой на следующий элемент <span class="text-bold">Node</span>, а он может иметь ссылку на другой, и так далее…

В итоге, данные элементы <span class="text-bold">Node</span> могут образовывать <span class="text-bold">односвязный список</span>, с элементами со ссылкой на следующие. При этом значение <span class="text-bold">hash</span> у элементов одной цепочки одинаковое.

После небольшого отступления давайте посмотрим, как происходит сохранение элементов в <span class="text-bold">HashMap</span>:<ol>

<li>Ключ проверяется на равенство <span class="text-bold">null</span>. Если он <span class="text-bold">null</span>, то key будет сохранен в ячейке <span class="text-bold">table[0]</span>, потому что хэш-код для null всегда равен 0.</li>
<li>Если ключ не <span class="text-bold">null</span>, то у объекта key вызывается метод <span class="code">hashcode()</span>, который выдаст его хэш-код. Этот хэш-код используется для определения ячейки массива, где будет храниться объект Node.</li>
<li>Далее данный hashcode помещается в внутренний метод <span class="code">hash()</span>, который высчитывает hashcode, но уже в пределах размера массива <span class="text-bold">table[]</span>.</li>
<li>Дальше, в зависимости от значения hash, Node помещается в конкретную ячейку в массиве <span class="text-bold">table[]</span>.</li>
<li>Если же ячейка <span class="text-bold">table[]</span>, используемая для сохранения текущего элемента <span class="text-bold">Node</span> не пуста, а уже имеет какой-то элемент, то происходит перебор элементов <span class="text-bold">Node</span> по значению <span class="text-bold">next</span>, пока не будет достигнут последний элемент. То есть, тот, у которого поле <span class="text-bold">next</span> равно <span class="text-bold">null</span>.
<p>Во время данного перебора сравниваются ключ охраняемого объекта <span class="text-bold">Node</span> с ключами перебираемых: </p><ul>
<li>если будет найдено соответствие, то перебор закончится, и новый <span class="text-bold">Node</span> перезапишет <span class="text-bold">Node</span>, в котором найдено соответствие (перезапишется только его поле <span class="text-bold">value</span>);</li>
<li>если соответствия ключей не найдены, то новый <span class="text-bold">Node</span> станет последним в этом списке, а предыдущий будет иметь ссылку <span class="text-bold">next</span> на него.</li></ul><p></p></li></ol>Часто на собеседованиях мелькает вопрос: <span class="text-bold">что такое коллизия</span>? 

Ситуацию, когда в ячейке массива <span class="text-bold">table[]</span> хранится не один элемент, а цепочка из двух и более, и называется <span class="text-bold">коллизия</span>. 

В обычных случаях, когда в одной ячейке <span class="text-bold">table[]</span> хранится только один элемент, доступ к элементам <span class="text-bold">HashMap</span> имеет константную временную сложность <span class="text-bold">O(1)</span>. Но когда в ячейке с нужным элементом присутствует цепочка элементов (<span class="text-bold">коллизия</span>), то <span class="text-bold">O(n)</span>, так как в таком случае время прямо пропорционально зависит от количества перебираемых элементов.<h2>10. Расскажите об итераторе</h2>В схеме с отображением иерархии <span class="text-bold">Collection</span> выше интерфейс <span class="text-bold">Collection</span> был тем, с чего начиналась вся иерархия, но на практике все не совсем так.  

Collection наследуется от интерфейса с методом <span class="code">iterator()</span>, который возвращает объект, реализующий интерфейс <span class="text-bold">Iterator&lt;E&gt;</span>. 

Интерфейс Iterator имеет вид:

<pre class="language-java line-numbers"><code>
public interface Iterator &lt;E&gt;{
   
    E next();
    boolean hasNext();
    void remove();
}
</code></pre>
<span class="code">next()</span> — вызывая данный метод, можно будет получить следующий элемент. 

<span class="code">hasNext()</span> — дает возможность узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И когда элементы еще есть, то <span class="code">hasNext()</span> вернет значение <span class="text-bold"><em>true</em></span>. Как правило, <span class="code">hasNext()</span> вызывается перед методом <span class="code">next()</span>, так как при достижении конца коллекции <span class="code">next()</span> будет выбрасывать исключение <span class="text-bold">NoSuchElementException</span>.

<span class="code">remove()</span> — удаляет элемент, который получен последним вызовом <span class="code">next()</span>.

Предназначением Iterator является перебор элементов. Например:

<pre class="language-java line-numbers"><code>
Set&lt;Integer&gt; values = new TreeSet&lt;&gt;();
  values.add(5);
values.add(3);
values.add(6);
values.add(8);
values.add(2);
values.add(4);
values.add(1);
values.add(7);

Iterator&lt;Integer&gt; iter = values.iterator();
while(iter.hasNext()){
  System.out.println(iter.next());
}
</code></pre>
Собственно, цикл <span class="text-bold">for-each loop</span> и реализован под капотом с помощью итератора. Подробнее об этом можно почитать <a href="https://javarush.com/groups/posts/1983-for-i-for-each-loop---skaz-o-tom-kak-ja-iterirovalsja-iterirovalsja-da-ne-vihiterirovalsja" target="_blank">тут</a>.

<span class="text-bold">List</span> предоставляет свою версию итератора, но более крутую и навороченную — <span class="text-bold">ListIterator</span>. 

Данный интерфейс расширяет <span class="text-bold">Iterator</span>, и у него есть дополнительные методы:<ul>
<li><span class="code">hasPrevious</span> вернет true, если в коллекции имеется предыдущий элемент, иначе — false;</li>
<li><span class="code">previous</span> возвращает текущий элемент и переходит к предыдущему; если такого нет, то выбрасывается исключение NoSuchElementException;</li>
<li><span class="code">add</span> вставит переданный объект перед элементом, который должен быть возвращен следующим вызовом <span class="code">next()</span>;</li>
<li><span class="code">set</span> присваивает текущему элементу ссылку на переданный объект;</li>
<li><span class="code">nextIndex</span> возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка;</li>
<li><span class="code">previousIndex</span> возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1.</li>
</ul>Что же, на этом у меня сегодня все. Я надеюсь, что после прочтения этой статьи вы стали еще ближе к заветной мечте — стать разработчиком.