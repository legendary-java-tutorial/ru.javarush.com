Java Core. Вопросы к собеседованию, ч. 2
<p>----------------------------------------</p>
Для тех, кто впервые слышит слово Java Core – это фундаментальные основы языка. С этими знаниями уже смело можно идти на стажировку/интернатуру. Приведенные вопросы помогут вам освежить знания перед собеседованием, или почерпнуть для себя что-то новое ...
<p>----------------------------------------</p>
Для тех, кто впервые слышит слово Java Core – это фундаментальные основы языка. С этими знаниями уже смело можно идти на стажировку/интернатуру.
<div class='row justify-content-center jr-image-wrap'><div class='col-12 col-sm-10 col-md-8'><img data-id="0a46c7cc-30da-4840-8626-96008b63c96e" data-max-width="710" alt="Java Core. Вопросы к собеседованию, ч. 2 - 1" src="https://cdn.javarush.com/images/article/0a46c7cc-30da-4840-8626-96008b63c96e/1024.jpeg"></div></div>Приведенные вопросы помогут вам освежить знания перед собеседованием, или почерпнуть для себя что-то новое. Для получения практических навыков занимайтесь на <a href="https://cdn.javarush.com/images/article/155cea79-acfd-4968-9361-ad585e939b82/original.png">JavaRush</a>.

<em><a href="http://howtodoinjava.com/2013/03/04/core-java-interview-questions-series-part-2/" rel="nofollow" >Оригинал статьи</a>
Ссылки на остальные части:
<a href="http://info.javarush.ru/translation/2014/02/12/Java-Core-%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%BA-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E-%D1%87-1.html">Java Core. Вопросы к собеседованию, ч. 1</a>
<a href="http://info.javarush.ru/translation/2014/03/22/Java-Core-%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%BA-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E-%D1%87-3.html">Java Core. Вопросы к собеседованию, ч. 3</a></em>

<h2>Почему необходимо избегать метода finalize()?</h2>Все мы знаем утверждение, что метод <code>finalize()</code> вызывается сборщиком мусора перед освобождением памяти, занимаемой объектом. Вот пример программы, которая доказывает, что вызов метода <code>finalize()</code> не гарантирован:

<pre class='lang-java line-numbers'><code>
public class TryCatchFinallyTest implements Runnable {

	private void testMethod() throws InterruptedException
	{
		try
		{
			System.out.println("In try block");
			throw new NullPointerException();
		}
		catch(NullPointerException npe)
		{
			System.out.println("In catch block");
		}
		finally
		{
			System.out.println("In finally block");
		}
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("In finalize block");
		super.finalize();
	}

	@Override
	public void run() {
		try {
			testMethod();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
</code></pre>
<pre class='lang-java line-numbers'><code>
public class TestMain
{
	@SuppressWarnings("deprecation")
	public static void main(String[] args) {
	for(int i=1;i< =3;i++)
	{
		new Thread(new TryCatchFinallyTest()).start();
	}
	}
}
</code></pre>
<strong>Вывод:

<em>In try block
In catch block
In finally block
In try block
In catch block
In finally block
In try block
In catch block
In finally block</em></strong>

Удивительно, метод <code>finalize</code> не был выполнен ни для одной нити. Это доказывает мои слова. Я думаю, причина в том, что финализаторы выполняются отдельной нитью сборщика мусора. Если виртуальная машина Java завершается слишком рано, тогда сборщик мусора не имеет достаточно времени для создания и выполнения финализаторов.

Другими причинами не использовать метод <code>finalize()</code> могут быть:
<ol>
    <li>Метод <code>finalize()</code> не работает с цепочками, как конструкторы. Имеется ввиду, что когда вы вызываете конструктор класса, то конструкторы суперклассов будут вызваны безоговорочно. Но в случае с методом <code>finalize()</code>, этого не последует. Метод <code>finalize()</code> суперкласса должен быть вызван явно.</li>
    <li>Любое исключение, брошенное методом <code>finalize</code> игнорируется нитью сборщика мусора, и не будет распространяться далее, что означает, что событие, не будет занесено в ваши логи. Это очень плохо, не правда ли?</li>
    <li><p>Также вы получаете значительное ухудшение производительности, если метод <code>finalize()</code> присутствует в вашем классе. В «Эффективном программировании» (2-е изд.) Джошуа Блох сказал:<br />
«Да, и еще одно: есть большая потеря производительности при использовании финализаторов. На моей машине время создания и уничтожения простых объектов составляет примерно 5,6 наносекунд.<br />
Добавление финализатора увеличивает время до 2 400 наносекунд. Другими словами, примерно в 430 раз медленнее происходит создание и удаление объекта с финализатором.»</p></li>
</ol>
<h2>Почему HashMap не должна использоваться в многопоточном окружении? Может ли это вызвать бесконечный цикл?</h2>Мы знаем, что <code>HashMap</code> — это не синхронизированная коллекция, синхронизированным аналогом которой является <code>HashTable</code>. Таким образом, когда вы обращаетесь к коллекции и многопоточном окружении, где все нити имеют доступ к одному экземпляру коллекции, тогда безопасней использовать <code>HashTable</code> по очевидным причинам, например во избежание грязного чтения и обеспечения согласованности данных. В худшем случае это многопоточное окружение вызовет бесконечный цикл.

Да, это правда. <code>HashMap.get()</code> может вызвать бесконечный цикл. Давайте посмотрим как?

Если вы посмотрите на исходный код метода <code>HashMap.get(Object key)</code>, он выглядит так:

<pre class='lang-java line-numbers'><code>
public Object get(Object key) {
    Object k = maskNull(key);
    int hash = hash(k);
    int i = indexFor(hash, table.length);
    Entry e = table[i];
    while (true) {
        if (e == null)
            return e;
        if (e.hash == hash &amp;&amp; eq(k, e.key))
            return e.value;
        e = e.next;
    }
}
</code></pre>
<code>while(true)</code> всегда может стать жертвой бесконечного цикла в многопоточном окружении времени исполнения, если по какой-то причине <code>e.next</code> сможет указать на себя. Это станет причиной бесконечного цикла, но как <code>e.next</code> укажет на себя(то есть на <code>e</code>)?

Это может произойти в методе <code>void transfer(Entry[] newTable)</code>, который вызывается, в то время как <code>HashMap</code> изменяет размер.
<pre class='lang-java line-numbers'><code>
do {
    Entry next = e.next;
    int i = indexFor(e.hash, newCapacity);
    e.next = newTable[i];
    newTable[i] = e;
    e = next;
} while (e != null);
</code></pre>
Этот фрагмент кода склонен к созданию бесконечного цикла, если изменение размера происходит в то же время, когда другая нить пытается изменить экземпляр карты (<code>HashMap</code>).

Единственный способ избежать описанного сценария – использовать синхронизацию в коде, или еще лучше, использовать синхронизированную коллекцию.

<h2>Объясните абстракцию и инкапсуляцию. Как они связаны?</h2>Простыми словами <em>«<strong>Абстракция</strong> отображает только те свойства объекта, которые значимы для текущего ракурса»</em>. В теории объектно-ориентированного программирования, абстракция включает возможность определения объектов, представляющих абстрактных «действующих лиц», которые могут выполнять работу, изменять и сообщать об изменении своего состояния, и «взаимодействовать» с другими объектами в системе.

Абстракция в любом языке программирования работает во многих отношениях. Это видно начиная от создания подпрограмм для определения интерфейсов низкоуровневых языковых команд. Некоторые абстракции стараются ограничить ширину общего представления потребностей программиста, полностью скрывая абстракции, на которых они построены, например шаблоны проектирования.

Как правило, абстракцию можно увидеть в двух отношениях:

<strong>Абстракция данных</strong> – это способ создания сложных типов данных и выставляя только значимые операции для взаимодействия с моделью данных, в то же время, скрывая все детали реализации от внешнего мира.

<strong>Абстракция исполнения</strong> – это процесс выявления всех значимых операторов и выставляя их как рабочую единицу. Мы обычно используем эту особенность, когда мы создаем метод для выполнения какой-либо работы.

<strong>Заключение данных и методов внутри классов в комбинации с осуществлением сокрытия (используя контроль доступа) часто называется инкапсуляцией.</strong> Результатом является тип данных с характеристиками и поведением. Инкапсуляция, в сущности, содержит также сокрытие данных и сокрытие реализации.

<strong><em>«Инкапсулируйте все, что может измениться»</em></strong>. Эта цитата является известным принципом проектирования. Если на то пошло, в любом классе, изменения данных могут произойти во время исполнения и изменения в реализации может произойти в следующих версиях. Таким образом, инкапсуляция применима как к данным, так и к реализации.

Итак, они могут быть связаны таким образом:
<ul>
<li>Абстракция по большей части является <strong>Что</strong> класс может делать [Идея]</li>
<li>Инкапсуляция более является <strong>Как</strong> достигнуть данной функциональности [Реализация]</li>
</ul>
<h2>Различия между интерфейсом и абстрактным классом?</h2>Основные различия могут быть перечислены следующим:
<ul>
    <li>Интерфейс не может реализовать никаких методов, зато абстрактный класс может.</li>
    <li>Класс может реализовать множество интерфейсов, но может иметь только один суперкласс (абстрактный или не абстрактный)</li>
    <li>Интерфейс не является частью иерархии классов. Несвязанные классы могут реализовывать один и тот же интерфейс.</li>
</ul>
Вы должны запомнить следующее: «Когда вы можете полностью описать понятие в словах «что это делает» без необходимости уточнять «как это делает», тогда вы должны использовать интерфейс. Если вам необходимо включить некоторые детали реализации, тогда вам надо представить вашу концепцию в абстрактном классе».

Также, говоря другими словами: Много есть классов, которые могут быть «группированы вместе» и описаны одним существительным? Раз так, создайте абстрактный класс с именем этого существительного, и унаследуйте классы от него. К примеру, <code>Cat</code> и <code>Dog</code> могут наследоваться от абстрактного класса <code>Animal</code>, и этот абстрактный базовый класс будет реализовывать метод <code>void Breathe()</code> – дышать, который все животные будут таким образом выполнять одинаковым способом.

Какие глаголы могут быть применены к моему классу и могут применяться к другим? Создайте интерфейс к каждому из этих глаголов. Например, все животные могут питаться, поэтому я создам интерфейс <code>IFeedable</code> и сделаю <code>Animal</code> реализующим этот интерфейс. Только <code>Dog</code> и <code>Horse</code> достаточно хороши для реализации интерфейса <code>ILikeable</code> (способны мне нравиться), но не все.

Кто-то сказал: главное отличие в том, где вы хотите вашу реализацию. Создавая интерфейс, вы можете переместить реализацию в любой класс, который реализует ваш интерфейс. Создавая абстрактный класс, вы можете разделить реализацию всех производных классов в одном месте и избежать много плохих вещей, таких как дублирование кода.

<h2>Как StringBuffer экономит память?</h2>Класс <code>String</code> реализован как неизменный (immutable) объект, то есть, когда вы изначально решили положить что-то в объект <code>String</code>, виртуальная машина выделяет массив фиксированной длины, точно такого размера, как и ваше первоначальное значение. В дальнейшем это будет обрабатываться как константа внутри виртуальной машины, что предоставляет значительное улучшение производительности в случае, если значение строки не изменяется. Однако если вы решите изменить содержимое строки любым способом, на самом деле виртуальная машина копирует содержимое исходной строки во временное пространство, делает ваши изменения, затем сохраняет эти изменения в новый массив памяти. Таким образом, внесение изменений в значение строки после инициализации является дорогостоящей операцией.

<code>StringBuffer</code>, с другой стороны выполнен в виде динамически расширяемого массива внутри виртуальной машины, что означает, что любая операция изменения может происходить на существующей ячейке памяти, и новая память будет выделяться по мере необходимости. Однако нет никакой возможности виртуальной машине сделать оптимизацию <code>StringBuffer</code>, поскольку его содержимое считается непостоянным в каждом экземпляре.

<h2>Почему методы wait и notify объявлены у класса Object взамен Thread?</h2>Методы <code>wait</code>, <code>notify</code>, <code>notifyAll</code> необходимы только тогда, когда вы хотите, чтобы ваши нити имели доступ к общим ресурсам и общий ресурс мог быть любым java объектом в хипе(heap). Таким образом эти методы определены на базовом классе <code>Object</code>, так что каждый объект имеет контроль, позволяющий нитям ожидать на своем мониторе. Java не имеет какого-либо специального объекта, который используется для разделения общего ресурса. Никакая такая структура данных не определена. Поэтому на класс <code>Object</code> возложена ответственность иметь возможность становиться общим ресурсом, и предоставлять вспомогательные методы, такие как <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>.

Java основывается на идее мониторов Чарльза Хоара (Hoare). В Java все объекты имеют монитор. Нити ожидают на мониторах, поэтому для выполнения ожидания нам необходимо два параметра:
<ul>
<li>нить</li>
<li>монитор (любой объект).</li>
</ul>
В Java проектировании, нить не может быть точно определена, это всегда текущая нить, исполняющая код. Однако мы можем определить монитор (который является объектом, у которого мы можем вызвать метод <code>wait</code>). Это хороший замысел, поскольку если мы можем заставить любую другую нить ожидать на определенном мониторе, это приведет к «вторжению», оказывая трудности проектирования/программирования параллельных программ. Помните, что в Java все операции, которые вторгаются в другие нити являются устаревшими(например, <code>stop()</code>).

<h2>Напишите программу для создания deadlock в Java и исправьте его</h2>В Java <code>deadlock</code> – это ситуация, когда минимум две нити удерживают блок на разных ресурсах, и обе ожидают освобождения другого ресурса для завершения своей задачи. И ни одна не в состоянии оставить блокировку удерживаемого ресурса.
<img data-max-width="249" alt="Java Core. Вопросы к собеседованию, ч. 2 - 2" src="https://cdn.javarush.com/images/article/5f7eb0a9-0861-4f37-bdd2-f62548c67f79/original.jpeg">
Пример программы:

<pre class='lang-java line-numbers'><code>
package thread;

public class ResolveDeadLockTest {

	public static void main(String[] args) {
		ResolveDeadLockTest test = new ResolveDeadLockTest();

		final A a = test.new A();
		final B b = test.new B();

		// Thread-1
		Runnable block1 = new Runnable() {
			public void run() {
				synchronized (a) {
					try {
					// Добавляем задержку, чтобы обе нити могли начать попытки
					// блокирования ресурсов
						Thread.sleep(100);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					// Thread-1 заняла A но также нуждается в B
					synchronized (b) {
						System.out.println("In block 1");
					}
				}
			}
		};

		// Thread-2
		Runnable block2 = new Runnable() {
			public void run() {
				synchronized (b) {
					// Thread-2 заняла B но также нуждается в A
					synchronized (a) {
						System.out.println("In block 2");
					}
				}
			}
		};

		new Thread(block1).start();
		new Thread(block2).start();
	}

	// Resource A
	private class A {
		private int i = 10;

		public int getI() {
			return i;
		}

		public void setI(int i) {
			this.i = i;
		}
	}

	// Resource B
	private class B {
		private int i = 20;

		public int getI() {
			return i;
		}

		public void setI(int i) {
			this.i = i;
		}
	}
}
</code></pre>
Запуск приведенного кода приведет к deadlock по весьма очевидным причинам (объяснены выше). Теперь нам необходимо решить эту проблему.
Я верю, что решение любой проблемы лежит в корне самой проблемы. В нашем случае модель доступа к А и В является главной проблемой. Поэтом для решения её, мы просто изменим порядок операторов доступа к разделяемым ресурсам.

После изменения это будет выглядеть так:

<pre class='lang-java line-numbers'><code>
      // Thread-1
Runnable block1 = new Runnable() {
	public void run() {
		synchronized (b) {
			try {
				// Добавляем задержку, чтобы обе нити могли начать попытки
				// блокирования ресурсов
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			// Thread-1 заняла B но также нуждается в А
			synchronized (a) {
				System.out.println("In block 1");
			}
		}
	}
};

// Thread-2
Runnable block2 = new Runnable() {
	public void run() {
		synchronized (b) {
			// Thread-2 заняла B но также нуждается в А
			synchronized (a) {
				System.out.println("In block 2");
			}
		}
	}
};
</code></pre>
Запустите снова этот класс, и теперь вы не увидите deadlock. Я надеюсь, это поможет вам избежать deadlocks и избавиться от них, если столкнетесь.

<h2>Что случится, если ваш класс, реализующий Serializable интерфейс содержит несериализуемый компонент? Как исправить это?</h2>В таком случае будет выброшено <code>NotSerializableException</code> в процессе выполнения. Для исправления этой проблемы, есть очень простое решение – отметить эти поля <code>transient</code>. Это означает, что отмеченные поля не будут сериализованы. Если вы также хотите сохранить состояние этих полей, тогда вам необходимо рассмотреть ссылочные переменные, которые уде реализуют интерфейс <code>Serializable</code>.

Также вам может понадобиться использовать методы <code>readResolve()</code> и <code>writeResolve()</code>.

Подведем итоги:
<ul>
    <li>Во-первых, сделайте ваше несериализуемое поле <code>transient</code>.</li>
    <li>В <code>writeObject</code> первым делом вызовите <code>defaultWriteObject</code> на потоке, для сохранения всех не <code>transient</code> полей, затем вызовите остальные методы для сериализации индивидуальных свойств вашего несериализуемого объекта.</li>
    <li>В <code>readObject</code>, сперва вызовите <code>defaultReadObject</code> на потоке для чтения всех не <code>transient</code> полей, затем вызовите другие методы (соответствующие тем, которые вы добавили в <code>writeObject</code>) для десериализации вашего не <code>transient</code> объекта.</li>
</ul><h2>Объясните ключевые слова transient и volatile в Java</h2>«Ключевое слово <code>transient</code> используется для обозначения полей, которые не будут сериализованы». Согласно спецификации языка Java: Переменные могут быть маркированы индикатором transient для обозначения, что они не являются частью устойчивого состояния объекта. Например, вы можете содержать поля, полученные из других полей, и их предпочтительнее получать программно, чем восстанавливать их состояние через сериализацию.

К примеру, в классе <code>BankPayment.java</code> такие поля, как <code>principal</code> (директор) и <code>rate</code> (ставка) могут быть сериализованы, а <code>interest</code> (начисленные проценты) могут быть вычислены в любое время, даже после десериализации.

Если мы вспомним, каждая нить в Java имеет собственную локальную память и производит операции чтения/записи в эту локальную память. Когда все операции сделаны, она записывает модифицированное состояние переменной в общую память, откуда все нити получают доступ к переменной. Как правило, это обычный поток внутри виртуальной машины. Но модификатор volatile говорит виртуальной машине, что обращение нити к этой переменной всегда должно согласовывать свою собственную копию этой переменной с основной копией переменной в памяти. Это означает, что каждый раз, когда нить хочет прочитать состояние переменной, она должна очистить состояние внутренней памяти и обновить переменную из основной памяти.

<code><strong>Volatile</strong></code> наиболее полезно в свободных от блокировок алгоритмах. Вы отмечаете переменную, хранящую общие данные как volatile, тогда вы не используете блокировки для доступа к этой переменной, и все изменения, сделанные одной нитью, будут видимы для других. Или если вы хотите создать отношение «случилось-после» для обеспечения того, чтобы не повторялись вычисления, опять же для обеспечения видимости изменений в реальном времени.

Volatile должно использоваться для безопасной публикации неизменяемых объектов в многопоточном окружении. Объявление поля <code>public volatile ImmutableObject</code> обеспечивает, что все нити всегда видят текущую доступную ссылку на экземпляр.

<h2>Разница между Iterator и ListIterator?</h2>Мы можем использовать <code>Iterator</code> для перебора элементов <code>Set</code>, <code>List</code> или <code>Map</code>. Но <code>ListIterator</code> может быть применим только для перебора элементов <code>List</code>. Другие отличия описаны ниже.

Вы можете:
<ol>
<li>итерировать в обратном порядке.</li>
<li>получить индекс в любом месте.</li>
<li>добавить любое значение в любом месте.</li>
<li>установить любое значение в текущей позиции.</li>
</ol>
Удачи в обучении!!

<em>Автор статьи <a href="https://plus.google.com/+LokeshGupta/posts" rel="nofollow" >Lokesh Gupta</a>
<a href="http://howtodoinjava.com/2013/03/04/core-java-interview-questions-series-part-2/" rel="nofollow" >Оригинал статьи</a>
<a href="http://info.javarush.ru/translation/2014/02/12/Java-Core-%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%BA-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E-%D1%87-1.html">Java Core. Вопросы к собеседованию, ч. 1</a>
<a href='https://javarush.com/groups/posts/780-java-core-voprosih-k-sobesedovaniju-ch-3' target='_blank'>Java Core. Вопросы к собеседованию, ч. 3</a></em>