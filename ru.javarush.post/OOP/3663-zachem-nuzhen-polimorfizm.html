Зачем нужен полиморфизм?
<p>----------------------------------------</p>
Для тех, кто почитал определение полиморфизма и реализовал несколько примеров с интерфейсами, но не понял зачем он нужен.
<p>----------------------------------------</p>
<span><a href="https://javarush.com/groups/posts/3665-zachem-nuzhnih-interfeysih" target="_blank" rel="nofollow">Зачем нужны интерфейсы?</a>
<a href="https://javarush.com/groups/posts/3664-zachem-nuzhno-nasledovanie-interfeysov" target="_blank" rel="nofollow">Зачем нужно наследование интерфейсов?</a>
Зачем нужен полиморфизм?</span>

Для тех, кто почитал определение полиморфизма и реализовал несколько примеров с интерфейсами, но не понял, зачем он нужен.

Есть привычки плохие, есть – хорошие, есть привычки индивидуальные, есть — распространенные. Но какая бы распространённая привычка не была, каждый человек ее делает со своими нюансами. 

Например, моя любимая привычка - спать. Все люди спят по-разному, и семье Ивановых – это тоже имеет место быть. 
<img data-id="4690b937-ec37-450d-a4ab-93c5db35765e" src="https://cdn.javarush.com/images/article/4690b937-ec37-450d-a4ab-93c5db35765e/512.jpeg" alt="Зачем нужен полиморфизм? - 1">Папа спит на спине и похрапывает, а Мама спит на правом боку и пинается.

Перенесем сонное царство в мир Java. Зная смысл интерфейсов, привычка спать будет такой:

<pre class="language-java line-numbers"><code>
public interface ПривычкаСпать {
     String какСпит();
}

public class Папа implements ПривычкаСпать {

    @Override
    public String какСпит() {
        return "Папа спит на спине и похрапывает";
    }
}

public class Мама implements ПривычкаСпать {

    @Override
    public String какСпит() {
        return "Мама спит на правом боку и пинается";
    }
}
</code></pre>
Чтобы точно сказать, кто как спит, нужно подойти к нему и посмотреть кто это тут спит и потом уже мы точно сможем узнать, услышим ли мы храп или получим пинок ногой. Подходить будем случайным порядком, то к Папе, то к Маме. 

В классе с методом <em>main</em> создадим метод, который будет в случайном порядке возвращать нам то <em>Папу</em>, то <em>Маму</em>.

<pre class="language-java line-numbers"><code>
public class Спальня {
    public static void main(String[] args) {

    }

    public static Object посмотретьКтоСпит() {
        int a = 1 + (int) (Math.random() * 2);
        if (a == 1) {
            return new Мама();
        }
        if (a == 2) {
            return new Папа();
        }
        return null;
    }
}
</code></pre>
Мы не знаем заранее, кого именно вернет метод <em>посмотретьКтоСпит()</em>, по этому тип возвращаемого объекта будет общий для всех – <em>Object</em>.

Чтобы проверить как метод работает в <em>main</em> запишем конструкцию, которая вызовет проверяемый метод 10 раз, и напечатает класс полученного объекта:

<pre class="language-java line-numbers"><code>
for (int i = 0; i &lt; 10; i++) {
    Object случайный = посмотретьКтоСпит ();
    System.out.println(случайный.getClass());
}
</code></pre>
При запуске в консоль выведется случайное количество Мам и Пап.

<div class="terminal">class Папа
class Папа
class Мама
class Папа
class Папа
class Мама
class Мама
class Мама
class Папа
class Мама</div>
Но вернемся ко сну. Нам нужно понимать кто как спит.

Метод <em>посмотретьКтоСпит ()</em>; вернет случайный объект, и записать вот так:

<pre class="language-java line-numbers"><code>
Object случайный = посмотретьКтоСпит ();
System.out.println(случайный.какСпит());
</code></pre>
У нас не получиться. 

Потому что  переменная <em>случайный</em> имеет тип <em>Object</em>, а у  <em>Object</em> нет такого метода, он есть только у <em>Папы</em> или <em>Мамы</em>, но кого это останавливает? Сейчас сделаем приведение типа <em>Object</em> к <em>Папе</em> или <em>Маме</em>, в зависимости от полученного класса и всего делов.

Пишем (хотите switch, хотите if, я выбрал if):

<pre class="language-java line-numbers"><code>
for (int i = 0; i &lt; 10; i++) {
    Object случайный = посмотретьКтоСпит();

    if (случайный.getClass().equals(Мама.class)) {
        Мама мама = (Мама) случайный;
        System.out.println(мама. какСпит());
    }
    if (случайный.getClass().equals(Папа.class)) {
        Папа папа = (Папа) случайный;
        System.out.println(папа. какСпит());
    }
}
</code></pre>
На выходе получим отличный результат из спящих Мам и Пап, дело закрыто!

<div class="terminal">Папа спит на спине и похрапывает
Папа спит на спине и похрапывает
Мама спит на правом боку и пинается
Папа спит на спине и похрапывает
Папа спит на спине и похрапывает
Папа спит на спине и похрапывает
Папа спит на спине и похрапывает
Мама спит на правом боку и пинается
Папа спит на спине и похрапывает
Мама спит на правом боку и пинается</div>
И так бы оно и было, если бы не все время меняющийся мир. У семьи Ивановых есть еще два ребенка, они тоже спят по-своему, их надо перенести в Java мир. А если в гости к Ивановым приедут Петровы со своими тройняшками, и они тоже спять каждый по-своему.  По мере расширения программы, новыми людьми-классами, которые умеют спать, метод <em>main</em> превратится в вавилонскую башню из пары сотен условий.

<pre class="language-java line-numbers"><code>
for (int i = 0; i &lt; 10; i++) {
    Object случайный = посмотретьКтоСпит();

    if (неизвестный.getClass().equals(Мама.class)) {
        Мама мама = (Мама) random;
        System.out.println(мама. какСпит());
    }

    if (неизвестный.getClass().equals(Папа.class)) {
        Папа папа = (Папа) random;
        System.out.println(папа. какСпит());
    }

//тут еще миллион строк кода

}
</code></pre>
То есть для расширения программы, такая организация классов совсем не подходит. Она заставляет нас писать много однообразного, в большей части повторяющегося кода.

Поможет нам только отец всея ООП, наисветлейший князь гибкости — Полиморфизм.
<img data-id="4b2effdc-8dc2-42c8-982d-3037bcf9eed1" src="https://cdn.javarush.com/images/article/4b2effdc-8dc2-42c8-982d-3037bcf9eed1/512.jpeg" alt="Зачем нужен полиморфизм? - 2">Применим полиморфизм и посмотрим, что изменилось:

<pre class="language-java line-numbers"><code>
public class Спальня {

public static void main(String[] args) {
	for (int i = 0; i &lt; 10; i++) {
    	  ПривычкаСпать случайный = посмотретьКтоСпит ();
          System.out.println(случайный.какСпит());
       }
}

public static ПривычкаСпать посмотретьКтоСпит() {
   //тут все без изменений
  }
}
</code></pre>
В методе <em>посмотретьКтоСпит()</em> изменился возвращаемый тип, был общий для всех класс <em>Object</em>, стал общий только для <em>Папы</em> и <em>Мамы</em>  интерфейс <em>ПривычкаСпать</em>. 

Значит явно изменять типы с <em>Object</em> на <em>Мама</em> или <em>Папа</em> уже не надо, проверять тип входящего класса тоже уже не надо. Можно добавить хоть +100500 имеющих привычку спать людей-классов, но метод <em>main</em> будет неизменным. 

Отвлечемся.

Лично у меня есть мнение, что объектно-ориентированное программирование очень сильно похоже на составление текстов. Существительные больше подходят для классов, глаголы для методов, прилагательные для полей классов.

Например предложение: «Красный автомобиль едет.»  можно переписать в код:

<pre class="language-java line-numbers"><code>
public class Автомобиль {

String цвет = «Красный»;

public void ехать() {
 System.out.println(цвет + « автомобиль едет.»)
  }
}
</code></pre>
Можно и код переписать как предложение, например:

<pre class="language-java line-numbers"><code>
ПривычкаСпать случайный = посмотретьКтоСпит ();
System.out.println(случайный.какСпит());
</code></pre>
На человечьем будет: «Выведи в консоль как спит случайный ПривычкаСпать».

Не слишком по-человечески, правильнее было <em>«ПривычкаСпать»</em> заменить на <em>«Человек»</em>.

Можно изменить наименование интерфейса <em>ПривычкаСпать</em> на <em>Человек</em>, тогда логика появиться: есть общий <em>Человек</em> и у него есть метод <em>какСпит()</em>. Но зная про проблемы с разными привычками из прошлой статьи про наследование, правильнее создать интерфейс <em>Человек</em> и унаследоваться от интерфейса <em>ПривычкаСпать</em>. А классам <em>Папа</em> и <em>Мама</em> имплементировать интерфейс <em>Человек</em>. Тогда все будет выглядеть логично:

Привычка спать объявляет метод как спит

<pre class="language-java line-numbers"><code>
public interface ПривычкаСпать {
     String какСпит();
}
</code></pre>
Человек тоже выглядит как человек с привычкой спать.

<pre class="language-java line-numbers"><code>
public interface Человек extends ПривычкаСпать {
     
}
</code></pre>
Папа и Мама — люди

<pre class="language-java line-numbers"><code>
public class Папа implements Человек {
    @Override
    public String какСпит() {
        return "Папа спит на спине и похрапывает";
    }
}
public class Мама implements Человек {
    @Override
    public String какСпит() {
        return "Мама спит на правом боку и пинается";
    }
}
</code></pre>
И в методе <em>main</em> тоже все нормально, в консоль выводится "Как спит случайный человек":

<pre class="language-java line-numbers"><code>
public class Спальня {

public static void main(String[] args) {
	for (int i = 0; i &lt; 10; i++) {
    	  Человек случайный = посмотретьКтоСпит ();
          System.out.println(случайный.какСпит());
       }
}

public static Человек посмотретьКтоСпит() {
   //тут все без изменений
  }
}
</code></pre>
Резюмирует за меня доктор Боб Келсо.
<img data-id="bfbf577f-9b85-4878-a00c-9d7cac7460be" src="https://cdn.javarush.com/images/article/bfbf577f-9b85-4878-a00c-9d7cac7460be/512.jpeg" alt="Зачем нужен полиморфизм? - 3">Дядюшка Боб говорит: что для лучшего понимания перепишите код в IDEA и по запускайте.

Полиморфизм автоматически определяет конкретный тип объектов с общим предком. Нам не нужно писать проверки на то -  каким типом является объект.

<strong> Резюме для трех статей: </strong>
Тут описаны самые очевидные (для меня) примеры использования интерфейсов, наследования и полиморфизма. Существуют и другие миры. 

Вообще моя основная мысль: «Приложение – это реализация (абстракция) реального мира, а так как мир постоянно меняется, то и приложение постоянно подвержено изменениям, нельзя написать раз и навсегда. Процесс внесения изменений в приложение может быть долгим и не понятным или быстрым и понятным. Это во многом зависит от организации кода, от организации классов, от дисциплинированного следования правилам.»

Понятия расширяемости и внесения изменений, поднимают представление о программировании на новый уровень. Возможно, если рассматривать ООП через расширяемость и внесение изменений, можно быстрее понять это самое ООП.  

Следующими вершинами после ООП станут: SOLID, чистый код, архитектура приложений и паттерны проектирования. Их так же можно понимать через расширяемость и внесение изменений.