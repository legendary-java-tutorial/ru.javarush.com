Концепции объектно-ориентированного программирования JAVA
<p>----------------------------------------</p>
JAVA основывается на концепциях объектно-ориентированного программирования, что позволяет перейти на более высокий уровень абстракции, чтобы разрешить любую проблему реалистичным путем ...
<p>----------------------------------------</p>
JAVA основывается на концепциях объектно-ориентированного программирования, что позволяет перейти на более высокий уровень абстракции, чтобы разрешить любую проблему реалистичным путем.

Объектно-ориентированный подход концептуализирует решение проблемы в плоскости объектов реального мира, которые легче повторно использовать в приложении. Например, <code>Chair</code> (стул), <code>Fan</code> (вентилятор), <code>Dog</code> (Собака), <code>Computer</code> (компьютер) и так далее.

В JAVA класс представляет собой макет, шаблон или прототип, который определяет общее поведение объекта данного типа.  Экземпляр — это отдельная реализация класса, и все экзепляры класса имеют одинаковые свойства, которые описаны в определении класса. Например, вы можете опрделить класс с именем House (дом) с количеством комнат в качестве атрибута и создать экземпляры класса, такие как дом с двумя комнатами, дом с тремя комнатами и так далее.<img data-id="08ebf159-c1bd-4a0c-a421-e3517694b7f5" data-max-width="850" alt="Концепции объектно-ориентированного программирования JAVA - 1" src="https://cdn.javarush.com/images/article/08ebf159-c1bd-4a0c-a421-e3517694b7f5/1024.jpeg"><strong>Преимущества:</strong>
Ниже перечислены некоторые плюсы объектно-ориентированной разработки программного обеспечения (ПО).
<ul>
    <li>Снижение затрат на поддержку ПО, в основном за счет того, что она осуществляется модульно.</li>
    <li>Усовершенствованное повторное использование кода благодаря таким качествам, как наследование, и, как результат, более быстрая разработка ПО.</li>
    <li>Повышенные надежность и гибкость кода.</li>
    <li>Легкость понимания вследствие моделирования реального мира.</li>
    <li>Лучшая абстракция на уровне объекта.</li>
    <li>Уменьшение сложности перехода от одной фазы разработки к другой.</li>
</ul>Есть четыре основные характеристики ООП:
<ul>
    <li>Инкапсуляция</li>
    <li>Наследование</li>
    <li>Полиморфизм</li>
    <li>Абстракция</li>
</ul><h2>Инкапсуляция</h2>Инкапсуляция выступает договором для объекта, что он должен скрыть, а что открыть для доступа другими объектами. В JAVA мы используем модификатор доступа <code>private</code> для того, чтобы скрыть метод и ограничить доступ к переменной из внешнего мира. JAVA также располагает различными модификаторами доступа: <code>public</code>, по умолчанию, <code>protected</code>, <code>private</code>, которые используются для ограничения видимости на разных уровнях. Но конечной целью является инкапсуляция тех вещей, которые не должны быть изменены. Лучше всего работает подход, при котором, у класса  должна быть только одна причина для изменения, и инкапсулирование воплощает в реальность проектирование этой “одной причины”.

Правильным в инкапсуляции считается сокрытие часто изменяющихся вещей во избежание повреждения других классов.

<strong>Преимущества:</strong>
Ниже представлены некоторые преимущества инкапсуляции:
<ul>
    <li>Мы можем защитить внутреннее состояние объекта с помощью сокрытия его атрибутов.</li>
    <li>Это улучшает модульное построение кода, так как предотвращает взаимодействие объектов неожиданными способами.</li>
    <li>Повышается практичность кода.</li>
    <li>Это поддерживает договорные отношения конкретного объекта.</li>
    <li>Инкапсуляция облегчает поддержку ПО.</li>
    <li>Изменения в коде могут производиться независимо друг от друга.</li>
</ul><h2>Полиморфизм</h2>Полиморфизм в программировании — это способность предоставлять один и тот же интерфейс для различных базовых форм (типов данных). Это означает, что классы, имеющие различную функциональность, совместно используют один и тот же интерфейс и могут быть динамически вызваны передачей параметров по ссылке.

Классический пример — это класс <code>Shape</code> (фигура) и все классы, наследуемые от него: <code>square</code> (квадрат), <code>circle</code> (круг), <code>dodecahedron</code> (додекаэдр), <code>irregular polygon</code> (неправильный многоугольник), <code>splat</code> (клякса) и так далее.

В этом примере каждый класс будет иметь свой собственный метод <code>Draw()</code> и клиентский код может просто делать:

<pre class="lang-java line-numbers"><code>
Shape shape = new Shape();
</code></pre>
<code>Shape.area()</code> чтобы получить корректное поведение любой фигуры

Красота полиморфизма заключается в том, что код, работая с различными классами, не должен знать, какой класс он использует, так как все они работают по одному принципу. Процесс, применяемый объектно-ориентированными языками программирования для реализации динамического полиморфизма, называется динамическим связыванием.

<em>Примечание:</em> Полиморфизм — это способность выбирать более конкретные методы для исполнения в зависимости от объекта. Полиморфизм осуществляется тогда, когда не задействованы абстракные классы.

<strong>Преимущества:</strong>
<ul>
    <li>Создание повторно используемого кода. То есть, как только  класс создан, реализован и протестирован, он может свободно использоваться без заботы о том, что конкретно в нем написано.</li>
    <li>Это обеспечивает более универсальный и слабосвязанный код.</li>
    <li>Понижается время компиляции, что ускоряет разработку.</li>
    <li>Динамическое связывание.</li>
    <li>Один и тот же интерфейс может быть использован для создания методов с разными реализациями.</li>
    <li>Вся реализация может быть заменена с помощью использования одинаковых сигнатур метода.</li>
</ul>
<strong>Переопределение методов как часть полиморфизма.</strong> Переопределение взаимодействует с двумя методами: методом родительского класса и методом производного класса. Эти методы имеют одинкавые имя и сигнатуры.

Переопределение позволяет вам производить одну и ту же оперецию различными путями для разных типов объектов.

Например:

<pre class="lang-java line-numbers"><code>
while(it.hasNext()) {
Shape s = (Shape) it.next();
totalArea += s.area(dim); //будет применен полиморфизм и вызван нужный метод для каждого объекта. 
}
</code></pre><img data-id="154d8a21-3ca0-4ee8-9934-f4819c4cda5e" data-max-width="850" alt="Концепции объектно-ориентированного программирования JAVA - 2" src="https://cdn.javarush.com/images/article/154d8a21-3ca0-4ee8-9934-f4819c4cda5e/1024.jpeg"><strong>Перезагрузка методов или ad-hoc полиморфизм или статический полиморфизм</strong>

Перезагрузка взаимодействует с несколькими методами одного класса, которые одинаково названы, но имеют разные сигнатуры методов. Перезагрузка позволяет вам описать одну и ту же операцию различными путями для разных данных. Иногда ее называют статическим полиморфизмом, но фактически полиморфизмом она не является. Это ничто иное, как просто наличие двух методов с одинаковыми именами, но разным списком аргументов. Перезагрузка не имеет ничего общего с наследованием и полиморфизмом. И перезагруженный метод совсем не то же самое, что переопределенный метод.

<strong>Параметрический полиморфизм через обобщение в JAVA</strong>

При объявлении класса поле имени может ассоциироваться с различными типами, а имя метода может ассоциироваться с различными параметрами и возвращаемыми типами. JAVA поддерживает параметрический полиморфизм, применяя обобщение (дженерики).

<pre class="lang-java line-numbers"><code>
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
</code></pre>
<strong>Почему мы не можем переопределить статический метод в JAVA?</strong>

Переопределение зависит от наличия экземпляра класса. Идея полиморфизма состоит в том, что вы можете создать подкласс, и объекты, реализуемые теми подклассами, будут вести себя по-другому с теми же методами родителького класса (переопределенными в подклассах). Статический метод не ассоциируется ни к каким экземпляром класса, таким образом, сама концепция переопределения не может быть применена.

Создателями JAVA руководили два соображения, которые повлияли на такой подход. Во-первых, это проблемы исполнения кода: лилось очень много критики в адрес Smalltalk из-за медленной работы (сборщик мусора и полиморфизм были частью этой проблемы), и в проектировании JAVA старались этого избежать. Вторым соображением было решение, что целевой аудиторией JAVA станут С++ разработчики. То, что статические методы работают именно таким образом, было очень знакомо C++ программистам, а так же ускоряло работу, так как не было необходимости проходить вверх по иерархии классов, чтобы выяснить, какой метод вызывать. Вы идете прямо к классу и вызываете конкретный метод.
<h2>Наследование</h2>Наследование — это включение поведения (т.е. методов) и состояния (т.е. переменных) базового класса в производный класс, таким образом они становятся доступны в этом производном классе. Главное преимущество наследования в том, что оно обеспечивает формальный механизм повторного использования кода и избегает дублирования.

Унаследованный класс расширяет функциональность приложения благодаря копированию поведения родительского класса и добавлению новых функций. Это делает код сильно связанным. Если вы захотите изменить суперкласс, вам придется знать все детали подклассов, чтобы не разрушить код.

Наследование — это форма повторного использования программного обеспечения, когда из уже существующего класса (суперкласса) создается новый класс (подкласс), который расширяет свою функциональность и при этом использует некоторые свойства суперкласса.

Так что, если у вас есть класс-родитель, а потом появляется класс-наследник, то наследник наследует все вещи, которыми обладает родитель.

<strong>Преимущества:</strong>
<ul>
    <li>Усовершенствованное повторное использование кода.</li>
    <li>Устанавливается логическое отношение «is a» (является кем-то, чем-то). Например: <u>Dog</u> is a<em>n</em> <u>animal</u>. (Собака является животным).</li>
    <li>Модуляризация кода.</li>
    <li>Исключаются повторения.</li>
</ul><strong>Недостаток:</strong>
<ul>
    <li><strong>Сильная связанность:</strong> подкласс зависит от реализации родительского класса, что делает код сильно связанным.</li>
</ul><table>
<tbody><tr>
<th>Что еще почитать:</th>
</tr>
<tr>
<td>
<p><a href="https://javarush.com/groups/java-developer" target="_blank"><em><strong>Группа Java Developer:</strong></em></a></p><ul>
<li><p><a href="https://javarush.com/groups/posts/1880--principih-oop" target="_blank">Принципы ООП</a></p></li></ul>
</td>
</tr>
</tbody></table><h2>Абстракция</h2>Абстракция означает разработку классов исходя из их интерфейсов и функциональности, не принимая во внимание реализацию деталей. Абстрактный класс представляет собой интерфейсы без включения фактической реализации. Он отличает реализацию объекта от его поведения. Абстракция упрощает код, скрывая несущественные детали. 

<strong>Преимущества:</strong>
<ul>
    <li>Применяя абстракцию, мы можем отделить то, что может быть сгруппировано по какому-либо типу.</li>
    <li>Часто изменяемые свойства и методы могут быть сгруппированы в отдельный тип, таким образом основной тип не будет подвергаться изменениям. Это усиливает принцип ООП: <em>«Код должен быть открытым для Расширения, но закрытым для Изменений»</em>.</li>
    <li>Абстракция упрощает представление доменных моделей.</li>
</ul><strong>Отличие между абстракцией и инкапсуляцией</strong>

Инкапсуляция — это стратегия, используемая как часть абстракции. Инкапсуляция относится к структуре объекта: объекты инкапсулируют свои свойства и скрывают их от доступа извне. Пользователи класса взаимодействуют с ним с помощью его методов, но не имеют доступа напрямую к структуре класса. Таким образом класс абстрагирует детали реализации, относящиеся к его строению.

Абстракция является более общим термином. Она также может достигаться среди прочего с помощью подклассов. Например, класс <code>List</code> (список) в стандартной библиотеке является абстракцией для последовательности элементов, проиндексированных согласно их места в списке. Конкретными примерами списка <code>List</code> являются <code>ArrayList</code> или <code>LinkedList</code>. Код, который взаимодействует со списком <code>List</code> абстрагируется от деталей, какой именно список он использует. 

Часто абстракция невозможна без сокрытия основного состояния с помощью инкапсуляции. Если класс раскрывает свою внутреннюю структуру, он не может изменить свои внутренние операции, а, следовательно, не может абстрагироваться.

<strong>Что такое абстрактный класс и абстрактный метод?</strong>

Случается, что во время разработки вы хотите, чтобы базовый класс представлял только интерфейс для его производных классов. То есть вы не хотите, чтобы кто-либо создавал экземпляры базового класса. Вам необходимо использовать интерфейс таким образом, чтобы только приводить объекты к нему (это неявное приведение, которое обеспечивает полиморфное поведение). Это достигается путем создания данного класса абстрактным с помощью ключевого слова <code>abstract</code>. 

Это накладывает некоторые ограничения, такие как невозможность создавать экземпляры абстрактного класса, при использовании абстрактного класса необходимо реализовывать абстрактные методы. Этим обеспечивается полиморфизм.

Абстрактный класс может содержать и абстрактные и конкретные методы. Если хоть один метод в классе объявлен абстрактным, весь класс должен так же быть объявлен абстрактным. Тем не менее, в обратную сторону правило не обязано соблюдаться. Если класс объявлен абстрактным, он может и не содержать абстрактные методы.

Метод, который всего лишь определяет свои сигнатуры и не обеспечивает реализацию, называется абстрактным. Фактическая его реализация оставлена его подклассам, которые расширяют абстрактный класс. Абстрактный метод не может быть использован объектом, только другой класс может его расширить.

<strong>Когда необходимо использовать абстрактный класс?</strong>

Абстрактные классы позволяют вам определить некоторое  поведение по умолчанию и заставить подклассы обеспечить любое конкретное поведение. Например: <code>List</code> (список) является интерфейсом, в свою очередь <code>AbstractList</code> определяет основное поведение Списка, которое может быть использовано как есть или уточнено в подклассе, например, в <code>ArrayList</code> (списочный массив).

<strong>Что такое интерфейс?</strong>

В концепции интерфейса лежит абстрактный класс, но интерфейс (определяется ключевым словом <code>interface</code>) шагнул дальше. Он предотвращает вообще любую реализацию метода или функции. Вы можете только объявлять метод или функцию, но не обеспечивать их реализацию. Класс, который реализует данный интерфейс, должен как раз и позаботиться о фактической  реализации. Интерфейсы очень полезны и повсеместно используются в ООП. Так как они разделяют сам интерфей и реализацию, они предоставляют много преимуществ своего использования:
<ol>
<li><strong>Множественное наследование</strong>.</li>
<li><strong>Слабая связанность</strong>. Происходит абстракция операции, такая как разделение на уровни, а конкретной реализацией может быть что угодно: JDBC, JPA, JTA и т.д.</li>
<li><strong>Программа-интерфейс не реализуется</strong>.</li>
<li><strong>Полиморфизм с динамическим связыванием</strong>: раскрывается програмный интерфейс объекта без раскрытия его фактической реализации.</li>
<li><strong>Абстрактные уровни</strong>, разделение функциональностей.</li>
</ol><strong>Разница между интерфейсом и абстрактным классом.</strong>
<ul>
    <li>Интерфейс — это договорные отношения с классами, которые этот интерфейс реализуют, о том, что реализация происходит путём, обозначенным интерфейсом. Это пустая оболочка с объявленными методами.</li>
    <li>Абстрактный класс определяет некоторое общее поведение и просит свои подклассы определить нетипичное или конкретное поведение для своего класса.</li>
    <li>Методы и члены абстрактного класса могут быть обозначены любым модификатором доступа, в свою очередь все методы интерфейса обязаны быть открытыми (public).</li>
    <li>Когда происходит наследование абстрактного класса, класс-наследник должен определить абстрактные методы, в то время как интерфейс может наследовать другой интерфейс и при этом не обязательно определять его методы.</li>
    <li>Класс-наследник может расширять только один абстрактный класс, а интерфейс может расширять или класс может реализовывать множество других интерфейсов.</li>
    <li>Класс-наследник может определять абстрактные методы с тем же или менее ограниченным модификатором доступа, при этом класс, реализующий интерфейс, должен определять методы с тем же уровнем видимости.</li>
    <li>Интерфейс не содержит конструкторы, в том время, как они есть в абстрактном классе.</li>
    <li>Переменные, объявленные в Java-интерфейсе по умолчанию являются final. Абстрактный класс может содержать переменные, которые не являются final.</li>
    <li>Все участники Java-интерфейса по умолчанию являются <code>public</code>. Участники абстрактного класса могут позволить себе быть <code>public</code>, <code>protected</code> и др.</li> 
</ul><h2>Композиция</h2>Повторное использование кода может быть достигнуто с помощью как наследования, так и композиции. Но при этом задействование композиции обеспечивает более высокий уровень инкапсуляции, чем наследование, так как изменения в back-end классе не обязательно затронут код, который относится к front-end классу.

Композиция — это техника проектирования, применяющая в классах отношения типа “has-a” (имеет, включает в себя). Для повторного использования кода могут применяться как наследование в java, так и композиция объекта.

Суть композиции заключается в выражении отношения "has a" между объектами. Подумайте о стуле. У стула есть (has a) сидение. У стула есть (has a) спинка. У стула есть (has a) определенное количество ножек. Фраза ”has a” / “есть” предполагает отношения, в которых стул имеет или, как минимум, использует другой объект. Это как раз и есть отношения “has-a”, являющиеся основой композиции.

<strong>Преимущества:</strong>
<ul>
    <li>Контроль видимости</li>
    <li>Реализация может быть заменена во время выполнения (run-time)</li>
    <li>Слабая связанность, так как класс-интерфейс не зависит от реализации.</li>
</ul><strong>Различия между композицией и наследованием</strong>
<table>
<tbody><tr><th>№</th><th>Композиция (has a / имеет)</th><th>Наследование (is a / является)
</th></tr>
<tr><td>1</td><td>Поддерживает полиморфизм и повторное использование кода.</td><td>Поддерживает полиморфизм и повторное использование кода.</td></tr>
<tr><td>2</td><td>Объект во время выполнения (run-time) уже создан.</td><td>Объект создается динамически во время компиляции.</td></tr>
<tr><td>3</td><td>Реализация может быть заменена во время выполнения (run-time).
</td><td>Реализация может быть заменена во время компиляции.</td></tr>
<tr></tr><tr><td>4</td><td>Подкласс не зависит от класса-родителя, что благоприятствует слабому связыванию (особенно под управлением интерфейса).</td><td>Подкласс завизист от реализации класса-родителя, поэтому связывание считается сильным.</td></tr>
<tr><td>5</td><td>Использование: в Доме есть Ванная комната. Неправильно говорить, что Дом — это Ванная комната.</td><td>Наследование является однонаправленным: Дом — это Здание. Но здание не является домом.</td></tr>
</tbody></table><em>Примечание:</em> Не используйте наследование только для того, чтобы обеспечить повторное использование кода. Если нет отношенией “is a“ (является), для этих целей используется композиция.

<strong>Разница между композицией и агрегацией в отношениях объектов.</strong>

<em>Агрегация</em> — это  взаимосвязь, при которой один класс вписывается в коллекцию. Это  часть целого отношения, где часть может существовать без целого. Такие отношения гораздо слабее. Нет циклической зависимости. Например: заказ и продукт.

<em>Композиция</em> — это  взаимосвязь, при которой один класс вписывается в коллекцию. Это  часть целого отношения, при которой часть не может существовать без целого. Если целое уничтожается, все его составляющие тоже будут уничтожены. Это более сильные отношения. Например: многоугольник и его вершины, заказ и его компонент.