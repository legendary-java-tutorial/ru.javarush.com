Простой способ внедрения зависимостей
<p>----------------------------------------</p>
Внедрение зависимостей или инъекция зависимостей (Dependency injection, DI) – непростая для понимания концепция, а её применение к новым или уже существующим приложениям – задача еще более запутанная. Джесс Смит покажет вам, как осуществлять внедрение ...
<p>----------------------------------------</p>
<em>Внедрение зависимостей или инъекция зависимостей (Dependency injection, DI) – непростая для понимания концепция, а её применение к новым или уже существующим приложениям – задача еще более запутанная. <a href='https://www.informit.com/articles/article.aspx?p=2302794' target='_blank' rel="nofollow">Джесс Смит</a> покажет вам, как осуществлять внедрение зависимостей без контейнера внедрения на языках программирования C# и Java.</em>
<img data-id="2c169f53-7f99-4009-9be7-b2b76c2b9b38" data-max-width="850" alt="Простой способ внедрения зависимостей - 1" src="https://cdn.javarush.com/images/article/2c169f53-7f99-4009-9be7-b2b76c2b9b38/1024.jpeg">В этой статье я покажу вам, как внедрять зависимости (DI) в .NET- и Java-приложениях. Концепция внедрения зависимостей впервые появилась в поле зрения разработчиков в 2000 году, когда Роберт Мартин написал статью "Принципы и паттерны проектирования" (позднее получивших известность под аббревиатурой <a href='https://javarush.com/groups/posts/698-pjatjh-osnovnihkh-principov-dizayna-klassov-solid-v-java' target='_blank'>SOLID</a>). Буква D в SOLID относится к инверсии зависимостей (Dependency of Inversion, DOI), которую позднее стали называть внедрением зависимостей.

Изначальное и чаще всего встречающееся определение: инверсия зависимостей — это инверсия способа управления зависимостями базовым классом. В исходной статье Мартина использовался следующий код, иллюстрирующий зависимость класса <code>Copy</code> от более низкоуровневого класса <code>WritePrinter</code>:

<pre class='lang-java line-numbers'><code>
void Copy()
	{
	 int c;
	 while ((c = ReadKeyboard()) != EOF)
		WritePrinter(c);
	}
</code></pre>
Первая очевидная проблема: если изменить список или типы параметров метода <code>WritePrinter</code>, нужно внедрить обновления везде, где есть зависимость от этого метода. Этот процесс повышает затраты на обслуживание и является потенциальным источником новых ошибок.
<table>
<tr>
<td>
Интересно читать о Java? Вступайте в группу <a href='https://javarush.com/groups/java-developer' target='_blank'>Java Developer</a>!
</td>
</tr>
</table>Другая проблема: класс Copy перестает быть потенциальным кандидатом на повторное использование. Например, что делать, если вам понадобится вывести вводимые с клавиатуры символы в файл вместо принтера? Для этого можно модифицировать класс <code>Copy</code> следующим образом (синтаксис языка C++):

<pre class='lang-java line-numbers'><code>
void Copy(outputDevice dev)
	{
	int c;
	while ((c = ReadKeyboard()) != EOF)
		if (dev == printer)
			WritePrinter(c);
		else
			WriteDisk(c);
	}
</code></pre>
Несмотря на появление новой зависимости <code>WriteDisk</code>, ситуация не улучшилась (а скорее ухудшилась), поскольку был нарушен другой принцип: "программные сущности, то есть, классы, модули, функции и так далее, должны быть открыты для расширения, но закрыты для изменения".

Мартин поясняет, что эти новые условные операторы if/else понижают стабильность и гибкость кода. Решение состоит в инверсии зависимостей, чтобы методы записи и чтения зависели от класса <code>Copy</code>. Вместо "выталкивания" зависимостей, они передаются через конструктор.

Переделанный код выглядит следующим образом:

<pre class='lang-java line-numbers'><code>
class Reader
	{
		public:
		virtual int Read() = 0;
	};
	class Writer
	{
		public:
		virtual void Write(char) = 0;
	};
	void Copy(Reader& r, Writer& w)
	{
		int c;
		while((c=r.Read()) != EOF)
		w.Write(c);
	}
</code></pre>
Теперь класс <code>Copy</code> можно легко использовать повторно с различными реализациями методов классов <code>Reader</code> и <code>Writer</code>. У класса <code>Copy</code> нет никакой информации о внутреннем устройстве типов <code>Reader</code> и <code>Writer</code>, благодаря чему возможно их переиспользование с различными реализациями.

Но если всё это кажется вам какой-то абракадаброй, возможно, ситуацию прояснят приведенные ниже примеры на языках Java и C#.
<h3>Пример на языках Java и C#</h3>Для иллюстрации простоты внедрения зависимостей без контейнера зависимостей, начнем с простого примера, который можно переделать под использование <code>DI</code> всего за несколько шагов.

Допустим, у нас есть класс <code>HtmlUserPresentation</code>, который, при вызове его методов, формирует пользовательский HTML-интерфейс.

Вот простой пример:

<pre class='lang-java line-numbers'><code>
HtmlUserPresentation htmlUserPresentation = new HtmlUserPresentation();
String table = htmlUserPresentation.createTable(rowTableVals, "Login Error Status");
</code></pre>
У любого использующего этот код класса проекта появляется зависимость от класса <code>HtmlUserPresentation</code>, что приводит к вышеописанным проблемам с удобством использования и обслуживанием.

Сразу напрашивается усовершенствование: создание интерфейса с сигнатурами всех ныне имеющихся в классе <code>HtmlUserPresentation</code> методов.

Вот пример этого интерфейса:

<pre class='lang-java line-numbers'><code>
public interface IHtmlUserPresentation {
	String createTable(ArrayList rowVals, String caption);
	String createTableRow(String tableCol);
	// Оставшиеся сигнатуры
}
</code></pre>
После создания интерфейса, модифицируем класс <code>HtmlUserPresentation</code> для его использования. Возвращаясь к созданию экземпляра типа <code>HtmlUserPresentation</code>, мы можем теперь использовать тип интерфейса вместо базового:

<pre class='lang-java line-numbers'><code>
IHtmlUserPresentation htmlUserPresentation = new HtmlUserPresentation();
String table = htmlUserPresentation.createTable(rowTableVals, "Login Error Status");
</code></pre>
Создание интерфейса позволяет нам легко использовать другие реализации типа <code>IHtmlUserPresentation</code>. Например, если мы хотим протестировать этот тип, то легко можем заменить базовый тип <code>HtmlUserPresentation</code> на другой тип, под названием <code>HtmlUserPresentationTest</code>.

Выполненные до сих пор изменения упрощают тестирование, обслуживание и масштабирование кода, но ничего не делают для переиспользования, поскольку все использующие тип <code>HtmlUserPresentation</code> классы все еще знают о его существовании.

Чтобы убрать эту прямую зависимость, можно передавать интерфейсный тип <code>IHtmlUserPresentation</code> в конструктор (или список параметров метода) класса или метод, который его будет использовать:

<pre class='lang-java line-numbers'><code>
public UploadFile(IHtmlUserPresentation htmlUserPresentation)
</code></pre>
У конструктора <code>UploadFile</code> теперь есть доступ ко всей функциональности типа <code>IHtmlUserPresentation</code>, но он ничего не знает о внутреннем устройстве реализующего этот интерфейс класса.

В данном контексте, внедрение типа происходит при создании экземпляра класса <code>UploadFile</code>. Интерфейсный тип <code>IHtmlUserPresentation</code> становится переиспользуемым, передавая различные реализации различным классам или методам, для которых необходима разная функциональность.
<h2>Заключение и рекомендации для закрепления материала</h2>Вы узнали о том, что такое внедрение зависимостей и о том, что классы называются напрямую зависящими друг от друга тогда, когда один из них создает экземпляр другого для получения доступа к функциональности целевого типа.

Для расцепления прямой зависимости между двумя типами следует создать интерфейс. Интерфейс предоставляет типу возможность включать различные реализации, в зависимости от контекста необходимой функциональности.

Благодаря передаче интерфейсного типа конструктору или методу класса, класс/метод, для которого нужна функциональность, не знает никаких подробностей о реализующем интерфейс типе. В силу этого интерфейсный тип можно использовать повторно для различных классов, требующих схожего, но не одинакового поведения.
<ul>
<li>Чтобы поэкспериментировать с внедрением зависимостей, просмотрите свой код из одного или нескольких приложений и попробуйте переделать интенсивно используемый базовый тип в интерфейс.</li><br>
<li>Измените непосредственно создающие экземпляры этого базового типа классы так, чтобы они использовали этот новый интерфейсный тип и передавали его через конструктор или список параметров метода класса, который его должен будет использовать.</li><br>
<li>Создайте тестовую реализацию для проверки этого интерфейсного типа. После рефакторинга вашего кода реализовать <code>DI</code> станет проще, и вы заметите, насколько более гибким станет ваше приложение в смысле переиспользования и сопровождения.</li>
</ul><table>
<tr><th>Что еще почитать?</th>
</tr>
<tr>
<td>
<p><a href='https://javarush.com/groups/posts/399-skaz-o-dvukh-iteratorakh-strategii-konkurentnoy-modifikacii-v-java-' target='_blank'>Сказ о двух итераторах: стратегии конкурентной модификации в Java</a></p>
<p><a href='https://javarush.com/groups/posts/394-mashinnihy-kod-i-bayt-kod-na-kakom-jazihke-govorit-vasha-programma' target='_blank'>Машинный код и байт код: на каком языке говорит ваша программа?</a></p>
</td>
</tr>
</table>