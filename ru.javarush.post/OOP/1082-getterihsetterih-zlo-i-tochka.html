Геттеры/Сеттеры. Зло. И точка
<p>----------------------------------------</p>
Этот старый спор начал Аллен Холаб в своей знаменитой статье, еще в 2003 году, Почему методы геттер и сеттер - зло - являются ли геттеры/сеттеры анти-паттерном и стоит ли их избегать, или это то, что нам неминуемо понадобиться в объектно-ориентированном ...
<p>----------------------------------------</p>
<em>Статья  Егора Бугаенко 19 Сентября, 2014 | Опубликовано в: Core Java</em> 
<img data-id="17a1f5cd-365a-4c77-b0f1-54e5465b3cf5" data-max-width="850" alt="Геттеры/Сеттеры. Зло. И точка - 1" src="https://cdn.javarush.com/images/article/17a1f5cd-365a-4c77-b0f1-54e5465b3cf5/1024.jpeg">Этот старый спор начал Аллен Холаб в своей знаменитой статье, еще в 2003 году, <a href="http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html" rel="nofollow" >Почему методы геттер и сеттер - зло</a> - являются ли геттеры/сеттеры анти-паттерном и стоит ли их избегать, или это то, что нам неминуемо понадобиться в объектно-ориентированном программировании. Добавлю я и свои полкопейки в эту дискуссию.

Суть текста ниже вот в чем: геттеры и сеттеры - это плохая практика, у тех, кто их использует нет никаких оправданий. Но опять же, чтобы избежать непонимания, я вовсе не утверждаю, что использование get/set нужно избегать, где возможно. 

Нет. Я говорю о том, <strong>что вы их даже близко к вашему коду не подпускали</strong>.
<img data-id="80cab84e-def7-4d05-995a-702e4c976bb8" data-max-width="410" alt="Геттеры/Сеттеры. Зло. И точка - 2" src="https://cdn.javarush.com/images/article/80cab84e-def7-4d05-995a-702e4c976bb8/1024.jpeg">Как вам такое заявление? Достойно вашего внимания? 

Вы уже пользуйтесь get/set паттерном 15 лет и вы уважаемый Java  архитектор? И не хотите даже слушать эту чепуху от незнакомца? Ну... я понимаю ваши чувства. Я чувствовал тоже самое, пока ни наткнулся на книгу Дэвида Уэста "Object Thinking" - это самая лучшая книга по объектно-ориентированному программированию, которую я когда-либо читал. Поэтому, пожалуйста. Успокойтесь и попробуйте понять, что я пытаюсь объяснить.

<strong>Предмет Спора</strong>

Есть несколько аргументов против "аксессоров" (другое название геттеров и сеттеров) в объектно-ориентированном мире. И все они - очень правильные аргументы. Давайте кратко их рассмотрим.

<strong>Спрашивай, Не Говори</strong>: 

Аллен Холаб говорит: "Не проси информацию, которая вам нужна для работы; "проси" объект, у которого есть эта информация сделать работу за вас."

<strong>Нарушенный Принцип Инкапсуляции</strong>: 

Предмет может быть разобран по частям другими объектами, потому что они в состоянии встроить любые данные в объект, через сеттеры. Объект просто не может инкапсулировать свое собственное состояние достаточно безопасно, потому что любой может это состояние изменить.

<strong>Раскрытые Детали Реализации</strong>: 

Если вы можете достать (get) один объект из другого объекта, тогда получается, что мы слишком надеемся на детали реализации первого объекта. Если завтра он изменится (к примеру тип результата), то нам придется изменять код.

Все вышеизложенные обоснования конечно имеют смысл, но тут упускается самый важный момент.

<strong>Основное Заблуждение</strong>

Большинство программистов верят, что объект - это структура данных с методами. Я цитирую статью Божидара Божанова: <a href="http://java.dzone.com/articles/getters-and-setters-are-not" rel="nofollow" >Геттеры и Сеттеры - не зло</a>. Но большинство объектов, для которых создаются геттеры и сеттеры просто содержат в себе данные.

Это заблуждение является результатом огромного непонимания! Объекты - не "просто хранят данные". Объекты - не структуры данных с прикрепленными методами. Эта концепция "хранения данных" пришла в объектно-ориентированное программирование их процедурных языков, особенно таких как C и COBOL. Я снова повторю: объект - не просто набор элементов данных и функции, которые ими манипулируют. Объект - это не объект данных. Тогда что?

<strong>Мячик и Собака</strong>

В настоящем объектно-ориентированном программировании объекты - живые существа, как вы и я. Они живые организмы, со своим собственным поведением, свойствами и циклом жизни.

Может живой организм иметь сеттер? Вы можете прицепить (“set”) мячик к собаке? Не думаю. Но ровно это и делает кусок кода ниже:

<pre class='lang-java line-numbers'><code>
Dog dog = new Dog();
dog.setBall(new Ball());
</code></pre>
Ну и как это вам?

Вы можете достать (“get ”) мячик из собаки? Ну, положим, что вы сможете. В случае, если она его съела и вы сделали ей операцию. В этом случае, да, вы сможете достать (“get”) мячик из собаки. Это как раз то, о чем я говорю:

<pre class='lang-java line-numbers'><code>
Dog dog = new Dog();
Ball ball = dog.getBall();
</code></pre>

Или еще более нелепый пример:

<pre class='lang-java line-numbers'><code>
Dog dog = new Dog();
dog.setWeight("23kg");
</code></pre>
Вы такое в реальной жизни себе можете представить?

Похоже на то, что вы пишете каждый день? Если да, то вы - процедурный программист. Просто признайтесь в этом. А вот, что говорит Дэвид Уэст на странице 30 своей книги:

Первым шагом в трансформации успешного процедурного разработчика в успешного объективного разработчика -это лоботомия.

Вам нужна лоботомия? Мне точно была нужна, и я ее получил, пока читал книгу Уэста "Object Thinking".

<strong>Объективное Мышление</strong>

Начните думать как объект и вы сразу же переименуете эти методы. Вот, что возможно у вас получится:

<pre class='lang-java line-numbers'><code>
Dog dog = new Dog();
dog.take(new Ball());
Ball ball = dog.give();
</code></pre>
Вот теперь мы относимся к собаке как к настоящему животному, которое может взять у нас мячик и может отдать обратно, если мы попросим. На всякий случай замечу, что собака не сможет вернуть NULL. Просто собаки не знают, что такое NULL! Объективное мышление (думание) сразу же убирает <a href="http://www.javacodegeeks.com/2014/09/why-null-is-bad.html" rel="nofollow" >NULL references</a> из вашего кода.
<img data-id="f8d5dfee-2d4d-493d-a278-9f67bd69fe7a" data-max-width="570" alt="Геттеры/Сеттеры. Зло. И точка - 3" src="https://cdn.javarush.com/images/article/f8d5dfee-2d4d-493d-a278-9f67bd69fe7a/1024.jpeg"><center><em>Рыбка по Имени Ванда (1988) Чарльза Кричтона</em></center>
Кроме того, объективное мышление приведет к неизменяемости (immutability) объекта, такого как "вес собаки" в нашем примере. Вы бы переписали код примерно так:

<pre class='lang-java line-numbers'><code>
Dog dog = new Dog("23kg");
int weight = dog.weight();
</code></pre>
Собака- это неизменяемый живой организм, который не позволит никому снаружи менять ее вес, или размер, или имя, и т.п. Она может "сообщить", по запросу, ее вес или имя. Нет ничего плохого в публичных методах, которые отображают запросы определенных "внутренних" свойств объекта. Но эти методы не "геттеры" и они никогда не должны получать префикс “get”. Мы не "достаем" (“getting”) из собаки. Мы не получаем ее имя. Мы просим ее сказать нам ее имя. 

Видите разницу?

Мы даже не о семантике тут говорим. Мы дифференцируем процедурный подход к программированию от объектно-ориентированного. В процедурном программировании мы работаем с данными, манипулируем ими, получаем (get) , и устанавливаем (set), и удаляем, если нужно. Мы руководим, а данные - просто пассивный компонент. Собака для нас ничто - она просто "содержит данные". У нее нет своей жизни. Мы можем свободно получить (get ) все, что нужно от нее и поместить (set) любые данные в нее. Так работают (работали) C, COBOL, Pascal  и другие процедурные языки.

И совершенно противоположная ситуация в объектно-ориентированном мире. Тут мы относимся к объектам как к живым организмам, с их собственной датой рождения и моментом смерти, со своей собственной индивидуальности и привычками, если хотите. Мы можем попросить собаку дать нам кусочек данных (к примеру ее вес) и она может вернуть нам информацию. Но всегда помните, что собака -это активный компонент. Она решает что случиться после запроса.

И именно поэтому -  это абсолютно неверно, когда методы объекта начинаются с set или get. И это даже не о нарушении инкапсуляции, как многие думают. Это о том, что либо вы думаете как объект или вы все еще пишете на COBOL с синтаксисом Java.

<strong>PS</strong>. И да, вы можете спросить: "А что по поводу JavaBeans, JPA, JAXB и многих других Java APIs, которые зависят от get/set?" А что по поводу встроенной функции в Ruby, которая упрощает создание акксессоров? Ну что вам сказать... вам не повезло. Намного легче оставаться в примитивном мире процедурного COBOL, чем понять и принять прекрасный мир настоящих объектов.

<strong>PPS</strong>. Забыл сказать, да, вставка зависимостей через сеттер - это тоже ужасный анти-паттерн. Но об этом в следующем посте!

<a href="http://www.javacodegeeks.com/2014/09/getterssetters-evil-period.html" rel="nofollow" >Oригинальная статья</a>