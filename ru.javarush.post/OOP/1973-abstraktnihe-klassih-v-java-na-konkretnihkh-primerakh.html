Абстрактные классы в Java на конкретных примерах
<p>----------------------------------------</p>
Привет! В прошлых лекциях мы познакомились с интерфейсами и разобрались, для чего они нужны. Сегодняшняя тема будет перекликаться с предыдущей. Поговорим об абстрактных классах в Java. Почему классы называют «абстрактными»?
<p>----------------------------------------</p>
Привет! В прошлых лекциях мы <a href="https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih" target="_blank">познакомились с интерфейсами</a> и разобрались, для чего они нужны. Сегодняшняя тема будет перекликаться с предыдущей. Поговорим об<strong> абстрактных классах</strong> в Java.
<img data-id="c8e6bd5a-3cbd-4721-9762-12c34e613233" data-max-width="850" alt="Абстрактные классы в Java на конкретных примерах - 1" src="https://cdn.javarush.com/images/article/c8e6bd5a-3cbd-4721-9762-12c34e613233/1024.jpeg"><h2>Почему классы называют «абстрактными»</h2>Ты наверняка помнишь, что такое «абстракция» — мы это уже проходили :) Если вдруг подзабыл — не страшно, вспомним: <em>это принцип ООП</em>, согласно которому при проектировании классов и создании объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные. 

Например, если будем проектировать класс <code>SchoolTeacher</code> — школьный учитель — вряд ли понадобится характеристика «<em>рост</em>». Действительно: для преподавателя эта характеристика не важна. Но вот если мы будем создавать в программе класс <code>BasketballPlayer</code> — игрок в баскетбол — <em>рост</em> станет одной из главных характеристик.

Так вот, <strong>абстрактный класс</strong> — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих классов. Эту заготовку нельзя использовать в готовом виде — слишком «сырая». Но она описывает некое общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.
<h2>Примеры абстрактных классов Java</h2>Рассмотрим простой пример с машинами:

<pre class="lang-java line-numbers"><code>
public abstract class Car {

   private String model;
   private String color;
   private int maxSpeed;
  
   public abstract void gas();

   public abstract void brake();

   public String getModel() {
       return model;
   }

   public void setModel(String model) {
       this.model = model;
   }

   public String getColor() {
       return color;
   }

   public void setColor(String color) {
       this.color = color;
   }

   public int getMaxSpeed() {
       return maxSpeed;
   }

   public void setMaxSpeed(int maxSpeed) {
       this.maxSpeed = maxSpeed;
   }
}
</code></pre>
Вот так выглядит самый простой абстрактный класс. Как видишь, ничего особенного :)

Для чего он может нам понадобиться?

Прежде всего, он максимально абстрактно описывает нужную нам сущность — автомобиль. Слово <strong>abstract</strong> находится здесь недаром. В мире не существует «просто машин». Есть грузовики, гоночные автомобили, седаны, купе, внедорожники.

<strong>Наш абстрактный класс — это просто «чертеж», по которому мы позже будем создавать классы-автомобили.</strong>

<pre class="lang-java line-numbers"><code>
public class Sedan extends Car {
  
   @Override
   public void gas() {
       System.out.println("Седан газует!");
   }

   @Override
   public void brake() {
       System.out.println("Седан тормозит!");
   }
  
}
</code></pre>
Это во многом похоже на то, о чем мы говорили в лекциях про наследование. Только там у нас класс <code>Car</code> и его методы не были абстрактными. Но у такого решения есть целый ряд минусов, которые в абстрактных классах исправлены.

Первое и главное — <strong>экземпляр абстрактного класса создать нельзя:</strong>

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       Car car = new Car(); // Ошибка! Класс Car является абстрактным!
   }
}
</code></pre>
Эта «фишка» была реализована создателями Java специально. Еще раз, для запоминания: <em>абстрактный класс — это просто чертеж для будущих «нормальных» классов</em>. Тебе же не нужны экземпляры чертежа, правильно? Вот и экземпляры абстрактного класса создавать не надо :)

А если бы класс <code>Car</code> не был абстрактным, мы легко могли бы создавать его объекты:

<pre class="lang-java line-numbers"><code>
public class Car {

   private String model;
   private String color;
   private int maxSpeed;
  
   public void gas() {
       // какая-то логика
   }

   public  void brake() {
       // какая-то логика
   }
}


public class Main {

   public static void main(String[] args) {

       Car car = new Car(); // Все ок, машина создалась
   }
}
</code></pre>
Теперь у нас в программе появилась какая-то непонятная машина — не грузовик, не гоночная, не седан, а вообще непонятно что. Та самая «просто машина», которых в природе не существует. 

Тот же пример можно привести с животными. Представь, если бы в твоей программе появились объекты <code>Animal</code> — «<em>просто животное</em>». Какого оно вида, к какому семейству относится, какие у него характеристики — непонятно. Было бы странно увидеть его в программе. Никаких «просто животных» в природе не существует. Только собаки, кошки, лисы, кроты и другие.

Абстрактные классы избавляют нас от «<em>просто объектов</em>». Они дают нам базовое состояние и поведение. Например, у всех машин должна быть <em>модель</em>, <em>цвет</em> и <em>максимальная скорость</em>, а еще они должны уметь <em>газовать</em> и <em>тормозить</em>. Вот и все. Это — общая абстрактная схема, дальше ты уже сам проектируешь нужные тебе классы. 
<table>
<tbody><tr>
<th>Что еще почитать:</th>
</tr>
<tr>
<td>
<p><a href="https://javarush.com/groups/java-developer" target="_blank"><em><strong>Группа Java Developer:</strong></em></a></p><ul>
<li><p><a href="https://javarush.com/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java" target="_blank">10 вопросов по абстрактным классам и интерфейсам с собеседований по Java</a></p></li></ul>
</td>
</tr>
</tbody></table><em>Обрати внимание: </em>два метода в абстрактном классе тоже обозначены как <strong>abstract</strong>, и они вообще не реализованы. Причина та же: абстрактные классы не создают «поведения по умолчанию» для «просто машин». Они просто говорят, что должны уметь делать все машины.

Впрочем, если поведение по умолчанию тебе все-таки нужно, методы в абстрактном классе можно реализовать. Java этого не запрещает:

<pre class="lang-java line-numbers"><code>
public abstract class Car {

   private String model;
   private String color;
   private int maxSpeed;

   public void gas() {
       System.out.println("Газуем!");
   }

   public abstract void brake();
  
   //геттеры и сеттеры
}


public class Sedan extends Car {

   @Override
   public void brake() {
       System.out.println("Седан тормозит!");
   }

}

public class Main {

   public static void main(String[] args) {

       Sedan sedan = new Sedan();
       sedan.gas();
   }
}
</code></pre>
Вывод в консоль:

<em>“Газуем!”</em>

Как видишь, мы реализовали в абстрактном классе один метод, а второй не стали.

В итоге поведение нашего класса <code>Sedan</code> разделилось на две части: если вызвать у него метод <code>gas()</code>, он «подтянется» из родительского абстрактного класса <code>Car</code>, а метод <code>brake()</code> мы переопределили в классе <code>Sedan</code>. Получилось очень удобно и гибко.

Но теперь <strong>наш класс не такой уж и абстрактный</strong>? Ведь у него, по факту, половина методов реализована.

На самом деле — и это очень важная особенность — <strong>класс является абстрактным, если хотя бы один из его методов является абстрактным</strong>. Хоть один из двух, хоть один из тысячи методов — без разницы.

Мы можем даже реализовать все методы и не оставить ни одного абстрактного. Будет абстрактный класс без абстрактных методов. В принципе, это возможно, и компилятор не выдаст ошибок, но лучше так не делать: слово abstract потеряет смысл, а твои коллеги-программисты сильно удивятся, увидев такое :/

При этом, <strong>если метод помечен словом abstract, каждый класс-наследник должен его реализовать или быть объявленным как абстрактный. Иначе компилятор выбросит ошибку</strong>.

Разумеется, каждый класс может наследоваться только от одного абстрактного класса, так что в плане наследования разницы между абстрактными и обычными классами нет. Неважно, наследуемся мы от абстрактного класса или от обычного, класс-родитель может быть только один.

<h2>Почему в Java нет множественного наследования классов</h2>Мы уже говорили, что в Java нет множественного наследования, но так толком и не разобрались почему. Давай попробуем сделать это сейчас.

Дело в том, что если бы в Java было множественное наследование, дочерние классы не могли бы определиться, какое именно поведение им выбрать.

Допустим, у нас есть два класса — <code>Toster</code> и <code>NuclearBomb</code>:

<pre class="lang-java line-numbers"><code>
public class Toster {
  
  
 public void on() {

       System.out.println("Тостер включен, тост готовится!");
   }
  
   public void off() {

       System.out.println("Тостер выключен!");
   }
}


public class NuclearBomb {

   public void on() {

       System.out.println("Взрыв!");
   }
}
</code></pre>
Как видишь, у обоих есть метод <code>on()</code>. В случае с тостером он запускает приготовление тоста, а в случае с ядерной бомбой — устраивает взрыв. 

Ой :/

А теперь представь, что ты решил (уж не знаю, с чего вдруг!) создать что-то среднее между ними. И вот он твой класс — <code>MysteriousDevice</code>!

Этот код, разумеется, нерабочий, и мы приводим его просто в качестве примера «а как оно могло бы быть»:

<pre class="lang-java line-numbers"><code>
public class MysteriousDevice extends Toster, NuclearBomb {

   public static void main(String[] args) {
      
       MysteriousDevice mysteriousDevice = new MysteriousDevice();
       mysteriousDevice.on(); // И что же здесь должно произойти? Мы получим тост, или ядерный апокалипсис?
   }
}
</code></pre>
Давай посмотрим, что у нас получилось. Загадочное устройство происходит одновременно и от Тостера, и от Ядерной Бомбы. У обоих есть метод <code>on()</code>, и в результате непонятно, какой из методов <code>on()</code> должен срабатывать у объекта <code>MysteriousDevice</code>, если мы его вызовем. Объект никак не сможет этого понять. 

Ну и в качестве вишенки на торте: у Ядерной Бомбы нет метода <code>off()</code>, так что если мы не угадали, отключить устройство будет нельзя.
<img data-id="0cf44fb9-0d80-4c1f-b409-31813c1b824a" data-max-width="850" alt="Абстрактные классы в Java на конкретных примерах - 2" src="https://cdn.javarush.com/images/article/0cf44fb9-0d80-4c1f-b409-31813c1b824a/1024.jpeg">
Именно из-за такой «непонятки», когда объекту неясно, какое поведение он должен выбрать, создатели Java отказались от множественного наследования. Впрочем, ты помнишь, что классы Java реализуют множество интерфейсов.

Кстати, ты уже встречался в учебе как минимум с одним абстрактным классом!
Хотя, может, и не заметил этого :)

<pre class="lang-java line-numbers"><code>
public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt;
</code></pre>
Это твой старый знакомый — класс <code>Calendar</code>. Он абстрактный, и у него есть несколько наследников. Одним из них — <code>GregorianCalendar</code>. Ты уже пользовался им в уроках о датах :) 

Вроде бы все понятно, остался только один момент: в чем все-таки принципиальная <a href="https://javarush.com/groups/posts/1985-raznica-mezhdu-abstraktnihmi-klassami-i-interfeysami" target="_blank">разница между абстрактными классами и интерфейсами</a>? Зачем в Java добавили и то, и другое, а не ограничились чем-то одним?  Этого ведь вполне могло хватить.

Об этом поговорим в следующей лекции! До встречи:)