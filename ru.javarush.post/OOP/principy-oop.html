Принципы ООП
<p>----------------------------------------</p>
Java является объектно-ориентированным языком. Это означает, что писать программы на Java нужно с применением объектно-ориентированного стиля. И стиль этот основан на использовании в программе объектов и классов. Попробуем с помощью примеров разобраться, что такое классы ...
<p>----------------------------------------</p>
Java является объектно-ориентированным языком. Это означает, что писать программы на Java нужно с применением объектно-ориентированного стиля. И стиль этот основан на использовании в программе объектов и классов. 

<h3>Основные принципы ООП:</h3><ul>
<li><a href="https://javarush.com/groups/posts/principy-oop#Абстракция-ООП">Абстракция</a></li>
<li><a href="https://javarush.com/groups/posts/principy-oop#Инкапсуляция">Инкапсуляция</a></li>
<li><a href="https://javarush.com/groups/posts/principy-oop#Наследование">Наследование</a></li>
<li><a href="https://javarush.com/groups/posts/principy-oop#Полиморфизм">Полиморфизм</a></li>
</ul><img data-id="307c1c60-c1a4-445b-8946-fcfb32b56d1e" data-max-width="850" alt=" Принципы ООП - 1" src="https://cdn.javarush.com/images/article/307c1c60-c1a4-445b-8946-fcfb32b56d1e/1024.jpeg">Попробуем с помощью примеров разобраться, что такое классы и объекты, а также с тем, как применять на практике основные принципы ООП: абстракцию, наследование, полиморфизм и инкапсуляцию.
<h3>Что такое объект?</h3>Мир, в котором мы живем, состоит из объектов. Если мы посмотрим вокруг, то увидим, что нас окружают дома, деревья, автомобили, мебель, посуда, компьютеры. Все эти предметы являются объектами, и каждый из них обладает набором определенных характеристик, поведением и назначением. 

Мы привыкли к объектам, и мы их используем всегда для вполне конкретных целей. Например, если нам необходимо доехать до работы, мы пользуемся автомобилем, если захотим поесть – посудой, а если отдохнуть – нам понадобится удобный диван.
 
Человек привык мыслить объектно для решения задач в повседневной жизни. Это послужило одной из причин использования объектов в программировании, а такой подход к созданию программ назвали объектно-ориентированным.

Приведём пример. Представьте, что вы разработали новую модель телефона и хотите наладить её серийное производство. Как разработчик телефона, вы знаете для чего он нужен, как он будет функционировать, и из каких деталей он будет состоять (корпус, микрофон, динамик, провода, кнопки и т.д.).  При этом только вы знаете, как соединить эти детали.

 Однако вы не планируете выпускать телефоны лично, для этого у вас есть целый штат работников. Чтобы вам не пришлось каждый раз объяснять, как соединить детали телефона, и чтобы все телефоны при производстве получались одинаковыми, прежде чем начать их выпуск, вам понадобиться сделать чертеж в виде описания устройства телефона. <span class="text-bold">В ООП такое описание, чертеж, схема или шаблон называется классом, из которого при выполнении программы создается объект.</span> 

Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.
<h2 id="Абстракция-ООП">Абстракция ООП</h2>Давайте теперь подумаем, как нам перейти от объекта из реального мира к объекту в программе на примере телефона. История этого средства связи превышает 100 лет и современный телефон, в отличие от своего предшественника из 19 века, представляет собой куда более сложное устройство.

Когда мы пользуемся телефоном, то не задумываемся о его устройстве и процессах, происходящих внутри него. Мы просто используем функции, предоставленные разработчиками телефона — кнопки или сенсорный экран для выбора номера и совершения вызовов. 

Одним из первых интерфейсов телефона была рукоятка, которую нужно было вращать, чтобы сделать вызов. Разумеется, это было не очень удобно. Тем не менее, свою функцию рукоять исправно выполняла.

Если посмотреть на самый современный и на самый первый телефон, можно сразу выделить самые важные детали, которые важны и для устройства конца 19-го века, и для суперсовременного смартфона. Это совершение вызова (набор номера) и приём вызова. По сути это то, что делает телефон телефоном, а не чем-то другим. Сейчас мы применили принцип в ООП — выделение наиболее важных характеристик и информации об объекте. <span class="text-bold">Этот принцип ООП называется абстракцией. </span>

Абстракцию в ООП можно также определить, как способ представления элементов задачи из реального мира в виде объектов в программе. Абстракция всегда связана с обобщением некоторой информации о свойствах предметов или объектов, поэтому главное — это отделить значимую информацию от незначимой в контексте решаемой задачи. При этом уровней абстракции может быть несколько.

Попробуем применить принцип абстракции к нашим телефонам. Для начала выделим наиболее распространённые типы телефонов от самых первых и до наших дней. Например, их можно представить в виде диаграммы, приведенной на рисунке 1.
<img data-id="231fecfa-b0f7-46d0-9500-32d1cdced5e2" data-max-width="850" alt=" Принципы ООП - 2" src="https://cdn.javarush.com/images/article/231fecfa-b0f7-46d0-9500-32d1cdced5e2/1024.jpeg">Теперь с помощью абстракции мы можем выделить в этой иерархии объектов общую информацию: общий абстрактный тип объектов — телефон, общую характеристику телефона — год его создания, и общий интерфейс — все телефоны способны принимать и посылать вызовы.

Вот как это выглядит на Java: 

<pre class="lang-java line-numbers"><code>
public abstract class AbstractPhone {
    private int year;

    public AbstractPhone(int year) {
        this.year = year;
    }
    public abstract void call(int outputNumber);
    public abstract void ring (int inputNumber);
}
</code></pre>
На основании этого абстрактного класса мы сможем создавать в программе новые типы телефонов с использованием других базовых принципов ООП Java, которые рассмотрим ниже.
<h2 id="Инкапсуляция">Инкапсуляция</h2><span class="text-bold">С помощью абстракции мы выделяем общее для всех объектов.</span> Однако каждая модель телефона — индивидуальна и чем-то отличается от других. Как же нам в программе провести границы и обозначить эту индивидуальность?

Как сделать так, чтоб никто из пользователей случайно или преднамеренно не смог сломать наш телефон, или попытаться переделать одну модель в другую? Для мира реальных объектов ответ очевиден: нужно поместить все детали в корпус телефона. Ведь если этого не сделать и оставить все внутренности телефона и провода, соединяющие их снаружи, обязательно найдется любознательный экспериментатор, который захочет “улучшить” работу нашего телефона. Для исключения подобного вмешательства в конструкцию и работу объекта <strong>в ООП используют принцип инкапсуляции</strong> – еще один базовый принцип ООП, при котором атрибуты и поведение объекта объединяются в одном классе, внутренняя реализация объекта скрывается от пользователя, а для работы с объектом предоставляется открытый интерфейс.

Задача программиста — определить, какие атрибуты и методы будут доступны для открытого доступа, а какие являются внутренней реализацией объекта и должны быть недоступны для изменений. 
<h2>Инкапсуляция и управление доступом</h2>Допустим, при производстве на тыльной стороне телефона гравируется информация о нем: год его выпуска или логотип компании производителя. Эта информация вполне конкретно характеризует данную модель — его состояние. Можно сказать, разработчик телефона позаботился о неизменности этой информации — вряд ли кому-то придет в голову удалять гравировку. 

В мире Java состояние будущих объектов описывается в классе с помощью полей, а их поведение – с помощью методов. Возможность же изменения состояния и поведения осуществляется с помощью модификаторов доступа к полям и методам – <code>private</code>, <code>protected</code>, <code>public</code>, а также <code>default</code> (доступ по умолчанию). 

Например, мы решили, что год создания, название производителя телефона и один из методов относятся к внутренней реализации класса и не подлежат изменению другими объектами в программе.

 С помощью кода класс можно описать так:

<pre class="lang-java line-numbers"><code>
public class SomePhone {

    private int year;
    private String company;
    public SomePhone(int year, String company) {
        this.year = year;
        this.company = company;
    }
private void openConnection(){
    //findComutator
    //openNewConnection...
}
public void call() {
    openConnection();
    System.out.println("Вызываю номер");
}

public void ring() {
    System.out.println("Дзынь-дзынь");
}

 }
</code></pre>
Модификатор <code>private</code> делает доступными поля и методы класса только внутри данного класса. Это означает, что получить доступ к <code>private</code> полям извне невозможно, как и нет возможности вызвать <code>private</code> методы.

Сокрытие доступа к методу <code>openConnection</code>, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Для работы с нашим объектом мы оставляем открытыми методы <code>call</code> и <code>ring</code> с помощью модификатора <code>public</code>. <span class="text-bold">Предоставление открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть доступ к объекту – он станет бесполезным.</span>
<h2 id="Наследование">Наследование</h2>Давайте посмотрим еще раз на диаграмму телефонов. Можно заметить, что она представляет собой иерархию, в которой модель, расположенная ниже обладает всеми признаками моделей, расположенных выше по ветке, плюс своими собственными. Например, смартфон, использует сотовую сеть для связи (обладает свойствами сотового телефона), является беспроводным и переносным (обладает свойствами беспроводного телефона) и может принимать и делать вызовы (свойствами телефона). В этом случае мы можем говорить о наследовании свойств объекта. 

<span class="text-bold">В программировании наследование заключается в использовании уже существующих классов для описания новых.</span>

Рассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных батарей, которые имеют определенный ресурс работы в часах. Поэтому добавим это свойство в класс беспроводных телефонов:

<pre class="lang-java line-numbers"><code>
public abstract class WirelessPhone extends AbstractPhone {

    private int hour;

    public WirelessPhone(int year, int hour) {
        super(year);
        this.hour = hour;
    }
    }
</code></pre>
Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов <code>call</code> и <code>ring</code>:

<pre class="lang-java line-numbers"><code>
public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
        super(year, hour);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Вам звонит абонент " + inputNumber);
    }
}
</code></pre>
И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность. С помощью кода класс можно описать так:

<pre class="lang-java line-numbers"><code>
public class Smartphone extends CellPhone {
    
    private String operationSystem;

    public Smartphone(int year, int hour, String operationSystem) {
        super(year, hour);
        this.operationSystem = operationSystem;
    }
public void install(String program){
    System.out.println("Устанавливаю " + program + "для" + operationSystem);
}

}
</code></pre>
Как видите, для описания класса <code>Smartphone</code> мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование принципа наследование ООП позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.
<h2 id="Полиморфизм">Полиморфизм</h2>Если мы посмотрим на все модели телефонов, то, несмотря на различия во внешнем облике и устройстве моделей, мы можем выделить у них некое общее поведение – все они могут принимать и совершать звонки и имеют достаточно понятный и простой набор кнопок управления. Применяя известный нам уже один из основных принципов ООП абстракцию в терминах программирования можно сказать, что объект телефон имеет один общий интерфейс. Поэтому пользователи телефонов могут вполне комфортно пользоваться различными моделями, используя одни и те же кнопки управления (механические или сенсорные), не вдаваясь в технические тонкости устройства. Так, вы постоянно пользуетесь сотовым телефоном, и без труда сможете совершить звонок с его стационарного собрата. 

Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется <span class="text-bold">полиморфизмом</span>. 

Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:

<pre class="lang-java line-numbers"><code>
public class User {
    private String name;

    public User(String name) {
        this.name = name;
            }

    public void callAnotherUser(int number, AbstractPhone phone){
// вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!
        phone.call(number);
    }
}
 }
</code></pre>
Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:

<pre class="lang-java line-numbers"><code>
public class ThomasEdisonPhone extends AbstractPhone {

public ThomasEdisonPhone(int year) {
    super(year);
}
    @Override
    public void call(int outputNumber) {
        System.out.println("Вращайте ручку");
        System.out.println("Сообщите номер абонента, сэр");
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
</code></pre>
Обычный стационарный телефон:

<pre class="lang-java line-numbers"><code>
public class Phone extends AbstractPhone {

    public Phone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер" + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
</code></pre>
И, наконец, крутой видеотелефон:

<pre class="lang-java line-numbers"><code>
public class VideoPhone extends AbstractPhone {

    public VideoPhone(int year) {
        super(year);
    }
    @Override
    public void call(int outputNumber) {
        System.out.println("Подключаю видеоканал для абонента " + outputNumber );
    }
    @Override
    public void ring(int inputNumber) {
        System.out.println("У вас входящий видеовызов..." + inputNumber);
    }
  }
</code></pre>
Создадим объекты в методе <code>main()</code> и протестируем метод <code>callAnotherUser</code>:

<pre class="lang-java line-numbers"><code>
AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
AbstractPhone phone = new Phone(1984);
AbstractPhone videoPhone=new VideoPhone(2018);
User user = new User("Андрей");
user.callAnotherUser(224466,firstPhone);
// Вращайте ручку
//Сообщите номер абонента, сэр
user.callAnotherUser(224466,phone);
//Вызываю номер 224466
user.callAnotherUser(224466,videoPhone);
//Подключаю видеоканал для абонента 224466
</code></pre>
Используя вызов одного и того же метода объекта <code>user</code>, мы получили различные результаты. Выбор конкретной реализации метода <code>call</code> внутри метода <code>callAnotherUser</code> производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения программы.

В примерах классов телефонов, приведенных выше, мы использовали переопределение методов – прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы. 

Обычно, при переопределении метода, используется аннотация <code>@Override</code>, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов. 

<span class="text-bold">В итоге</span>, чтобы стиль вашей программы соответствовал концепции ООП и принципам ООП java следуйте следующим советам:
<ul>
<li>выделяйте главные характеристики объекта;</li>
<li>выделяйте общие свойства и поведение и используйте наследование при создании объектов;</li>
<li>используйте абстрактные типы для описания объектов;</li>
<li>старайтесь всегда скрывать методы и поля, относящиеся к внутренней реализации класса.</li>
</ul>