Приведение (преобразование) примитивных типов в Java
<p>----------------------------------------</p>
Привет! Во время прохождения JavaRush ты не раз сталкивался с примитивными типами. Вот краткий список того, что мы о них знаем: они не являются объектами и представляют собой значение, хранящееся в памяти, они бывают нескольких видов ...
<p>----------------------------------------</p>
Привет! Во время прохождения JavaRush ты не раз сталкивался с примитивными типами.

Вот краткий список того, что мы о них знаем:
<ol>
<li>Они не являются объектами и представляют собой значение, хранящееся в памяти</li>
<li>Примитивные типы бывают нескольких видов: 
<ul>
<li>Целые числа — <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code></li>
<li>Числа с плавающей точкой (дробные) — <code>float</code> и <code>double</code></li>
<li>Логический — <code>boolean</code></li>
<li>Символьный (для обозначения букв и цифр) — <code>char</code></li></ul>
</li><li>Каждый из них имеет свой диапазон значений:</li>
</ol><table>
<thead>
<tr>
<th>Примитивный тип</th>
<th>Размер в памяти</th>
<th>Диапазон значений</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8 бит</td>
<td>от -128 до 127</td>
</tr>
<tr>
<td>short</td>
<td>16 бит</td>
<td>до -32768 до 32767</td>
</tr>
<tr>
<td>char</td>
<td>16 бит</td>
<td>от 0 до 65536</td>
</tr>
<tr>
<td>int</td>
<td>32 бита</td>
<td>	от -2147483648 до 2147483647</td>
</tr>
<tr>
<td>long</td>
<td>64 бита</td>
<td>от -9223372036854775808
до 9223372036854775807
</td>
</tr>
<tr>
<td>float</td>
<td>32 бита</td>
<td>от (2 в степени -149)
до ((2-2 в степени -23)*2 в степени 127)
</td>
</tr>
<tr>
<td>double</td>
<td>64 бита</td>
<td>от (-2 в степени 63)
до ((2 в степени 63) - 1)
</td>
</tr>
<tr>
<td>boolean</td>
<td>8 (при использовании в массивах),
32 (при использовании не в массивах)
</td>
<td>true или false</td>
</tr>
</tbody>
</table>
Но, помимо значений, типы отличаются еще и размером в памяти.

<code>int</code> занимает больше, чем <code>byte</code>.
А <code>long</code> — больше, чем <code>short</code>.

Объем занимаемой примитивами памяти можно сравнить с матрешками:
<img data-id="e50fb1f1-3ad8-4d84-96ba-e1ee8e3a0439" data-max-width="851" alt="Расширение и сужение примитивных типов - 2" src="https://cdn.javarush.com/images/article/e50fb1f1-3ad8-4d84-96ba-e1ee8e3a0439/1024.jpeg">
Внутри матрешки есть свободное место. Чем больше матрешка — тем больше места.
Внутрь большой матрешки <code>long</code> мы легко можем положить меньшую по размеру <code>int</code>. Она легко уместится, и ничего делать дополнительно не нужно.

В Java при работе с примитивами это называется автоматическим преобразованием. По-другому его называют расширением.

Вот простой пример расширения:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
      
       int bigNumber = 10000000;

       byte littleNumber = 16;

       bigNumber = littleNumber;
       System.out.println(bigNumber);
   }
}
</code></pre>
Здесь мы присваиваем значение <code>byte</code> в переменную <code>int</code>. Присваивание прошло успешно и безо всяких проблем: значение, хранящееся в <code>byte</code>, занимает меньший объем в памяти, чем “влезает” в <code>int</code>. 

“Маленькая матрешка” (значение <code>byte</code>) легко влезает в “большую матрешку” (переменную <code>int</code>).

Другое дело, когда ты пытаешься сделать наоборот — положить значение большого размера в переменную, которая на такие размеры не рассчитана.

С настоящими матрешками такой номер в принципе не пройдет, а в Java — пройдет, но с нюансами.

Давай попробуем положить значение <code>int</code> в переменную <code>short</code>:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   int bigNumber = 10000000;
  
   short littleNumber = 1000;

   littleNumber = bigNumber;//ошибка!
   System.out.println(bigNumber);
}
</code></pre>
Ошибка!

Компилятор понимает, что ты пытаешься сделать что-то нестандартное, и засунуть большую матрешку (<code>int</code>) внутрь маленькой (<code>short</code>).

Ошибка компиляции в данном случае — предупреждение от компилятора: “<em>Эй, ты точно уверен, что хочешь это сделать?</em>”

Если ты уверен, говоришь об этом компилятору: “<em>Все ок, я знаю, что делаю!</em>”

Этот процесс называется явным преобразованием типов, или <strong>сужением</strong>.

Чтобы сделать сужение, тебе необходимо явно указать тип, к которому ты хочешь привести свое значение.
Иными словами, ответить компилятору на его вопрос: “<em>Ну и в какую из этих маленьких матрешек ты хочешь засунуть эту большую матрешку?</em>”

В нашем случае это будет выглядеть так:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   int bigNumber = 10000000;

   short littleNumber = 1000;

   littleNumber = (short) bigNumber;
   System.out.println(littleNumber);
}
</code></pre>
Мы явно указали, что хотим уместить значение <code>int</code> в переменную <code>short</code> и берем ответственность на себя. Компилятор, видя явное указание на более узкий тип, проводит преобразование.

Каков же будет результат?

<strong>Вывод в консоль:

<em>-27008</em></strong>

Немного неожиданно. Почему именно такой? На самом деле все просто.

У нас было изначальное значение — 10000000
Оно хранилось в переменной <code>int</code>, которая занимала 32 бита, и в двоичной форме оно выглядело так:
<img data-id="17d2a1a1-34dc-4b5e-a556-1b3476d5b52c" data-max-width="710" alt="Расширение и сужение примитивных типов - 3" src="https://cdn.javarush.com/images/article/17d2a1a1-34dc-4b5e-a556-1b3476d5b52c/1024.jpeg">
Мы записываем это значение в переменную <code>short</code>, но она может хранить только 16 бит!

Соответственно, только первые 16 бит нашего числа и будут туда перемещены, остальные — отбросятся.

В итоге в переменную <code>short</code> попадет значение
<img data-id="eb45b52c-56a0-4611-855b-a2cea5c8e902" data-max-width="710" alt="Расширение и сужение примитивных типов - 4" src="https://cdn.javarush.com/images/article/eb45b52c-56a0-4611-855b-a2cea5c8e902/1024.jpeg">,
которое в десятичной форме как раз равно -27008

Именно поэтому компилятор “просил подтверждения” в форме явного приведения к конкретному типу. Во-первых, оно показывает, что ты берешь ответственность за результат на себя, а во-вторых, указывает компилятору сколько места выделить при приведении типов. Ведь если бы мы в последнем примере приводили <code>int</code> к типу <code>byte</code>, а не к <code>short</code>, в нашем распоряжении было бы только 8 бит, а не 16, и результат был бы уже другим.

Для дробных типов (<code>float</code> и <code>double</code>) сужение происходит по-своему. Если попытаться привести такое число к целочисленному типу, у него будет отброшена дробная часть.

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   double d = 2.7;

   long x = (int) d;
   System.out.println(x);
}
</code></pre>
<strong>Вывод в консоль:

<em>2</em></strong>

<h2>Тип данных char</h2>Ты уже знаешь, что тип char используется для отображения отдельных символов.

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   char c = '!';
   char z = 'z';
   char i = '8';
  
}
</code></pre>
Но у него есть ряд особенностей, которые важно понимать.

Давай еще раз посмотрим в таблицу с диапазонами значений:

<table>
<thead>
<tr>
<th>Примитивный тип</th>
<th>Размер в памяти</th>
<th>Диапазон значений</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8 бит</td>
<td>от -128 до 127</td>
</tr>
<tr>
<td>short</td>
<td>16 бит</td>
<td>от -32768 до 32767</td>
</tr>
<tr>
<td>char</td>
<td>16 бит</td>
<td>от 0 до 65536</td>
</tr>
<tr>
<td>int</td>
<td>32 бита</td>
<td>от -2147483648 до 2147483647</td>
</tr>
<tr>
<td>long</td>
<td>64 бита</td>
<td>от -9223372036854775808
до 9223372036854775807
</td>
</tr>
<tr>
<td>float</td>
<td>32 бита</td>
<td>от (2 в степени -149)
до ((2-2 в степени -23)*2 в степени 127)
</td>
</tr>
<tr>
<td>double</td>
<td>64 бита</td>
<td>от (-2 в степени 63)
до ((2 в степени 63)-1)
</td>
</tr>
<tr>
<td>boolean</td>
<td>8 (при использовании в массивах),
32 (при использовании не в массивах)
</td>
<td>true или false</td>
</tr>
</tbody>
</table>
Для типа <code>char</code> указан числовой диапазон — от 0 до 65536.
Но что это значит? Ведь <code>char</code> — это не только цифры, но и буквы, знаки препинания…

Дело в том, что значения <code>char</code> хранятся в Java в формате Юникода.

Мы уже сталкивались с Юникодом в одной из прошлых лекций. Ты, наверное, помнишь, что <strong>Unicode</strong> — это стандарт кодирования символов, включающий в себя знаки почти всех письменных языков мира.

Иными словами, это список специальных кодов, в котором найдется код почти для любого символа из любого языка.

Общая таблица Юникодов очень большая, и, конечно, ее не нужно учить наизусть.

Вот, например, ее кусочек:
<img data-id="2188f0cc-7b3b-4e7b-adc0-dad301bb96db" data-max-width="850" alt="Расширение и сужение примитивных типов - 5" src="https://cdn.javarush.com/images/article/2188f0cc-7b3b-4e7b-adc0-dad301bb96db/1024.jpeg">
Главное — понимать принцип хранения значений <code>char</code>, и помнить, что <strong>зная код конкретного символа</strong> всегда можно получить его в программе.

Давай попробуем это сделать с каким-нибудь случайным числом:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   int x = 32816;

   char c = (char) x ;
   System.out.println(c);
}
</code></pre>
<strong>Вывод в консоль:

耰</strong>
Именно в таком формате в Java хранятся символы <code>char</code>. Каждому символу соответствует число — числовой код размером 16 бит, или два байта. Юникоду 32816 соответствует иероглиф 耰.

Обрати внимание вот на какой момент.

В этом примере мы использовали переменную <strong><code>int</code></strong>. Она занимает в памяти <strong>32 бита</strong>, в то время как <strong><code>char</code></strong> — <strong>16</strong>. 

Здесь мы выбрали <code>int</code>, потому что нужное нам число 32816 находится за пределами диапазона <code>short</code>. Хотя размер <code>char</code>, как и short, равен 16 битам, но в диапазоне <code>char</code> нет отрицательных чисел, поэтому “положительный” диапазон <code>char</code> в два раза больше (65536 вместо 32767 у <code>short</code>).

Мы можем использовать <code>int</code>, пока наш код укладывается в диапазон до 65536.
Но если создать число <code>int &gt;65536</code>, оно будет занимать больше 16 битов. 

И при сужении типов:

<pre class="lang-java line-numbers"><code>
char c = (char) x;
</code></pre>
лишние биты будут отброшены, и результат будет весьма неожиданным.

<h2>Особенности сложения char и целых чисел</h2>Давай рассмотрим вот такой необычный пример:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

      char c = '1';

      int i = 1;

       System.out.println(i+c);
   }
}
</code></pre>
<strong>Вывод в консоль:

<em>50</em></strong>

O_О

Где логика? 
1+1, откуда взялось 50?!

Ты уже знаешь, что значения <code>char</code> хранятся в памяти как числа в диапазоне от 0 до 65536, обозначающие Юникод нашего символа.
<img data-id="b1d698bc-cdcd-4090-9d2c-d988b9555e8a" data-max-width="850" alt="Расширение и сужение примитивных типов - 6" src="https://cdn.javarush.com/images/article/b1d698bc-cdcd-4090-9d2c-d988b9555e8a/1024.jpeg">
Так вот.

Когда мы производим сложение <code>char</code> и какого-то целочисленного типа, <code>char</code> преобразуется к числу, которое соответствует ему в Юникоде.

Когда в нашем коде мы складывали 1 и ‘1’ — символ ‘1’ преобразовался к своему коду, который равен 49 (можешь проверить в таблице выше).

Поэтому результат и стал равен 50.

Давай еще раз возьмем для примера нашего старого друга — <strong>耰</strong>, и попробуем сложить его с каким-нибудь числом.

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   char c = '耰';
   int x = 200;

   System.out.println(c + x);
}
</code></pre>
<strong>Вывод в консоль:

<em>33016</em></strong>
Мы уже выяснили, что <strong>耰</strong> соответствует коду 32816. А при сложении этого числа и 200 мы получаем как раз наш результат — 33016 :)

Механизм работы, как видишь, достаточно простой.