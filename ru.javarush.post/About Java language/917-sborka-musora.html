Сборщик мусора в Java (Garbage Collector)
<p>----------------------------------------</p>
Java-программисту не нужно следить за распределением памяти, так как сборщик мусора управляет памятью автоматически. Сборщик мусора запускается виртуальной машиной Java (JVM). Сборщик мусора — это низкоприоритетный процесс, который запускается периодически ...
<p>----------------------------------------</p>
<h2>Линия поведения сборщика мусора (утилизатора памяти)</h2>Java-программисту не нужно следить за распределением памяти, так как сборщик мусора управляет памятью автоматически. Сборщик мусора (Garbage Collector) запускается виртуальной машиной Java (JVM). Сборщик мусора — это низкоприоритетный процесс, который запускается периодически и освобождает память, использованную объектами, которые больше не нужны.

Разные JVM имеют отличные друг от друга алгоритмы сбора мусора. Существует несколько используемых алгоритмов, например: алгоритм подсчёта ссылок или алгоритмы разметки и очистки.<img data-id="1347de00-5020-4e24-9a7c-3a03011dcfe9" data-max-width="850" alt="Сборка мусора - 1" src="https://cdn.javarush.com/images/article/1347de00-5020-4e24-9a7c-3a03011dcfe9/1024.jpeg"><h2>Запуск сборщика мусора в Java</h2>JVM обычно запускает сборщик мусора при низком уровне свободной памяти. Но работа сборщика мусора не гарантирует, что всегда будет оставаться достаточно свободной памяти.

Если памяти недостаточно даже после восстановления, JVM генерирует исключение OutOfMemoryError. Обратите внимание, что перед генерированием исключения JVM обязательно запускает сборщик мусора как минимум 1 раз.

Вы можете запросить запуск сборщика мусора в Java, но вы не можете принудительно задавать это действие.
<h2>Запрос запуска сборщика мусора</h2>Для запроса вы можете вызвать один из следующих методов:

<pre class="lang-java"><code>
System.gc()
Runtime.getRuntime().gc()
</code></pre><h2>Пригодность для запуска сборщика мусора</h2>Объект подлежит утилизации, когда он недоступен живому потоку.

Объект может подлежать утилизации в разных случаях:
<ul>
<li>Если переменная ссылочного типа, которая ссылается на объект, установлена в положение "0", объект подлежит утилизации, в том случае, если на него нет других ссылок.</li>
<li>Если переменная ссылочного типа, которая ссылается на объект, создана для ссылки на другой объект, объект подлежит утилизации, в том случае, если на него нет других ссылок.</li>
<li>Объекты, созданные локально в методе, подлежат утилизации, когда метод завершает работу, если только они не экспортируются из этого метода (т.е, возвращаются или генерируются как исключение).</li>
<li>Объекты, которые ссылаются друг на друга, могут подлежать утилизации, если ни один из них не доступен живому потоку.</li>
</ul>Рассмотрим пример:

<pre class="lang-java"><code>
public class TestGC
  {	
    public static void main(String [] args)  
    {
      Object o1 = new Integer(3);               // Line 1
      Object o2 = new String("Tutorial");       // Line 2
      o1 = o2;                                  // Line 3
      o2 = null;                                // Line 4
      // Rest of the code here
    }
  }
</code></pre>
В этом примере объект <code>Integer</code> (целочисленный), на который первоначально ссылается указатель o1 может подвергаться утилизации после строки 3, так как o1 теперь ссылается на объект <code>String</code> (строковый). Несмотря на то, что o2 создан для ссылки к нулю, объект <code>String</code> (строковый) не подлежит утилизации, так как o1 ссылается на него.
<h2>Финализация</h2>Java-технология позволяет использовать метод <code>finalize()</code> (финализировать), чтобы произвести необходимую очистку перед тем, как сборщик мусора извлекает объект из памяти. Этот метод вызывается для объекта сборщиком мусора, когда сборщик мусора вычисляет, что ссылок к объекту больше нет. Это описано в классе <code>Object</code>, а значит, это наследуется всеми классами. Подкласс отменяет метод <code>finalize()</code>, чтобы освободиться от системных ресурсов или для ещё одной очистки:

<pre class="lang-java line-numbers"><code>
protected void finalize() throws Throwable
</code></pre>
Если незарегистрированное исключение генерируется методом <code>finalize()</code>, то исключение игнорируется и финализация этого объекта прекращается.

Метод <code>finalize()</code> будет активизирован только один раз за время существования объекта.

Возможно использование метода <code>finalize()</code> любого объекта, чтобы защитить его от утилизации. Но в этом случае сборщик мусора уже не активирует <code>finalize()</code> для этого объекта.

Метод <code>finalize()</code> всегда будет активизирован один раз перед тем, как объект будет удалён сборщиком мусора. Однако, возможно, что метод <code>finalize()</code> не будет активизирован для данного объекта за всё время его существования, так как он может не подлежать утилизации.
<h2>Резюме</h2>В этом разделе мы рассмотрели процесс сборки мусора, который относится к технике управления памятью языка Java. Сборка мусора не может быть задана принудительно. Мы познакомились с различными способами обращения объектов в подлежащие утилизации и узнали, что метод <code>finalize()</code> активизируется перед тем, как объект извлекается сборщиком мусора.
<h2>Упражнение</h2><strong>Вопрос:</strong> <em>Сколько объектов будут подлежать утилизации после строки 7?</em>

<pre class="lang-java"><code>
public class TutorialGC
  {
    public static void main(String [] args)
    {
      Object a = new Integer(100);  // Line1
      Object b = new Long(100);     // Line2
      Object c = new String("100"); // Line3
      a = null;                     // Line4
      a = c;                        // Line5
      c = b;                        // Line6
      b = a;                        // Line7
      // Rest of the code here
    }
  }
</code></pre>
<strong>Варианты ответа:</strong>
    A. 0
    B. 1
    C. 2
    D. 3
    E. Код не возможно скомпилировать

<strong>Правильный вариант:</strong> B

<strong>Пояснение:</strong> из трёх объектов, созданных в строках 1, 2 и 3, только объект <code>Integer</code> подлежит утилизации в конце строки 7. Переменная ссылки, a, которая первоначально ссылалась на объект <code>Integer</code>, ссылается на объект <code>String</code> в строке 5. Таким образом, <code>Integer</code> oбъект подлежит утилизации после строки 5, так как нет переменных, которые ссылаются на него. Переменные <code>b</code> и <code>c</code> ссылаются на объекты <code>String</code> и <code>Long</code> объекты в строках 6 и 7, поэтому они не подлежат утилизации.