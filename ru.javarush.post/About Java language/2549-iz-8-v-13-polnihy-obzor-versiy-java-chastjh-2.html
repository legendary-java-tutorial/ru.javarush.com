Из 8 в 13: полный обзор версий Java. Часть 2
<p>----------------------------------------</p>
Эта статья является второй частью моего обзора по нововведениям в Java версий 8-13. Первая часть — здесь. Без лишних предисловий двигаемся дальше: в 25 сентября 2018, когда и вышла новая JDK — Java 11. Отныне и во веки веков мы можем указать типы лямбда-параметров или пропустить...
<p>----------------------------------------</p>
Эта статья является второй частью моего обзора по нововведениям в Java версий 8-13. Первая часть — <a href="https://javarush.com/groups/posts/2547-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-1" target="_blank">здесь</a>.
 
Без лишних предисловий двигаемся дальше: в 25 сентября 2018, когда и вышла новая JDK:
<h2>Java 11</h2><img data-max-width="650" alt="Из 8 в 13: полный обзор версий Java. Часть 2 - 1" src="https://cdn.javarush.com/images/article/d218a72d-c99e-4b9f-9711-611706eaab86/original.jpeg"><h3>var (в лямбде)</h3>Отныне и во веки веков мы можем указать типы лямбда-параметров или пропустить их при написании лямбда-выражения (неявно типизированных лямбда-выражений):

<pre class="lang-java line-numbers"><code>
Function&lt;String, String&gt; append = (var string) -&gt; string + " Text";
String appendedString = append.apply("Some");
System.out.println(appendedString);
</code></pre>
Также можно добавлять аннотации к лямбда-параметрам без необходимости писать полное имя типа переменной:
 
<pre class="lang-java line-numbers"><code>
Function&lt;String, String&gt; append = (@NonNull var string) -&gt; string + " Text";
</code></pre><h3>Z (ZGC)</h3>ZGC — это новый сборщик мусора, который не работает. Он выделяет новую память, но никогда не перезапускает ее. ZGC обещает управлять большими объемами памяти с высокой пропускной способностью и коротким временем паузы (ZGC доступен только на 64-битных платформах).

Эталонная окраска — ZGC использует 64-битные указатели с техникой, называемой окрашиванием указателей. Цветные указатели хранят дополнительную информацию об объектах в куче. Когда память становится фрагментированной, это помогает избежать снижения производительности, когда GC необходимо найти место для нового распределения.

Сборка мусора с помощью ZGC состоит из таких этапов:
<ol>
  <li>остановки мира: мы ищем отправные точки для достижения объектов в куче (например, локальных переменных или статических полей);</li>
  <li>пересечение граф объектов, начиная с корневых ссылок. Мы отмечаем каждый объект, который достигаем (ZGC ходит по графу объектов и исследует цветные указатели, отмечая доступные объекты);</li>
  <li>обработки некоторых крайних случаев, например, слабых ссылок;</li>
  <li>перемещение живых объектов, освобождая большие участки кучи, чтобы ускорить распределение.</li>
  <li>когда начинается фаза перемещения, ZGC разделяет кучу на страницы и работает по одной странице за раз;</li>
  <li>ZGC заканчивает движение любых корней, и происходит остальная часть перемещения.</li>
</ol>Данная тема весьма сложная и запутанная. Подробное рассмотрение тянет на отдельную статью, поэтому просто оставлю это здесь:
<ul>
<li><a href="https://www.baeldung.com/jvm-zgc-garbage-collector" rel="nofollow" target="_blank">An Introduction to ZGC: A Scalable and Experimental Low-Latency JVM Garbage Collector</a></li>
<li><a href="https://habr.com/ru/company/jugru/blog/443250/" rel="nofollow" target="_blank">Самодельный сборщик мусора для Open JDK</a></li>
<li><a href="https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/" rel="nofollow" target="_blank">Java's new Z Garbage Collector (ZGC) is very exciting</a></li>
</ul><h3>Epsilon GC</h3>Эпсилон — это сборщик мусора, который обрабатывает выделение памяти, но не реализует какой-либо реальный механизм ее восстановления памяти. Как только доступная куча Java будет исчерпана, JVM закроется. То есть, если в бесконечном массиве запустить создание объекта без привязки к ссылке с данным сборщиком мусора, приложение упадёт с <em>OutOfMemoryError</em> (а если с любым другим нет, так как он будет подчищать объекты без ссылок).

Зачем он нужен? А вот зачем:
<ol>
  <li>Тестирование производительности.</li>
  <li>Тестирование давления памяти.</li>
  <li>Тестирование интерфейса VM.</li>
  <li>Чрезвычайно недолгая работа.</li>
  <li>Улучшения латентности последней капли.</li>
  <li>Улучшения пропускной способности последней капли.</li>
</ol><span class="text-bold">Полезные ссылки:</span>
<ul>
<li><a href="https://habr.com/ru/post/321856/" rel="nofollow" target="_blank">Новый GC Epsilon. У джавы может не быть сборки мусора. Шок. Сенсация</a></li>
<li><a href="https://www.baeldung.com/jvm-epsilon-gc-garbage-collector" rel="nofollow" target="_blank">An Introduction to Epsilon GC: A No-Op Experimental Garbage Collector</a></li>
</ul><span class="text-bold">Другие нововведения:</span>
<ol>
  <li><code>ByteArrayOutputStream</code> получил метод <code>void writeBytes(byte [])</code>, записывающий все байты из аргумента в <code>OutputStream</code>.</li>
  <li><code>FileReader</code> и <code>FileWriter</code> получили новые конструкторы, позволяющие указывать Charset.</li>
  <li><code>Path</code> отхватил два новых метода, <code>of(String, String [])</code> возвращает <code>Path</code> из строкового аргумента пути или последовательности строк, которые при объединении образуют строку пути и <code>of(URI)</code>: возвращает Path из URI.</li>
  <li><code>Pattern</code> — получил метод <code>asMatchPredicate()</code>, который проверяет, соответствует ли заданная строка ввода, заданному шаблону (позволяет ли создать предикат по регулярному выражению, чтобы можно было, например, фильтровать данные в stream).</li>
  <li><code>String</code> отхватил много полезных методов, таких как:<ul>
  <li><code>String strip()</code>: вернёт нам строку, которая является этой строкой, при этом удаляются все пробелы в начале и в конце строки (аналог trim(), но по-другому определяет пробелы);</li>
  <li><code>String stripLeading()</code>: вернёт нам строку, которая является этой строкой, при этом удаляются все пробелы в начале строки;</li>
  <li><code>String stripTrailing()</code>: вернёт нам строку, которая является этой строкой, при этом удаляются все пробелы в конце строки;</li>
  <li><code>Stream lines()</code>: вернёт нам <code>Stream</code> из <code>String</code>, извлеченных из этой строки, поделенных разделителями строк;</li>
  <li><code>String repeat(int)</code>: вернёт нам строку, которая  представляет собой конкатенацию этой строки, повторяющееся количество раз.</li>
  <li><code>boolean isBlank()</code>:  вернёт нам  true, если строка пуста или содержит только пробелы, иначе false.</li>
</ul></li>
<li><code>Thread</code> — были удалены методы destroy() и stop(Throwable).</li>
<li><code>Files</code> получил ряд новых методов:
<ul>
  <li><code>String readString(Path)</code>: читает все данные из файла в строку, при этом декодируя из байт в символы с использованием кодировки UTF-8;</li>
  <li><code>String readString(Path, Charset)</code>: так же, как и в методе выше, с разницей в том, что декодирование из байт в символы происходит с использованием указанной Charset;</li>
  <li><code>Path writeString (Path, CharSequence, OpenOption [])</code>: записывает последовательность символов в файл. Символы кодируются в байты, используя кодировку UTF-8;</li>
  <li><code>Path writeString(Path, CharSequence,Charset, OpenOption [])</code>: такой же метод, что и выше,  только символы кодируются в байты, используя кодировку, указанную в Charset.</li>
</ul></li></ol>Это были самые интересные нововведения API (по моему скромному мнению), вот пара материалов для более детального ознакомления:
<ul>
<li><a href="https://javarush.com/groups/posts/1961-vihshla-java-11-novihe-fichi-i-vozmozhnosti-" target="_blank">Java 11: что нового? Новые фичи и возможности</a></li>
<li><a href="https://habr.com/ru/post/441154/" rel="nofollow" target="_blank">Одиннадцать скрытых жемчужин Java 11</a></li>
</ul><h2>Java 12</h2>Проходит полгода, и мы видим следующую ступень эволюции Java. Значит, пора доставать лопатку знаний и копать.
<img data-max-width="1024" src="/images/article/9fe24f32-06c4-415b-a366-d2d56a750854/original.jpeg class=" img-fluid'="" alt="Из 8 в 13: полный обзор версий Java. Часть 2 - 2"><h3>Update G1</h3>Для G1 были внесены такие улучшения:
<ol>
<li><p><span class="text-bold">Возврат неиспользуемой выделенной памяти</span></p>
<p>В Java heap memory есть такое понятие как неиспользуемая память (или по-другому — неактивная). В Java 12 решили пофиксить эту проблему, теперь:</p><ul>
<li>G1 возвращает память из кучи в полном GC или во время параллельного цикла; G1 старается предотвратить полный GC и запускает параллельный цикл, исходя из распределения кучи. Придется принуждать G1 к возвращению памяти из кучи.</li></ul><p>Данное улучшение фокусируется на быстродействии за счет автоматического возврата памяти из кучи в ОС, когда G1 не используется.</p></li>
<li><p><span class="text-bold">Прерывание смешанных коллекций, когда время паузы превышено</span></p>
<p>G1 использует механизм анализа для выбора объема работы, необходимого для сбора мусора. Он собирает живые объекты без остановки после определения набора и запуска очистки. Это приводит к тому, что сборщик мусора превышает целевое значение времени паузы. Собственно, такую проблему и решает улучшение, так как если время выполнения следующего шага выходит за рамки разумного, этот шаг можно прервать.</p></li></ol><h3>Microbenchmark</h3>В Java 12 ввели тесты микробенчмаркинга, чтобы производительность JVM легко тестировалась с помощью уже существующих тестов. Это было бы очень полезно для всех, кто хочет работать над самой JVM. Добавляемые тесты создаются с использованием Java Microbenchmark Harness (JMH). Эти тесты позволяют проводить непрерывное тестирование производительности на JVM. JEP 230 предлагает ввести около 100 тестов, причем новые тесты вводятся по мере выпуска новых версий Java.

Вот <a href="https://www.baeldung.com/java-microbenchmark-harness" rel="nofollow" target="_blank">пример добавляемых тестов</a>.<h3>Shenandoah</h3>Это алгоритм сборки мусора (GC), цель которого — гарантировать низкое время отклика (нижний предел — 10-500 мс). Это уменьшает время паузы GC при выполнении работы по очищению одновременно с работающими потоками Java.

В Shenandoah время паузы не зависит от размера кучи. Это означает, что время паузы будет одинаковым независимо от размера вашей кучи. Это <span class="text-bold">экспериментальная функция</span>, которая не включена в стандартную (Oracle) сборку OpenJDK.
<h3>Improve Switch</h3>В Java 12 улучшены выражения Switch для сопоставления с образцом. Был введен, новый синтаксис L →.

Вот список <span class="text-bold">ключевых моментов нового switch</span>:
<ol>
  <li>Новый синтаксис устраняет необходимость в операторе break для предотвращения ошибок.</li>
  <li>Выражения переключателя больше не проваливаются.</li>
  <li>Кроме того, мы можем определить несколько констант в одной метке.</li>
  <li>default регистр теперь обязателен в выражениях переключателей.</li>
  <li>break используется в выражениях Switch для возврата значений из самого регистра (по сути switch может возвращать значения).</li>
</ol>Рассмотрим как пример:

<pre class="lang-java line-numbers"><code>
var result = switch (someDay) {
  case "M", "W", "F" -&gt; "MWF";
  case "T", "TH", "S" -&gt; "TTS";
  default -&gt; {
      if(someDay.isEmpty())
            break "Please insert a valid day.";
      else
            break "Looks like a Sunday.";
  }
};
</code></pre><a href="https://blog.codefx.org/java/switch-expressions/" rel="nofollow" target="_blank">
Definitive Guide To Switch Expressions In Java 13
</a>
<span class="text-bold">Другие нововведения:</span>
<ol>
<li><p><code><span class="text-bold">String:</span></code></p>
<p><code>transform(Function f)</code> — применяет предоставленную функцию к строке. Результат может не быть строкой.<br>
<code>indent(int x)</code> — добавляет x пробелов в строку. Если параметр отрицателен, то это количество начальных пробелов будет удалено(если это возможно).</p></li>
<li><p><code><span class="text-bold">Files</span></code> — отхватил такой метод как <code>mismatch()</code>, который, в свою очередь, находит и возвращает позицию первого несовпадающего байта в содержимом двух файлов или -1L, если нет несоответствия.</p></li>
<li><p><span class="text-bold">Появился новый класс — </span><code><span class="text-bold">CompactNumberFormat</span></code>, для форматирования десятичного числа в компактной форме. Пример такой компактной формы — 1M вместо 1000000. Таким образом, требуется всего лишь два два вместо девяти символов.</p></li>
<li><p>Существует также <span class="text-bold">новый</span> <code><span class="text-bold">enum</span></code>, <code>NumberFormatStyle</code>, у которого есть два значения — LONG и SHORT.</p></li>
<li><p><code><span class="text-bold">InputStream</span></code> <span class="text-bold">получил метод —</span> <code><span class="text-bold">skipNBytes(long n)</span></code>: пропустить n-ое количество байтов из входного потока.</p></li>
</ol><span class="text-bold">Интересные ссылки по Java 12:</span>
<ul>
<li><a href="https://javarush.com/groups/posts/2171-java-12-uzhe-zdesjh-chto-novogo" target="_blank">Java 12 уже здесь: что нового?</a></li>
<li><a href="https://blog.gypsyengineer.com/ru/tech-ru/what-is-new-in-java-12-ru.html" rel="nofollow" target="_blank">Что нового в Java 12</a></li>
<li><a href="https://urvanov.ru/2019/03/20/%D1%87%D1%82%D0%BE-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B2-java-12/" rel="nofollow" target="_blank">Что нового в Java 12 (из блога записки ведьмака-программиста)</a></li>
</ul><h2>Java 13</h2>Мир не стоит на месте, шевелится, развивается, как и Java — Java 13.
<img data-max-width="450" alt="Из 8 в 13: полный обзор версий Java. Часть 2 - 3" src="https://cdn.javarush.com/images/article/44205340-0908-4979-975c-0058aad9ab50/original.jpeg"><h3>Text block</h3>Java всегда немного страдала от определения строк. Если нам нужно определить строку с пробелом, перенос строки, кавычку или ещё что-то, это вызывало некоторые трудности, так приходилось использовать специальные символы: например, \n для переноса строки, или экранировать некоторые из самой строки. 
Это существенно снижает читаемость кода, и занимает лишнее время при написании такой строки.  Эта становится особо заметным при написании строк, отображающих JSON, XML, HTML и т.д.

В итоге если мы хотим написать небольшой Json, это будет выглядеть как-то так:

<pre class="lang-java line-numbers"><code>
String JSON_STRING = "{\r\n" + "\"name\" : \"someName\",\r\n" + "\"site\" : \"https://www.someSite.com/\"\r\n" + "}";
</code></pre>
И тут на сцену выходит Java 13 и предлагает нам свое решение в виде тройных двойных кавычек до и после текста (которые и обозвали текстовыми блоками).

Давайте рассмотрим предыдущий пример json с использованием данного нововведения:

<pre class="lang-java line-numbers"><code>
String TEXT_BLOCK_JSON = """
{
    "name" : "someName",
    "site" : "https://www.someSite.com/"
}
""";
</code></pre>
В разы проще и наглядней, не правда ли?

Также было в <code>String</code> было добавлено три новых метода, соответственно, для управления данными блоками:
<ul>
<li><code>stripIndent()</code>: удаляет случайные пробелы из строки. Это полезно, если вы читаете многострочные строки и хотите применить такое же исключение случайных пробелов, как это происходит с явным объявлением (по сути имитирует компилятор для удаления случайных пробелов);</li>
<li><code>formatted(Object... args )</code>: аналог <code>format(String format, Object... arg)</code>, но для текстовых блоков;</li>
<li><code>translateEscapes()</code>: возвращает строку с escape-последовательностями (например, \ r), переведенными в соответствующее значение Unicode.</li>
</ul><h3>Improve Switch</h3>Выражения-переключатели были введены в Java 12, а 13 уточняет их.

В 12 вы определяете возвращаемые значения с помощью break. В 13 возвращаемое значение заменили на  yield. Теперь выражение со switch, которое было у нас в разделе Java 12, можно переписать как:

<pre class="lang-java line-numbers"><code>
var result = switch (someDay) {
  case "M", "W", "F" -&gt; "MWF";
  case "T", "TH", "S" -&gt; "TTS";
  default -&gt; {
      if(someDay.isEmpty())
          yield "Please insert a valid day.";
      else
          yield "Looks like a Sunday.";
  }
};
</code></pre>
Хотя нам программистам, уже знакомым с Java, было нормально принять break, но, тем не менее, это было довольно странно. Что break true пытается мне сказать? Новое (условно новое) ключевое слово yield более понятно, и в будущем оно может появиться в других местах, где возвращаются значения.

Кому глубоко интересна данная тема, рекомендую ознакомиться с данными материалами:
<ul>
<li><a href="https://www.dariawan.com/tutorials/java/java-13-switch-expressions-jep-354/" rel="nofollow" target="_blank">Java 13 - Switch Expressions (JEP 354)</a></li>
<li><a href="https://blog.codefx.org/java/java-13-guide/" rel="nofollow" target="_blank">Definitive Guide To Java 13</a></li>
</ul><h3>Dynamic CDS Archives</h3>CDS — Class-Data Sharing. Позволяет упаковывать набор часто используемых классов в архив, который позже может быть загружен несколькими экземплярами JVM. 

Зачем нам это? Дело в том, что в процессе загрузки классов JVM делает довольно много ресурсозатратных действий, таких как чтение классов, сохранение их во внутренних структурах, проверка правильности прочитанных классов, поиск и загрузка зависимых классов и т. д., и лишь после всего этого классы готовы к работе. Понятное дело, попусту тратится большое количество ресурсов, ведь экземпляры JVM часто могут загружать одни и те же классы. Например String, LinckedList, Integer. Ну или же классы одного и того же приложения, а все это — ресурсы.

Если бы мы выполнили все необходимые действия лишь один раз и после поместили переработанные классы в архив, который может быть подгружен в память нескольких JVM, это могло бы существенно сэкономить место в памяти и сократить время запуска приложения. Собственно, CDS дает возможность создать именно такой архив.

Java 9 позволяла добавлять в архив только системные классы. Java 10 — включать в архив классы приложения. 

<span class="text-bold">Создание такого архива</span> состоит из:
<ul>
<li>создания списка классов, загружаемых приложением;</li>
<li>создания так необходимого нам архива с найденными классами.</li>
</ul>Нововведение в Java 13 улучшает CDS так, чтобы он мог создавать архив по завершении приложения. Это означает, что два шага, приведенные выше, теперь будут объединены в один.

И ещё один важный момент: только классы, которые были загружены во время работы приложения, будут добавлены в архив. Другими словами словами, те классы, которые все же содержатся в application.jar, но по каким-то причинам на были загружены, не добавятся в архив.
<h3>Update Socket API</h3>API Socket (<em>java.net.Socket и java.net.ServerSocket</em>) — по сути неотъемлемая часть Java с момента ее появления, но при этом сокеты ни разу не апдейтили за последний двадцаток лет.

Написанные на C и Java, они были очень и очень громоздкими и сложными в обслуживании. Но Java 13 решила внести свои коррективы в это всё дело и  заменила базовую реализацию.

Теперь вместо <em>PlainSocketImpl</em> интерфейс провайдера заменяется на <em>NioSocketImpl</em>. Эта новая кодированная реализация основана на той же внутренней инфраструктуре, что и <em>java.nio</em>. По сути класс использует механизм буферного кэша и блокировки java.util.concurrent (которые являются сегментными), а не синхронизированные методы. Он больше не требует нативного кода, тем самым упрощая портирование на разные платформы.

Всё же, у нас есть способ вернуться к использованию <em>PlainSocketImpl</em>, но отныне по дефолту используется <em>NioSocketImpl</em>. 
<h3>Memory Return for ZGC</h3>Как мы помним, <span class="text-bold">Z сборщик мусора</span> ввели в Java 11 как механизм сборки мусора с малой задержкой, чтобы GC пауза никогда не превышала 10 мс. Но при этом, в отличие от остальных виртуальных GC HotSpot, таких как Shenandoah и G1, он мог возвращать неиспользованную динамическую память в ОС. Данная модификация добавляет эту возможность J в ZGC.

Соответственно, мы получаем уменьшенный объем памяти вместе с улучшением производительности, и ZGC теперь возвращает не зафиксированную память операционной системе по умолчанию, пока не будет достигнут указанный минимальный размер кучи.

И ещё: у ZGC теперь есть максимальный поддерживаемый размер кучи 16 ТБ. Раньше 4ТБ было пределом.
<span class="text-bold">Другие нововведения:</span><ol>
<li><code>javax.security</code> — добавлено свойство <code>jdk.sasl.disabledMechanisms</code> для отключения механизмов SASL.</li>
<li><code>java.nio</code> — добавлен метод <code>FileSystems.newFileSystem (Path, Map &lt;String,?&gt;)</code> — соответственно, для создания нового файла.</li>
<li>Классы <code>java.nio</code> теперь имеют абсолютные (в отличие от относительных) <code>get</code> и <code>set</code>-методы. Они, как и базовый абстрактный класс <code>Buffer</code>, включают метод <code>slice()</code> для извлечения части буфера.</li>
<li>В <code>javax.xml.parsers</code> добавлены методы для создания экземпляров фабрик DOM и SAX (с поддержкой пространств имен).</li>
<li>Поддержка Unicode обновлена ​​до версии 12.1.</li>
</ol><span class="text-bold">Интересные ссылки по Java 13:</span><ul>
<li><a href="https://javarush.com/groups/posts/2353-java-13-novihe-vozmozhnosti" target="_blank">Java 13: новые возможности</a></li>
<li><a href="https://proglib.io/p/vse-o-java-13-pogruzhenie-v-mir-obnovleniy-2019-10-18" rel="nofollow" target="_blank">Всё о Java 13: погружение в мир обновлений</a></li>
<li><a href="https://dzone.com/articles/81-new-features-and-apis-in-jdk-13" rel="nofollow" target="_blank">81 New Features and APIs in JDK 13</a></li>
</ul><h2>Итоги</h2>Мы могли бы и пройтись по заявленным нововведениям в Java 14, но так как она довольно-таки скоро увидит свет — выпуск JDK 14 запланирован на 17 марта 2020 года, лучше всего будет провести отдельный, полноценный обзор на неё уже непосредственно после выхода.

Еще хотелось бы обратить внимание на то, что в других языках программирования с большими перерывами между выпусками, как например в Python 2–3, нет совместимости: то есть если код написан на Python 2, нужно будет изрядно попотеть, переводя его на 3.

Java — особенная в этом отношении, поскольку она <em>чрезвычайно</em> обратно совместима. Это означает, что ваша программа на Java 5 или 8 гарантированно будет работать с виртуальной машиной Java 8-13 — с некоторыми исключениями, о которых вам сейчас не нужно беспокоиться.

Понятное дело, что это не работает наоборот: например, если ваше приложение юзает функции Java 13, которые просто недоступны в Java 8 JVM.

На этом у меня сегодня всё, тем кто дочитал до этого места — респект))
<img data-max-width="500" alt="Из 8 в 13: полный обзор версий Java. Часть 2 - 5" src="https://cdn.javarush.com/images/article/69fd2c0a-d711-49ec-bb53-a0240a842ac4/original.jpeg">