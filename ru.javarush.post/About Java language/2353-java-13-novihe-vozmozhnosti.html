Java 13: новые возможности
<p>----------------------------------------</p>
Мы уже успели привыкнуть к тому, что новый релиз JDK появляется раз в полгода. Пока что такой подход себя оправдал, а переживания некоторых разработчиков, дескать они не будут поспевать за обновлениями, оказались напрасными: полугодовых изменений немного и они не столь глобальны...
<p>----------------------------------------</p>
Мы уже успели привыкнуть к тому, что новый релиз JDK появляется раз в полгода. Пока что такой подход себя оправдал, а переживания некоторых разработчиков, дескать они не будут поспевать за обновлениями, оказались напрасными: полугодовых изменений немного и они не столь глобальны, как раньше. Ну а начинающие программисты могут и вовсе не заметить новшества.

<img data-id="0e9a1fd4-aebe-436d-b47a-9d99cb37686b" data-max-width="850" alt="Java 13: новые возможности - 1" src="https://cdn.javarush.com/images/article/0e9a1fd4-aebe-436d-b47a-9d99cb37686b/1024.jpeg">Тем не менее, будущим разработчикам ПО лучше быть в курсе нововведений. В этой статье мы традиционно опишем принятые предложения по расширению (JEP). Java 13 включает в себя только пять JEP’ов и 76 новых элементов базовой библиотеки (из которых почти половина — простые дополнения к пакету java.io). 
<h2><a href="https://openjdk.java.net/jeps/355" rel="nofollow" target="_blank">JEP 355</a>: Text Blocks(Preview)</h2>Начнем с изменения синтаксиса языка. Самое значительное из них — это текстовые блоки. Они позволяют избегать экранирования символов и умеют форматировать строки.

Возможно, вы <a href="https://javarush.com/groups/posts/2171-java-12-uzhe-zdesjh-chto-novogo" target="_blank">помните</a>, что в JDK 12 так и не появилась ожидаемая фича Raw String Literals (JEP 326) для работы со строковыми литералами. В Java 13 ей на смену пришёл JEP 355 с его текстовыми блоками. 
   
Вы, вероятнее всего, помните, что в Java строка обёрнута в двойные кавычки. Это хорошо, но проблема в том, что строка не может занимать больше одной линии исходного файла (чтобы не путать с Java-строкой, здесь будем называть строку файла “линией”). Что ж, пойдём в обход и используем, например, символ <code><strong>\n</strong></code>, если требуется разрыв, или конкатенацию многострочных выражений. Не очень-то красиво получается! Особенно громоздко выглядят текстовые литералы со встроенными фрагментами HTML, XML, SQL или JSON. Все эти экранирования, конкатенации, ручное редактирование делает код неудобным для написания и трудночитаемым. 

Текстовые блоки пытаются эту проблему решить. Они начинаются эээ… с тройных двойных кавычек и заканчиваются ими же (знаю, звучит не очень). Всё, что находится между кавычками, интерпретируется как часть строки, включая переводы на новую линию. Текстовые блоки можно использовать точно так же, как стандартные текстовые литералы, Java скомпилирует код одинаково.

Открывающие кавычки должны сопровождаться ограничителем строки; текстовые блоки нельзя использовать в одну линию, так что код  

<pre class="lang-java line-numbers"><code>
String smallBlock = """Only one line""";
</code></pre>
приведёт к следующим ошибкам:

<pre class="lang-java line-numbers"><code>
TextBlock.java:3: error: illegal text block open delimiter sequence, missing line terminator
   String smallBlock = """Text Block""";
                          ^
TextBlock.java:3: error: illegal text block open delimiter sequence, missing line terminator
   String smallBlock = """Text Block""";
                                   	^
</code></pre>
Простой HTML-фрагмент теперь можно написать так: 

<pre class="lang-java line-numbers"><code>
String htmlBlock = """
               	&lt;html&gt;
                 	&lt;body&gt;
                   	&lt;p&gt;CodeGym Web page&lt;/p&gt;
                 	&lt;/body&gt;
               	&lt;html&gt;
         	     """;
</code></pre>
Упомянём несколько тонкостей, о которых лучше знать при использовании текстовых блоков. Расположение закрывающих кавычек оказывается важным: оно определяет, как обрабатывается случайный пробел. В приведенном выше примере закрывающие кавычки выровнены с отступом текста HTML. В этом случае компилятор удалит пробелы отступа, и в результате мы получим такую строку:

<pre class="lang-java line-numbers"><code>
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;My web page&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<mark>Обратите внимание:</mark> такая строка будет содержать новую линию в конце строки. Если она не нужна, закрывающие кавычки “”” можно поставить непосредственно после тега &lt;/ html&gt;. 

Если мы переместим закрывающие кавычки ближе к левому полю, это изменит количество удаленных отступов. Если бы мы переместили их на два пробела влево, мы бы добавили два пробела для отступа к каждой линии строки. Перемещение к левому краю приведет к тому, что все отступы будут сохранены. Перемещение кавычек дальше вправо не возымеет никакого эффекта и не добавит больше отступов.

В версию JDK 13 текстовые блоки попали в качестве превью-фичи. Это значит, что они пока не включены в соответствующую спецификацию языка Java. То есть непонятно, станет ли эта фича постоянной частью языка или она тут только гость. В настоящее время разработчики могут протестировать фичу и высказать мнение о ней. От него и будет зависеть судьба текстовых блоков: фичу могут улучшить, а если она не понравится — то и вовсе удалить. Если вы хотите опробовать текстовые блоки на практике, помните, что превью-фичи нужно явно включать для компиляции и выполнения.  

Компиляция: 

<pre><code>
javac --enable-preview --release 13 TextBlock.java
</code></pre>
Чтобы запустить приложение, нужно включить функции предварительного просмотра:

<pre><code>
java --enable-preview TextBlock
</code></pre>
В классе <code>String</code> есть три новых метода, которые дополняют это изменение языка: 
<ul>
<li><code><strong>formatted()</strong></code>: форматирует строку, используя саму строку в качестве строки формата. Эквивалентен вызову <code>format(this, args)</code></li>
<li><code><strong>stripIndent()</strong></code>: удаляет случайные пробелы из строки. Это полезно, если вы читаете многострочные строки и хотите применить такое же исключение случайных пробелов, как и в случае явного объявления.</li>
<li><code><strong>translateEscapes()</strong></code>: возвращает строку с escape-последовательностями (например, <code>\ r</code>), переведенными в соответствующее значение Unicode.</li>
</ul>Любопытно, что эти методы только появились, но уже помечены как <strong>deprecated</strong>... такое положение вещей наводит на мысль, что их могут удалить в будущей версии JDK. Это кажется несколько эксцентричным — добавлять новый метод и сразу же отказываться от него. Однако нужно учесть, что эти методы связаны с превью-фичей, которая может быть изменена или удалена. Возможно, введение аннотации <code>@PreviewFeature</code> помогло бы с подобными ситуациями, но пока такая она не входит в JDK (хотя с высокой долей вероятности она появится в JDK 14). 
<h2><a href="https://openjdk.java.net/jeps/354" rel="nofollow" target="_blank">JEP 354</a>: Switch Expression (Preview)</h2>В Java 12 появилось предложение о новой форме написания выражений с оператором switch — <a href="http://openjdk.java.net/jeps/325" rel="nofollow" target="_blank">JEP 325</a>. Оно оказалось самой первой превью-фичей и её судьба доказывает, что выносить предложения на суд пользователей — отличная идея. До JDK 12 <code>switch</code> можно было использовать только как оператор, который выполняет действие, но не возвращает результат. А вот в Java 12 позволила использовать <code>switch</code> как выражение, возвращающее результат, который можно присвоить переменной. Были и другие изменения, в синтаксисе операторов case внутри <code>switch</code>. Давайте рассмотрим пример из JEP, чтобы разобраться, как это работает.   

<pre class="lang-java line-numbers"><code>
int numberOfLetters;
switch(dayOfWeek) {
  case MONDAY:
  case FRIDAY:
  case SUNDAY:
    numberOfLetter = 6;
    break;
  case TUESDAY
    numberOfLetter = 7;
    break;
  case THURSDAY
  case SATURDAY
    numberOfLetter = 8;
    break;
  case WEDNESDAY
    numberOfLetter = 9;
    break;
  default:
   throw new IllegalStateException("Huh?: " + day);
}
</code></pre>
В этом примере мы используем значение <code><strong>dayOfWeek</strong></code>, чтобы присвоить значение <code><strong>numberOfLetters</strong></code>. Из-за особенностей работы оператора <code><strong>switch</strong></code>, данный код — не самый красивый и в нём легко наделать ошибок. Во-первых, если мы забудем применить оператор <code><strong>break</strong></code> для каждой группы case-меток, мы по умолчанию перейдём к следующей группе меток. Это может привести к ошибкам, которые сложно отыскать. Во-вторых, мы должны определить каждую группу case-меток. Если забудем, то, разумеется, получим ошибку компилятора, однако и такой вариант не идеален. Также наш код весьма многословен, поскольку каждое значение <code><strong>dayOfWeek</strong></code> должно иметь свою собственную case-метку.

Используя новый синтаксис, мы получаем намного более чистый и менее подверженный ошибкам код:

<pre class="lang-java line-numbers"><code>
int numberOfLetters = switch (dayOfWeek) {
   case MONDAY, FRIDAY, SUNDAY -&gt; 6;
   case TUESDAY -&gt; 7;
   case THURSDAY, SATURDAY -&gt; 8;
   case WEDNESDAY -&gt; 9;
   default -&gt; throw new IllegalStateException("Huh?: " + day);
};
</code></pre>
Теперь нам нужно сделать присваивание только один раз (из возвращаемого выражением <code>switch</code> значения) и можно использовать разделяемый запятыми список для case-меток. И, поскольку мы не используем оператор <code>break</code>, то устраняем связанные с ним проблемы. 

Синтаксис выражения <code>switch</code> позволяет использовать синтаксис более старого стиля, поэтому в JDK 12 мы можем написать и так:

<pre class="lang-java line-numbers"><code>
int numberOfLetters = switch (dayOfWeek) {
  case MONDAY:
  case FRIDAY:
  case SUNDAY:
   break 6;
  case TUESDAY
   break 7;
  case THURSDAY
  case SATURDAY
   break 8;
  case WEDNESDAY
   break 9;
  default:
   throw new IllegalStateException("Huh?: " + day);
};
</code></pre>
Согласно мнению Java-сообщества, перегрузка использования <code>break</code> для указания возвращаемого значения может сбивать с толку. Язык Java также позволяет использовать <code>break</code> (и <code>continue</code>) с меткой наподобие оператора безусловного перехода <code>goto</code>. В JEP 354 было изменено подобное использование <code>break</code>, так что в Java 13 наш код несколько меняется:

<pre class="lang-java line-numbers"><code>
int numberOfLetters = switch (dayOfWeek) {
  case MONDAY:
  case FRIDAY:
  case SUNDAY:
   yield 6;
  case TUESDAY
   yield 7;
  case THURSDAY
  case SATURDAY
   yield 8;
  case WEDNESDAY
   yield 9;
  default:
   throw new IllegalStateException("Huh?: " + day);
};
</code></pre>
Следующие три JEP’а связаны с виртуальной машиной Java. 
<h2><a href="https://openjdk.java.net/jeps/350" rel="nofollow" target="_blank">JEP 350</a> Dynamic CDS Archive</h2>Это расширение позволяет провести динамическое архивирование классов в конце выполнения Java-приложения. CDS или Class Data Sharing позволяет упаковать все запускаемые при старте классы в специальный архив <code>class data sharing</code>, используя список этих самых классов по умолчанию. Это приводит к существенному ускорению запуска приложений и экономии оперативной памяти. 

Раньше использование AppCDS было многоэтапным процессом, включающим создание списка соответствующих классов и использование этого списка для создания архива, который будет использоваться для последующих запусков. Теперь всё, что требуется, — это один запуск приложения с флагом -XX: <code>ArchiveClassesAtExit</code>, указывающим место, куда будет записан архив. При таком подходе классы автоматически упаковываются в архив после нормальной остановки приложения.
<h2><a href="https://openjdk.java.net/jeps/351" rel="nofollow" target="_blank">JEP 351 ZGC</a>: Uncommit unused memory</h2>Год назад в <a href="https://javarush.com/groups/posts/1961-vihshla-java-11-novihe-fichi-i-vozmozhnosti-" target="_blank">JDK 11</a> быд представлен ZGC — экспериментальный масштабируемый сборщик мусора с низкой задержкой. Поначалу ZGC вёл себя довольно странно: он не позволял вернуть память операционной системе, даже если она уже была не нужна.

Для некоторых сред, например, для контейнеров, где ресурсы используются несколькими службами одновременно, это может ограничивать масштабируемость и эффективность системы.

Куча ZGC состоит из так называемых ZPages. Когда ZPages очищаются во время цикла сбора мусора, они возвращаются в кэш ZPageCache. ZPages в этом кэше упорядочены по порядку давности использования. В Java 13 ZGC будет возвращать в операционную систему страницы, которые были определены как те, что не использовались достаточно долго. Таким образом их можно будет использовать повторно для других процессов. 
<h2><a href="https://openjdk.java.net/jeps/353" rel="nofollow" target="_blank">JEP 353</a> Reimplement the legacy Socket API</h2>Обе реализации API <code><strong>java.net.Socket</strong></code> и <code><strong>java.net.ServerSocket</strong></code> относятся ещё JDK 1.0. В этой, да и во всех последующих JDK, реализация этих API-интерфейсов использует несколько методов (таких, как использование стека потоков в качестве буфера ввода-вывода), которые делают их негибкими и сложными в обслуживании. 

Чтобы решить эту проблему, в JDK 13 предоставили новую реализацию <code>NioSocketImpl</code>. Она больше не требует нативного кода, тем самым упрощая портирование на разные платформы. Этот класс также использует существующий механизм буферного кэша (исключая использование стека потоков для этой цели) и блокировки <code>java.util.concurrent</code>, а не синхронизированные методы. Это упростит интеграцию с файберами из <a href="https://openjdk.java.net/projects/loom/" rel="nofollow" target="_blank">Project Loom</a>.
<h2>Новые API</h2>Мы уже упоминали ранее, что Java 13 включает в себя 76 новых API в библиотеках базовых классов. Они охватывают следующие области:
<ul>
<li>Обновления поддержки Unicode.</li>
<li>Три новых метода в <code><strong>String</strong></code> для поддержки текстовых блоков (см. описание JEP 255 выше).</li>
<li>Классы <code><strong>java.nio</strong></code> теперь имеют абсолютные (в отличие от относительных) <code>get</code> и <cpode>set-методы. Они, как и базовый абстрактный класс <code>Buffer</code>, включают метод <code>slice()</code> для извлечения части буфера.</cpode></li>
<li>Метод <code><strong>force()</strong></code> класса <code><strong>MappedByteBuffer</strong></code> принудительно записывает раздел буфера в его резервное хранилище.</li>
<li><code><strong>nio.FileSystem</strong></code> добавляет три новые перегруженные формы <code><strong>newFileSystem()</strong></code> для доступа к содержимому файла как файловой системы.</li>
<li>В <code>javax.annotation.processing.ProcessingEnvironment</code> появился новый интересный метод. <code>isPreviewEnabled()</code>. Он  сообщит о том, включены ли preview-фичи. Это интересно потому, что упомянутая выше аннотация <code>@PreviewFeature</code> не будет доступна до выхода JDK 14.</li>
<li><code>DocumentBuilderFactory</code> и <code>SAXParserFactory</code> в <code>javax.xml.parsers</code> получают три новых метода для создания экземпляров, поддерживающих пространство имен.</li>
</ul>
<em>Материал основан на статье <a href="https://www.azul.com/jdk-13-81-new-features-and-apis/" rel="nofollow" target="_blank">Саймона Риттера</a> и <a href="http://openjdk.java.net/" rel="nofollow" target="_blank">официальной документации</a>.</em>