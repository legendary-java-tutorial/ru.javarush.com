Компиляция и запуск Java без IDE
<p>----------------------------------------</p>
В свое время на reddit.com, в теме Компиляция и запуск Java без IDE, был задан вопрос: Является ли команда, которая компилирует группу файлов Java, которые находятся внутри пакета в отдельную папку (назовем ее bin), и как бы я идти о запуске новых файлов класса?...
<p>----------------------------------------</p>
В свое время на <a href='https://www.reddit.com/r/java/' rel='nofollow' target='_blank'>reddit.com</a>, в теме <a href='https://www.reddit.com/r/java/comments/21s5h3/compiling_java_packages_without_ide/' rel='nofollow' target='_blank'>Компиляция и запуск Java без IDE</a>, был задан вопрос: Является ли команда, которая компилирует группу файлов Java, которые находятся внутри пакета в отдельную папку (назовем ее <em>bin</em>), и как бы я идти о запуске новых файлов класса? "
<img data-id="9df7451d-7006-408f-a66e-2f5e7230b2fc" data-max-width="850" alt="Компиляция и запуск Java без IDE - 1" src="https://cdn.javarush.com/images/article/9df7451d-7006-408f-a66e-2f5e7230b2fc/1024.jpeg">Автор темы, <a href='https://www.reddit.com/user/kylolink' rel='nofollow' target='_blank'>kylolink</a>, объясняет: "Когда я начинал использование Java, я полагался на Eclipse, чтобы сделать всю компиляцию для меня, и просто беспокоился о написании кода." Я видел этот вопрос много раз, и, в самом деле, это то, что подтолкнуло меня мои сообщение в блог системы GPS и интегрированных сред разработки: полезно или вредно? Я люблю мощные современные Java IDE, и они делают мою жизнь легче на ежедневной основе, но есть и преимущества, чтобы знать, как строить и запускать простые примеры Java без них. Это сообщение посвящено тому, как сделать именно это.

В моем блоге обучения Java с помощью простых тестов, я написал о том, как я иногда люблю использовать простой текстовый редактор и средства командной строки для написания, построения и запуска простых приложений. У меня есть довольно хорошее представление теперь, как моя много "накладные расходы" мои любимые IDE для Java требуют и сделать раннее решение, являются ли преимущества, достигнутые с помощью интегрированной среды достаточно, чтобы оправдать "накладные расходы". В большинстве реальных приложений, нет никаких сомнений, IDE «ВЛ», дорогого стоит. Тем не менее, для простейших примеров приложений, это не всегда так. В остальной части этой должности показывает, как построить и запустить Java код без IDE для этих ситуаций.
<h2>Написание и выполнение Java-кода</h2>Чтобы сделать пример более наглядным, я буду использовать некоторые очень простые Java-классы, которые связаны друг с другом через композиции или наследования и находятся в одном пакете с именем <em>dustin.examples</em>. В двух классах отсутствует функция <code>main</code>, в третьем классе Main.java есть функция <code>main</code>, которая позволяет продемонстрировать запуск класса без IDE. Ниже приведен код этих трех классов:

<strong>Parent.java</strong>

<pre class='lang-java line-numbers'><code>
package dustin.examples;

public class Parent
{
   @Override
   public String toString()
   {
      return "I'm the Parent.";
   }
}
</code></pre>
<strong>Child.java</strong>

<pre class='lang-java line-numbers'><code>
package dustin.examples;

public class Child extends Parent
{
   @Override
   public String toString()
   {
      return "I'm the Child.";
   }
}
</code></pre>
<strong>Main.java</strong>

<pre class='lang-java line-numbers'><code>
package dustin.examples;

import static java.lang.System.out;

public class Main
{
   private final Parent parent = new Parent();
   private final Child child = new Child();

   public static void main(final String[] arguments)
   {
      final Main instance = new Main();
      out.println(instance.parent);
      out.println(instance.child);
   }
}
</code></pre>
На следующем скриншоте показана структура каталогов с этими классами <em>.java</em>.Снимок экрана показывает, что исходные файлы в иерархии каталогов, представляющей имя пакета (<em>dustin/examples</em>, потому что информация о пакете <em>dustin.examples</em>) и что этот пакет отражающей иерархию каталогов находится под подкаталоге SRC. Я также создал подкаталог классов (который в настоящее время пуст) для размещения скомпилированных файлов <em>.class</em> потому <em>Javac</em> не создаст этот каталог, когда он не существует. 
<h2>Здание с JAVAC и запуск с Java</h2>Независимо от того, какой подход один использует для создания Java-код (Ant, Maven, Gradle или IDE), это в конечном счете сводится к JAVAC. Стандартные параметры в Oracle/Sun предоставленный JAVAC инструмент командной строки можно увидеть, запустив JAVAC -help и дополнительные опции расширения могут быть просмотрены, запустив JAVAC -help -X. Подробнее о том, как применять эти варианты можно найти в документации инструментов для JAVAC для ОС Windows или Unix / Linux. 

Как говорится в Javac документации, опция -sourcepath можно использовать, чтобы выразить каталог, в котором существует исходные файлы. В моей структуре каталогов, показанного на снимке экрана выше, это означает, что, предполагая, что я бегу команду JAVAC из <em>C: \ Java \ примеров \ javacAndJava \ директории</em>, я должен был бы иметь нечто подобное в моей команде: <em>Javac -sourcepath SRC SRC \ Дастин \ примеры \ *. Java</em>. Следующий снимок экрана показывает результаты этого.
<img data-id="1052a703-deb8-43cf-8e03-50b6e9d41035" data-max-width="570" alt="Компиляция и запуск Java без IDE - 2" src="https://cdn.javarush.com/images/article/1052a703-deb8-43cf-8e03-50b6e9d41035/1024.jpeg">Потому что мы не указать каталог для файлов <em>.class</em>, они были размещены по умолчанию в том же каталоге, что и исходный <em>.java</em> файлы, из которых они были составлены. Мы можем использовать опцию <code>-d</code>, чтобы исправить эту ситуацию. Наша команда может быть запущена сейчас, например, как <em>Javac -sourcepath SRC -d классов SRC \ Дастин \ примеры \ *. Явы</em>. Как отмечалось ранее, выбранную папку (классы) должны уже существовать. Когда это произойдет, команда поместит <em>.class</em> файлы в указанную папку, как показано на следующем снимке экрана
<img data-id="982efc96-00d0-4c72-8ee3-2a659b46b9d1" data-max-width="570" alt="Компиляция и запуск Java без IDE - 3" src="https://cdn.javarush.com/images/article/982efc96-00d0-4c72-8ee3-2a659b46b9d1/1024.jpeg">С исходные файлы Java составлен в соответствующие <em>.class</em> файлов в указанной директории, мы можем запустить приложение, используя меню быстрого запуска инструмента командной строки Java Java. Это просто сделать, следуя инструкциям, приведенным на Java -help или страницы ява инструментов и указав расположение файлов <em>.class</em> с опцией <code>-classpath</code> (или <code>-cp</code>). Использование обоих подходов указать, что каталог классы, где искать файлы <em>.class</em> демонстрируется в следующем снимке экрана. Последний аргумент является полное (весь пакет Java) имя класса, который имеет главную функцию, которая будет выполнена. Команды продемонстрировали в следующем снимке экрана является классы Java -cp dustin.examples.Main и классы Java -classpath dustin.examples.Main.
<img data-id="e7afd7f3-ea37-40f1-a389-883b56c91ce8" data-max-width="570" alt="Компиляция и запуск Java без IDE - 4" src="https://cdn.javarush.com/images/article/e7afd7f3-ea37-40f1-a389-883b56c91ce8/1024.jpeg"><h2>Построение и запуск с Ant</h2>Для простейших Java приложений, это довольно проста в использовании JAVAC и Java для создания и запуска приложения, соответственно, как только что продемонстрировали. Как приложения получить немного сложнее (например, код существующей в более чем один пакет / каталог или более сложных классам зависимостей от сторонних библиотек и фреймворков), такой подход может стать громоздким. Apache Ant является старейшим из "большой тройки" Явы построить инструменты и был использован в тысячи приложений и развертывания. Как я уже говорил в предыдущем посте блога, очень простой Ant построить файл легко создать, особенно если начинается с шаблона, как я изложил в этой должности. 

Следующий список кода предназначен для Ant файла <em>build.xml</em>, которую можно использовать для составления <em>.java</em> файлы в файлы .class а затем запустить класс <em>dustin.examples.Main</em> как это было сделано выше с JAVAC и Java.

<strong>build.xml</strong>

<pre class='lang-java line-numbers'><code>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project name="BuildingSansIDE" default="run" basedir="."&gt;
   &lt;description&gt;Building Simple Java Applications Without An IDE&lt;/description&gt;

   &lt;target name="compile"
           description="Compile the Java code."&gt;
      &lt;javac srcdir="src"
             destdir="classes"
             debug="true"
      includeantruntime="false" /&gt;
   &lt;/target&gt;

   &lt;target name="run" depends="compile"
           description="Run the Java application."&gt;
      &lt;java classname="dustin.examples.Main" fork="true"&gt;
         &lt;classpath&gt;
           &lt;pathelement path="classes"/&gt;
         &lt;/classpath&gt;
      &lt;/java&gt;
   &lt;/target&gt;
&lt;/project&gt;
</code></pre>
Я не использовал Ant свойства и не входит общих целей я обычно включают (например, "чистых" и "Javadoc"), чтобы сохранить этот пример как можно более простым и держать его близко к предыдущему примеру с помощью JAVAC и Java. Отметим также, что я включил "отладки" установлен на "истинный" для JAVAC Ant задачи, потому что это не так в случае отказа Ant, но верно с умолчанию JAVAC в. Не удивительно, Javac задача и Java задача Муравья напоминают JAVAC команда инструменты и Java. 

Потому что я использовал имя по умолчанию Ant ожидает файла сборки, когда он не указан явно (build.xml) и потому что я предоставил "Выполнить" цель как "по умолчанию" для этого сборки и потому, что я включен "скомпилировать" как зависимость запустить "Run" цель и потому Ant был на пути моем окружении в, все, что нужно сделать в командной строке, чтобы получить Ant для компиляции и запуска пример типа "муравей" в каталоге с файлом <em>build.xml</em>. Это показано в следующем снимке экрана.
<img data-id="4521c59b-8bf3-4e97-b98b-4b7eba96ff08" data-max-width="570" alt="Компиляция и запуск Java без IDE - 5" src="https://cdn.javarush.com/images/article/4521c59b-8bf3-4e97-b98b-4b7eba96ff08/1024.jpeg">Хотя я продемонстрировал компиляции и выполнения простого приложения Java с Ant, я, как правило, только компилировать с Ant и бежать с Java (или скрипта, который вызывает Java, если путь к классам, являются тяжкими). 
<h2>Построение и запуск с Maven</h2>Хотя Ant был первый основной инструмент Java сборки, Apache Maven в конечном итоге получили свои известность во многом благодаря его принятия конфигурации в соответствии с соглашением и поддержкой общих хранилищ библиотек. Maven является простым в использовании, когда код и сгенерированные объекты соответствовать его стандартной схеме директорий. К сожалению, мой пример не следует эту структуру каталогов, но Maven действительно позволяет нам переопределить ожидаемое структуру каталогов по умолчанию. Следующий список код для POM файл Maven, который используется вместо каталоги исходные и целевые и обеспечивает другие минимально необходимые элементы для Maven построить с помощью Maven 3.2.1.

<strong>pom.xml</strong>

<pre class='lang-java line-numbers'><code>
&lt;project&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
   &lt;groupId&gt;dustin.examples&lt;/groupId&gt;
   &lt;artifactId&gt;CompilingAndRunningWithoutIDE&lt;/artifactId&gt;
   &lt;version&gt;1&lt;/version&gt;

   &lt;build&gt;
      &lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;
      &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt;
      &lt;outputDirectory&gt;classes&lt;/outputDirectory&gt;
      &lt;finalName&gt;${project.artifactId}-${project.version}&lt;/finalName&gt;
   &lt;/build&gt;
&lt;/project&gt;
</code></pre>Поскольку выше файл <em>pom.xml</em> определяет "defaultGoal" из "скомпилировать" и потому <em>pom.xml</em> файлов POM по умолчанию обычай, что Maven исполняемый (МВН) ищет и потому каталог бен установку Maven находится на моем пути, только я необходимые для запуска "MVN" для компиляции файлы .class как указано в следующем снимке экрана.
<img data-id="210699b7-d0ed-4bc8-95aa-d0bf53a0a554" data-max-width="570" alt="Компиляция и запуск Java без IDE - 6" src="https://cdn.javarush.com/images/article/210699b7-d0ed-4bc8-95aa-d0bf53a0a554/1024.jpeg">Я могу также запуска скомпилированного приложения с Maven с помощью командной <em>Mvn Exec: Java -Dexec.mainClass = dustin.examples.Main</em>, которое наблюдается в на следующем снимке экрана.
<img data-id="3dc361cd-e9d5-47db-9ffa-d0414755ac01" data-max-width="570" alt="Компиляция и запуск Java без IDE - 7" src="https://cdn.javarush.com/images/article/3dc361cd-e9d5-47db-9ffa-d0414755ac01/1024.jpeg">Как и в случае с Ant, я, как правило, не использовать Maven для запуска мой простой Java приложения, а вместо этого использовать Java на скомпилированный код (или использовать сценарий, вызывающий Java непосредственно в течение длительного классам). 
<h2>Построение и запуск с Gradle</h2>Gradle является самым молодым, модных и стильных из трех основных инструментов Java сборки. Я иногда скептически относятся к существу то, что является модным, но я нашел много вещей, чтобы нравится Gradle (написанной в Groovy вместо XML, встроенный в Ant поддержки, встроенной поддержкой Ivy, конфигурации по соглашению, которое легко перенастроен , поддержка хранилища Maven, и т.д.). Следующий пример показывает сборки Gradle, который можно использовать, чтобы скомпилировать и запустить простое приложение, которое является основным пример кода для этого поста. Это адаптированный примере я представил в блоге Simple Gradle Java Plugin Customization.

<strong>build.gradle</strong>

<pre class='lang-java line-numbers'><code>
apply plugin: 'java'
apply plugin: 'application'

// Redefine where Gradle should expect Java source files (*.java)
sourceSets {
    main {
        java {
            srcDirs 'src'
        }
    }
}

// Redefine where .class files are written
sourceSets.main.output.classesDir = file("classes")

// Specify main class to be executed
mainClassName = "dustin.examples.Main"

defaultTasks 'compileJava', 'run'
</code></pre>
Первые две строки из файла <em>build.gradle</em> указать применение плагина Java и плагином Application, в результате чего кучу функциональности автоматически этой сборке. Определение «sourceSets" и "sourceSets.main.output.classesDir" позволяет перекрывать каталогов по умолчанию Java плагина Gradle для исходного кода Java и скомпилированных двоичных классов соответственно."MainClassName" позволяет явным указанием, какой класс должен быть запущен в рамках плагина Application. Линия "defaultTasks" определяет задачи, которые будут работать, просто набрав "Gradle" в командной строке: 'compileJava' является стандартной задачей обеспечивается плагином Java и "Выполнить" является стандартной задачей обеспечивается плагином Application. Потому что я назвал сборки build.gradle и потому я указал задач по умолчанию 'compileJava "и" Выполнить "и потому что я есть установочный бен каталог Gradle на моем пути, все, что я должен был сделать, чтобы построить и запустить примеры было введите "Gradle", и это демонстрируется в следующем снимке экрана.
<img data-id="e0199f7c-a67d-466c-bdae-50e321790bcb" data-max-width="570" alt="Компиляция и запуск Java без IDE - 8" src="https://cdn.javarush.com/images/article/e0199f7c-a67d-466c-bdae-50e321790bcb/1024.jpeg">Даже самый большой скептик должен признать, что Gradle сборки очень скользкий для этого простого примера. Она сочетает в себе лаконичность от опираясь на определенные конвенций и предположений с очень легкой механизма переопределения выберите по умолчанию в случае необходимости. Тот факт, что он находится в Groovy вместо XML также очень привлекательным! 

Как и в случае с Ant и Maven, я, как правило, чтобы построить только с помощью этих инструментов и, как правило, работать скомпилированные файлы .class непосредственно с Java или скрипта, который вызывает Java. Кстати, я, как правило, также архивировать эти .class в баночку для запуска, но это выходит за рамки этой статьи. 
<h2>Заключение</h2>IDE часто нет необходимости для построения простых приложений и примеры и может быть даже более накладные, чем это стоит для простейших примеров. В таком случае, это довольно легко применять JAVAC и Java непосредственно построить и запустить примеры. Как примеры принимать более активное участие, инструмент для сборки, такие как Ant, Maven, или Gradle становится более привлекательным. Тот факт, что многие среды разработки поддерживают эти утилиты сборки означает, что разработчик может перейти в IDE с помощью встроенного инструмента, созданного ранее в процессе, если было определено, что поддержка IDE был нужен как простое приложение переросла в полноценный проект.