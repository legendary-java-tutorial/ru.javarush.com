Java 12 уже здесь: что нового?
<p>----------------------------------------</p>
Итак, появилась Java под номером 12. И пускай это не LTS-релиз (то есть, не Long term support, не тот релиз, который будет долго поддерживаться. Первым LTS-релизом с восьмилетним сроком поддержки считается 11 версия), в нём появились интересные обновления...
<p>----------------------------------------</p>
Итак, появилась Java под номером 12. И пускай это не LTS-релиз (то есть, не Long term support, не тот релиз, который будет долго поддерживаться. Первым LTS-релизом с восьмилетним сроком поддержки считается <a href='https://javarush.com/groups/posts/1961-vihshla-java-11-novihe-fichi-i-vozmozhnosti-' target='_blank'>11 версия</a>), в нём появились интересные обновления. Рассмотрим самые важные из них. Напомним, в Java предложения по изменению сокращённо называют jep’ами (от JDK Enhancement Proposal). 
<img data-id="eb6239b9-0950-4d5a-8715-df4abb756c61" data-max-width="850" alt="Java 12 уже здесь: что нового? - 1" src="https://cdn.javarush.com/images/article/eb6239b9-0950-4d5a-8715-df4abb756c61/1024.jpeg"><h2>Самые интересные Jep’ы JDK 12</h2>
<strong>189: <a href='http://openjdk.java.net/jeps/189' rel='nofollow' target='_blank'>Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></strong>

В сборщике мусора (Garbage Collector) по имени Shenandoah применён новый алгоритм, который сокращает время работы, поскольку занимается “чисткой” одновременно с запущенными потоками Java. При этом время паузы в Shenandoah будет одинаковым независимо от размера кучи (heap). 

Oracle почему-то не включила Sheandoah в свои “официальные” релизные сборки, невзирая на то, что разработчики считают эту фичу одной из важнейших в новом релизе. Так что если вы планируете опробовать продвинутый Garbage Collector, нужно использовать сборки сторонних компаний, например, <a href='https://www.azul.com/downloads/zulu/' rel='nofollow' target='_blank'>Azul</a>. 

<strong>230: <a href='http://openjdk.java.net/jeps/230' rel='nofollow' target='_blank'>Microbenchmark Suite</a></strong>

Microbenchmark — это микротест, который измеряет производительность какого-то небольшого элемента. В Java их пишут и запускают с помощью фреймворка JMH. Начиная с 12 версии JMH была добавлена в JDK, и уже есть <a href='https://hg.openjdk.java.net/jdk/jdk12/file/0276cba45aac/test/micro/org/openjdk/bench' rel='nofollow' target='_blank'>тесты</a>, которые написаны на нём, что упрощает жизнь разработчикам.    

<strong>325: <a href='http://openjdk.java.net/jeps/325' rel='nofollow' target='_blank'>Switch Expressions (Preview)</a></strong>

Новая форма написания выражения с оператором switch. На странице фичи приводится пример кода с традиционным использованием switch, где постоянное использование break делает его излишне многословным, что приводит к частым случайным ошибкам. 

<pre class='lang-java line-numbers'><code>
switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        System.out.println(6);
        break;
    case TUESDAY:
        System.out.println(7);
        break;
    case THURSDAY:
    case SATURDAY:
        System.out.println(8);
        break;
    case WEDNESDAY:
        System.out.println(9);
        break;
}
</code></pre>
Авторы обновления предлагают ввести новую форму метки switch “case L ->” чтобы очевидным образом показать, что выполнятся будет только код справа от метки, если эта метка – подходящая. Так, код, показанный выше с помощью нового синтаксиса можно существенно сократить:

<pre class='lang-java line-numbers'><code>
switch (day) {
    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);
    case TUESDAY                -> System.out.println(7);
    case THURSDAY, SATURDAY     -> System.out.println(8);
    case WEDNESDAY              -> System.out.println(9);
}
</code></pre>
<strong>334: <a href='http://openjdk.java.net/jeps/334' rel='nofollow' target='_blank'>JVM Constants API</a></strong>

В пуле констант располагаются так называемые loadable constants. Это значения, например типа String или любого примитивного типа, а также run-time артефакты, такие как классы и методы. Во время работы с класс-файлами, программистам не помешали бы удобные инструменты для манипуляции с loadable constants.   

Авторы этого jep’а принялись решать эту проблему с помощью введения новых value-based типов символических ссылок, при этом каждая из них будет описывать конкретный вид констант. <a href='http://cr.openjdk.java.net/~vromero/constant.api/webrev.04/constants.api.patch' rel='nofollow' target='_blank'>Код нововведения</a>.  

<strong>340: <a href='http://openjdk.java.net/jeps/340' rel='nofollow' target='_blank'>One AArch64 Port, Not Two</a></strong> 

Под этим сложным названием скрывается решение проблемы, образовавшейся ещё в Java 9, когда в ките появились 64-битные ARM-порты Oracle и aarch64 от Red Hat одновременно. При этом уже во время выхода JDK 11, 64-битную версию портов Oracle не поддерживала даже сама Oracle. Так что теперь 64-битные порты Oracle убрали, остались 32-битные ARM32, и 64-битные, более производительные, aarch64. 

<strong>341: <a href='http://openjdk.java.net/jeps/341' rel='nofollow' target='_blank'>Default CDS Archives</a></strong>
 
Очень приятное обновление, поскольку оно реально ускоряет запуск приложений. 

Не секрет, что при старте Java-приложения начинает загрузку огромное количество классов, а это достаточно длительный процесс. 

CDS расшифровывается как Class Data Sharing, и эта функция позволяет упаковать все эти запускаемые при старте классы в специальный class data sharing архив, используя дефолтный список этих самых классов. В результате скорость запуска приложений существенно возрастает.    

<strong>344: <a href='http://openjdk.java.net/jeps/344' rel='nofollow' target='_blank'>Abortable Mixed Collections for G1</a></strong>

G1 — это сборщик мусора, который стал основным в JDK 9, сменив на этом посту Parallel GC. В Java 10 G1 научился собирать мусор в нескольких потоках. Однако его работой были довольны не все, одной из главных проблем оказались длительные паузы. Теперь их можно отменить. G1 на основе анализа поведения программы определяет объем работы, а затем собирает “живые” объекты в Collection set пока не соберёт все, не останавливаясь. Часто G1 промахивался с подсчётом объёма работы и работал слишком долго. После внедрения jep-344 G1 может перейти на пошаговую сборку мусора и если время выполнения следующего шага выходит за рамки разумного, этот шаг можно прервать. 

<strong>346: <a href='http://openjdk.java.net/jeps/346' rel='nofollow' target='_blank'>Promptly Return Unused Committed Memory from G1</a></strong>

И ещё немного обновлений в стане вышеупомянутого сборщика G1. Порой бывало, что куча Java heap memory есть, а её, эту память, никто не использует. Теперь в Java 12 можно “вернуть” неактивную память в операционную систему.  Раньше добиться от G1 отдать память можно было очень редко, теперь всё упростилось. С новой фичей приложение определяется как неактивное если закончился интервал с последней сборки и нет concurrent cycle. Другая ситуация — если  или если функция getloadavg(), работу которой отслеживали в течение какого-то времени, показывает нагрузку ниже установленного допустимого порога. Если произошло одно из двух событий, начинается частичная сборка мусора. 

<strong>Чего в Java 12 нет: <a href='https://openjdk.java.net/jeps/326' rel='nofollow' target='_blank'>Raw String Literals</a></strong> 

Многие разработчики с интересом отнеслись к этой функции, однако она так и не появилась в данном релизе. Её авторы решили, что над ней ещё нужно поработать. Так что, смеем надеяться, функция удобной работы со строковыми литералами появится в одной из ближайших версий Java. 

Поддержка необработанных строковых литералов позволяет работать со строковой информацией независимо от языка. Это устраняет необходимость в экранировании. Особенно полезно в регулярных выражениях, где широко используется обратный слэш и в Windows-path, где слэш используется в качестве разделителя. То есть во избежание таких конструкций: 
<em><strong>C:\\My\\Test\\Pack\\</strong></em>
<table class="table table--striped">
<tr>
<td>
Каждый программист часто сталкивается с теми или иными сложностями при работе. Иногда они связаны с неопытностью разработчика, но порой — с неидеальностью самого инструмента.  Java — классный язык, но далеко не идеальный. Возможно, вы уже столкнулись с чем-то в Java, и знаете, что хотели бы изменить в вашем “инструменте” (языке)? Делитесь в комментариях!  
</td>
</tr>
</table><h2>Выводы</h2>Никакой революции в Java 12 не произошло. Впрочем, её никто и не планировал. Однако ряд нововведений направлен на оптимизацию работы приложений и ускорение работы, что не может не радовать. Кстати, IDEA уже поддерживает JDK 12, так что вы вполне можете опробовать её возможности. 

Разумеется, мало какие обновления касаются новичков непосредственно, хотя поиграться с новым switch (предварительно установив флаг --enable-preview) может даже тот, кто только начал обучение на JavaRush. 