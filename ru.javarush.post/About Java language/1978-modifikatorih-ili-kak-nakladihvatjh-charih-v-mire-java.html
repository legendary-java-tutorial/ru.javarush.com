Модификаторы или как накладывать чары в мире Java
<p>----------------------------------------</p>
О модификаторах... Доброго галактического времени суток, комрады! Это мой первый межпланетный манускрипт, а поскольку являюсь я инженером, трактовка некоторых понятий может производиться на внеземном языке. На мой взгляд Java похожа на бесконечный коридор с дверьми (package) ...

<p>----------------------------------------</p>
Доброго галактического времени суток, комрады! Это мой первый межпланетный манускрипт, а поскольку являюсь я инженером, трактовка некоторых понятий может производиться на внеземном языке. 
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="16fb55c8-8ec6-496e-9b19-e6d0bdaa13ea" alt="Модификаторы или как накладывать чары в мире Java - 1" src="https://cdn.javarush.com/images/article/16fb55c8-8ec6-496e-9b19-e6d0bdaa13ea/1024.jpeg"></div></div><u><strong>Вступление</strong></u>
На мой взгляд Java похожа на бесконечный коридор с дверьми (package). За каждой из таких дверей имеется свободное пространство и картотека, в которой хранится гора магических свитков с инструкциями (классов) по созданию объектов. В каждом свитке описывается набор характеристик (переменных) и способностей (методов) — действий (полей), совершаемых над или самим классом, или собранным на его основе объектом. На этом этапе давайте представим себя волшебниками и попробуем создать совершенно новую инструкцию (класс). Итак:
<img data-id="054face5-8ad4-461a-a60e-3ed477f77e09" alt="Модификаторы или как накладывать чары в мире Java - 2" src="https://cdn.javarush.com/images/article/054face5-8ad4-461a-a60e-3ed477f77e09/1024.jpeg">Выпиваем эликсир мудрости (изучаем основы) и приступаем к написанию инструкции.

<u><strong>Access и non-access модификаторы</strong></u>
Представим себе, что любая инструкция и создаваемый на ее основе объект, а также его характеристики и способности будут изначально магически зачарованы, т.е. им будут присвоены определенные наборы модификаторов. Попробуем создать пособие по возможным зачарованиям.

<ol>
<li><p>Модификатор <strong>доступа</strong>, который описывает доступность класса, объекта или поля — обязательный: при его отсутствии JVM (это такой источник вселенской магии) автоматически присваивает идентификатор по умолчанию package.</p>
<p>Начиная со второго модификатора идут non-access модификаторы, которые не являются обязательными, а также могут конфликтовать друг с другом (но обо всем по порядку).</p></li>
<li><p>Модификатор <strong>Static</strong> говорит о том, что класс, объект или поле статичны. Но что это значит? В основном он примерим к полям. </p>
<p>Статические переменные называются переменными класса и являются уникальными для всех экземпляров данного класса. Статические методы могут быть вызваны без создания объекта, в котором они описаны. Статические классы используются при вложении одного класса в другой и принцип взаимодействия внутреннего класса с внешним схож с методами (является темой отдельного разговора). Также может использоваться в виде отдельного блока внутри объекта.</p></li>
<li><p>Модификатор <strong>Final</strong> фактически служит для переменной указанием на то, что она является константой. Для методов — что они не могут быть переопределены при наследовании, ну а для классов это указание на то, что наследоваться от него нельзя (immutable).</p>
<p>Модификаторы static и final применимы к классам, объектам и полям. Однако есть модификаторы, которые применимы лишь к некоторым из них (или даже части, ведь и переменная и метод — это поле, но не все модификаторы применимы к обоим). Если проводить аналогию, на скорость можно зачаровать лишь ботинки и перчатки (чтобы быстрее двигались), а вот зачаровывать шляпу на скорость бессмысленно (да и Вселенский Надзирательный Совет (компилятор) не даст).</p></li>
<li><p>Модификатор <strong>Abstract</strong> <em>применим только к методам и классам</em>. Абстрактный метод — это метод без реализации (тела). </p>
<p>Если класс помечается как абстрактный, он либо содержит абстрактные методы, либо это делается для того чтобы запретить создание экземпляров этого класса. Если проводить аналогию, посреди инструкции можно увидеть заголовок «Раскраска объекта», после которого нет описания. Т.е. по этой инструкции можно создать объект и раскрасить его тоже можно, но в конкретно этой инструкции не написано как (пишите свою инструкцию по созданию красного объекта на основе этого объекта и опишите как его раскрашивать).</p></li></ol>При работе в многопоточной среде могут использоваться специальные модификаторы:<ol><li><p>Модификатор <strong>Syncronized</strong> <em>используется только для методов.</em> Его наличие свидетельствует о том, что его может одновременно выполнять лишь один поток. Также может использоваться в виде отдельного блока кода внутри объекта (с указанием объекта синхронизации).</p></li>
<li><p>Модификатор <strong>Volatile</strong> — <em>только для переменных</em>. Его рекомендуется использовать для переменных, которые могут быть одновременно использоваться несколькими потоками. Переменная с таким модификатором при каждом изменении моментально копируется из кэша процессора в основную память, позволяя параллельным потокам получать самое «свежее» значение.</p>
<p>Стоит отметить, что volatile применим в тех случаях, когда только один поток может записывать в переменную, а остальные лишь читают из нее. Для остальных случаев лучше вешать модификатор synchronized на методы, которые записывают в волатильную переменную. </p></li>
<li><p>Модификатор <strong>Transient</strong> – <em>только для переменных</em>. Таким модификатором помечаются переменные, которые нужно пропускать при сериализации объекта (это такой умный процесс, о котором, в принципе, и самостоятельно почитать можно…)*</p>
<p>* - данная статья написана мною на 17 уровне и до тех пор сериализация как процесс описан не был, поэтому вместо копипасты я советую, при необходимости, изучить его самостоятельно.</p></li></ol>
<u><strong>Конфликтующие пары модификаторов</strong></u>
Помимо применимости модификаторов к различным классам, объектам и полям существует также понятие конфликтующих пар. Допустим, наложение на шлем чар прочности делает его тяжелым, и одновременно вы хотите зачаровать его на легкость. Одно с другим не вяжется.

<ol>
<li><em>Final и Volatile</em> – когда речь идет о переменных, мы не можем одновременно сказать что она финальна (константа) и что несколько потоков имеют возможность ее изменить… Ведь она постоянна, и в любой момент поток может ее считать, но ни один поток не в силах изменить константу (Вселенский Надзирательный Совет не даст).</li>
<li><em>Final и Abstract</em> — классы и методы не могут быть одновременно абстрактными (что в большинстве случаев подразумевает необходимость их уточнения для реализации) и финальными, т.е. неизменяемыми. Получается, что в инструкции написано, как создать хороший прочный шлем из любого материала (абстрактная часть), но для этого в нем обязательно не должно быть отверстий (финальная обязательная часть, изменению не подлежит).</li>
<li><em>Abstract и Static</em> — абстрактный метод не может одновременно быть статическим или синхронизированным. Статический абстрактный метод не имеет смысла, ведь он мало того, что ничего не делает, так еще и принадлежит целому классу — бесполезная штука получается.</li>
<li><em>Abstract и Syncronized</em> — какой смысл в синхронизации работы с методом, который ничего не делает?</li>
</ol><strong><u>Подведение итогов</u></strong>
Итак, описание модификаторов закончилось, все конфликты разобраны и теперь можно закрепить полученный результат шпаргалкой — схемой зачарований:
<img data-id="c75b48f6-3120-4f51-b0f1-55c66da594b6" alt="Модификаторы или как накладывать чары в мире Java - 3" src="https://cdn.javarush.com/images/article/c75b48f6-3120-4f51-b0f1-55c66da594b6/1024.jpeg">В завершение хочу сказать, что написание этой статьи явилось реализацией моего желания изучить модификаторы. Успешный опыт или нет — на ваш суд. Я жду ваших предложений по ее улучшению/исправлению и, возможно совместно мы сделаем из нее полезнейший мануал для начинающих джавистов.