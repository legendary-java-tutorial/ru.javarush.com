Зачем нужны интерфейсы?
<p>----------------------------------------</p>
Для тех, кто почитал и понял, как делать интерфейсы, но не понял, зачем.
<p>----------------------------------------</p>
<span>Зачем нужны интерфейсы?
<a href="https://javarush.com/groups/posts/3664-zachem-nuzhno-nasledovanie-interfeysov" target="_blank" rel="nofollow">Зачем нужно наследование интерфейсов?</a>
<a href="https://javarush.com/groups/posts/3663-zachem-nuzhen-polimorfizm" target="_blank" rel="nofollow">Зачем нужен полиморфизм?</a></span>

Для тех, кто почитал и понял как делать интерфейсы, но не понял зачем.

<p>Дисклеймер:
В этой статье и последующих, нейминги классов и методов будут приведены на русском языке.</p>

Когда речь заходит о принципах объектно-ориентированного программирования (ООП): полиморфизм, наследование и инкапсуляция, полезно приводить аналогии из реального мира. Большой плюс ООП в том, что мы в программе можем смоделировать часть реальной вселенной. 

Смоделируем семью Ивановых: <em>Папа</em>, <em>Мама</em> и мальчик <em>Петя</em>. От <em>Папы</em> <em>Петя</em> унаследовал привычку прихлюпывать когда пьет чай, а от <em>Мамы</em> он унаследовал привычку поджимать губы во время чтения. Если попытаться реализовать эту ситуацию в программу, то у нас получиться  три класса: 

<pre class="language-java line-numbers"><code>
class Папа 
class Мама 
class Петя 
</code></pre>
У <em>Папы</em> и <em>Мамы</em> есть привычки, которые нужно передать <em>Пете</em>. Привычки — это какие-то действия - так что лучше всего реализовать их в программном мире как методы: 

Сначала <em>Папа</em>:

<pre class="language-java line-numbers"><code>
class Папа {
public void прихлюпывать() {
System.out.println("Хлюп");
    }
}
</code></pre>
Теперь <em>Мама</em>:

<pre class="language-java line-numbers"><code>
class Мама {
public void поджимать() {
System.out.println("Поджать губки");
   }
}
</code></pre>
Если речь идет о наследовании, то логично написать код так: 

<pre class="language-java line-numbers"><code>
class Петя extends Папа, Мама {
@Override
public void прихлюпывать() {
     System.out.println("Хлюп");
   }

@Override
public void поджимать() {
System.out.println("Поджать губки");
    }
}
</code></pre>
То есть унаследовать <em>Петю</em> от <em>Папы</em> и <em>Мамы</em> одновременно. Если так написать, то компилятор будет ругаться, потому что в Java нельзя реализовать множественное наследование классов. К слову, в С++ можно, а вот в Java нельзя, потому что с множественным наследованием могут возникнуть большие проблемы: подробно пишут в <a href="https://ravesli.com/urok-161-mnozhestvennoe-nasledovanie/" target="_blank" rel="nofollow">интернете</a>. 
<img data-id="9732ab9a-84d0-4f57-b374-d24720e5268e" src="https://cdn.javarush.com/images/article/9732ab9a-84d0-4f57-b374-d24720e5268e/512.jpeg" alt="Зачем нужны интерфейсы? - 1">Что бы обойти это «нельзя», в Java есть интерфейсы. И для привычек мы придумаем свой интерфейс. Даже два: 

Выглядеть они будут так: 

<pre class="language-java line-numbers"><code>
public interface ПривычкиПапы {
    public void прихлюпывать();
}
public interface ПривычкиМамы {
    public void поджимать();
}
</code></pre>
В интерфейсе мы только описали привычки, но не описали что они конкретно делают, потому что конкретную реализацию мы пропишем в классах. Сначала отдадим <em>Папе</em> и <em>Маме</em> их законные привычки. 

<pre class="language-java line-numbers"><code>
class Папа implements ПривычкиПапы {

   @Override
    public void прихлюпывать() {
     System.out.println("Хлюп");
   }
}

class Мама implements ПривычкиМамы{

@Override
public void поджимать() {
System.out.println("Поджать губки");
    }
}
</code></pre>
И теперь, абсолютно легально можно передать <em>Пете</em> привычки от <em>Папы</em> и <em>Мамы</em> одновременно 

<pre class="language-java line-numbers"><code>
class Петя implements ПривычкиПапы, ПривычкиМамы {

@Override
public void прихлюпывать() {
     System.out.println("Хлюп");
   }

@Override
public void поджимать() {
System.out.println("Поджать губки");
    }
}
</code></pre>
То есть множественная реализация (чаще говорят имплементация) в Java вполне возможна. 
<img data-id="74e25108-fba8-4d32-a722-35b170bb183f" src="https://cdn.javarush.com/images/article/74e25108-fba8-4d32-a722-35b170bb183f/512.jpeg" alt="Зачем нужны интерфейсы? - 2">Смысл интерфейсов теперь должен быть понятен – в Java с помощью интерфейсов можно реализовать множественное наследование.

Если развивать ситуацию дальше, например: ведь у <em>Папы</em> и <em>Мамы</em> наверняка есть привычки, которые они не передали <em>Пете</em>, да и у <em>Пети</em> могут быть свои личные привычки. Как эту жизненную Санта-Барбару перенести в плоскость Java вы узнаете в следующих сериях.

Это не единственный пример для понимания интерфейсов.Если не читали следующие статьи, то обязательно прочтите:
<a href="https://javarush.com/quests/lectures/questsyntaxpro.level17.lecture06" target="_blank" rel="nofollow">Интерфейсы в Java</a> (если не открыто, можно выйти из профиля или прочитать в режиме - инкогнито)
<a href="https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih" target="_blank" rel="nofollow">Для чего в Java нужны интерфейсы</a> - тут реализуйте все примеры из статьи и поизменяйте методы и в интерфейсах и в калассах: наименования методов, сигнатуры (то что метод принимает на вход), типы вывода методов. 
Разберитесь самостоятельно: 
- с разницей  при имплементации интерфейса с классом и абстрактным классом;
- дефолтными методами.