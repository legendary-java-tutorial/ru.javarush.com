Интерфейсы в Java
<p>----------------------------------------</p>
Привет! Сегодня поговорим о важном понятии в Java — интерфейсы. Слово тебе наверняка знакомо. Например, интерфейсы есть у большинства компьютерных программ и игр. В широком смысле интерфейс — некий «пульт», который связывает две взаимодействующие друг ...
<p>----------------------------------------</p>
Привет! Сегодня поговорим о важном понятии в Java — интерфейсы. 

Слово тебе наверняка знакомо. Например, интерфейсы есть у большинства компьютерных программ и игр. В широком смысле интерфейс — некий «пульт», который связывает две взаимодействующие друг с другом стороны.

Простой пример интерфейса из повседневной жизни — пульт от телевизора.

Он связывает два объекта, человека и телевизор, и выполняет разные задачи: прибавить или убавить звук, переключить каналы, включить или выключить телевизор.

Одной стороне (человеку) нужно обратиться к интерфейсу (нажать на кнопку пульта), чтобы вторая сторона выполнила действие. Например, чтобы телевизор переключил канал на следующий. При этом пользователю не обязательно знать устройство телевизора и то, как внутри него реализован процесс смены канала. <img data-id="41c3ebe9-9db0-4720-a036-27ac16057a52" data-max-width="850" alt="Для чего в Java нужны интерфейсы - 1" src="https://cdn.javarush.com/images/article/41c3ebe9-9db0-4720-a036-27ac16057a52/1024.jpeg">Все, к чему пользователь имеет доступ — это<em> интерфейс</em>. Главная задача — получить нужный результат. 

Какое это имеет отношение к программированию и Java? Прямое :)

Создание интерфейса очень похоже на создание обычного класса, только вместо слова <code>class</code> мы указываем слово <code>interface</code>.

Давай посмотрим на простейший Java-интерфейс, и разберемся, как он работает и для чего нужен:

<pre class="lang-java line-numbers"><code>
public interface Swimmable  {

     public void swim();
}
</code></pre>
Мы создали интерфейс <code>Swimmable</code> — «<em>умеющий плавать</em>». Это что-то вроде нашего пульта, у которого есть одна «кнопка»: метод <code>swim()</code>  — «плыть». 

Как же нам этот «<em>пульт</em>» использовать?

Для этого метод, т.е. кнопку нашего пульта, нужно имплементировать. Чтобы использовать интерфейс, его методы должны реализовать какие-то классы нашей программы.

Давай придумаем класс, объекты которого подойдут под описание «умеющий плавать». Например, подойдет класс утки — <code>Duck</code>:

<pre class="lang-java line-numbers"><code>
public class Duck implements Swimmable {
    
    public void swim() {
        System.out.println("Уточка, плыви!");
    }
    
    public static void main(String[] args) {
        
        Duck duck = new Duck();
        duck.swim();
    }
}
</code></pre>
Что же мы здесь видим?

Класс <code>Duck</code> «связывается» с интерфейсом <code>Swimmable</code> при помощи ключевого слова <code>implements</code>. Если помнишь, мы использовали похожий механизм для связи двух классов в наследовании, только там было слово «<em>extends</em>».

«<code>public class Duck implements Swimmable</code>» можно для понятности перевести дословно: «публичный класс <code>Duck</code> реализует интерфейс <code>Swimmable</code>». 

Это значит, что класс, связанный с каким-то интерфейсом, должен реализовать все его методы. <em>Обрати внимание:</em> в нашем классе <code>Duck</code> прямо как в интерфейсе <code>Swimmable</code> есть метод <code>swim()</code>, и внутри него содержится какая-то логика.

Это обязательное требование. Если бы мы просто написали «<code>public class Duck implements Swimmable</code>» и не создали бы метод <code>swim()</code> в классе <code>Duck</code>, компилятор выдал бы нам ошибку:

<em>Duck is not abstract and does not override abstract method swim() in Swimmable</em>

Почему так происходит? 

Если объяснять ошибку на примере с телевизором, получится, что мы даем человеку в руки пульт с кнопкой «переключить канал» от телевизора, который не умеет переключать каналы.

Тут уж нажимай на кнопку сколько влезет, ничего не заработает. Пульт сам по себе не переключает каналы: он только дает сигнал телевизору, внутри которого реализован сложный процесс смены канала.

Так и с нашей уткой: она должна уметь плавать, чтобы к ней можно было обратиться с помощью интерфейса <code>Swimmable</code>.

Если она этого не умеет, интерфейс <code>Swimmable</code> не свяжет две стороны — человека и программу. Человек не сможет использовать метод <code>swim()</code>, чтобы заставить объект <code>Duck</code> внутри программы плыть.

Теперь ты увидел более наглядно, для чего нужны интерфейсы.

Интерфейс описывает поведение, которым должны обладать классы, реализующие этот интерфейс. «Поведение» — это совокупность методов.

Если мы хотим создать несколько мессенджеров, проще всего сделать это, создав интерфейс <code>Messenger</code>. Что должен уметь любой мессенджер? В упрощенном виде, принимать и отправлять сообщения.

<pre class="lang-java line-numbers"><code>
public interface Messenger{

     public void sendMessage();
     
     public void getMessage();
}
</code></pre>
И теперь мы можем просто создавать наши классы-мессенджеры, имплементируя этот интерфейс. Компилятор сам «заставит» нас реализовать их внутри классов.

Telegram:

<pre class="lang-java line-numbers"><code>
public class Telegram implements Messenger {
    
    public void sendMessage() {
        
        System.out.println("Отправляем сообщение в Telegram!");
    }
     
     public void getMessage() {
         System.out.println("Читаем сообщение в Telegram!");
     }
}
</code></pre>
WhatsApp:

<pre class="lang-java line-numbers"><code>
public class WhatsApp implements Messenger {
    
    public void sendMessage() {
        
        System.out.println("Отправляем сообщение в WhatsApp!");
    }
     
     public void getMessage() {
         System.out.println("Читаем сообщение в WhatsApp!");
     }
}
</code></pre>
Viber:

<pre class="lang-java line-numbers"><code>
public class Viber implements Messenger {
    
    public void sendMessage() {
        
        System.out.println("Отправляем сообщение в Viber!");
    }
     
     public void getMessage() {
         System.out.println("Читаем сообщение в Viber!");
     }
}
</code></pre>
Какие преимущества это дает? Самое главное из них — слабая связанность.

Представь, что мы проектируем программу, в которой у нас будут собраны данные клиентов. В классе <code>Client</code> обязательно нужно поле, указывающее, каким именно мессенджером клиент пользуется.

Без интерфейсов это выглядело бы странно:

<pre class="lang-java line-numbers"><code>
public class Client {
    
    private WhatsApp whatsApp;
    private Telegram telegram;
    private Viber viber;
}
</code></pre>
Мы создали три поля, но у клиента запросто может быть всего один мессенджер. Просто мы не знаем какой. И чтобы не остаться без связи с клиентом, приходится «заталкивать» в класс все возможные варианты. Получается, один или два из них всегда будут <code>null</code>, и они вообще не нужны для работы программы.

Вместо этого лучше использовать наш интерфейс:

<pre class="lang-java line-numbers"><code>
public class Client {
    
    private Messenger messenger;
}
</code></pre>
Это и есть пример «слабой связанности»! Вместо того, чтобы указывать конкретный класс мессенджера в классе <code>Client</code>, мы просто упоминаем, что у клиента есть мессенджер. Какой именно — определится в ходе работы программы. 

Но зачем нам для этого именно интерфейсы? Зачем их вообще добавили в язык?

Вопрос хороший и правильный! Того же результата можно добиться с помощью обычного наследования, так ведь?

Класс <code>Messenger</code> — родительский, а <code>Viber</code>, <code>Telegram</code> и <code>WhatsApp</code> — наследники. Действительно, можно и так.

Но есть одна загвоздка. Как ты уже знаешь, множественного наследования в Java нет. А вот множественная реализация интерфейсов — есть. Класс может реализовывать сколько угодно интерфейсов.

Представь, что у нас есть класс <code>Smartphone</code>, у которого есть поле <code>Application</code> — установленное на смартфоне приложение. 

<pre class="lang-java line-numbers"><code>
public class Smartphone {
    
    private Application application;
}
</code></pre>
Приложение и мессенджер, конечно, похожи, но все-таки это разные вещи. Мессенджер может быть и мобильным, и десктопным, в то время как Application — это именно мобильное приложение.

Так вот, если бы мы использовали наследование, не смогли бы добавить объект <code>Telegram</code> в класс <code>Smartphone</code>. Ведь класс <code>Telegram</code> не может наследоваться одновременно от <code>Application</code> и от <code>Messenger</code>! А мы уже успели унаследовать его от <code>Messenger</code>, и в таком виде добавить в класс <code>Client</code>.

Но вот реализовать оба интерфейса класс <code>Telegram</code> запросто может!  Поэтому в классе <code>Client</code> мы сможем внедрить объект <code>Telegram</code> как <code>Messenger</code>, а в класс <code>Smartphone</code> — как <code>Application</code>. Вот как это делается:

<pre class="lang-java line-numbers"><code>
public class Telegram implements Application, Messenger {
    
    //...методы
}

public class Client {
    
    private Messenger messenger;
    
    public Client() {
        this.messenger = new Telegram();
    }
}


public class Smartphone {
    
    private Application application;
    
    public Smartphone() {
        this.application = new Telegram();
    }
}
</code></pre>
Теперь мы используем класс <code>Telegram</code> как захотим. Где-то он будет выступать в роли <code>Application</code>, где-то — в роли <code>Messenger</code>.

Наверняка ты уже обратил внимание, что методы в интерфейсах всегда «пустые», то есть они не имеют реализации.

Причина этого проста: интерфейс описывает поведение, а не реализует его.

«Все объекты классов, имплементирующих интерфейс <code>Swimmable</code>, должны уметь плавать»: вот и все, что говорит нам интерфейс. Как там конкретно будет плавать рыба, утка или лошадь — вопрос к классам <code>Fish</code>, <code>Duck</code> и <code>Horse</code>, а не к интерфейсу. Также как переключение канала — задача телевизора. Пульт просто предоставляет тебе кнопку для этого.

Впрочем, в Java8 появилось интересное дополнение — методы по умолчанию (default method).

Например, в твоем интерфейсе есть 10 методов. 9 из них реализованы по-разному в разных классах, но один реализован одинаково у всех. Раньше, до выхода Java8, методы внутри интерфейсов вообще не имели реализации: компилятор сразу выдавал ошибку. Теперь же можно сделать вот так:

<pre class="lang-java line-numbers"><code>
public interface Swimmable {

   public default void swim() {
       System.out.println("Плыви!");
   }
  
   public void eat();
  
   public void run();
}
</code></pre>
Используя ключевое слово <code>default</code>, мы создали в интерфейсе метод с реализацией по умолчанию. Два других метода, <code>eat()</code> и <code>run()</code>, нам необходимо будет реализовать самим во всех классах, которые будут имплементировать <code>Swimmable</code>. С методом <code>swim()</code> этого делать не нужно: реализация будет во всех классах одинаковой.

Кстати, ты уже не раз сталкивался с интерфейсами в прошлых задачах, хоть и не замечал этого сам :) Вот очевидный пример:
<img data-id="dd15b9e7-137d-45f1-8233-51f18c9a41a6" data-max-width="1024" alt="Для чего в Java нужны интерфейсы - 2" src="https://cdn.javarush.com/images/article/dd15b9e7-137d-45f1-8233-51f18c9a41a6/1024.jpeg">Ты работал с интерфейсами <code>List</code> и <code>Set</code>! Точнее, с их реализациями — <code>ArrayList</code>, <code>LinkedList</code>, <code>HashSet</code> и прочими.

На этой же схеме видно пример, когда один класс реализует сразу несколько интерфейсов. Например, <code>LinkedList</code> реализует интерфейсы <code>List</code> и <code>Deque</code> (двусторонняя очередь). 

Ты знаком и с интерфейсом <code>Map</code>, а точнее, с его реализаций — <code>HashMap</code>.

Кстати, на этой схеме ты можешь увидеть одну особенность: интерфейсы могут быть унаследованы друг от друга. Интерфейс <code>SortedMap</code> унаследован от <code>Map</code>, а <code>Deque</code> наследуется от очереди <code>Queue</code>. Это нужно, если ты хочешь показать связь интерфейсов между собой, но при этом один интерфейс является расширенной версией другого. 

Давай рассмотрим пример с интерфейсом <code>Queue</code> — очередь. Мы пока не проходили коллекции <code>Queue</code>, но они достаточно простые и устроены как обычная очередь в магазине. 
Добавлять элементы можно только в конец очереди, а забирать — только из начала. На определенном этапе разработчикам понадобился расширенный вариант очереди, чтобы добавлять и получать элементы можно было с обеих сторон. Так создали интерфейс <code>Deque</code> — двустороннюю очередь. В нем присутствуют все методы обычной очереди, ведь она является «родителем» двусторонней, но при этом добавлены новые методы.