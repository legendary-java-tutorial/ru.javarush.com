Java @Аннотации. Что это и как этим пользоваться?
<p>----------------------------------------</p>
Краткий (возможно не очень) урок, по @Аннотациям в Java, на примере простого слушателя команд для бота. Данная статья предназначена для людей, которые никогда не работали с Аннотациями, но хотели бы разобраться что это и с чем его едят.
<p>----------------------------------------</p>
Данная статья предназначена для людей, которые никогда не работали с Аннотациями, но хотели бы разобраться, что это и с чем его едят. Если же вы имеете опыт в данной сфере, не думаю, что эта статья как-то расширит ваши знания (да и, собственно, такую цель я не преследую).

<span>Также</span> статья не подходит для тех, кто только начинает изучать язык Java. Если Вы не понимаете что такое <span>Map&lt;&gt;</span> или <span>HashMap&lt;&gt;</span> или не знаете что означает запись <span>static{ }</span> внутри определения класса, либо же никогда не работали с рефлексией – Вам рано читать эту статью и пытаться понять, что такое аннотации. <span>Сам по себе этот инструмент не создан для использования новичками, так как требует уже не совсем базовых пониманий взаимодействия классов и объектов</span> (моё мнение) (спасибо комментариям за то, что показали необходимость этой приписки).
<img data-id="30a09fa9-4766-40fa-bae8-345ed391c67c" alt="Java @Аннотации. Что это и как этим пользоваться? - 1" src="https://cdn.javarush.com/images/article/30a09fa9-4766-40fa-bae8-345ed391c67c/1024.jpeg">Итак, приступим.

Аннотации в Java являются своего рода метками в коде, описывающими метаданные для функции/класса/пакета. Например, всем известная Аннотация @Override, обозначающая, что мы собираемся переопределить метод родительского класса. Да, с одной стороны, можно и без неё, но если у родителей не окажется этого метода, существует вероятность, что мы зря писали код, т.к. конкретно этот метод может и не вызваться никогда, а с Аннотацией @Override компилятор нам скажет, что: "Я не нашел такого метода в родителях... что-то здесь нечисто".

Однако Аннотации могут нести в себе не только смысл "для надежности": в них можно хранить какие-то данные, которые после будут использоваться.
<h2>Для начала рассмотрим простейшие аннотации предоставляемые стандартной библиотекой.</h2> (снова же спасибо комментариям, вначале не подумал что этот блок нужен)

Сначала обсудим, какие бывают аннотации. Каждая из них имеет 2 главных <span>обязательных</span> параметра: <ul>
<li>Тип хранения (Retention);</li>
<li>Тип объекта над которым она указывается (Target).</li>
</ul><h4>Тип хранения</h4>Под "типом хранения" понимается стадия до которой "доживает" наша аннотация внутри класса. Каждая аннотация имеет <span>только один</span> из возможных "типов хранения" указанный в классе <span>RetentionPolicy</span>:<ul>
<li><span>SOURCE</span> - аннотация используется только при написании кода и игнорируется компилятором (т.е. не сохраняется после компиляции). Обычно используется для каких-либо препроцессоров (условно), либо указаний компилятору</li>
<li><span>CLASS</span> - аннотация сохраняется после компиляции, однако игнорируется JVM (т.е. не может быть использована во время выполнения). Обычно используется для каких-либо сторонних сервисов, подгружающих ваш код в качестве plug-in приложения</li>
<li><span>RUNTIME</span> - аннотация которая сохраняется после компиляции и подгружается JVM (т.е. может использоваться во время выполнения самой программы). Используется в качестве меток в коде, которые напрямую влияют на ход выполнения программы (пример будет рассмотрен в данной статье)</li>
</ul><h4>Тип объекта над которым указывается</h4>Данное описание стоит понимать практически буквально, т.к. в Java аннотации могут указываться над чем угодно (Поля, классы, функции, т.д.) и для каждой аннотации указывается, над чем конкретно она может быть задана. Здесь уже нет правила "что-то одно", аннотацию можно указывать над всем ниже перечисленным, либо же выбрать только нужные элементы класса <span>ElementType</span>:<ul>
<li><span>ANNOTATION_TYPE</span> - другая аннотация</li>
<li><span>CONSTRUCTOR </span> - конструктор класса</li>
<li><span>FIELD </span> - поле класса</li>
<li><span>LOCAL_VARIABLE </span> - локальная переменная</li>
<li><span>METHOD </span> - метод класса</li>
<li><span>PACKAGE </span> - описание пакета <span>package</span></li>
<li><span>PARAMETER </span> - параметр метода <span>public void hello(@Annontation String param){}</span></li>
<li><span>TYPE</span> - указывается над классом</li>
</ul>Всего на момент версии Java SE 1.8 стандартная библиотека языка предоставляет нам 10 аннотаций. В данной статье рассмотрим самые часто встречающиеся из них (кому интересны они все <a href="https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html" target="_blank" rel="nofollow">Welcome to Javadoc</a>):<h4>@Override</h4>Retention: SOURCE;
Target: METHOD.

Данная аннотация показывает, что метод над котором она прописана наследован у родительского класса.

Первая аннотация с которой сталкивался каждый начинающий Java-программист, при использовании IDE, которая настойчиво пихает эти @Override. Зачастую учителя с ютуба рекомендуют либо: "сотрите чтобы не мешало", либо: "оставьте не задумываясь зачем оно здесь". На самом деле аннотация более чем полезна: она не только позволяет понять какие методы были определены в этом классе впервые, а какие уже есть у родителей (что бесспорно повышает читаемость вашего кода), но также данная аннотация служит "самопроверкой", что вы не ошиблись при определении перегружаемой функции.<h4>@Deprecated</h4>Retention: Runtime;
Target: CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE.

Данная аннотация указывает на методы, классы или переменные, которые является "устаревшими" и могут быть убраны в последующих версиях продукта.

С данной аннотацией обычно сталкиваются те, кто читает документацию каких-либо API, либо той же стандартной библиотеки Java. Иногда эту аннотацию игнорируют, т.к. она не вызывает никаких ошибок и в принципе сама по себе сильно жить не мешает. Однако главный посыл, который несет в себе данная аннотация – "мы придумали более удобный метод реализации данного функционала, используй его, не используй старый" -  ну, либо же - "мы переименовали функцию, а это так, для легаси оставили..."  (что тоже в общем-то неплохо). Короче говоря, если видите @Deprecated - лучше стараться не использовать то, над чем она висит, если в этом нет прям крайней необходимости и, возможно, стоит перечитать документацию, чтобы понять каким образом теперь реализуется задача, выполняемая устаревшим элементом. Например вместо использований <span>new Date().getYear()</span> рекомендуется использовать <span>Calendar.getInstance().get(Calendar.YEAR)</span>.<h4>@SuppressWarnings</h4>Retention: SOURCE;
Target: TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE

Данная аннотация отключает вывод предупреждений компилятора, которые касаются элемента над которым она указана. Является SOURCE аннотацией указываемой над полями, методами, классами.<h4>@Retention</h4>Retention: RUNTIME;
Target: ANNOTATION_TYPE;

Данная аннотация задает "тип хранения" аннотации над которой она указана. Да эта аннотация используется даже для самой себя... магия да и только.<h4>@Target</h4>Retention: RUNTIME;
Target: ANNOTATION_TYPE;

Данная аннотация задает тип объекта над которым может указываться создаваемая нами аннотация. Да и она тоже используется для себя же, привыкайте...

Думаю, на этом можно завершить ознакомление со стандартными аннотациями библиотеки Java, т.к. остальные используются достаточно редко и, хоть и несут свою пользу, сталкиваться с ними приходится не всем и совершенно необязательно. <em>Если же вы хотите чтобы я рассказал о какой-то конкретной аннотации из стандартной библиотеки (либо, возможно, аннотации типа @NotNull и @Nullable которые в STL не входят) напишите в комментариях - либо вам там ответят добрые пользователи, либо я когда увижу. Если уж много людей будут просить какую-то аннотацию - также внесу её в статью.</em>
<h2>Практическое применение RUNTIME аннотаций</h2>Собственно, думаю, хватит теоретической болтавни: давайте перейдем к практике на примере бота. 

Допустим вы хотите написать бота для какой-то соцсети. У всех крупных сетей, таких как ВК, Facebook, Discord, есть свои API, которые позволяют написать бота. Для этих же сетей есть уже написанные библиотеки для работы с API, на языке Java в том числе. Поэтому не будем углубляться в работу какого-либо API или библиотеки. Всё, что нам нужно знать в данном примере — то, что наш бот умеет реагировать на сообщения, отправленные в чат, в котором, собственно, наш бот находится.

Т.е допустим, у нас есть класс <span>MessageListener</span> с функцией:

<pre class="lang-java line-numbers"><code>
public class MessageListener
{
    public void onMessageReceived(MessageReceivedEvent event)
    {
    }
}
</code></pre>
Она отвечает за обработку принятого сообщения. Всё что нам нужно от класса <span>MessageReceivedEvent</span> — строка полученного сообщения (например, "Привет" или "Бот, привет"). Стоит учесть: в разных библиотеках эти классы называются по-разному. Я использовал библиотеку для Discord.

И вот мы хотим сделать так, чтобы бот реагировал на какие-то команды, начинающиеся с "Бот" (с запятой или без — решайте сами: для урока предположим, что запятой там быть не должно).

То есть, уже наша функция будет начинаться с чего-то вроде:

<pre class="lang-java line-numbers"><code>
    public void onMessageReceived(MessageReceivedEvent event)
    {
        //Убираем чувствительность к регистру (БоТ, бОт и т.д.)
        String message = event.getMessage().toLowerCase(); 
        if (message.startsWith("бот"))
        {
           
        }
    }
</code></pre>
И вот теперь перед нами есть множество вариантов реализации той или иной команды. Бесспорно, для начала нужно отделить команду от её аргументов, т.е разбить на массив.

<pre class="lang-java line-numbers"><code>
    public void onMessageReceived(MessageReceivedEvent event)
    {
        //Убираем чувствительность к регистру (БоТ, бОт и т.д.)
        String message = event.getMessage().toLowerCase(); 
        if (message.startsWith("бот"))
        {
            try
            {
                //получим массив {"Бот", "(команду)", "аргумент1", "аргумент2",... "аргументN"};
                String[] args = message.split(" "); 
                //Для удобства уберем "бот" и отделим команду от аргументов 
                String command = args[1];
                String[] nArgs = Arrays.copyOfRange(args, 2, args.length);
                //Получили command = "(команда)"; nArgs = {"аргумент1", "аргумент2",..."аргументN"}; 
                //Данный массив может быть пустым
            }
            catch (ArrayIndexOutOfBoundsException e)
            {
                //Вывод списка команд или какого-либо сообщения
                //В случае если просто написать "Бот"
            }
        }
    }
</code></pre>
Данного куска кода нам никак не избежать, потому что отделение команды от аргументов нужно всегда. А вот дальше уже у нас есть выбор:
<ul>
<li>Сделать if(command.equalsIngnoreCase("..."))</li>
<li>Сделать switch(command)</li>
<li>Сделать ещё какой-то способ обработки...</li>
<li>Либо же прибегнуть к помощи Аннотаций.</li>
</ul>И вот мы наконец дошли до практической части использования Аннотаций.

Давайте рассмотрим код аннотации для нашей задачи (он может отличаться, конечно же).

<pre class="lang-java line-numbers"><code>
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

//Указывает, что наша Аннотация может быть использована
//Во время выполнения через Reflection (нам как раз это нужно).
@Retention(RetentionPolicy.RUNTIME)

//Указывает, что целью нашей Аннотации является метод 
//Не класс, не переменная, не поле, а именно метод.
@Target(ElementType.METHOD) 
public @interface Command //Описание. Заметим, что перед interface стоит @;
{
    //Команда за которую будет отвечать функция (например "привет");
    String name(); 

     //Аргументы команды, использоваться будут для вывода списка команд
    String args();

     //Минимальное количество аргументов, сразу присвоили 0 (логично)
    int minArgs() default 0;

    //Описание, тоже для списка
    String desc(); 

     //Максимальное число аргументов. В целом не обязательно, но тоже можно использовать
    int maxArgs() default Integer.MAX_VALUE;

     //Показывать ли команду в списке (вовсе необязательная строка, но мало ли, пригодится!)
    boolean showInHelp() default true;

    //Какие команды будут считаться эквивалентными нашей 
    //(Например для "привет", это может быть "Здаров", "Прив" и т.д.)
    //Под каждый случай заводить функцию - не рационально
    String[] aliases(); 

}
</code></pre>
<span>Важно!</span> Каждый параметр описывается как функция (с круглыми скобками). В качестве параметров могут быть использованы только примитивы, <span>String</span>, <span>Enum</span>. Нельзя написать <span>List&lt;String&gt; args();</span> — ошибка.

Теперь, когда мы описали Аннотацию, давайте заведем класс, назовем его <span>CommandListener</span>.

<pre class="lang-java line-numbers"><code>
    public class CommandListener
    {
        @Command(name = "привет",
                args = "",
                desc = "Будь культурным, поздоровайся",
                showInHelp = false,
                aliases = {"здаров"})
        public void hello(String[] args)
        {
            //Какой-то функционал, на Ваше усмотрение.
        }

        @Command(name = "пока",
                args = "",
                desc = "",
                aliases = {"удачи"})
        public void bye(String[] args)
        {
             // Функционал
        }

        @Command(name = "помощь",
                args = "",
                desc = "Выводит список команд",
                aliases = {"help", "команды"})
        public void help(String[] args)
        {
            StringBuilder sb = new StringBuilder("Список команд: \n");
            for (Method m : this.getClass().getDeclaredMethods())
            {
                if (m.isAnnotationPresent(Command.class))
                {
                    Command com = m.getAnnotation(Command.class);
                    if (com.showInHelp()) //Если нужно показывать команду в списке.
                    {
                        sb.append("Бот, ")
                           .append(com.name()).append(" ")
                           .append(com.args()).append(" - ")
                           .append(com.desc()).append("\n");
                    }
                }
            }
            //Отправка sb.toString();

        }
    }
</code></pre>
<em>Стоит отметить одно небольшое неудобство: т.к. мы сейчас боремся за универсальность, все функции должны иметь одинаковый список формальных параметров, поэтому даже если у команды нет аргументов, у функции должен быть параметр </em><span>String[] args</span><em>.</em>

Мы сейчас описали 3 команды: привет, пока, помощь.

Теперь давайте модифицируем наш <span>MessageListener</span> так, чтобы он как-то с этим работал. Для удобства и скорости работы, будем сразу хранить наши команды в <span>HashMap</span>:

<pre class="lang-java line-numbers"><code>
    public class MessageListner
    {
        //Map который хранит как ключ команду
        //А как значение функцию которая будет обрабатывать команду
        private static final Map&lt;String, Method&gt; COMMANDS = new HashMap&lt;&gt;(); 

        //Объект класса с командами (по сути нужен нам для рефлексии)
        private static final CommandListener LISTENER = new CommandListener();

        static
        {
           //Берем список всех методов в классе CommandListener
            for (Method m : LISTENER.getClass().getDeclaredMethods())
            {
                //Смотрим, есть ли у метода нужная нам Аннотация @Command
                if (m.isAnnotationPresent(Command.class)) 
                {
                    //Берем объект нашей Аннотации
                    Command cmd = m.getAnnotation(Command.class); 
                    //Кладем в качестве ключа нашей карты параметр name()
                    //Определенный у нашей аннотации,
                    //m — переменная, хранящая наш метод
                    COMMANDS.put(cmd.name(), m);

                    //Также заносим каждый элемент aliases
                   //Как ключ указывающий на тот же самый метод.
                    for (String s : cmd.aliases())  
                    {
                        COMMANDS.put(s, m);
                    }
                }
            }
        }

        public void onMessageReceived(MessageReceivedEvent event)
        {

            String message = event.getMessage().toLowerCase();
            if (message.startsWith("бот"))
            {
                try
                {
                    String[] args = message.split(" ");
                    String command = args[1];
                    String[] nArgs = Arrays.copyOfRange(args, 2, args.length);
                    Method m = COMMANDS.get(command);
                    if (m == null)
                    {
                        //(вывод помощи)
                        return;
                    }
                    Command com = m.getAnnotation(Command.class);
                    if (nArgs.length &lt; com.minArgs())
                    {
                        //что-то если аргументов меньше чем нужно
                    }
                    else if (nArgs.length &gt; com.maxArgs())
                    {
                        //что-то если аргументов больше чем нужно
                    }
                    //Через рефлексию вызываем нашу функцию-обработчик 
                    //Именно потому что мы всегда передаем nArgs у функции должен быть параметр
                    //String[] args — иначе она просто не будет найдена;  
                    m.invoke(LISTENER, nArgs);
                }
                catch (ArrayIndexOutOfBoundsException e)
                {
                    //Вывод списка команд или какого-либо сообщения
                    //В случае если просто написать "Бот"
                }
            }
        }
    }
</code></pre>
Вот собственно и всё, что нужно, чтобы наши команды работали. Теперь добавление новой команды — это не новый if, не новый case, в которых нужно было бы заново переучесть количество аргументов, также пришлось бы переписывать help, добавляя в него новые строки. Теперь же, чтобы добавить команду, нам нужно просто в классе CommandListener добавить новую функцию с аннотацией @Command и всё — команда добавлена, случаи учтены, help дополнен автоматически.

Абсолютно бесспорно, что данную задачу можно решить множеством других путей. Да, всё что можно сделать при помощи аннотаций/рефлексий можно сделать и без них, вопрос лишь в удобстве, оптимальности и размерах кода, конечно же, совать Аннотацию везде где есть малейший намек на то, что получится её использовать - тоже не самый рациональный вариант, во всем нужно знать меру =). Но при написании API, Библиотек или программ, в которых возможно повторение однотипного (но не совсем одинакового) кода, аннотации - бесспорно оптимальное решение.
