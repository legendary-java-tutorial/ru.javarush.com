Зачем нужно наследование интерфейсов?
<p>----------------------------------------</p>
Для тех, кто почитал и понял, как делать наследование интерфейсов, но не понял, зачем.
<p>----------------------------------------</p>
<span><a href="https://javarush.com/groups/posts/3665-zachem-nuzhnih-interfeysih" target="_blank" rel="nofollow">Зачем нужны интерфейсы?</a>
Зачем нужно наследование интерфейсов?
<a href="https://javarush.com/groups/posts/3663-zachem-nuzhen-polimorfizm" target="_blank" rel="nofollow">Зачем нужен полиморфизм?</a></span>

Для тех, кто почитал и понял, как делать наследование интерфейсов, но не понял, зачем.

В прошлый раз, на примере обычной семьи Ивановых мы разобрали, зачем нужны интерфейсы. 

Продолжаем оцифровывать беспокойное семейство.

У каждого человека есть какие-то привычки, которые он ни от кого не наследовал или никому не передавал по наследству - его личные привычки. 
У нас задача: наделить каждого члена семьи уникальными привычками. Переводим в плоскость Java: надо реализовать в классах уникальные методы, которые будут принадлежать только этим классам. 

Что же, вперед!

Это Петя:

<pre class="language-java line-numbers"><code>
class Петя implements ПривычкиПапы, ПривычкиМамы {

//это личные Петины привычки
public void ковырятьВНосу () {
System.out.println("Ковырь-ковырь");
    }

//это унаследованные привычки
@Override
public void прихлюпывать() {
     System.out.println("Хлюп");
   }

@Override
public void поджимать () {
System.out.println("Поджать губки");
    }
}
</code></pre>
Это Папа:

<pre class="language-java line-numbers"><code>
class Папа implements ПривычкиПапы {

//это личные Папины привычки
public void чесатьБороду () {
System.out.println("Чешу бороду");
    }

//это переданные привычки
   @Override
    public void прихлюпывать() {
     System.out.println("Хлюп");
   }
}
</code></pre>
Это Мама:

<pre class="language-java line-numbers"><code>
class Мама implements ПривычкиМамы{

//это личные Мамины привычки
public void хлопатьРесницами () {
System.out.println("Хлоп-хлоп");
    }

//это переданные привычки
@Override
public void поджимать() {
System.out.println("Поджать губки");
    }
}
</code></pre>
Идеально! Все работает как надо! 

В первой статье, говорилось, что программа — это отражение реального мира. Самое интересное свойство реальности – это все время меняться. Семья Ивановых не стала исключением, у них появилась лапочка-дочка по имени Маша. И она унаследовала от Мамы привычку хлопать ресницами, а от Папы прихлюпывать. Надо вносить изменения в нашу программу.

<img data-id="d8ae54bd-9a85-4d9c-88e4-7def87314079" src="https://cdn.javarush.com/images/article/d8ae54bd-9a85-4d9c-88e4-7def87314079/512.jpeg" alt="Зачем нужно наследование интерфейсов? - 1">Да ладно, это не так и сложно, главное мыслить логически. Ведь все знают зачем нужны интерфейсы. Сейчас создадим <em>interface ПривычкиМаши</em>, опишем там метод <em>хлопатьРесницами()</em> и <em>прихлюпывать()</em> имплементируем его к <em>Маше</em> и дело в шляпе. Ну и что, что методы с таким названием уже реализованы в других интерфейсах, один раз можно.
<img data-id="3a696d87-1904-4fb2-861a-7739c9cccae3" src="https://cdn.javarush.com/images/article/3a696d87-1904-4fb2-861a-7739c9cccae3/512.jpeg" alt="Зачем нужно наследование интерфейсов? - 2">Действительно, кто знает какие планы у семейства Ивановых, если родиться <em>Сережа</em>, который унаследует привычки от <em>Папы, Мамы, ПраДедушки</em> и еще кого-то из четвертого колена, каждый раз создавать интерфейс, типа: <em>interface ПривычкиСережи</em>, и там объявлять методы, которые уже могут быть объявлены сотни раз в других интерфейсах? 

Через пару, тройку поколений мы рискуем получить интерфейсы с кучей одинаковых методов, которые уже описаны в других интерфейсах, и если надо будет изменить наименование какой-нибудь привычки (а это вполне реально – ведь мир меняется), то как разобраться в этом спагетти, я не представляю.

Остается только сидеть и мечтать о чуде.
<img data-id="02058d4f-b29a-47f5-a0fb-921fa94cece3" src="https://cdn.javarush.com/images/article/02058d4f-b29a-47f5-a0fb-921fa94cece3/512.jpeg" alt="Зачем нужно наследование интерфейсов? - 3">Вот если бы для каждой привычки был свой интерфейс. 

Двайте представим:

<pre class="language-java line-numbers"><code>
public interface ПривычкаПрихлюпывать {
    public void прихлюпывать();
}
public interface ПривычкаПоджимать {
    public void поджимать();
}
public interface ПривычкаКовырятьВНосу {
    public void ковырятьВНосу();
}
public interface ПривычкаХлопатьРесницами {
    public void хлопатьРесницами();
}
public interface ПривычкаЧесатьБороду {
    public void чесатьБороду();
}
</code></pre>
А потом, можно было бы как в лего, с помощью множественного наследования из отдельных привычек набрать нужный нам интерфейс привычек отдельного члена семейства. Как-то так:

<pre class="language-java line-numbers"><code>
public interface ПривычкиМамы extends ПривычкаПоджимать, ПривычкаХлопатьРесницами {
    }
public interface ПривычкиПапы extends ПривычкаЧесатьБороду, ПривычкаХлюпать {
    }
public interface ПривычкиПети extends ПривычкаПоджимать, ПривычкаХлюпать,ПривычкаКовырятьВНосу {
    }
public interface ПривычкиМаши extends ПривычкаХлюпать, ПривычкаХлопатьРесницами {
    }
</code></pre>
А потом просто имплементировать нужный интерфейс нужному классу, например, Маме:

<pre class="language-java line-numbers"><code>
class Мама implements ПривычкиМамы{
@Override
public void хлопатьРесницами () {
System.out.println("Хлоп-хлоп");
    }

@Override
public void поджимать() {
System.out.println("Поджать губки");
    }
}
</code></pre>
Так же можно было бы поступить с <em>Папой, Петей и Машей</em>. И потом, при расширении семейства Ивановых, проблем бы с привычками не было, мы просто бы их тасовали через наследование на уровне интерфейсов, как ингредиенты в салате, и не плодили кучу методов с одинаковым наименованием. Эх, мечты, мечты…
<img data-id="8ab45d5c-e0a4-43da-b2a4-13a7b7f428a5" src="https://cdn.javarush.com/images/article/8ab45d5c-e0a4-43da-b2a4-13a7b7f428a5/512.jpeg" alt="Зачем нужно наследование интерфейсов? - 4">Нарисованный человек прав, так на самом деле можно - теперь симуляция семейства Ивановых спасена! 

Внимательный читатель, может задать вопрос: "А зачем плодить интерфейсы для каждого члена семьи? У нас есть набор действий - сразу имплементировать нужному классу."
Представим что во многих параллельных мирах существуют двойники <em>Пети</em>, и всем <em>Петям</em> надо имплементировать <em>interface ПривычкиПети</em>
<pre class="language-java line-numbers"><code>
interface ПривычкиПети extends ПривычкаПоджимать, ПривычкаХлюпать,ПривычкаКовырятьВНосу 

class ПетяВселеннаяХ implements ПривычкиПети
class ПетяВселеннаяY implements ПривычкиПети
// и т.д.
</code></pre>

А если бы общего интерфейса не было 
<pre class="language-java line-numbers"><code>
class ПетяВселеннаяХ implements ПривычкаПоджимать, ПривычкаХлюпать,ПривычкаКовырятьВНосу
class ПетяВселеннаяY implements ПривычкаПоджимать, ПривычкаХлюпать,ПривычкаКовырятьВНосу
// и т.д.
</code></pre>
Получается более объемный повторяющийся код. 

Наследование интерфейсов делает приложение более гибким к изменениям, в частности — можно решить проблемы с повторяющимися методами. 
Еще раз обратите внимание, что множественное наследование интерфейсов — разрешено.