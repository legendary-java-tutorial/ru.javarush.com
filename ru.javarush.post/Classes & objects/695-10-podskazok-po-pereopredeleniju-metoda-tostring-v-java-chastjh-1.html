10 подсказок по переопределению метода toString() в Java (часть 1)
<p>----------------------------------------</p>
toString метод в Java используется для предоставления ясной и достаточной информации об объекте (Object) в удобном для человека виде. Правильное переопределение метода toString...
<p>----------------------------------------</p>
<strong>10 подсказок по переопределению метода toString() в Java - ToStringBuilder Netbeans Eclipse</strong>
<img data-id="436e7fd7-f4c0-4ea3-9bad-37f73315fd9f" data-max-width="850" alt="10 подсказок по переопределению метода toString() в Java (часть 1) - 1" src="https://cdn.javarush.com/images/article/436e7fd7-f4c0-4ea3-9bad-37f73315fd9f/1024.jpeg"><h2>Java toString метод</h2><code>toString</code> метод в Java используется для предоставления ясной и достаточной информации об объекте (<code>Object</code>) в удобном для человека виде. Правильное переопределение метода <code>toString</code> может помочь <a href="https://javarevisited.blogspot.com/2011/05/top-10-tips-on-logging-in-java.html" rel="nofollow" target="_blank">в ведении журнала работы</a> и в <a href="https://javarevisited.blogspot.com/2011/07/java-debugging-tutorial-example-tips.html" rel="nofollow" target="_blank">отладке</a> Java программы предоставляя ценную и важную информацию. Поскольку <code>toString()</code> определен в <code>java.lang.Object</code> класса и его реализация по умолчанию не предоставляет много информации, всегда лучшей практикой является переопределение данного метода в классе-потомке.

Фактически, если вы создаете важный или общий класс типа <code>Order</code>, <code>Trade</code> или <code>Employee</code>, всегда переопределяйте <a href="https://javarevisited.blogspot.com/2011/02/how-to-write-equals-method-in-java.html" rel="nofollow" target="_blank">equals</a>, <a href="https://javarevisited.blogspot.com/2011/02/how-to-write-equals-method-in-java.html" rel="nofollow" target="_blank">hashCode</a>, <a href="https://javarevisited.blogspot.com/2011/11/how-to-override-compareto-method-in.html" rel="nofollow" target="_blank">compareTo</a> и <code>toString</code> методы в Java. По умолчанию реализация <code>toString</code> создает вывод в виде <code>package.class@hashCode</code>, к примеру для нашего примера <code>toString()</code>, <code>toString()</code> метод класса <code>Country</code> напечатает test.Country@18e2b22 где 18e2b22 это хэш-код объекта в шестнадцатеричном виде, если вы вызовете <a href="https://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html" rel="nofollow" target="_blank">hashCode</a> метод то он вернет 260943370, что является <a href="https://javarevisited.blogspot.com/2011/10/convert-decimal-binary-octal-java.html" rel="nofollow" target="_blank">десятеричным</a> эквивалентом 18e2b22. Эта информация не особо полезна во время поиска какой-либо проблемы. Давайте посмотрим на пример из реальной жизни где вам нужно найти проблему в соединении с сетью, в том случае если вы хотите знать с каким именно хостом и портом пытается соединиться ваша система и если <code>Socket</code> или <code>ServerSocket</code> печатает только информацию <code>toString</code> по умолчанию, то будет невозможно представить реальную проблему, но с переопределенной реализацией <code>toString</code> они могут предоставить полезную информацию, такую как имя хоста и номер порта. В этой Java-консультации мы дадим несколько подсказок по переопределению метода <code>toString</code> с примерами кода.
<h2>Как переопределить метод toString в Java:</h2>Печать форматированной даты(т.е. день/месяц/год) вместо "сырого" значения.

Это очень полезная подсказка при переопределении Java-метода <code>toString</code>. Обычный <code>toString()</code> класса <code>java.util.Date</code> не выводит форматированную дату и включает много деталей, которые не всегда нужны. Если вы используете частичный <a href="https://javarevisited.blogspot.com/2011/09/convert-date-to-string-simpledateformat.html" rel="nofollow" target="_blank">DateFormat</a> т.е. dd-MM-yy в вашем приложении, то вы определенно хотели бы видеть этот формат вместо данного по умолчанию. IDE обычно не генерирует форматированный вывод <code>Date</code> и это то, что вам нужно сделать самому, но это того стоит. Прочитайте <a href="https://javarevisited.blogspot.com/2011/09/convert-date-to-string-simpledateformat.html" rel="nofollow" target="_blank">Как распечатать Date в формате ddMMyy в Java</a> где детально описано форматирование <code>Date</code> в Java. Вы так же можете использовать <a href="https://javarevisited.blogspot.com/2012/03/simpledateformat-in-java-is-not-thread.html" rel="nofollow" target="_blank">SimpleDataFormat</a> класс или библиотеку Joda Date time для этого.
<h2>Документирование формата toString</h2>Если ваш метод <code>toString()</code> не выводит данные в виде поле=значение, то хорошей идеей будет документирование формата вывода <code>toString</code>, особенно для важных объектов типа Работник или Студент. К примеру если метод <code>toString()</code> класса <code>Работник(Employee)</code> печатает "<em>John-101-Sales-9846387321</em>" то хорошей практикой будет указать формат как "имя-ID-отдел-контакт", но в то же время не давайте клиенту возможность получать информацию из метода <code>toString()</code>, вы должны всегда предоставлять соответствующие методы для получения данных, такие как <code>getName()</code>, <code>getId()</code>, <code>getContact()</code> и так далее, поскольку информация полученная из <code>toString()</code> представления объекта является хрупкой и подвержена ошибкам, так что клиент всегда должен иметь чистый путь получения информации.
<h2>Используйте StringBuilder для составления вывода toString()</h2>Если вы пишете код для метода <code>toString()</code> в Java, тогда используйте <a href="https://javarevisited.blogspot.com/2011/07/string-vs-stringbuffer-vs-stringbuilder.html" rel="nofollow" target="_blank">StringBuilder</a> что бы добавить отдельные атрибуты. Если вы используете IDE вроде <a href="https://javarevisited.blogspot.com/2011/02/how-to-setup-remote-debugging-in.html" rel="nofollow" target="_blank">Eclipse</a>, Netbeans или IntelliJ тогда использование <code>StringBuilder</code> и метода <code>append()</code> вместо оператора + для составления <code>toString</code>, так же является верным путем. По умолчанию и Eclipse и Netbeans генерируют <code>toString</code> с оператором конкатенации.
<h2>Использование аннотации @Override</h2>Использование <code>@Override</code> при переопределении метода в Java это одна из лучших практик в языке. Но эта подсказка не так важна, как это было бы в случае с переопределением методов <code>equals()</code> и <code>compareTo()</code>, поскольку перегрузка вместо переопределения может создать более тонкие, сложно вычисляемые, ошибки. В любом случае лучше использовать аннотацию <code>@Overrride</code>.
<h2>Печать содержимого массива, вместо вывода объекта массива</h2>Массив это объект в Java но он не переопределяет метод <code>toString</code> и когда вы печатаете массив, то по умолчанию формат вывода не особо полезен, поскольку мы хотели бы видеть содержимое массива. К слову это еще одна причина <a href="https://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html" rel="nofollow" target="_blank">почему char[] array предпочтительнее String</a> для хранения чувствительных данных, таких как пароль. Найдите время взглянуть помогает ли печать содержимого массива вашим клиентам или нет и если это имеет смысл, то печатайте содержимое массива вместо самого объекта. Из соображений производительности предпочтительнее использовать <code>Collection</code> такие как <code>ArrayList</code> или <a href="https://javarevisited.blogspot.com/2012/06/hashset-in-java-10-examples-programs.html" rel="nofollow" target="_blank">HashSet</a> вместо <code>Array</code> для хранения других объектов.
<h2>Бонусные подсказки</h2>Еще несколько бонусных подсказок по переопределению метода <code>toString</code> в Java.
<ol>
<li><p>Печатать вывод <code>toString</code> в несколько строк или в одну основываясь на его длине.</p></li>
<li><p>Включать полные имена классов в представление <code>toString</code>, другими словами <code>package.class</code> что бы избежать любого непонимания.</p></li>
<li><p>Вы можете пропускать значения null или показывать их, но лучше показывать. Иногда они полезны, поскольку показывают какое поле является <code>null</code> во время какого-то инциндента, к примеру <a href="https://javarevisited.blogspot.com/2012/06/common-cause-of-javalangnullpointerexce.html" rel="nofollow" target="_blank">NullPointerException</a>.</p></li>
<li><p>Используйте формат ключ-значение,  к примеру <code>member.name=member.value</code>, большинство IDE поддерживают это.</p></li>
<li><p>Включайте унаследованных членов, если вы считаете, что они должны предоставлять необходимую информацию в класс-наследник.</p></li>
<li><p>Иногда объект содержит много необязательных и обязательных параметров, как мы показали в нашем примере <a href="https://javarevisited.blogspot.com/2012/06/builder-design-pattern-in-java-example.html" rel="nofollow" target="_blank">шаблона Builder</a>, когда практически невозможно распечатать все поля, в этом случае можно выводить только обязательные поля, тем более, что у нас есть необязательные.</p></li>
</ol>