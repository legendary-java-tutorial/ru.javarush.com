Контракты equals и hashCode или как оно всё там
<p>----------------------------------------</p>
Преобладающее большинство программирующих на Java конечно же знают, что методы equals и hashCode тесно связаны друг с другом, и что оба этих метода желательно переопределять в своих классах согласованно. Чуть меньшее количество знают, почему это так и какие печальные ...
<p>----------------------------------------</p>
Преобладающее большинство программирующих на Java конечно же знают, что методы <code>equals</code> и <code>hashCode</code> тесно связаны друг с другом, и что оба этих метода желательно переопределять в своих классах согласованно. Чуть меньшее количество знают, почему это так и какие печальные последствия могут быть, если нарушить данное правило. Предлагаю рассмотреть концепцию этих методов, повторить их назначение и разобраться, почему они так связаны.

Эту статью, как и предыдущую про загрузку классов, я писал для себя, чтобы окончательно раскрыть все детали вопроса и больше не возвращаться к сторонним источникам. Поэтому буду рад конструктивной критике, т. к. если где-то есть пробелы, их следует устранить. Статья, увы, получилась достаточно объемная.
<h2>Правила переопределения equals</h2>Метод <code>equals()</code> необходим в Java для подтверждения или отрицания того факта, что два объекта одного происхождения являются <em>логически равными</em>. То есть, сравнивая два объекта, программисту необходимо понять, эквивалентны ли их <em>значимые поля</em>. Не обязательно все поля должны быть идентичны, так как метод <code>equals()</code> подразумевает именно <em>логическое равенство</em>.

Но иногда нет особой необходимости в использовании этого метода. Как говорится, самый легкий путь избежать проблем, используя тот или иной механизм — не использовать его. Также следует заметить, что однажды нарушив контракт <code>equals</code> вы теряете контроль над пониманием того, как другие объекты и структуры будут взаимодействовать с вашим объектом. И впоследствии найти причину ошибки будет весьма затруднительно.
<h3>Когда не стоит переопределять этот метод</h3><ul>
<li><strong>Когда каждый экземпляр класса является уникальным.</strong></li>
В большей степени это касается тех классов, которые предоставляют определенное поведение, нежели предназначены для работы с данными. Таких, например, как класс <code>Thread</code>. Для них реализации метода <code>equals</code>, предоставляемого классом <code>Object</code>, более чем достаточно. Другой пример — классы перечислений (<code>Enum</code>).
<li><strong>Когда на самом деле от класса не требуется определять эквивалентность его экземпляров.</strong></li>
Например для класса <code>java.util.Random</code> вообще нет необходимости сравнивать между собой экземпляры класса, определяя, могут ли они вернуть одинаковую последовательность случайных чисел. Просто потому, что природа этого класса даже не подразумевает такое поведение.
<li><strong>Когда класс, который вы расширяете, уже имеет свою реализацию метода <code>equals</code> и поведение этой реализации вас устраивает.</strong></li>
Например, для классов <code>Set</code>, <code>List</code>, <code>Map</code> реализация <code>equals</code> находится в <code>AbstractSet</code>, <code>AbstractList</code> и <code>AbstractMap</code> соответственно.
<li><strong>И, наконец, нет необходимости перекрывать <code>equals</code>, когда область видимости вашего класса является <code>private</code> или <code>package-private</code> и вы уверены, что этот метод никогда не будет вызван.</strong></li>
</ul><h3>Контракт equals</h3>При переопределении метода <code>equals</code> разработчик должен придерживаться основных правил, определенных в спецификации языка Java.
<ul>
<li><strong>Рефлексивность</strong></li>
для любого заданного значения <code>x</code>, выражение <code>x.equals(x)</code> должно возвращать <code>true</code>.<br>
<em>Заданного</em> — имеется в виду такого, что <code>x != null</code>
<li><strong>Симметричность</strong></li>
для любых заданных значений <code>x</code> и <code>y</code>, <code>x.equals(y)</code> должно возвращать <code>true</code> только в том случае, когда <code>y.equals(x)</code> возвращает <code>true</code>.
<li><strong>Транзитивность</strong></li>
для любых заданных значений <code>x</code>, <code>y</code> и <code>z</code>, если <code>x.equals(y)</code> возвращает <code>true</code> и <code>y.equals(z)</code> возвращает <code>true</code>, <code>x.equals(z)</code> должно вернуть значение <code>true</code>.
<li><strong>Согласованность</strong></li>
для любых заданных значений <code>x</code> и <code>y</code> повторный вызов <code>x.equals(y)</code> будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.
<li><strong>Сравнение null</strong></li>
для любого заданного значения <code>x</code> вызов <code>x.equals(null)</code> должен возвращать <code>false</code>.
</ul><h3>Нарушение контракта equals</h3>Многие классы, например классы из Java Collections Framework, зависят от реализации метода <code>equals()</code>, поэтому не стоит им пренебрегать, т.к. нарушение контракта этого метода может привести к нерациональной работе приложения и в таком случае найти причину будет достаточно трудно.

Согласно принципу <u><strong>рефлексивности</strong></u>, каждый объект должен быть эквивалентен самому себе. Если этот принцип будет нарушен, при добавлении объекта в коллекцию и при последующем поиске его с помощью метода <code>contains()</code> мы не сможем найти тот объект, который только что положили в коллекцию.

Условие <u><strong>симметричности</strong></u> гласит, что два любых объекта должны быть равны независимо от того, в каком порядке они будут сравниваться. Например, имея класс, содержащий всего одно поле строкового типа, будет неправильно сравнивать в методе <code>equals</code> данное поле со строкой. Т.к. в случае обратного сравнения  метод всегда вернет значение <code>false</code>.

<pre class="lang-java line-numbers"><code>
// Нарушение симметричности
public class SomeStringify {
    private String s;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o instanceof SomeStringify) {
            return s.equals(((SomeStringify) o).s);
        }
        // нарушение симметричности, классы разного происхождения
        if (o instanceof String) {
            return s.equals(o);
        }
        return false;
    }
}
</code></pre>
<pre class="lang-java line-numbers"><code>
//Правильное определение метода equals
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    return o instanceof SomeStringify &amp;&amp;
            ((SomeStringify) o).s.equals(s);
}
</code></pre>
Из условия <u><strong>транзитивности</strong></u> следует, что если любые два из трех объектов равны, то в таком случае должны быть равны все три. Этот принцип легко нарушить в том случае, когда необходимо расширить некий базовый класс, добавив к нему <em>значимый компонент</em>.

Например, к классу <code>Point</code> с координатами <code>x</code> и <code>y</code> необходимо добавить цвет точки, расширив его. Для этого потребуется объявить класс <code>ColorPoint</code> с соответствующим полем <code>color</code>. Таким образом, если в расширенном классе вызывать метод <code>equals</code> родителя, а в родительском будем считать, что сравниваются только координаты <code>x</code> и <code>y</code>, тогда две точки разного цвета, но с одинаковыми координатами будут считаться равными, что неправильно.

В таком случае, необходимо научить производный класс различать цвета. Для этого можно воспользоваться двумя способами. Но один будет нарушать правило <em>симметричности</em>, а второй — <em>транзитивности</em>.

<pre class="lang-java line-numbers"><code>
// Первый способ, нарушая симметричность
// Метод переопределен в классе ColorPoint
@Override
public boolean equals(Object o) {
    if (!(o instanceof ColorPoint)) return false;
    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;
}
</code></pre>
В этом случае вызов <code>point.equals(colorPoint)</code> вернет значение <code>true</code>, а сравнение <code>colorPoint.equals(point)</code> —<code>false</code>, т.к. ожидает объект “своего” класса. Таким образом и нарушается правило симметричности.

Второй способ подразумевает делать “слепую” проверку, в случае, когда нет данных о цвете точки, т. е. имеем класс <code>Point</code>. Или же проверять цвет, если информация о нем доступна, т. е. сравнивать объект класса <code>ColorPoint</code>.

<pre class="lang-java line-numbers"><code>
// Метод переопределен в классе ColorPoint
@Override
public boolean equals(Object o) {
    if (!(o instanceof Point)) return false;

    // Слепая проверка
    if (!(o instanceof ColorPoint))
        return super.equals(o);

    // Полная проверка, включая цвет точки
    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;
}
</code></pre>
Принцип <em>транзитивности</em> здесь нарушается следующим образом. Допустим, есть определение следующих объектов:

<pre class="lang-java line-numbers"><code>
ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
</code></pre>
Таким образом хоть и выполняется равенство <code>p1.equals(p2)</code> и <code>p2.equals(p3)</code>, <code>p1.equals(p3)</code> вернет значение <code>false</code>. При этом второй способ, на мой взгляд, выглядит менее привлекательным, т.к. в некоторых случаях алгоритм может ослепнуть и не выполнить сравнение в полной мере, а вы об этом можете и не узнать.

<em>Немного лирики</em>

В общем-то конкретного решения этой проблемы, как я понял, нет. Есть мнение одного авторитетного автора по имени Кей Хорстманн, что можно заменить использование оператора <code>instanceof</code> на вызов метода <code>getClass()</code>, который возвращает  класс объекта и, прежде чем начать сравнивать сами объекты, убедиться, что они одного типа, а на факт их общего происхождения не обращать внимания. Таким образом, правила <em>симметричности</em> и <em>транзитивности</em> будут выполнены.

Но при этом на другой стороне баррикады стоит еще один не менее уважаемый в широких кругах автор Джошуа Блох, который считает, что такой подход нарушает принцип подстановки Барбары Лисков. Этот принцип гласит, что <em>“вызывающий код должен работать с базовым классом точно так же, как и с его подклассами, не зная об этом”</em>. И в решении, предлагаемом Хорстманном, этот принцип явно нарушается, т. к. зависит от реализации.

Короче дело ясное, что дело темное. Следует также отметить, что Хорстманн уточняет правило применения своего подхода и английским по белому пишет, что нужно определиться со стратегией при проектировании классов, и если проверка на равенство будет проводиться только силами суперкласса, можно это делать, выполняя операцию <code>instanceof</code>. Иначе, когда семантика проверки меняется в зависимости от производного класса и реализацию метода требуется спустить вниз по иерархии, необходимо использовать метод <code>getClass()</code>.

Джошуа Блох, в свою очередь, предлагает отказаться от наследования и воспользоваться композицией объектов, включив в состав класса <code>ColorPoint</code> класс <code>Point</code> и предоставив метод доступа <code>asPoint()</code> для получения информации конкретно о точке. Это позволит избежать нарушения всех правил, но, как по мне, затруднит понимание кода.

Третий вариант — воспользоваться автоматической генерацией метода equals с помощью IDE. Idea, кстати, воспроизводит генерацию по Хорстманну, причем позволяя выбрать стратегию реализации метода в суперклассе или в его наследниках.

И, наконец, следующее правило <u><strong>согласованности</strong></u> гласит, что если объекты <code>x</code> и <code>y</code> не меняются,  повторный вызов <code>x.equals(y)</code> должен вернуть то же значение, что и ранее. 

Последнее правило заключается в том, что ни один объект не должен быть равен <code>null</code>. Здесь все понятно, <code>null</code> — это неопределенность, равен ли объект неопределенности? Непонятно, т. е. <code>false</code>.
<h3>Общий алгоритм определения equals</h3><ol>
<li>Проверить на равенство ссылки объектов <code>this</code> и параметра метода <code>o</code>.<br>
<code>if (this == o) return true;</code></li>
<li>Проверить, определена ли ссылка <code>o</code>, т. е. является ли она <code>null</code>.<br>
Если в дальнейшем при сравнении типов объектов будет использоваться оператор <code>instanceof</code>, этот пункт можно пропустить, т. к. этот параметр возвращает <code>false</code> в данном случае <code>null instanceof Object</code>.</li>
<li>Сравнить типы объектов <code>this</code> и <code>o</code> с помощью оператора <code>instanceof</code> или метода <code>getClass()</code>, руководствуясь описанием выше и собственным чутьем.</li>
<li>Если метод <code>equals</code> переопределяется в подклассе, не забудьте сделать вызов <code>super.equals(o)</code></li>
<li>Выполнить преобразование типа параметра <code>o</code> к требуемому классу.</li>
<li>Выполнить сравнение всех значимых полей объектов:
<ul>
<li>для примитивных типов (кроме <code>float</code> и <code>double</code>), используя оператор <code>==</code></li>
<li>для ссылочных полей необходимо вызвать их метод <code>equals</code></li>
<li>для массивов можно воспользоваться перебором по циклу, либо методом <code>Arrays.equals()</code></li>
<li>для типов <code>float</code> и <code>double</code> необходимо использовать методы сравнения соответствующих оберточных классов <code>Float.compare()</code> и <code>Double.compare()</code></li>
</ul>
</li>
<li>И, наконец, ответить на три вопроса: является ли реализованный метод <u>симметричным</u>? <u>Транзитивным</u>? <u>Согласованным</u>? Два других принципа (<u>рефлексивность</u> и <u>определенность</u>), как правило, выполняются автоматически.</li></ol><h3>Правила переопределения hashCode</h3>Хэш — это некоторое число, генерируемое на основе объекта и описывающее его состояние в какой-то момент времени. Это число используется в Java преимущественно в хэш-таблицах, таких как <code>HashMap</code>. При этом хэш-функция получения числа на основе объекта должна быть реализована таким образом, чтобы обеспечить относительно равномерное распределение элементов по хэш-таблице. А также минимизировать вероятность появления коллизий, когда по разным ключам функция вернет одинаковое значение.
<h3>Контракт hashCode</h3>Для реализации хэш-функции в спецификации языка определены следующие правила:
<ul>
<li>вызов метода <code>hashCode</code> один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.</li>
<li>вызов метода <code>hashCode</code> над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода <code>equals</code> для этих объектов возвращает <code>true</code>).</li>
<li>вызов метода <code>hashCode</code> над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.</li>
</ul><h3>Методы equals и hashCode необходимо переопределять вместе</h3>Исходя из описанных выше контрактов следует, что переопределяя в своем коде метод <code>equals</code>, необходимо всегда переопределять и метод <code>hashCode</code>. Так как фактически два экземпляра класса отличаются, потому что находятся в разных областях памяти, сравнивать их приходится по некоторым логическим признакам. Соответственно, два логически эквивалентных объекта, должны возвращать одинаковое значение хэш-функции.

<u><strong>Что произойдет, если будет переопределен только один из этих методов?</strong></u>
<ol>
<li><p><code>equals</code> есть, <code>hashCode</code> нет</p>
<p>Допустим мы правильно определили метод <code>equals</code> в нашем классе, а метод <code>hashCode</code> решили оставить как он есть в классе <code>Object</code>. Тогда с точки зрения метода <code>equals</code> два объекта будут логически равны, в то время как с точки зрения метода <code>hashCode</code> они не будут иметь ничего общего. И, таким образом, помещая некий объект в хэш-таблицу, мы рискуем не получить его обратно по ключу.<br />
Например, так:</p>
<pre class="lang-java line-numbers"><code>
Map&lt;Point, String&gt; m = new HashMap&lt;&gt;();
m.put(new Point(1, 1), “Point A”);
// pointName == null
String pointName = m.get(new Point(1, 1));
</code></pre>
<p>Очевидно, что помещаемый и искомый объект — это два разных объекта, хотя они и являются логически равными. Но, т.к. они имеют разное хэш-значение, потому что мы нарушили контракт, можно сказать, что мы потеряли свой объект где-то в недрах хэш-таблицы.<p></li>
<li><p><code>hashCode</code> есть, <code>equals</code> нет.</p>
<p>Что будет если мы переопределим метод <code>hashCode</code>, а реализацию метода <code>equals</code> унаследуем из класса <code>Object</code>. Как известно метод <code>equals</code> по умолчанию просто сравнивает указатели на объекты, определяя, ссылаются ли они на один и тот же объект. Предположим, что метод <code>hashCode</code> мы написали по всем канонам, а именно — сгенерировали средствами IDE, и он будет возвращать одинаковые хэш-значения для логически одинаковых объектов. Очевидно, что тем самым мы уже определили некоторый механизм сравнения двух объектов.<br>
<p>Следовательно, пример из предыдущего пункта по идее должен выполняться. Но мы по-прежнему не сможем найти наш объект в хэш-таблице. Хотя будем уже близки к этому, потому что как минимум найдем корзину хэш-таблицы, в которой объект будет лежать.<br>
<p>Для успешного поиска объекта в хэш-таблице помимо сравнения хэш-значений ключа используется также определение логического равенства ключа с искомым объектом. Т. е. без переопределения метода <code>equals</code> никак не получится обойтись.</li></ol><h2>Общий алгоритм определения hashCode</h2>Здесь, мне кажется, вообще не стоит сильно переживать и выполнить генерацию метода в своей любимой IDE. Потому что все эти смещения битов вправо, влево в поиске золотого сечения, т. е. нормального распределения — это для совсем упоротых чуваков. Лично я сомневаюсь, что смогу сделать лучше и быстрее, чем та же Idea.
<h2>Вместо заключения</h2>Таким образом, мы видим, что методы <code>equals</code> и <code>hashCode</code> играют четко определенную роль в языке Java и предназначены для получения характеристики логического равенства двух объектов. В случае с методом <code>equals</code> это имеет прямое отношение к сравнению объектов, в случае с <code>hashCode</code> косвенное, когда необходимо, скажем так, определить примерное расположение объекта в хэш-таблицах или подобных структурах данных с целью увеличения скорости поиска объекта.

Помимо контрактов <code>equals</code> и <code>hashCode</code> имеется еще одно требование, относящееся к сравнению объектов. Это согласованность метода <code>compareTo</code> интерфейса <code>Comparable</code> с методом <code>equals</code>. Данное требование обязывает разработчика всегда возвращать <code>x.equals(y) == true</code>, когда <code>x.compareTo(y) == 0</code>. Т. е. мы видим, что логическое сравнение двух объектов не должно противоречить нигде в приложении и всегда быть согласованным.
<h2>Источники</h2><a href="https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683" target="_blank" rel="nofollow">Effective Java, Second Edition. Joshua Bloch.</a>
Свободный перевод очень неплохой книги.
<a href="https://www.ozon.ru/context/detail/id/137377512/" target="_blank" rel="nofollow">Java, библиотека профессионала. Том 1. Основы. Кей Хорстманн.</a>
Чуть менее теории и более практики. Но не так подробно разобрано все, как у Блоха. Хотя есть свой взгляд на тот же equals().
<a href="https://habr.com/post/128017" target="_blank" rel="nofollow">Структуры данных в картинках. HashMap</a>
Крайне полезная статья по устройству HashMap в Java. Вместо того, чтобы исходники смотреть.
