Руководство по классу Java Integer
<p>----------------------------------------</p>
В данной статье мы поговорим о классе Integer. Рассмотрим такие вопросы: что такое классы обертки; автоупаковка/распаковка примитивов; работа класса Integer, егоa методы и константы. Как известно, в Java есть различные типы данных, которые условно можно разделить на два блока...
<p>----------------------------------------</p>
В данной статье мы поговорим о классе Integer. Рассмотрим такие вопросы:
<ul>
<li>что такое классы-обертки;</li>
<li>автоупаковка/распаковка примитивов;</li>
<li>работа класса Integer, его методы и константы.</li>
</ul><img data-max-width="800" data-id="b0959a24-d691-4253-ae24-b181f7d5a403" src="/images/article/b0959a24-d691-4253-ae24-b181f7d5a403/800.jpeg" class="img-fluid" alt="Руководство по классу Java Integer - 1"><h2>Классы-обертки примитивных типов</h2>Как известно, в Java есть различные типы данных, которые условно можно разделить на два блока:
<ul>
<li>примитивные; </li>
<li>ссылочные.</li>
</ul>Примитивных типов данных в Java несколько:
<ul>
<li>целые числа — byte, short, int, long;</li>
<li>числа с плавающей точкой (вещественные) — float, double;</li>
<li>логический тип данных — boolean;</li>
<li>символьный тип данных — char.</li>
</ul>У каждого примитивного типа данных есть свой класс-обертка. Ссылочный тип данных, который “оборачивает” своего примитивного младшего брата в Java-объект. Ниже приведены примитивные типы данных и соответствующие им классы обертки:
<table>
<tbody><tr>
<th>Примитивный тип</th>
<th>Класс обертка</th>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr><td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>В практическом смысле у примитивов и их классов-оберток много общего. Большинство операций выполняются идентично. Однако у классов-оберток есть ряд характеристик, не свойственных примитивам. 

Во-первых, это классы: при работе с классам- обертками мы работаем с объектами. 
Во-вторых (все последующее вытекает из пункта во-первых), данные объекты могут быть null.
В-третьих классы-обертки предоставляют ряд констант и методов, упрощающих работу с определенным типом данных. 

В данной статье мы подробнее рассмотрим работу с классом Integer.
<h2><s>The</s> Integer</h2>Класс Integer — это класс-обертка примитивного типа int. Внутри данного класса содержится единственное поле типа int. 

Будучи классом оберткой, Integer предоставляет различные методы для работы с int, а также ряд методов для преобразования int в String и String в int.

Ниже мы рассмотрим различные примеры работы с классом. Начнем с создания. Чаще всего используется (да и проще всего использовать) следующий вариант создания: 

<pre class="lang-java line-numbers"><code>
Integer a = 3; 
</code></pre>
То есть инициализация Integer переменной в данном случае аналогична инициализации int переменной. Более того, Integer переменную можно проинициализировать значением int переменной: 

<pre class="lang-java line-numbers"><code>
int i = 5; 
Integer x = i;
System.out.println(x); // 5
</code></pre>
В кейсе выше неявно происходит автоупаковка. Мы поговорим еще о ней ниже. 

Помимо вариантов инициализации, указанных выше, переменную Integer можно создать, как и прочие объекты, с использованием конструктора и ключевого слова new: 

<pre class="lang-java line-numbers"><code>
Integer x = new Integer(25);
System.out.println(x);
</code></pre>
Однако так дольше писать и дольше читать, поэтому данный вариант наименее распространен. 

С Integer переменными можно делать все то, что и с int переменными. Их можно:
<table>
<tbody><tr>
<td>Складывать</td>
<td><pre><code>
Integer a = 6;
Integer b = 2;
Integer c = a + b;
System.out.println(c); // 8
</code></pre></td>
</tr>
<tr>
<td>Вычитать</td>
<td><pre><code>
Integer a = 6;
Integer b = 2;
Integer c = a - b;
System.out.println(c); // 4
</code></pre></td>
</tr>
<tr>
<td>Умножать</td>
<td><pre><code>
Integer a = 6;
Integer b = 2;
Integer c = a * b;
System.out.println(c); // 12
</code></pre></td>
</tr>
<tr>
<td>Делить</td>
<td><pre><code>
Integer a = 6;
Integer b = 2;
Integer c = a / b;
System.out.println(c); // 3
</code></pre></td>
</tr>
<tr>
<td>Инкрементировать</td>
<td><pre><code>
Integer a = 6;
a++;
++a;
System.out.println(a); // 8
</code></pre></td>
</tr>
<tr>
<td>Декрементировать</td>
<td><pre><code>
Integer a = 6;
a--;
--a;
System.out.println(a); // 4
</code></pre></td>
</tr>
</tbody></table>Однако при всем этом нужно быть осторожным и помнить, что Integer — это ссылочный тип данных, и переменная данного типа может быть null. В таком случае (если переменная равна null) лучше воздержаться от арифметических операций (да и любых других, в которых null ничего хорошего не сулит). Приведем пример: 

<pre class="lang-java line-numbers"><code>
Integer a = null;
Integer b = a + 1; // Здесь мы упадем с "Exception in thread "main" java.lang.NullPointerException"
System.out.println(b);
</code></pre>
Операции сравнения в основной массе проводятся также, как и в примитивном типе int:

<pre class="lang-java line-numbers"><code>
Integer a = 1;
Integer b = 2;

System.out.println(a &gt; b);
System.out.println(a &gt;= b);
System.out.println(a &lt; b);
System.out.println(a &lt;= b);
</code></pre>
Output:

<pre><code>
false
false
true
true
</code></pre>
Особняком стоит операция сравнения двух Integer переменных. И дело тут в том, что Integer — это ссылочный тип данных, и его переменные хранят ссылки на значения, а не сами значения (объекты). Проявления этого факта можно наблюдать при выполнении следующего фрагмента кода: 

<pre class="lang-java line-numbers"><code>
Integer a = 1;
Integer b = 1;
Integer c = new Integer(1);

System.out.println(a == b); // true
System.out.println(a == c); // false
</code></pre>
Результат первого равенства будет true, а второго — false. Так происходит, потому что в первом случае мы сравниваем две переменные (“а” и “b”), которые хранят в себе ссылки на один и тот же объект. А во втором случае мы сравниваем две переменные, ссылающиеся на два разных объекта (при создании  переменной “c” мы создали новый объект). 

Приведем еще 1 интересный пример: 

<pre class="lang-java line-numbers"><code>
Integer a = 1;
Integer b = 1;

Integer x = 2020;
Integer y = 2020;

System.out.println(a == b); // true
System.out.println(x == y); // false
</code></pre>
Как мы видим, результат первого сравнения у нас true, а результат второго — false. Тут все дело в кэшировании. Все целые числа в промежутке от -128 до 127 включительно (данные значения можно кастомизировать) кэшируются. Поэтому когда мы создаем новую переменную и присваиваем ей целочисленное значение, лежащее в промежутке от -128 до 127, мы не создаем новый объект, а присваиваем переменной ссылку на уже созданный объект в кэше. 

Теперь, зная этот факт, пример выше не кажется таким уж мистическим. Переменные а и  b ссылаются на один и тот же объект — объект из кэша. А во время инициализации переменных x и y мы каждый раз создавали новый объект, и данные переменные хранили в себе ссылки на разные объекты. А как известно, оператор == сравнивает значения переменных, а значением ссылочных переменных являются ссылки. 

Чтобы безошибочно проверять на равенство две Integer переменные, необходимо использовать (как бы банально это ни звучало) метод equals. Перепишем пример выше:

<pre class="lang-java line-numbers"><code>
Integer a = 1;
Integer b = 1;

Integer x = 2020;
Integer y = 2020;

System.out.println(a.equals(b)); // true
System.out.println(x.equals(y)); // true
</code></pre><h2>Автоупаковка и распаковка Integer</h2>Что такое автоупаковка и распаковка? При создании новых Integer переменных мы использовали такую конструкцию: 

<pre class="lang-java line-numbers"><code>
Integer a = 2020;
</code></pre>
Таким образом мы создавали новый объект без использования ключевого оператора new. Такое возможно благодаря механизму автоупаковки примитивного типа int.  Обратная процедура проявляется при присваивании примитивной переменной int значения ссылочной Integer переменной: 

<pre class="lang-java line-numbers"><code>
Integer a = 2020;
int x = a;
</code></pre>
В данном случае мы вроде бы присвоили ссылку (а именно — ссылка на объект является значением переменной “а”) примитивной переменной. Но по факту благодаря механизму автораспаковки в переменную “х” записалось значение 2020. 

Автоупаковка/распаковка — весьма распространенное явление в Java. Часто оно происходит само собой, иногда даже без ведома программиста. Но знать об этом явлении все же нужно. У нас на Javarush есть интересная <a href="https://javarush.com/groups/posts/706-avtoupakovka-i-raspakovka-v-java" target="_blank">статья на эту тему</a>.
<h2>Константы класса Integer</h2>Класс Integer предоставляет различные константы и методы для работы с целыми числами. В данном разделе мы более подробно рассмотрим некоторые из них на практике. 

Начнем с констант. В таблице ниже приведены все константы класса: 
<table>
<tbody><tr>
<th>Костанта</th>
<th>Описание</th>
</tr>
<tr>
<td>SIZE</td>
<td>Количество битов в двузначной системе счисления, занимаемое типом int</td>
</tr>
<tr>
<td>BYTES</td>
<td>Количество байтов в двузначной системе счисления, занимаемое типом int</td>
</tr>
<tr>
<td>MAX_VALUE</td>
<td>Максимальное значение, которое вмещает в себя тип int</td>
</tr>
<tr>
<td>MIN_VALUE</td>
<td>Минимальное значение, которое вмещает в себя тип int</td>
</tr>
<tr><td>TYPE</td>
<td>Возвращает объект типа Class от типа int</td>
</tr>
</tbody></table>Посмотрим на значения всех этих констант, выполнив следующий код:

<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {
        System.out.println(Integer.SIZE);
        System.out.println(Integer.BYTES);
        System.out.println(Integer.MAX_VALUE);
        System.out.println(Integer.MIN_VALUE);
        System.out.println(Integer.TYPE);
}
</code></pre>
В результате получим следующий вывод: 

<pre><code>
32
4
2147483647
-2147483648
int
</code></pre><h2>Методы класса Integer</h2>А теперь кратко рассмотрим наиболее используемые методы класса Integer. 

Итак, “топ” возглавляют методы по преобразованию числа из строки, либо преобразованию строки из числа.

Начнем с преобразований строки в число. Для этих целей служит метод <strong>parseInt</strong>, сигнатура ниже: 
<ul><li><pre><code>
static int parseInt(String s)
</code></pre></li></ul>Данный метод преобразует String в int. Продемонстрируем работу данного метода: 

<pre class="lang-java line-numbers"><code>
int i = Integer.parseInt("10");
System.out.println(i); // 10
</code></pre>
Если преобразование невозможно — например, мы передали слово в метод parseInt — будет брошено исключение NumberFormatException.

У метода parseInt(String s) есть перегруженный собрат:
<ul>
<li><pre><code>
static int parseInt(String s, int radix)
</code></pre></li></ul>Данный метод преобразует параметр s в int. В параметре radix указывается, в какой системе счисления изначально записано число в s, которое необходимо преобразовать в int. 

Примеры ниже: 

<pre class="lang-java line-numbers"><code>
System.out.println(Integer.parseInt("0011", 2)); // 3
System.out.println(Integer.parseInt("10", 8));   // 8 
System.out.println(Integer.parseInt("F", 16));   // 15
</code></pre>
Методы parseInt возвращают примитивный тип данных int. 

У данных методов есть аналог — метод <strong>valueOf</strong>. Некоторые вариации данного метода внутри себя просто вызывают parseInt. Отличие от parseInt в том, что результатом работы valueOf будет Integer, а не int. Рассмотрим ниже все варианты данного метода и пример его работы: 
<ul>
<li>static Integer valueOf(int i) — возвращает Integer значением которого является i;</li>
<li>static Integer valueOf(String s) — аналогичен parseInt(String s), но результатом будет Integer;</li>
<li>static Integer valueOf(String s, int radix) — аналогичен parseInt(String s, int radix), но результатом будет Integer.</li>
</ul>Примеры:
<pre class="lang-java line-numbers"><code>
int a = 5;
Integer x = Integer.valueOf(a);
Integer y = Integer.valueOf("20");
Integer z = Integer.valueOf("20", 8);

System.out.println(x); // 5
System.out.println(y); // 20
System.out.println(z); // 16
</code></pre>
Мы рассмотрели методы, позволяющие перевести String в int/Integer. Обратная процедура достигается с помощью методов <strong>toString</strong>. 

У любого Integer объекта можно вызвать метод toString и получить его строковое представление:

<pre class="lang-java line-numbers"><code>
Integer x = 5;
System.out.println(x.toString()); // 5
</code></pre>
Однако в связи с тем, что метод toString часто вызывается у объектов неявно (например, при передаче объекта на печать в консоль), данный метод редко используется разработчиками в явном виде. 

Есть также и статический метод toString, который принимает в себя int параметр и переводит его в строковое представление. Например: 

<pre class="lang-java line-numbers"><code>
System.out.println(Integer.toString(5)); // 5
</code></pre>
Однако, как и не статический метод toString, использование статического в явном виде можно встретить редко. 

Более интересен статический метод toString, который принимает 2 целочисленных параметра: 
<ul><li>static String toString(int i, int radix) — переведет i в строковое представление в системе счисления radix.</li></ul>Пример: 

<pre class="lang-java line-numbers"><code>
System.out.println(Integer.toString(5, 2)); // 101
</code></pre>
В классе Integer есть пару методов для нахождения максимума/минимума из двух чисел: 
<ul>
<li>static int max(int a, int b) вернет наибольшее из значений среди переданных переменных;</li>
<li>static int min(int a, int b) вернет наименьшее из значений среди переданных переменных.</li>
</ul>Примеры:

<pre class="lang-java line-numbers"><code>
int x = 4;
int y = 40;

System.out.println(Integer.max(x,y)); // 40
System.out.println(Integer.min(x,y)); // 4
</code></pre><h2>Заключение</h2>В данной статье мы рассмотрели класс Integer. 

Поговорили о том, что это за класс, что такое классы обертки. 

Рассмотрели класс с практической точки зрения. Разобрали примеры арифметических операций, в том числе операций сравнения. Взглянули на тонкости сравнения двух Integer переменных, разобрали такое понятие как кэшированные объекты. 

Также, мы упомянули о таком явлении как автоупаковка/распаковка примитивных типов данных. 

Кроме того, мы успели рассмотреть некоторые методы класса Integer, а также некоторые константы. Привели примеры перевода чисел из одной системы счисления в другую. 
<h2>Домашнее задание</h2><ol>
<li><p>Изучить, какие еще есть методы класса Integer (изучать можно <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" rel="nofollow" target="_blank">на сайте с официальной документацией</a>), написать в комментариях, какой из изученных вами методов (без учета тех, которые приведены в статье) наиболее полезен по вашему мнению (будет использоваться вами наиболее часто). А также привести обоснование своего мнения.</p>
<p>P.S. Тут нет правильных ответов, но данная активность позволит лучше изучить класс.</p></li>
<li><p>Решить небольшую простенькую задачку для закрепления материала.</p>
<p>У нас есть два числа:</p>
<p>1100001001 — в двоичной системе счисления<br>
33332 — в пятеричной системе счисления</p>
<p>Необходимо используя только методы класса Integer определить максимум среди двух данных чисел, а затем вывести разницу между максимальным и минимальным значением в троичной системе счисления.</p></li>
<li><p>Перевести максимально возможное значение Integer в восьмеричную систему счисления и вывести на экран количество цифр в полученном числе (количество считать программно).</p></li>
</ol>