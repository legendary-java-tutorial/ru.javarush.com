Вложенные внутренние классы или Inner Class в Java
<p>----------------------------------------</p>
Привет! Сегодня мы начнем рассматривать важную тему — работу вложенных классов в Java. По-английски они называются nested classes. Java позволяет создавать одни классы внутри других, именно такие классы и называют вложенными. Они делятся на 2 вида ...
<p>----------------------------------------</p>
Привет! Сегодня мы начнем рассматривать важную тему — работу вложенных классов в Java. По-английски они называются nested classes.

Java позволяет создавать одни классы внутри других:

<pre class="lang-java line-numbers"><code>
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
</code></pre>
Именно такие классы и называют вложенными.

Они делятся на 2 вида:
<ol>
<li>Non-static nested classes — нестатические вложенные классы. По-другому их еще называют inner classes — внутренние классы.</li>
<li>Static nested classes — статические вложенные классы.</li>
</ol>В свою очередь, внутренние классы (inner classes) имеют два особых подвида. Помимо того, что внутренний класс может быть просто внутренним классом, он еще бывает:
<ul>
<li>локальным классом (local class)</li>
<li>анонимным классом (anonymous class)</li>
</ul>Сложновато? :) Ничего страшного, вот тебе схема для наглядности. Возвращайся к ней по ходу лекции, если вдруг почувствуешь, что запутался!
<img data-max-width="800" data-id="3381c131-b7a8-48e5-948c-e84990ef12d6" src="/images/article/3381c131-b7a8-48e5-948c-e84990ef12d6/800.jpeg" class="img-fluid" alt="Вложенные внутренние классы - 2">На сегодняшней лекции мы поговорим об Inner classes — внутренних классах (они же — non static nested classes, нестатические вложенные классы).

Они специально выделены на общей схеме, чтобы ты не потерялся :)

Начнем с очевидного вопроса: почему эти классы называются «внутренними»?

Ответ достаточно прост: потому что они создаются внутри других классов.

Вот пример:

<pre class="lang-java line-numbers"><code>
public class Bicycle {

   private String model;
   private int weight;

   public Bicycle(String model, int weight) {
       this.model = model;
       this.weight = weight;
   }
  
   public void start() {
       System.out.println("Поехали!");
   }

   public class HandleBar {

       public void right() {
           System.out.println("Руль вправо!");
       }

       public void left() {

           System.out.println("Руль влево!");
       }
   }

   public class Seat {
      
       public void up() {

           System.out.println("Сиденье поднято выше!");
       }
      
       public void down() {

           System.out.println("Сиденье опущено ниже!");
       }
   }
}
</code></pre>
Здесь у нас есть класс <code>Bicycle</code> — велосипед. У него есть 2 поля и 1 метод — <code>start()</code>.
<img data-max-width="800" data-id="04a187f2-66ec-4d77-8d1b-52691e0f4f22" src="/images/article/04a187f2-66ec-4d77-8d1b-52691e0f4f22/800.jpeg" class="img-fluid" alt="Вложенные внутренние классы - 3">Его отличие от обычного класса в том, что у него есть два класса, код которых написан внутри <code>Bicycle</code> — это классы <code>HandleBar</code> (руль) и <code>Seat</code> (сиденье).

Это полноценные классы: как видишь, у каждого из них есть собственные методы.

На этом моменте у тебя мог возникнуть вопрос: а зачем мы вообще засунули одни классы внутрь другого? Зачем делать их внутренними?

Ну ладно, допустим, нам нужны в программе отдельные классы для руля и сидения. Но ведь необязательно делать их вложенными! Можно же сделать обычные классы. Например, вот так:

<pre class="lang-java line-numbers"><code>
public class HandleBar {
   public void right() {
       System.out.println("Руль вправо!");
   }

   public void left() {

       System.out.println("Руль влево");
   }
}

public class Seat {

   public void up() {

       System.out.println("Сиденье поднято выше!");
   }

   public void down() {

       System.out.println("Сиденье опущено ниже!");
   }
}
</code></pre>
Очень хороший вопрос!

Конечно, технических ограничений у нас нет — можно сделать и так.

Здесь дело скорее в правильном проектировании классов с точки зрения конкретной программы и в смысле этой программы.

Внутренние классы — это классы для выделения в программе некой сущности, которая неразрывно связана с другой сущностью.

Руль, сиденье, педали — это составные части велосипеда. Отдельно от велосипеда они не имеют смысла.

Если бы мы сделали все эти классы отдельными публичными классами, в нашей программе мог бы появиться, к примеру такой код:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {
       HandleBar handleBar = new HandleBar();
       handleBar.right();
   }
}
</code></pre>
Эммм… Смысл этого кода даже объяснить сложно.

У нас есть какой-то непонятный велосипедный руль (зачем он нужен? Без понятия, если честно). И этот руль поворачивает вправо...сам по себе, без велосипеда...зачем-то.

Отделив сущность руля от сущности велосипеда, мы потеряли логику нашей программы.

С использованием внутреннего класса код смотрится совсем иначе:

<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       Bicycle peugeot = new Bicycle("Peugeot", 120);
       Bicycle.HandleBar handleBar = peugeot.new HandleBar();
       Bicycle.Seat seat = peugeot.new Seat();

       seat.up();
       peugeot.start();
       handleBar.left();
       handleBar.right();
   }
}
</code></pre>
Вывод в консоль:

<pre><code>
Сиденье поднято выше!
Поехали!
Руль влево!
Руль вправо!
</code></pre>
Происходящее внезапно обрело смысл! :)

Мы создали объект велосипеда. Создали два его «подобъекта» — руль и сиденье.
Подняли сиденье повыше для удобства — и поехали: катимся и рулим, куда надо! :)
Нужные нам методы вызываются у нужных объектов. Все просто и удобно.

В данном примере выделение руля и сидения усиливает инкапсуляцию (мы скрываем данные о частях велосипеда внутри соответствующего класса), и позволяет создать более подробную абстракцию.

Теперь давай рассмотрим другую ситуацию.

Допустим, мы хотим создать программу, моделирующую магазин велосипедов и их запчастей.
<img data-max-width="800" data-id="5149870e-e33f-4391-bdca-10fee20e8930" src="/images/article/5149870e-e33f-4391-bdca-10fee20e8930/800.jpeg" class="img-fluid" alt="Вложенные внутренние классы - 4">В этой ситуации наше предыдущее решение будет неудачным.

В рамках магазина запчастей каждая отдельная часть велосипеда имеет смысл даже отдельно от сущности велосипеда. Например, нам понадобятся методы типа «продать покупателю педали», «купить новое сидение» и т.д.

Здесь использовать внутренние классы было бы ошибкой — каждая отдельная часть велосипеда в рамках нашей новой программы имеет собственный смысл: она отделима от сущности велосипеда, никак не привязана к нему.

Именно на это тебе следует обращать внимание, если ты задумался, нужно ли тебе использовать внутренние классы, или разнести все сущности по отдельным классам.

Объектно-ориентированное программирование хорошо тем, что позволяет легко моделировать сущности реального мира. Именно этим ты можешь руководствоваться, решая, нужно ли использовать внутренние классы. В реальном магазине запчасти отдельно от велосипедов — это нормально. Значит, и при проектировании программы это будет правильно.

Ладно, с «философией» разобрались :)

Теперь давай познакомимся с важными «техническими» особенностями внутренних классов. Вот что тебе обязательно нужно помнить и понимать:
<ol>
<li><p>Объект внутреннего класса не может существовать без объекта «внешнего» класса.</p>
<p>Это логично: для того мы и сделали <code>Seat</code> и <code>HandleBar</code> внутренними классами, чтобы в нашей программе не появлялись то тут, то там бесхозные рули и сиденья.</p>
<p>Этот код не скомпилируется:</p>
<pre class="lang-java line-numbers"><code>
public static void main(String[] args) {

   HandleBar handleBar = new HandleBar();
}
</code></pre>
<p>Из этого вытекает следующая важная особенность:</p></li>
<li><p>У объекта внутреннего класса есть доступ к переменным «внешнего» класса.</p>
<p>Для примера давай добавим в наш класс <code>Bicycle</code> переменную <code>int seatPostDiameter</code> — диаметр подседельного штыря.</p>
<p>Тогда во внутреннем классе <code>Seat</code> мы можем создать метод <code>getSeatParam()</code>, который сообщит нам параметр сиденья: 

</p><pre class="lang-java line-numbers"><code>
public class Bicycle {

   private String model;
   private int weight;

   private int seatPostDiameter;

   public Bicycle(String model, int weight, int seatPostDiameter) {
       this.model = model;
       this.weight = weight;
       this.seatPostDiameter = seatPostDiameter;

   }

   public void start() {
       System.out.println("Поехали!");
   }

   public class Seat {

       public void up() {

           System.out.println("Сиденье поднято выше!");
       }

       public void down() {

           System.out.println("Сиденье опущено ниже!");
       }

       public void getSeatParam() {

           System.out.println("Параметр сиденья: диаметр подседельного штыря = " + Bicycle.this.seatPostDiameter);
       }
   }
}
</code></pre>
<p>И теперь мы можем получить эту информацию в нашей программе:</p>
<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       Bicycle bicycle = new Bicycle("Peugeot", 120, 40);
       Bicycle.Seat seat = bicycle.new Seat();

       seat.getSeatParam();
   }
}
</code></pre>
<p>Вывод в консоль:
</p><pre><code>
Параметр сиденья: диаметр подседельного штыря = 40
</code></pre><p></p>
<p><mark>Обрати внимание:</mark> новая переменная объявлена с самым строгим модификатором — <code>private</code>. И все равно у внутреннего класса есть доступ! </p></li>
<li><p>Объект внутреннего класса нельзя создать в статическом методе «внешнего» класса.</p>
<p>Это объясняется особенностями устройства внутренних классов.
У внутреннего класса могут быть конструкторы с параметрами или только конструктор по умолчанию. Но независимо от этого, когда мы создаем объект внутреннего класса, в него незаметно передается ссылка на объект «внешнего» класса. Ведь наличие такого объекта — обязательное условие. Иначе мы не сможем создавать объекты внутреннего класса.</p>

<p>Но если метод внешнего класса статический, значит, объект внешнего класса может вообще не существовать! А значит, логика работы внутреннего класса будет нарушена. В такой ситуации компилятор выбросит ошибку:</p>
<pre class="lang-java line-numbers"><code>
public static Seat createSeat() {
  
   //Bicycle.this cannot be referenced from a static context
   return new Seat();
}
</code></pre></li>
<li><p>Внутренний класс не может содержать статические переменные и методы.</p>
<p>Логика здесь та же: статические методы и переменные могут существовать и вызваться даже при отсутствии объекта.</p>
<p>Но без объекта «внешнего» класса доступа к внутреннему классу у нас не будет.</p>
<p>Явное противоречие! Поэтому наличие статических переменных и методов во внутренних классах запрещено.</p>
<p>Компилятор выбросит ошибку при попытке их создать:</p>
<pre class="lang-java line-numbers"><code>
public class Bicycle {

   private int weight;


   public class Seat {
      
       //inner class cannot have static declarations
       public static void getSeatParam() {

           System.out.println("Параметр сиденья: диаметр подседельного штыря = " + Bicycle.this.seatPostDiameter);
       }
   }
}
</code></pre></li>
<li><p>При создании объекта внутреннего класса важную роль играет его модификатор доступа.</p>
<p>Внутренний класс можно обозначить стандартными модификаторами доступа — <code>public</code>, <code>private</code>, <code>protected</code> и <code>package private</code>.</p>
<p>Почему это важно?</p>
<p>Это влияет на то, где в нашей программе мы сможем создавать экземпляры внутреннего класса.</p>
<p>Если наш класс <code>Seat</code> объявлен как <code>public</code>, мы можем создавать его объекты в любом другом классе. Единственное требование — объект «внешнего» класса тоже обязательно должен существовать.</p>
<p>Кстати, мы уже это делали вот здесь:</p>
<pre class="lang-java line-numbers"><code>
public class Main {

   public static void main(String[] args) {

       Bicycle peugeot = new Bicycle("Peugeot", 120);
       Bicycle.HandleBar handleBar = peugeot.new HandleBar();
       Bicycle.Seat seat = peugeot.new Seat();

       seat.up();
       peugeot.start();
       handleBar.left();
       handleBar.right();
   }
}
</code></pre>
<p>Мы легко получили доступ к внутреннему классу <code>HandleBar</code> из класса <code>Main</code>.</p>
<p>Если же мы объявим внутренний класс как <code>private</code>, доступ к созданию объектов у нас будет только внутри «внешнего» класса.</p>
<p>Создать объект <code>Seat</code> снаружи мы уже не сможем:</p>
<pre class="lang-java line-numbers"><code>
private class Seat {

   //методы
}

public class Main {

   public static void main(String[] args) {

       Bicycle bicycle = new Bicycle("Peugeot", 120, 40);

       //Bicycle.Seat has a private access in 'Bicycle'
       Bicycle.Seat seat = bicycle.new Seat();
   }
}
</code></pre>
<p>Наверное, ты уже понял логику :)</p></li>
<li><p>Модификаторы доступа для внутренних классов работают так же, как и для обычных переменных.</p>
<p>Модификатор <code>protected</code> предоставляет доступ к переменной класса в его классах-наследниках и в классах, которые находятся в том же пакете.</p>
<p>Так же <code>protected</code> работает и для внутренних классов. Объекты <code>protected</code> внутреннего класса можно создавать:</p>
<ul>
<li>внутри «внешнего» класса; </li>
<li>в его классах-наследниках;</li>
<li>в тех классах, которые находятся в том же пакете.</li>
</ul><p>Если у внутреннего класса нет модификатора доступа (<code>package private</code>), объекты внутреннего класса можно создавать</p>
<ul>
<li>внутри «внешнего» класса;</li>
<li>в классах, которые находятся в том же пакете.</li>
</ul>
<p>С модификаторами ты уже давно знаком, так что тут проблем не будет.</p></li>
</ol>На этом пока все :) Но не расслабляйся! Внутренние вложенные классы — довольно обширная тема, с которой мы продолжим знакомиться на следующих занятиях.

Сейчас ты можешь освежить в памяти <a href="https://javarush.com/quests/lectures/questmultithreading.level03.lecture03" target="_blank">лекцию о внутренних классах</a> из нашего курса.

А в следующий раз поговорим о статических вложенных классах.