Классы, виды вложенных классов с примерами 
<p>----------------------------------------</p>
Какие же есть виды классов и как переварить их? Давайте разбираться подробнее и проводя параллели с реальностью. На самом деле, достаточно осознать вложенные статические и вложенные нестатические классы, ведь остальные два вида - особый случай вложенного нестатического класса.
<p>----------------------------------------</p>
Всем привет. В данной теме я хочу подробно рассказать про классы Java и их виды, чтобы помочь новичкам разобраться с данной темой, и, возможно, не новичкам узнать что-то новое. По возможности, все будет показано на примерах из реальной жизни с прилегающими примерами кода. Давайте приступать.

<img data-id="6afb0dd3-918e-4261-ad45-b18ec6a76115" data-max-width="850" alt="Классы, виды вложенных классов с примерами  - 1" src="https://cdn.javarush.com/images/article/6afb0dd3-918e-4261-ad45-b18ec6a76115/1024.jpeg">И хотелось бы отметить, что главное осознать первые два вида классов, а локальные и анонимные - это просто подвиды внутреннего класса.
<h2>Что такое класс?</h2><em><strong>Класс</strong></em> – логическое описание чего-либо, шаблон, с помощью которого можно создавать реальные экземпляры этого самого чего-либо. Другими словами, это просто описание того, какими должны быть созданные сущности: какими свойствами и методами должны обладать.

<em><strong>Свойства</strong></em> – характеристики сущности, <em><strong>методы</strong></em> – действия, которые она может выполнять. Хорошим примером класса из реальной жизни, дающим понимание, что же такое класс, можно считать чертежи: чертежи используются для описания конструкций (катапульта, отвертка), но чертеж – это не конструкция. Инженеры используют чертежи, чтобы создавать конструкции, так и в программировании классы используются для того, чтобы создавать объекты, обладающие описанными свойствами и методами.

<pre class="lang-java line-numbers"><code>
public class Student {
    private String name, group, specialty;

    public Student(String name, String group, String specialty) {
       this.name = name;
       this.group = group;
       this.specialty = specialty;
   }

   // getters/setters
}
</code></pre>
В данном примере мы создали Java класс, описывающий сущность «студент»: у каждого студента есть имя, группа и специальность. Теперь в других местах программы мы можем создавать реальные образцы данного класса. Другими словами: если класс <code>Student</code> - это портрет того, какими должны быть студент, то созданный экземпляр - это непосредственно реальный студент.

Пример создания нового студента: <code>new Student("Ivan", "KI-17-2", "Computer Engineering");</code> Оператор <code>new</code> ищет класс <code>Student</code>, после чего вызывает специальный метод (конструктор) данного класса. Конструктор возвращает готовый объект класса <code>Student</code> - нашего родного, голодного студента без стипендии :))
<h2>Виды классов в Java</h2>В Java есть 4 вида классов внутри другого класса:
<ol>
<li><em><p><strong>Вложенные внутренние классы</strong> – нестатические классы внутри внешнего класса.</p></em></li>
<li><em><p><strong>Вложенные статические классы</strong> – статические классы внутри внешнего класса.</p></em></li>
<li><em><p><strong>Локальные классы Java </strong>– классы внутри методов.</p></em></li>
<li><em><p><strong>Анонимные Java классы</strong> – классы, которые создаются на ходу.</p></em></li>
</ol>Про каждый из них будем говорить отдельно.
<h3>Нестатические классы внутри внешнего класса</h3>Сначала, я хочу, чтобы вы осознали, что это такое, на реальном примере, потому что это облегчает понимание в разы. Так что сейчас мы будем разбивать реальную большую вещь на более мелкие составные части, а разбирать мы будем – самолёт! Однако, для примера будет достаточно показать немного, полностью разбивать мы не будем.

Для визуализации данного процесса, будем использовать схему самолёта.
<img data-id="3034dba9-769d-45e9-a291-0a24493054c5" data-max-width="952" alt="Классы, виды вложенных классов с примерами  - 2" src="https://cdn.javarush.com/images/article/3034dba9-769d-45e9-a291-0a24493054c5/1024.jpeg">
Для начала, нам нужно создать класс <code>Airplane</code>, куда мы можем занести немного описание: название самолета, идентификационный код,  рейс.

<pre class="lang-java line-numbers"><code>
public class Airplane {
    private String name, id, flight;

    public Airplane(String name, String id, String flight) {
        this.name = name;
        this.id = id;
        this.flight = flight;
    }

    // getters/setters
}
</code></pre>
Теперь мы хотим добавить крылья. Создавать отдельный класс? Возможно в этом и есть логика, если у нас сложная программа для конструирования самолетов, и где нам нужно создавать огромное количество производных классов (классы, которые обладают такой же логикой, как и родительский класс, то есть класс, от которого они наследуются, но так же расширяют родительский класс, добавляя логику или более подробные характеристики), но что, если у нас просто игра, где у нас есть один самолет? Тогда нам будет рациональней укомплектовать всю структуру в одном месте (в одном классе).

Тут идут в бой нестатические вложенные классы. По сути, это более подробное описание каких-то деталей нашего внешнего класса. В данном примере, нам нужно создать крылья для самолета – левое и правое. Давайте создавать!

<pre class="lang-java line-numbers"><code>
public class Airplane {
    private String name, id, flight;
    private Wing leftWing = new Wing("Red", "X3"), rightWing = new Wing("Blue", "X3");

    public Airplane(String name, String id, String flight) {
        this.name = name;
        this.id = id;
        this.flight = flight;
    }

    private class Wing {
        private String color, model;
        
        private Wing(String color, String model) {
            this.color = color;
            this.model = model;
        }
        
        // getters/setters
    }
    
    // getters/setters
}
</code></pre>
Так мы создали нестатический вложенный класс <code>Wing</code> (крыло) внутри класса <code>Airplane</code> (самолет), и добавили две переменные – левое крыло и правое крыло. И у каждого крыла есть свои свойства (цвет, модель), которые мы можем изменять. Так можно укомплектовывать структуры столько, сколько нужно.

И заметьте: ранее на схеме было довольно много деталей у самолета, и, по сути, мы можем все детали разбить на внутренние классы, однако не всегда такой процесс целесообразен. Такие моменты нужно прослеживать в зависимости от задачи. Возможно, вам вообще не нужны крылья для решения задачи. Тогда и незачем их делать. Это как распилить человека на ноги, руки, торс и голову – можно, но зачем, если данный класс используется только для хранения данных об людях?

<em><strong>Особенности нестатических вложенных классов Java:</strong></em>
<ol>
<li>Они существуют только у объектов, потому для их создания нужен объект. Другими словами: мы укомплектовали наше крыло так, чтобы оно было частью самолета, потому, чтобы создать крыло, нам нужен самолет, иначе оно нам не нужно.</li>
<li>Внутри Java класса не может быть статических переменных. Если вам нужны какие-то константы или что-либо еще статическое, выносить их нужно во внешний класс. Это связано с тесной связью нестатического вложенного класса с внешним классом.</li>
<li>У класса полный доступ ко всем приватным полям внешнего класса. Данная особенность работает в две стороны.</li>
<li>Можно получить ссылку на экземпляр внешнего класса. Пример: Airplane.this – ссылка на самолет, this – ссылка на крыло.</li>
</ol><h3>Статические классы внутри внешнего класса</h3>Данный вид классов не отличается ничем от обычного внешнего класса, кроме одного: для создания экземпляра такого класса, нужно через точку перечислить весь путь от внешнего класса до нужного. Например: <code>Building.Plaftorm platform = new Building.Platform();</code>

Статические классы используются для того, чтобы укомплектовать связанные классы рядышком, чтобы с логической структурой было работать проще. Например: мы можем создать внешний класс <code>Building</code>, где будет конкретный список классов, которые будут представлять из себя уже конкретную постройку.

<pre class="lang-java line-numbers"><code>
public abstract class Building {
    private String name, address, type;

    Building(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public static class Platform extends Building {
        public Platform(String name, String address) {
            super(name, address);
            setType("Platform");
        }

        // some additional logic
    }

    public static class House extends Building {
        public House(String name, String address) {
            super(name, address);
            setType("House");
        }

        // some additional logic
    }

    public static class Shop extends Building {
        public Shop(String name, String address) {
            super(name, address);
            setType("Shop");
        }

        // some additional logic
    }

    // getters/setters
}
</code></pre>
Данный пример демонстрирует, как статические классы позволяют укомплектовывать логическую структуру в более удобный вид. Если бы их не было, нам бы понадобилось создавать 4 совершенно разных класса. 

<em><strong>Плюсы такого подхода:</strong></em>
<ol>
<li>Количество классов уменьшилось.</li>
<li>Все классы внутри их класса-родителя. Мы способны прослеживать всю иерархию без открытия каждого класса отдельно. </li>
<li>Мы можем обратиться к классу Building, а IDE уже будет подсказывать весь список всех подклассов данного класса. Это будет упрощать поиск нужных классов и показывать всю картину более цело.</li>
</ol><em><strong>Пример создания экземпляра вложенного статического класса:</strong></em><code>Building.Shop myShop = new Building.Shop(“Food &amp; Fun!”, “Kalyaeva 8/53”);</code>

Хотелось бы еще отметить, что данная стратегия задействована в 2D классах AWT для описания фигур, таких, как Line2D, Arc2D, Ellipse2D и другие.
<h3>Локальные классы</h3>Данные классы объявляются внутри других методов. По сути, они обладают всеми свойствами нестатического вложенного класса, только создавать их экземпляры можно только в методе, при чем метод не может быть статическим (для их создания нужен экземпляр внешнего класса, в нестатические методы неявно передается ссылка на экземпляр вызывающего объекта, а в статическом методе данной ссылки нет). 

<em><strong>Но, свои особенности у них есть:</strong></em>
<ol>
<li>Локальные классы способны работать только с final переменными метода. Все дело в том, что экземпляры локальных классов способны сохраняться в «куче» после завершения работы метода, а переменная может быть стёрта. Если же переменная объявлена final, то компилятор может сохранить копию переменной для дальнейшего использования объектом. И еще: с 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.</li>
<li>Локальные классы нельзя объявлять с модификаторами доступа.</li>
<li>Локальные классы обладают доступом к переменным метода.</li>
</ol>Локальные классы можно встретить крайне редко, так как они затрудняют прочтение кода и не обладают никакими плюсами, кроме одного – доступ к переменным метода. Я не знаю, какой можно взять пример локального класса, который бы показал их эффективное применение, так что покажу просто свой пример.

Допустим, что у нас есть класс <code>Person</code> (будет считать, что это человек) со свойствами <code>street</code> (улица), <code>house</code> (дом). Нам бы хотелось возвращать какой-то объект для доступа только к местоположению человека. Для этого, мы создали интерфейс AddressContainer, который подразумевает собой хранилище данных об местоположении человека. 

<pre class="lang-java line-numbers"><code>
public class Person {
    private String name, street, house;

    public Person(String name, String street, String house) {
        this.name = name;
        this.street = street;
        this.house = house;
    }

    private interface AddressContainer {
        String getStreet();
        String getHouse();
    }

    public AddressContainer getAddressContainer() {
        class PersonAddressContainer implements AddressContainer {
            final String street = Person.this.street, house = Person.this.house;

            @Override
            public String getStreet() {
                return this.street;
            }

            @Override
            public String getHouse() {
                return this.house;
            }
        }

        return new PersonAddressContainer();
    }

    public static void main(String[] args) {
        Person person = new Person("Nikita", "Sholohova", "17");

        AddressContainer address = person.getAddressContainer();

        System.out.println("Address: street - " + address.getStreet() + ", house - " + address.getHouse());
    }

    // getters/setters
}
</code></pre>
Как можно заметить, внутри метода мы создали класс, реализующий хранилище местоположения человека, создали там константные переменные (чтобы после выхода из метода переменные хранились в объекте) и реализовали метод для получения адреса и дома. Теперь мы можем использовать данный объект в других местах программы, чтобы получать местоположение человека.

Понимаю, что данный пример неидеальный и его было правильней сделать просто оставив геттеры в классе <code>Person</code>, однако создание данного класса и его возможное использование было показано, а далее решать вам.
<h3>Анонимные классы</h3>Под капотом анонимные классы – просто обычные нестатические вложенные классы. Их особенность в удобстве их использования. Вы можете написать свой класс прямо при создании экземпляра другого класса.

<pre class="lang-java line-numbers"><code>
public class Animal {
    public void meow() {
        System.out.println("Meow!");
    }

    public static void main(String[] args) {
        Animal anonTiger = new Animal() {
            @Override
            public void meow() {
                System.out.println("Raaar!");
            }
        };

        Animal notAnonTiger = new Animal().new Tiger();
        
        anonTiger.meow(); // будет выведено Raaar!
        notAnonTiger.meow(); // будет выведено Raaar!
    }
    
    private class Tiger extends Animal {
        @Override
        public void meow() {
            System.out.println("Raaar!");
        }
    }
}
</code></pre>
По сути, мы просто совмещаем в одном месте две вещи: создание экземпляра одного класса (<code>Animal</code>) и создание экземпляра его внутреннего-класса наследника (<code>Tiger</code>). Иначе нам нужно создавать класс отдельно и использовать более длинные конструкции, чтобы добиться того же самого результата.

<em><strong>Использование анонимных классов оправдано во многих случаях, в частности когда:</strong></em>
<ul>
<li>тело класса является очень коротким;</li>
<li>нужен только один экземпляр класса;</li>
<li>класс используется в месте его создания или сразу после него;</li>
<li>имя класса не важно и не облегчает понимание кода.</li>
</ul>Часто анонимные классы используются в графических интерфейсах для создания обработчиков событий. <em>Например для создания кнопки и реакции на её нажатие:</em>

<pre class="lang-java line-numbers"><code>
JButton b2 = new JButton("Click");
b2.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("Кнопка нажата!");
    }
});
</code></pre>
Однако после Java 8 начали использовать лямбда-выражения, но все равно много кода было написано до 8 версии и вы можете столкнуться (и столкнетесь в ходе обучения на JavaRush) с такими вот надписями.\

<em>Аналог с лямбдами:</em>

<pre class="lang-java line-numbers"><code>
JButton b2 = new JButton("Click");
b2.addActionListener(e -&gt; System.out.println("Кнопка нажата!"));
</code></pre>

<strong>Конец статьи</strong>
Спасибо всем за внимание и надеюсь, что вы узнали что-нибудь новое или разобрались в чем-то, чего раньше не понимали. Хочу так же уточнить, что данная статья относится к номинации <strong>«внимание к деталям»</strong>. Это моя первая работа, так что буду рассчитывать, что кому-то она была полезна. В ближайшее время, когда придут новые идеи, буду пытаться написать еще что-то, как раз есть одна идея... Удачи всем и успехов в программировании :)