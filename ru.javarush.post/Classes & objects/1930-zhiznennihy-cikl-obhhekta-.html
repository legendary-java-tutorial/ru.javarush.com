Жизненный цикл объекта 
<p>----------------------------------------</p>
Привет! Думаю, ты не сильно удивишься, если тебе сказать, что размер памяти на твоем компьютере ограничен :) Даже жесткий диск, который в разы больше оперативной памяти, можно забить под завязку любимыми играми, сериалами и прочим...
<p>----------------------------------------</p>
Привет! Думаю, ты не сильно удивишься, если тебе сказать, что размер памяти на твоем компьютере ограничен:) 

Даже жесткий диск, который в разы больше оперативной памяти, можно забить под завязку любимыми играми, сериалами и прочим. Чтобы этого не произошло, нужно следить за текущим состоянием памяти и удалять с компа ненужные файлы.

Какое отношение ко всему этому имеет программирование на Java? Прямое! Ведь при создании любого объекта Java-машиной под него выделяется память. В реальной большой программе создаются десятки и сотни тысяч объектов, под каждый из которых в памяти выделяется свой кусочек.<img data-id="8b70deaf-eb68-4b2d-babd-e3ba2d2f0837" data-max-width="850" alt="Жизненный цикл объекта  - 1" src="https://cdn.javarush.com/images/article/8b70deaf-eb68-4b2d-babd-e3ba2d2f0837/1024.jpeg">Но как ты думаешь, сколько существуют все эти объекты? “Живут” ли они все время, пока работает наша программа? Разумеется, нет. 

При всех достоинствах Java-объектов, они не бессмертны :) У объектов есть собственный жизненный цикл. 

Сегодня мы чуть-чуть отдохнем от написания кода и рассмотрим этот процесс :) Тем более что он является очень важным для понимания работы программы и распоряжения ресурсами.

Итак, с чего же начинается жизнь объекта? Как и у человека — с его рождения, то есть, создания.

<pre class="lang-java line-numbers"><code>
Cat cat = new Cat();//вот сейчас и начался жизненный цикл нашего объекта Cat!
</code></pre>
Вначале виртуальная Java-машина выделяет необходимый объем памяти для создания объекта.

Потом она создает на него ссылку, в нашем случае — <code>cat</code>, чтобы иметь возможность его отслеживать. После этого происходит инициализация всех переменных, вызов конструктора и вот — наш свежий объект уже живет своей жизнью :)

Срок жизни у объектов разный, точных цифр здесь не существует. В любом случае, в течение какого-то времени он живет внутри программы и выполняет свои функции.

Если говорить точно, объект является “живым” пока на него есть ссылки. Как только ссылок не остается — объект “умирает”.

Например:

<pre class="lang-java line-numbers"><code>
public class Car {
  
   String model;

   public Car(String model) {
       this.model = model;
   }

   public static void main(String[] args) {
       Car lamborghini  = new Car("Lamborghini Diablo");
       lamborghini = null;

   }

}
</code></pre>
В методе <code>main()</code> объект машины Lamborghini Diablo перестает быть живым уже на второй строке. На него была всего одна ссылка, а теперь этой ссылке был присвоен <code>null</code>. Поскольку на Lamborghini Diablo не осталось ссылок, он становится “мусором”.

Ссылку при этом не обязательно обнулять:

<pre class="lang-java line-numbers"><code>
public class Car {

   String model;

   public Car(String model) {
       this.model = model;
   }

   public static void main(String[] args) {
       Car lamborghini  = new Car("Lamborghini Diablo");

       Car lamborghiniGallardo = new Car("Lamborghini Gallardo");
       lamborghini = lamborghiniGallardo;
   }

}
</code></pre>
Здесь мы создали второй объект, после чего взяли ссылку <code>lamborghini</code> и присвоили ей этот новый объект. Теперь на объект <code>Lamborghini Gallardo</code> указывает две ссылки, а на объект <code>Lamborghini Diablo</code> — ни одной. Поэтому объект <code>Diablo</code> становится мусором.

И в этот момент в работу вступает встроенный механизм Java под названием сборщик мусора, или по-другому — Garbage Collector, GC. 
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="90f951c8-7932-4b1b-91d8-ba17fae210fc" data-max-width="850" alt="Жизненный цикл объекта  - 2" src="https://cdn.javarush.com/images/article/90f951c8-7932-4b1b-91d8-ba17fae210fc/1024.jpeg"></div></div>Сборщик мусора — внутренний механизм Java, который отвечает за освобождение памяти, то есть удаление из нее ненужных объектов.

Мы не зря выбрали для его изображения картинку с роботом-пылесосом. Ведь сборщик мусора работает примерно так же: в фоновом режиме он “ездит” по твоей программе, собирает мусор, и при этом ты с ним практически не взаимодействуешь.

Его работа — удалять объекты, которые уже не используются в программе. Таким образом он освобождает в компьютере память для других объектов. Помнишь в начале лекции мы говорили, что в обычной жизни тебе приходится следить за состоянием твоего компьютера и удалять старые файлы? 

Так вот, в случае с Java-объектами сборщик мусора делает это вместо тебя. 

Garbage Collector запускается многократно в течение работы твоей программы: его не надо вызывать специально и отдавать команды, хотя технически это возможно. 

Позднее мы еще поговорим о нем и разберем процесс его работы более детально.

В момент, когда сборщик мусора добрался до объекта, перед самым его уничтожением, у объекта вызывается специальный метод — <code>finalize()</code>.

Его можно использовать, чтобы освободить какие-то дополнительные ресурсы, которые использовал объект.

Метод <code>finalize()</code> принадлежит классу <code>Object</code>. То есть, наравне с <code>equals()</code>, <code>hashCode()</code> и <code>toString()</code>, с которыми ты уже познакомился ранее, он есть у любого объекта.

Его отличие от других методов в том, что он... как бы это сказать... весьма своенравен. 

А именно — перед уничтожением объекта он вызывается далеко не всегда.

Программирование — штука точная. Программист говорит компьютеру что-то сделать — компьютер это и делает. Ты, полагаю, уже привык к такому поведению, и тебе поначалу может быть сложно принять идею: “Перед уничтожением объектов вызывается метод <code>finalize()</code> класса <code>Object</code>. Или не вызывается. Как повезет!”

Тем не менее, это действительно так. Java-машина сама определяет, вызывать метод <code>finalize()</code> в каждом конкретном случае или нет. 

Например, давай попробуем ради эксперимента запустить такой код:

<pre class="lang-java line-numbers"><code>
public class Cat {

   private String name;

   public Cat(String name) {
       this.name = name;
   }

   public Cat() {
   }

   public static void main(String[] args) throws Throwable {

       for (int i = 0 ; i &lt; 1000000; i++) {

           Cat cat = new Cat();
           cat = null;//вот здесь первый объект становится доступен сборщику мусора
       }
   }

   @Override
   protected void finalize() throws Throwable {
       System.out.println("Объект Cat уничтожен!");
   }
}
</code></pre>
Мы создаем объект <code>Cat</code> и уже в следующей строчке кода обнуляем единственную ссылку на него. И так — миллион раз.

Мы явно переопределили метод <code>finalize()</code>, и он должен миллион раз вывести строку в консоль, каждый раз перед уничтожением объекта <code>Cat</code>. 

Но нет! Если быть точным, на моем компьютере он отработал всего 37346 раз! То есть только в 1 случае из 27-ми установленная у меня Java-машина принимала решение вызвать метод <code>finalize()</code> — в остальных случаях сборка мусора проходила без этого. 

Попробуй запустить этот код у себя: скорее всего, результат будет отличаться.

Как видишь,<code>finalize()</code> трудно назвать надежным партнером :)

Поэтому небольшой совет на будущее: не стоит полагаться на метод <code>finalize()</code> в случае с освобождением каких-то критически важных ресурсов. Может JVM его вызовет, а может нет. Кто знает? Если твой объект при жизни занимал какие-то суперважные для производительности ресурсы, например, держал открытым соединение с базой данных, лучше создай в своем классе специальный метод для их освобождения и вызови его явно, когда объект уже будет не нужен. Так ты точно будешь знать, что производительность твоей программы не пострадает.

В самом начале мы сказали, что работа с памятью и удаление мусора очень важны, и это действительно так. Неподобающая работа с ресурсами и непонимание процесса сборки ненужных объектов могут привести к утечке памяти. Это одна из самых известных ошибок в программировании.

Неправильно написанный программистом код может привести к тому, что для вновь созданных объектов каждый раз будет выделяться новая память, при этом старые, ненужные объекты будут недоступны для удаления сборщиком мусора.

Раз уж мы привели аналогию с роботом пылесосом, представь, что будет, если перед запуском робота разбросать по дому носки, разбить стеклянную вазу и оставить на полу разобранный конструктор Lego. Робот, конечно, попытается что-то сделать, но в один прекрасный момент он застрянет. 
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="f1d8aa4a-eff7-41c2-ac32-5753ac45bee3" data-max-width="850" alt="Жизненный цикл объекта  - 3" src="https://cdn.javarush.com/images/article/f1d8aa4a-eff7-41c2-ac32-5753ac45bee3/1024.jpeg"></div></div>Для его правильной работы нужно держать пол в нормальном состоянии и убирать оттуда все, с чем не справится пылесос.

По такому же принципу работает и сборщик мусора. Если в программе будет оставаться много объектов, которые он не может собрать (как носок или Lego для робота-пылесоса), в один прекрасный момент память закончится. И зависнет не только написанная тобой программа, но и все остальные программы, запущенные в этот момент на компьютере. Для них тоже не будет хватать памяти.
Вот так выглядят в Java жизненный цикл объектов и сборщик мусора. Это не нужно заучивать: достаточно просто понять принцип работы. В следующей лекции мы поговорим об этих процессах подробнее, а пока — можешь вернуться к решению задач JavaRush :) Успехов!