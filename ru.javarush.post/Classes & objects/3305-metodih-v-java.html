Методы в Java
<p>----------------------------------------</p>
Существует один интересный принцип, о котором многие слышали. Он называется “Разделяй и властвуй”. Этот принцип используется во многих сферах человеческой жизни, например, в политике. Он обозначает разделение большого количества разнородных частей...
<p>----------------------------------------</p>
Существует один интересный принцип, о котором многие слышали. Он называется “Разделяй и властвуй”. Этот принцип используется во многих сферах человеческой жизни, например, в политике. Он обозначает разделение большого количества разнородных частей в государстве, разжигание и использование вражды между этими частями. Иными словами: создать конфликт между теми, кто потенциально создает угрозу власти.

Но мы с вами программисты, поэтому нас интересует исключительно техническая трактовка данного принципа. А звучит она так:

“Принцип “Разделяй и властвуй” заключается в разбиении большой задачи на более мелкие до тех пор, пока они не станут элементарными. Затем нужно последовательно решить их и объединить все в одну целую систему. Данная программа должна решать поставленную задачу”

То есть, вы просто разбиваете большую задачу на более мелкие, решить которые для вас не составляет проблем. А потом собираете решение в одно большое. Чтобы следовать этому простому и полезному принципу, в Java-программировании используют методы.

<img data-max-width="800" data-id="630ad0a8-9c3d-4519-a5ec-65506fd274ae" src="https://cdn.javarush.com/images/article/630ad0a8-9c3d-4519-a5ec-65506fd274ae/800.jpeg" alt="Методы в Java - 1">Например, мы создаем робота-боксера. Для нас важно, чтобы он хорошо двигался, проводил точные удары, а также следил за противником в поисках слабых мест. Будет неудобно писать все это в одном методе <span class="code">main</span>, не так ли?

Если мы опишем все в одном методе, будет что-то вроде такого:

<pre class="language-java line-numbers"><code>
метод main() {
// Описание действий шага вперед
подача напряжения в отдельные модули;
поднятие ноги;
перевод в другую точку;
поставить ногу;
перенести вес на другую ногу;
если (противникАтакует()) {
        	// Описание действий уклонения робота.
        	...
} еслиНет {
        	// Описание действий обманного атакующего удара.
        	...
}
// Описание действий шага назад
...
}
</code></pre>
А если нам понадобится использовать шаг вперед или удар еще где-либо в программе? Описывать все действия снова? Не подходит. Слишком много повторяющихся строк, в которых легко запутаться.

Нам нужно вынести описание деталей действия в отдельный модуль, который будет выполнять шаг робота. И мы можем вызывать метод одной строкой.

Как-то так:
 
<pre class="language-java line-numbers"><code>
метод шагВперед() {
// Описание действий шага вперед
  	подача напряжения в отдельные модули;
  	поднятие ноги;
  	перевод в другую точку;
  	поставить ногу;
  	перенести вес на другую ногу;
}

метод уклонение() {
  	// Действия для уклонения
  	...
}

метод обманныйАтакующийУдар() {
  	// Действия для удара
  	...
}

метод шагНазад() {
  	// Действия для шага назад
  	...
}
 
метод противникАтакует() {
	// Робот проверяет атакует ли противник
}

метод main() {
	шагВперед();
	если (противникАтакует()) {
        	уклонение();
	} еслиНет {
  	  обманныйАтакующийУдар();     	
	}
	шагНазад();
}
</code></pre>
Теперь у нас есть разделенный функционал робота, а также компактный и понятный метод <span class="code">main()</span>. Остальные методы также можно разделить на какой-либо функционал, например, <span class="code">обманныйАтакующийУдар</span> можно разделить на методы <span class="code">обманноеДвижение</span>, <span class="code">движениеНог</span>, <span class="code">атака</span>. И их, в свою очередь, на более простые задачи, чтобы в итоге получить набор элементарных.

Окей, а теперь напишем это все красиво в таком виде, который примет Java.

<pre class="language-java line-numbers"><code>
  	public static void stepForward() {
  	    // Многострочный код, описывающий
  	    // действия робота для выполнения шага
  	    System.out.println("The robot takes a step forward");
	}

	public static void evasion() {
  	    // Действия для уклонения
  	    System.out.println("Robot shy of impact");
	}

	public static void deceptiveAttackBlow() {
  	    // Действия для удара
  	    System.out.println("The robot performs a deceptive strike");
	}

	public static void stepBack() {
  	    // Действия для шага назад
  	    System.out.println("The robot takes a step backwards");
	}

	public static void main(String[] args) {
    	stepForward();
    	if (isEnemyAttacked()) {
        		evasion();
    	} else {
  	    	deceptiveAttackBlow();       	
    	}
    	stepBack();
	}
	
	public static boolean isEnemyAttacked() {
    	// Метод проверяет, атакует ли враг. Возвращает логическое значение.
    	return true;
	}
</code></pre>
Понимаю, что вам может быть сейчас этот код немного непонятен, особенно некоторые слова вроде <span class="code">void</span>, <span class="code">return</span> и так далее. Не спешите бросаться помидорами, сейчас все объясню.

Общая мысль парадигмы “Разделяй и властвуй” вам должна быть понятна. В этом нам помогут методы.

Общая структура объявления методов такая:

<pre class="language-java line-numbers"><code>
модификатор_доступа возвращаемое_значение имя_метода(принимаемые_параметры) {
   	//Тело метода
}
</code></pre><h2>Модификатор доступа</h2>Модификатор доступа — это несколько ключевых слов: <span class="code">public</span>, <span class="code">private</span>, <span class="code">package</span>. Эти слова указывают на область видимости метода. Я объясню просто: этим словом вы как будто делитесь с другими вкусняшкой. Вкусняшка — ваш метод.

Если это <span class="code">private</span>, вы не делитесь методом с другими классами. Если <span class="code">package</span>, вы делитесь только с классами в рамках пакета (классы собираются в определенные пакеты, это вы узнаете дальше). Ну а <span class="code">public</span> показывает, что вы  — сама доброта и делитесь вкусняшкой (методом) со всей программой. Как-то так. Через несколько уровней вы гораздо лучше поймете роль этих слов.<h2>Возвращаемое значение</h2>Посмотрите пример выше: все методы помечены ключевым словом <span class="code">void</span>, кроме одного — <span class="code">isEnemyAttacked</span>, который возвращает логическое значение <span class="code">boolean</span>.

Если метод помечен как <span class="code">void</span>, он может ничего не возвращать. Такой метод просто выполняет набор действий и все.

А теперь обратите внимание на метод <span class="code">main</span>. Те методы, которые возвращают <span class="code">void</span>, вызываются просто так, в теле метода. А вот метод <span class="code">isEnemyAttacked</span> вызывается в скобках оператора <span class="code">if</span>. Благодаря тому, что он возвращает логическое значение, мы получаем возможность не использовать промежуточную переменную, а вставлять его напрямую.

Возврат значения происходит с помощью ключевого слова <span class="code">return</span>.

Если метод возвращает тип <span class="code">int</span>, мы можем вызывать метод из любого выражения:

<pre class="language-java line-numbers"><code>
    public static int getNumber() {
 	    return 5;
	}

	public static void main(String[] args) {
    	int result = 5 + 6 + getNumber();
    	System.out.println(result);
	}
</code></pre>
Вывод:

<div class="terminal">16</div>
Метод <span class="code">getNumber</span> возвращает значение типа <span class="code">int</span>, поэтому мы можем вызывать его из выражения.

Также метод может возвращать любой тип, включая те, которые вы создали сами.

Если вы указали тип возвращаемого значения у метода, то вы обязаны вернуть что-либо. Нельзя написать так:

<pre class="language-java line-numbers"><code>
    	   public static int findMaxNumber(int a, int b) {
      	if(a&gt;b) {
      	    return a;
      	}
     }
</code></pre>
Компилятор будет ругать вас, что при выполнении первого условия вы что-то возвращаете, а при выполнении второго — нет.<h2>Передача параметров</h2>В метод можно передавать параметры, которые используются при его работе. Самый примитивный пример — суммирование двух чисел. Но мы же не примитивные, верно?

Возьмем другой пример, достаточно стереотипный.

Допустим, у нас есть метод <span class="code">chef()</span> — повар. Мы можем передать в блоке параметров в этот метод ингредиенты супа, и в итоге этот метод возвращает нам суп.

Вот так:

<pre class="language-java line-numbers"><code>
	public static void main(String[] args) {
    	String[] ingredients;
    	// Инициализация массива ингредиентов
    	Soup soup = chef(ingredients);
    	
	}
	
	public static Soup chef(String[] ingredients) {
    	Soup soup = new Soup();
    	// Процесс варки супа
    	return soup;
	}
</code></pre>
(Допустим, у нас есть заранее созданный класс <span class="code">Soup</span>)

В главном методе мы создаем массив ингредиентов, а затем “отдаем его повару” (передаем в метод <span class="code">chef</span>). “Повар варит суп”, а затем возвращает его нам в виде объекта класса <span class="code">Soup</span>. Все очень просто.

В метод можно передавать любые параметры, примитивные типы, объекты, массивы и так далее.<h3>Передача параметров по ссылке и по значению</h3>В языке программирования Java любые параметры передаются в метод по своему значению. Однако для примитивных типов и для объектов этот механизм различен.

Если вы передадите в метод любой примитивный тип и измените его, он не изменится в основном методе. Вы просто отдали копию значения, а оригинальная переменная сохранилась. Самый простой пример:

<pre class="language-java line-numbers"><code>
public static void main(String[] args) {
    	int x = 1;
    	System.out.println(x);
    	getNumber(x);
    	System.out.println(x);
    	
	}
	
	public static void getNumber(int i) {
    	i = i + 100;
	}
</code></pre>
Вывод:

<div class="terminal">1
1</div>
 Однако в случае с объектами изменения затрагивают оригинальный объект:

<pre class="language-java line-numbers"><code>
public class Program
{
	public static void main(String[] args) {
    	WiseMan wiseMan = new WiseMan();
    	wiseMan.setIq(300);
    	System.out.println(wiseMan);
    	changeObject(wiseMan);
    	System.out.println(wiseMan);
    	
	}
	
	public static void changeObject(WiseMan m) {
    	m.setIq(100);
	}
}

public class WiseMan {
	int iq;
	
	public void setIq(int iq) {
    	this.iq = iq;
	}
	
	public int getIq() {
    	return iq;
	}
	
	public String toString() {
    	return "Our wise man has an IQ "+iq;
	}
}
</code></pre>
Вывод:

<div class="terminal">Our wise man has an IR 300
Our wise man has an IR 100</div>
У нас есть класс <span class="code">WiseMan</span> (Мудрец), который имеет свойство <span class="code">iq</span>. И два метода, которые управляют значением этого поля. В главном методе мы создаем объект <span class="code">wiseMan</span>, устанавливаем значение <span class="code">iq 300</span>. Затем мы передаем в метод <span class="code">changeObject</span> нашего мудреца с iq 300. Но в этом методе он глупеет. Мы устанавливаем значение <span class="code">iq</span>, равное 100. Затем в главном методе выводим объект. Видно, что в методе <span class="code">changeObject</span> мы манипулируем другим мудрецом в переменной <span class="code">m</span>. Однако мы изменяем наш первоначальный объект.

Дело в том, что объект <span class="code">wiseMan</span> в главном методе и объект <span class="code">m</span>, в методе <span class="code">changeObject</span> — один и тот же мудрец, а в метод в качестве параметра копируется ссылка на объект.

Помните об этом, когда будете редактировать объект в отдельных методах.<h2>Напоследок несколько слов о модификаторе static</h2>Вообще, несколькими словами здесь не обойтись, но я попробую.

Обычные методы, не помеченные данным модификатором, принадлежат объекту класса. А <span class="code">static</span>-методы принадлежат самому классу.

Обычные методы можно использовать у отдельных объектов. Посмотрите на класс <span class="code">WiseMan</span> из примера выше. Методы <span class="code">getIq</span> и <span class="code">setIq</span> у каждого мудреца будут свои, ведь уровень айкью у всех разный.

Если мы добавим в этот класс <span class="code">static</span> метод <span class="code">generateAWisePhrase</span>, то такой метод мы сможем вызывать без объекта:
 
<pre class="language-java line-numbers"><code>
WiseMan.generateAWisePhrase();
</code></pre>
В общем, этой информации пока достаточно, ведь о <span class="code">static</span> можно написать несколько лекций.

Придерживайтесь нескольких правил при написании метода для поддержания порядка в своем коде:<ul>

<li>Придумывайте своим методам говорящие названия, чтобы было ясно, что они делают.</li>
<li>Старайтесь не писать очень длинных методов. Оптимальная длина — 8-15 строк.</li>
<li>Количество параметров метода не должно превышать 4-5.</li>
<li>Если в вашем коде дважды встречается похожий функционал, подумайте: может, стоит обобщить, вынести его в отдельный метод?</li>

</ul>Эти способы помогут вам повысить производительность вашей программы и, самое главное, сделают ваш код более читабельным.