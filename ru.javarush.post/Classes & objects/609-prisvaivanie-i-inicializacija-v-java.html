Присваивание и инициализация в Java
<p>----------------------------------------</p>
Сказ о том, как переменным присваивать присваиваемое и не присваивать неприсваиваемое. О том, какие бывают переменные и почему это важно. Основное предназначение компьютерных программ - обработка данных. Чтобы обработать данные нужно их как-то хранить. Предлагаю ...
<p>----------------------------------------</p>
<h2>Вступление</h2>Основное предназначение компьютерных программ - обработка данных.
Чтобы обработать данные нужно их как-то хранить. Предлагаю разобраться с тем, как происходит хранение данных.
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="bcefb1cb-a4fc-47e0-9298-f3620e515d4e" data-max-width="700" alt="Присваивание и инициализация в Java - 1" src="https://cdn.javarush.com/images/article/bcefb1cb-a4fc-47e0-9298-f3620e515d4e/1024.jpeg"></div></div><h2>Переменные</h2><strong>Переменные</strong> (variables) - это контейнеры, которые хранят какие-либо данные. 
Посмотрим официальный Tutorial от Oracle : <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html" target="_blank" rel="nofollow">Declaring Member Variables</a>.

Согласно данному Tutorial, существует несколько типов переменных:
<ul>
<li><strong>Поля</strong> (fields) : переменные, объявленные в классе;</li>
<li><strong>Локальные переменные</strong> (local variables) : переменные в методе или в блоке кода;</li>
<li><strong>Параметры</strong> (parameters) : переменные в объявлении метода (в сигнатуре).</li>
</ul>
Все переменные должны иметь тип переменной и название переменной.
<ul>
<li><strong>Тип переменной</strong> показывает, какие данные представляет данная переменная (т.е. какие данные может хранить). Как мы знаем, тип переменной может быть <strong>примитивным</strong> (primitives <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="nofollow">primitives</a>) или <strong>объектным</strong>, не примитивными (Non-primitive). При объектных переменных их тип описывается определённым классом.</li>
<li><strong>Название переменной</strong> должно быть с маленькой буквы, в camel case. Подробнее про именование можно прочитать в "<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming" target="_blank" rel="nofollow">Variables:Naming</a>".</li>
</ul>
Так же если переменная уровня класса, т.е. является полем класса, то для неё может указываться модификатор доступа. Подробнее см. <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html" target="_blank" rel="nofollow">Controlling Access to Members of a Class</a>.
<h2>Объявление переменной (Declaration)</h2>Итак, мы вспомнили, что такое переменная. Для того, чтобы с переменной начать работать нужно её объявить. Для начала, разберёмся с локальной переменной.

Вместо IDE для удобства воспользуемся онлайн решением от tutorialspoint: <a href="https://www.tutorialspoint.com/compile_java_online.php" target="_blank" rel="nofollow">Online IDE</a>. Выполним в их online IDE вот такую простенькую программку:

<pre class="lang-java line-numbers"><code>
public class HelloWorld{
    public static void main(String []args){
        int number;
        System.out.println(number);
    }
}
</code></pre>
Итак, как видно, мы объявили локальную переменную с именем <code>number</code> и типом <code>int</code>. Нажимаем кнопку «Execute» и получаем ошибку:

<pre class='lang-java line-numbers'><code>
HelloWorld.java:5: error: variable number might not have been initialized
        System.out.println(number);
</code></pre>
Что же произошло? Мы объявили переменную, но значение её не инициализировали. Стоит заметить, что ошибка эта произошла не в момент выполнения (т.е. не в Runtime), а в момент компиляции. Умный компилятор проверил, будет ли локальная переменная инициализирована до обращения к ней или нет.
Поэтому, из этого следует следующие утверждения:
<ul>
<li>Обращение к локальным переменным должно быть выполнено только после того, как они будут инициализированы;</li>
<li>Локальные переменные не имеют значений по умолчанию;</li>
<li>Проверка значений локальных переменных выполняется в момент компиляции.</li>
</ul>
Итак, нам говорят, что переменная должна быть проинициализирована.
Инициализация переменной – присвоение переменной значения. Давайте тогда разбираться, что это и почему.
<h2>Инициализация локальной переменной</h2>Инициализация переменных одна из самых мудрёных тем в Java, т.к. очень тесно связана с работой с памятью, с реализацией JVM, спецификацией JVM и другими не менее страшными и хитрыми вещами. Но можно попробовать разобраться хоть в какой-то мере. Пойдём от простого к сложному.

Чтобы инициализировать переменную воспользуемся оператором присваивания и изменим строчку в нашем прошлом коде:

<pre class="lang-java line-numbers"><code>
int number = 2;
</code></pre>
В таком варианте ошибок не будет и на экран выведется значение.

Что же происходит в этом случае? Давайте попробуем порассуждать. Если мы хотим присвоить переменной какое-то значение, значит мы хотим, чтобы эта переменная хранила значение. Получается, что значение где-то должно храниться, но где? На диске? Но это очень медленно и может на нас накладывать ограничения. Получается, единственное, где мы можем быстро и эффективно хранить данные «здесь и сейчас» это память. Значит, нам нужно выделить в памяти какое-то место.

Так и есть. При инициализации переменной под неё будет выделено место в памяти, отведённой java процессу, в рамках которого будет выполняться наша программа. Память, выделяемая java процессу, разделена на несколько областей или зон. В какой из них будет выделено место зависит от того, какого типа была объявлена переменная.

<strong>Память разделяется на следующие разделы: Heap, Stack и Non-Heap</strong>.

Начнём со стэковой памяти. <strong>Stack</strong> переводится как стопка (например, стопка книг). Представляет собой LIFO структуру данных (Last In, First Out). То есть как стопка книг. Когда мы добавляем в неё книги – мы кладём их сверху, а когда забираем – берём верхнюю (т.е. ту, которая добавлена самой последней).

Итак, мы запускаем нашу программу. Как мы знаем, Java программу выполняет JVM, то есть виртуальная Java машина. JVM должна знать то, откуда должно начаться выполнение программы. Для этого мы объявляем main метод, который называется «точкой входа». Для выполнения в JVM создаётся основной поток (Thread). При создании потока ему выделяется свой стэк в памяти. Этот стэк состоит из фрэймов. При выполнении каждого нового метода в потоке под него будет выделен новый фрэйм и добавлен на вершину стэка (как новая книжка в стопке книг). Этот фрэйм будет содержит ссылки на объекты и примитивные типы. Да да, наш int будет храниться в стэке, т.к. int это примитивный тип. Прежде чем выделить фрэйм JVM должна понимать, что туда сохранять. Именно по этой причине мы получим ошибку «variable might not have been initialized», ведь если она не инициализирована, то JVM не сможет нам подготовить стэк. Поэтому при компиляции программы умный компилятор поможет нам не допустить ошибку и не сломать всё.

<strong>(!)</strong> Для наглядности советую <strong>супер-пупер</strong> статью: "<a href="https://www.guru99.com/java-stack-heap.html" target="_blank" rel="nofollow">Java Stack and Heap: Java Memory Allocation Tutorial</a>".

В ней ссылаются на не менее крутое видео:

<div class="row">
<div class="col col-md-10 col-lg-8">
<div class="embed-responsive embed-responsive-16by9">
<iframe width="560" height="315" src="https://www.youtube.com/embed/450maTzSIvA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
</div>
</div>
После завершения выполнения метода из стэка потока будут удаляться фрэймы, выделенные под эти методы, а вместе с ними и очищаться память, выделенная под этот фрэйм со всеми данными.
<h2>Инициализация локальных объектных переменных</h2>Давайте опять изменим наш код на чуть более хитрый:

<pre class="lang-java line-numbers"><code>
public class HelloWorld{

    private int number = 2;
    
    public static void main(String []args){
        HelloWorld object = new HelloWorld();
        System.out.println(object.number);
    }
    
}
</code></pre>
Что же тут будет происходить? 

Давайте ещё раз рассуждать. JVM узнает о том, откуда ей выполнять программу, т.е. она видит main метод. Она создаёт поток, под него выделяет память (потоку ведь надо где-то хранить данные, которые нужны для выполнения). В этом потоке выделяется фрэйм под метод main. Далее мы создаём объект HelloWorld. Этот объект уже создаётся не в стэке, а в хипе. Потому что object у нас не примитивный тип, а объектный. А в стэке будет храниться только ссылка на объект в хипе (мы ведь как-то должны обращаться к этому объекту). Далее в стэке метода main будут выделены фрэймы для выполнения метода println. После выполнения метода main будут уничтожены все фрэймы. При уничтожении фрэйма будут уничтожены все данные. Объект object не будет уничтожен сразу. Сначала на него будет уничтожена ссылка и таким образом на объект object больше никто ссылаться не будет и доступа больше к этому объекту в памяти будет не получить. Умная JVM имеет свой механизм для такого – сборщик мусора (garbage collector или сокращённо GC). Он то и удаляет из памяти такие объекты, на которые больше никто не ссылается.

Данный процесс опять же был описан в ссылке, что была приведена выше. Там даже видео есть с объяснением.
<h2>Инициализация полей</h2>Инициализация полей, указанных в классе происходит особым образом в зависимости от того, является ли поле статическим или нет. Если у поля стоит ключевое слово static, то данное поле относится к самому классу, а не слово static не указано, то данное поле относится к экземпляру класса. Давайте рассмотрим это на примере:

<pre class="lang-java line-numbers"><code>
public class HelloWorld{
    private int number;
    private static int count;
    
    public static void main(String []args){
        HelloWorld object = new HelloWorld();
        System.out.println(object.number);
    }
}
</code></pre>
В данном примере, инициализация полей происходит в разное время. Поле number будет инициализировано после того, как будет создан объект object класса HelloWorld. А вот поле count будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной. Загрузка классов – это отдельная тема, поэтому не будем сюда примешивать её. Просто стоит знать, что статические переменные инициализируются тогда, когда о классе становится известно при выполнении.

Тут важнее другое и Вы уже это заметили. Мы нигде не указали значения, а оно работает. И действительно. Переменные, которые являются полями, если для них не указано значение, то они инициализируются значением по умолчанию. Для числовых значением это 0 или 0.0 для чисел с плавающей точкой. Для boolean это false. А для всех переменных объектных типов значение будет null (об этом мы ещё поговорим).

Казалось бы, а почему так? А потому, что объекты создаются в Heap (в куче). Работа с данной областью выполняется в Runtime. И мы в runtime можем инициализировать эти переменные, в отличии от стэка, память под который должна быть подготовлена ещё до выполнения. Так устроена работа с памятью в Java.

Но есть тут и ещё одна особенность. В этом маленьком кусочке затрагиваются разные уголки памяти. Как мы помним, в Stack памяти под метод main выделяется фрэйм. В этом фрэйме хранится ссылка (reference) на объект в Heap памяти. Но где тогда хранится count? Как мы помним, эта переменная инициализируется сразу, до создания объекта в хипе. Вот тут действительно хитрый вопрос. До Java 8 существовала область памяти, называемая PERMGEN. Начиная с Java 8 эта область претерпела изменения и называется METASPACE. По сути, статические переменные являются частью описания класса, т.е. его метаданными. Поэтому, логично, что хранится в хранилище метаданных, METASPACE. MetaSpace относится к той самой Non-Heap области памяти, является её частью.

Важно ещё учитывать то, что учитывается порядок, в котором объявлены переменные. Например, в этом коде ошибка:

<pre class="lang-java line-numbers"><code>
public class HelloWorld{
    
    private static int b = a;
    private static int a = 1;
    
    public static void main(String []args){
        System.out.println(b);
    }
    
}
</code></pre>
<h2>Что такое null</h2>Как было сказано выше, переменные объектных типов, если они являются полями класса, инициализируются значениями по умолчанию и таким значением по умолчанию является null. Но что же такое null в Java?

Первое что важно помнить – примитивные типы не могут быть null. А всё потому, что null – это особенная ссылка (reference), которая не ссылается никуда, ни на какой объект. Поэтому, только объектная переменная может быть равна null.

Второе, что важно понимать, что null – это ссылка, reference. Я reference тоже имеют свой вес. На эту тему можно почитать вопрос на stackoverflow: "<a href="https://stackoverflow.com/questions/2430655/java-does-null-variable-require-space-in-memory?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="nofollow">Does null variable require space in memory</a>".
<h2>Блоки инициализации</h2>Рассматривая инициализацию переменных грех не рассмотреть блоки инициализации. Выглядит это следующим образом:

<pre class="lang-java line-numbers"><code>
public class HelloWorld{
    
    static {
        System.out.println("static block");
    }
    
    {
        System.out.println("block");
    }
    
    public HelloWorld () {
        System.out.println("Constructor");
    }
    
    public static void main(String []args){
        HelloWorld obj = new HelloWorld();
    }
    
}
</code></pre>
Порядок вывода будет: static block, block, Constructor. Как мы видим, блоки инициализации выполняются раньше, чем конструктор. И иногда это может быть удобным средством для инициализации.
<h2>Заключение</h2>Надеюсь, этот небольшое обзор смог привнести понимание того, как это работает и почему. 

#Viacheslav