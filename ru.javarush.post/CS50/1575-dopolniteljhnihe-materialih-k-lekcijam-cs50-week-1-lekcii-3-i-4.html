Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4)
<p>----------------------------------------</p>


Задачи 1 недели

Цели первой недели

    Ознакомиться с основными командами Linux
    Изучить основной синтаксис C и решить несколько задач  
    Нача
<p>----------------------------------------</p>
<img data-id="e3237b9e-ac01-4e02-a0b1-0507942d7214" data-max-width="740" alt="cs50 на русском дополнительные материалы" src="https://cdn.javarush.com/images/article/e3237b9e-ac01-4e02-a0b1-0507942d7214/1024.jpeg">

<a href="http://info.javarush.ru/Masha/2016/07/18/%D0%93%D0%B0%D1%80%D0%B2%D0%B0%D1%80%D0%B4-CS50-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B9-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B8-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8-3-%D0%B8-4-.html">Задачи 1 недели</a>

<h4 id = "#goals">Цели первой недели</h4>
<ul>
    <li>Ознакомиться с основными командами Linux</li>
    <li>Изучить основной синтаксис C и решить несколько задач</li>  
    <li>Начать мыслить четче =)</li> 
</ul>

<h5>IDE CS50</h5> 
Для выполнения заданий CS50 предлагает IDE (Integrated Development Environment, интегрированную среду разработки) в «облаке». Чтобы ею воспользоваться, создайте аккаунт на платформе edX, и зарегистрируйтесь на <a href="https://courses.edx.org/courses/course-v1:HarvardX+CS50+X/info" rel="nofollow" >оригинальный курс</a>. После этого:  
</br> 
    1. Заходим на cs50.io, из списка выбираем edX, вводим логин и пароль, жмем <strong>Submit</strong>
    2. Вводим данные своего edX-аккаунта, жмем <strong>Return to ID.CS50.NET</strong>.

<img data-id="4148a158-fca2-40fb-9a74-c2de63829484" data-max-width="684" alt="cs50.io" src="https://cdn.javarush.com/images/article/4148a158-fca2-40fb-9a74-c2de63829484/1024.jpeg">

    3. Ждем: создается ваше виртуальное пространство.

<img data-id="57edaa77-a943-49d1-94a2-5d2fee357aa1" data-max-width="740" alt="виртуальное пространство cs50" src="https://cdn.javarush.com/images/article/57edaa77-a943-49d1-94a2-5d2fee357aa1/1024.jpeg">

    4. Готово!

<img data-id="6c52dac2-9a3d-4557-9ffa-c33e328220a7" data-max-width="740" alt="cs50 ide" src="https://cdn.javarush.com/images/article/6c52dac2-9a3d-4557-9ffa-c33e328220a7/1024.jpeg">

<h5>Командная строка и запуск CS50 IDE</h5>  
В нижней части окна CS50 IDE во вкладке Terminal есть терминальное окно или панель командной строки. Сюда можно вводить строковые команды: вы сможете делать то же самое, что и с оконным интерфейсом, например, запускать приложения, удалять и создавать файлы, инсталлировать ПО.  

Если вы никогда не работали с командной строкой, вероятно, такой способ покажется громоздким: нужно помнить команды, набирать их текстом вместо того, чтобы щелкать по иконкам и кнопкам. В какой-то мере так и есть, затем оконный интерфейс и придумали. Однако командная строка есть во всех ОС и её обожают админы. А всё потому, что порой без неё никак.

В окне IDE в терминале вы увидите загадочную строку: <strong>username:~/workspace $</strong>
на месте «username» будет автоматически сгенерированное (на основе ваших регистрационных данных) имя. 

Кликните по окошку терминала, напечатайте: 

<code>update50</code>
Нажмите Enter. Команда просит систему обновиться. Вы увидите, как в терминале появляются строки, описывающие процесс установки. Не закрывайте CS50 IDE пока не увидите <strong>Update complete!</strong>.  

После этого снова появится строка по умолчанию, та, что с вашим именем. 

<h5>Работа в IDE</h5> 
Создадим папку, где будут лежать ваши файлы. Кликните правой кнопкой мыши по <strong>~/workspace</strong> (ваш корневой каталог) в левом верхнем углу <strong>CS50 IDE</strong>, выберите <strong>New Folder</strong>. Переименуйте папку в <strong>pset1</strong>(если вы ошиблись в имени, щелкните по вашей папке правой кнопкой и выберите <strong>Rename</strong>). 

<img data-max-width="229" alt="cs50 ide rename folder" src="https://cdn.javarush.com/images/article/8f8f100f-95c5-43ea-a57c-def8fa98fac2/original.jpeg">

Затем кликаем правой кнопкой по папке <strong>pset1</strong>, выбираем <strong>New File</strong>. Появляется файл Untilted, переименуем его в <strong>hello.txt</strong>. 

<img data-max-width="229" alt="cs50 ide" src="https://cdn.javarush.com/images/article/d4118710-8cdd-408c-981d-443b8ea23469/original.jpeg">

Дважды кликнете по hello.txt. В CS50 IDE справа вы увидите новую вкладку и поле, где можно печатать. Если вы это сделали, обратите внимание на появившуюся перед названием файла на вкладке символ звездочки (*) — индикатор того, что в файл были внесены, но не сохранены, изменения.   

<img data-id="a63981ef-95e9-4065-815c-63e1d3f907ec" data-max-width="630" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 1" src="https://cdn.javarush.com/images/article/a63981ef-95e9-4065-815c-63e1d3f907ec/1024.jpeg">

Сохраните файл, зайдя в меню <strong>*File > Save</strong> или с помощью клавиш <strong>command + S</strong> (на машинах Apple) или <strong>Ctrl + S</strong> (на ПК). Звездочка должна исчезнуть. 

Давайте проверим, лежит ли файл там, где должен. Сделаем это с помощью командной строки, пора к ней привыкать:). Как и ранее, активная строка в терминале выглядит так: 

<code>username:~/workspace $</code>

Workspace — текущая рабочая директория (та, что открыта в рабочей среде). Тильда (~) указывает на корневую директорию (в ней лежит workspace). Обратите внимание, что workspace в терминале — то же самое, что и иконка ~/workspace в левом верхнем углу CS50 IDE. 
Давайте попрактикуемся. Кликнете в каком-либо месте терминала и наберите в командной строке

<code>ls</code>
и нажмите Enter. Эти две строчные буквы — сокращение от "list" («список») — вызовут список файлов и папок, находящихся внутри текущей директории workspace. Среди всего прочего вы увидите и созданную вами <strong>pset1</strong>! Теперь откроем нашу папку с помощью команды. Набираем  

<code>cd pset1</code>
или многословнее: 

<code>cd ~/workspace/pset1</code>
Команда cd (change directory) меняет активную директорию, в нашем случае на 

<code>~/pset1</code> 
Активная строка поменялась на 

<code>username:~/workspace/pset1 $</code>
Это подтверждает, что вы теперь находитесь в директории 

<code>~/workspace/pset1</code>
(строка расшифровывается как «я нахожусь в pset1 внутри папки workspace, которая лежит в корневой папке, обозначаемой ~"). Теперь наберите 

<code>ls</code>
Вы увидите файл <strong>hello.txt</strong>! Если вы кликнете по названию в терминале, ничего не произойдет: это текст, и он не выдает активной ссылки, но подтверждает, что hello.txt находится там, где должен. Наберите 
<code>cd</code>
Если вы пишете только саму команду cd, но не подставляете аргумент (то есть имя папки, в которую ей нужно перейти), она вернет вас в корневую директорию по умолчанию. Таким образом, в активной строке вы увидите следующую картину: 

<code>username:~ $</code>
Чтобы вернуться назад в папку pset1, наберите

<code>cd workspace</code>
и нажмите Enter. Затем 

<code>cd pset1</code>
и снова Enter. Также вы можете заменить эти две команды одной, подлиннее: 

<code>cd workspace/pset1</code>

<h5>Hello, C!</h5> 
Наконец-то эта минута наступила! Начинаем программировать. Внутри нашей папки pset1 в IDE создаем файл под названием <strong>hello.c</strong> (расширение обязательно), открываем в новой вкладке (думаем, вы помните, как это делать из предыдущего параграфа). 

<strong>ВАЖНО!</strong> Буквы должны быть строчными, Linux чувствителен к регистру. Hello.c и hello.c — разные файлы. 

В правой части окна CS50 IDE набираем точь-в-точь такой текст, как вы видите ниже. Да, его можно скопировать, но полезнее — набрать. 

<code>#include <stdio.h>

int main(void)
{
    printf("hello, world\n");
}</code>
Буквы разного цвета потому, что в CS50 IDE работает подсветка синтаксиса. Она выделяет цветом блоки текста для лучшей читаемости. В самом файле цвета не сохраняются, они видны только в IDE. Если они есть, значит, IDE понимает C, а о том, что это именно C, вы сообщили в расширении файла (*.c). Если бы вы назвали тот же файл hello.txt, текст был бы одноцветный.  

Убедитесь, что вы напечатали всё ровно так, как в примере, иначе поймаете первый баг=). Снова обращаем ваше внимание на разницу между строчными и прописными буквами. Символ \n переводит курсор на следующую строку, и введенный следом текст не слипнется с выведенным программой. Ах да, и о точке с запятой (;) не забывайте. Это важный разделитель операторов программы, C без них работать не захочет. 

Нажмите <strong>File > Save</strong> (или комбинацию command- или Ctrl-s). Заметили, что звездочка перед названием файла исчезла? Если да, значит изменения сохранились. Кликните в любом месте по терминальному окну под вашим кодом и убедитесь, что вы внутри <strong>~/workspace/pset1</strong> (если это не так, кликните cd и нажмите Enter, затем cd workspace/pset1 и снова Enter). Ваша активная строка должна выглядеть так: 

<code>username:~/workspace/pset1 $</code>
Убедимся, что файл <strong>hello.c</strong> находится ровно там, где должен. Набираем

<code>ls</code>
и жмем Enter. Вы видите и hello.c? Если нет, вернитесь на пару шагов назад и создайте файл в нужной директории еще раз.
… Теперь наступает торжественный момент: скрещиваем пальцы и… печатаем: 

<code>make hello</code>
и скрещенными же пальцами жмем Enter. Именно hello, не hello.c. Если все, что вы после этого действа перед собой увидели — вторая активная строка, которая выглядит точь-в-точь, как предыдущая, значит, всё работает! Ваш исходный код был переведен в машинный или объектный код (то есть, в последовательности 0 и 1). Теперь этот код можно выполнить (то есть запустить программу!). Для этого печатаем:  

<code>./hello</code>
в командной строке, жмем Enter. Если вы не меняли заключенный между "" текст, ниже вы увидите:

<code>hello, world</code>
Если вы теперь наберете команду 

<code>ls</code>
и нажмете Enter, вы увидите новый файл hello, наряду с hello.c и hello.txt. У первого hello, должна быть звездочка после имени, которая сигнализирует о том, что это исполняемый файл, то есть такой, с помощью которого вы запускаете программу. 

<h5>Баги?</h5> 
Если после команды make, вы увидели ошибки, пришло время первой отладки! Надписи вроде «expected declaration» означают, что вы где-то допустили опечатку. Сверьте код с приведенным выше еще раз, только будьте очень внимательны ко всем деталям.  

<strong>Внимание!</strong> Описания ошибок выдаются на английском. Если непонятно, воспользуйтесь поисковиком, Google Translate или задайте вопрос в комментарии. 

Как только вы исправили ошибки, не забудьте сохранить ваш код с помощью <strong>File > Save</strong> (или command- или Ctrl-s), снова щелкнете по внутренней части терминального окна и наберите 

<code>make hello</code>
(Только предварительно убедитесь, что вы находитесь в директории ~/workspace/pset1). Если больше ошибок нет, запускайте программу, набирая команду 

<code>./hello</code>
По идее перед вами должна возникнуть заветная фраза, заключенная в кавычки оператора printf, который командует «напечатай». 

Если окно терминала кажется вам слишком маленьким, кликните по иконке заключенного в окружности плюса (+), расположенной рядом с hello.c.

<h5>Проверка на правильность</h5>

В CS50 IDE встроено приложение check50. Оно работает из командной строки и проверяет некоторые из программ на наличие ошибок. 

Если вы еще не там, перейдите в директорию ~/workspace/pset1 выполнив в терминале команду: 

<code>cd ~/workspace/pset1</code>
Теперь выполните 

<code>ls</code>
вы увидите, по меньшей мере, файл hello.c. Убедитесь, что название файла выглядит именно так, а не, скажем, Hello.c или hello.C. Переименовать файл можно, выполнив команду 

<code>mv source destination</code>
source — текущее имя файла, destination — новое имя файла. mv (от англ. move) — утилита для переименования. Если вы случайно назвали файл Hello.c, наберите строку: 

<code>mv Hello.c hello.c</code>
Убедившись, что файл точно называется hello.c вызовем проверочную программу check50. Обратите внимание, что 2015.fall.pset1.hello —уникальный идентификатор для задачки “hello world”. 
check50 2015.fall.pset1.hello hello.c

Если программа выполнена правильно, вы увидите: 

<img data-id="d40b2da7-25f6-40d7-ab89-c4cbe33ec566" data-max-width="441" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 2" src="https://cdn.javarush.com/images/article/d40b2da7-25f6-40d7-ab89-c4cbe33ec566/1024.jpeg">

Зеленые смайлики означают, что тест пройден. Также можете видеть URL внизу вывода check50, но он нужен только сотрудникам (впрочем, если интересно, заходите!).

check50 запускает 3 теста: существует ли файл hello.c, компилируется ли hello.c и выдает ли приложение строку, в которой написан текст "hello, world\n".   
Если вы увидите грустные красные смайлики, значит у вас баг. 

<code>:( hello.c exists
  \ expected hello.c to exist
:| hello.c compiles
  \ can't check until a frown turns upside down
:| prints "hello, world\n"
  \ can't check until a frown turns upside down
</code>
Здесь check50 не нашел hello.c, и красный смайлик сигнализирует, что вы либо ошиблись в имени, либо загрузили файл не туда. Жёлтые «нейтральные» смайлы означают, что тесты не запустились. И откуда им запуститься, если программа не нашла файл, который нужно проверить? 

Вот еще один вариант, который выскочит в том случае, если вы меняли текст, который должна вывести функция printf(): 

<code>:) hello.c exists
:) hello.c compiles
:( prints "hello, world\n"
  \ expected output, but not "hello, world"
</code>
check50 сообщает, что ожидалась строка hello, world\n, но появилось что-то другое. 
check50 не считает баллы за прохождение курса, но проверяет, отличается ли результат выполнения задания от ожидаемого. И позволяет вам убедиться в этом прежде, чем подтвердить правильность задачи внутри курса (как это сделать, мы расскажем позднее). 

<h5>Основы С: сравнение со Scratch</h5> 
<h6>Hello world на Scratch и C:</h6>

<img data-id="b371e02b-93f6-49b3-90d7-fb9dd0267d80" data-max-width="344" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 3" src="https://cdn.javarush.com/images/article/b371e02b-93f6-49b3-90d7-fb9dd0267d80/1024.jpeg">

<code>#include <stdio.h>
int main(void)
{
    printf("hello, world\n");
}</code>
<ul>
    <li><img data-max-width="62" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 4" src="https://cdn.javarush.com/images/article/576f71b0-6a06-4683-9fe8-47ac5f966893/original.jpeg"> представляет функцию, которая печатает «слова» спрайта в облачке комикса в Scratch, в C есть функция printf, которая делает то же самое, только без мультиков.</li>
    <li>main — по-английски — «главная». Точка входа в программу. То же самое, что <img data-max-width="127" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 5" src="https://cdn.javarush.com/images/article/b04077a5-06f0-4210-aeeb-1e87ed5a0171/original.jpeg">.</li>
</ul>

<h6>Бесконечный цикл</h6> 
<img data-id="c8d90434-4347-4614-bfed-ea03be77a42f" data-max-width="271" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 6" src="https://cdn.javarush.com/images/article/c8d90434-4347-4614-bfed-ea03be77a42f/1024.jpeg">

в переводе на C: 

<code>while (true)
{
    printf("hello, world\n");
}</code>
while (true) делает то же самое: цикл продолжает свою работу пока (while) значение true (булевское выражение «правда» или «единичка»). Такой цикл будет выполнятся бесконечно. 

<h6>Цикл, выводящий фразу на экран 10 раз</h6>
<strong>Scratch</strong> 
 
<img data-id="0e6e10b4-57c3-48bd-8448-97a76fc4d6e1" data-max-width="281" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 7" src="https://cdn.javarush.com/images/article/0e6e10b4-57c3-48bd-8448-97a76fc4d6e1/1024.jpeg">

<strong>С</strong> 

<code>for (int i = 0; i < 10; i++)
{

    printf("hello, world!\n");
}</code>
i — переменная-счетчик, её значение меняет оператор инкремента i++, увеличивая его на 1 при каждом витке цикла. Изначально i присваивается значение 0 с помощью оператора присваивания =. 

<strong>Внимание!</strong> <em>Как и в Java, в C равенство обозначается ==, оператор присваивания =. 
То есть, a = 5 означает, что переменной a присвоили значение 5, а (a= =5) означает булонское выражение (если а равно 5, то выражение правдиво, если не равно, то ложно).</em>  

Цикл остановится, когда i «дорастет» до 9. Несложно посчитать, цикл выполнится 10 раз. 

Таким образом, если вам нужно повторить что-то определенное количество раз, в C вы задаете цикл for (int i = 0; i < 10; i++). 
 
<strong>Еще один пример:</strong> 

<img data-id="fc692af9-1a60-4504-a4c8-2a8315204aa1" data-max-width="359" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 8" src="https://cdn.javarush.com/images/article/fc692af9-1a60-4504-a4c8-2a8315204aa1/1024.jpeg">
 
И то же самое в переводе на C: 

<code>int counter = 0;
while (true)
{
    printf("%i\n",  counter); 

    counter++;
}</code>
<ul>
    <li>counter сохраняет значение в C и Scratch. В С задаем int counter = 0 вместо <img data-id="b440590e-488b-443a-8121-fdf1cc131678" data-max-width="274" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 9" src="https://cdn.javarush.com/images/article/b440590e-488b-443a-8121-fdf1cc131678/1024.jpeg">.</li> 
    <li>Помечаем тип переменной как int для уточнения: i — целое число (от англ. integer, целый).</li>
    <li>Значок %i, который мы используем в printf в четвертой строке — заполнитель, говорящий о том, что мы должны напечатать десятичное целое, точно так же, мы говорим printf заменить заполнитель на значение, которое принимает переменная counter.</li>
</ul>

<h6>Булевы выражения</h6>

<img data-id="021cfb41-3d5f-4d5d-b403-fe6969b38855" data-max-width="412" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 10" src="https://cdn.javarush.com/images/article/021cfb41-3d5f-4d5d-b403-fe6969b38855/1024.jpeg">

Это то же самое, что 

<code>(x < y)
((x < y) && (y < z))</code>

<h6>Условия</h6>

<img data-id="8e5a5854-d3c6-40bc-8549-51fb2fa1acda" data-max-width="392" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 11" src="https://cdn.javarush.com/images/article/8e5a5854-d3c6-40bc-8549-51fb2fa1acda/1024.jpeg">

И «сишный» эквивалент: 

<img data-id="99dc8cfb-bd5d-4c18-8edd-47f5d620f315" data-max-width="491" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 12" src="https://cdn.javarush.com/images/article/99dc8cfb-bd5d-4c18-8edd-47f5d620f315/1024.jpeg">

А что насчет первой непонятной фразы? 

<code>#include <stdio.h></code>

Об этом позднее, в разделе «Библиотеки»

<h6>Условные операторы</h6>  
Эти ребята проверяют, выполняется ли некоторое условие (логическое выражение, вопрос, на который можно ответить только «да» или «нет»), и если это так, то исполняют некоторые действия, привязанные к этому условию. Пример из жизни: если пошел дождь (при условии, что пошел дождь) и я на улице (я во время дождя нахожусь на улице), я открываю зонтик.   

<code>if (условие) 
{
  //исполнить, если значение истинно
}</code>
Усложненный вариант: если условие выполняется, сделать действие, если нет — сделать другое действие. 

<code>if (условие) 
{
  //выполнить действие
}
else 
{
  //выполнить другое действие, если условие ложно 
}</code>
Пример: если тебе больше 18, одобрить доступ. Если меньше, не одобрить. 

<img data-id="71d0fe2c-a39b-49b7-96c9-3209cd5eb32f" data-max-width="378" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 12" src="https://cdn.javarush.com/images/article/71d0fe2c-a39b-49b7-96c9-3209cd5eb32f/1024.jpeg">

<h6>Оператор выбора</h6> 
<code>switch (n)
{
  case const1:
    // если n равен const1, выполнить
    break; // условие совершилось — выйти из выбора
  case const2:
    // если n равен const2, выполнить
    break;
   ...
  default:
    // если n не равен ни одной из констант, выполнить
    break;
}</code>
Пример: если n = 50, напечатать "CS50 is Introduction to Computer Science I", если n = 51, напечатать "CS51 is Introduction to Computer Science II", иначе — напечатать "Sorry, I'm not familiar with that class!"

<code>switch (n)
{
  case 50:
    printf("CS50 is Introduction to Computer Science I\n");
    break;
  case 51:
    printf("CS51 is Introduction to Computer Science II\n");
    break;
  default:
    printf("Sorry, I'm not familiar with that class!\n");
    break;
}</code>
<h6>Циклы</h6>
while: проверяет условие, затем исполняет действие, пока условие истинно

<code>while (условие)
{
  // выполнять, пока истина 
}</code>
do/while отличается тем, что первый раз он исполняет действие без проверки условия, а затем только проверяет его. Если условие выполняется, он повторяет действие, пока условие не станет ложью. 

<code>do
{
)  // выполнять, пока истина
}
while (условие);</code>
Цикл for повторяет действие заданное количество раз 

<img data-id="455f6072-2928-4e83-afcf-5c0ed5b74e13" data-max-width="582" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 13" src="https://cdn.javarush.com/images/article/455f6072-2928-4e83-afcf-5c0ed5b74e13/1024.jpeg">

Циклы можно вкладывать один в другой. В таком случае на каждом шаге внешнего цикла будет полностью выполнятся внутренний цикл. 

<img data-id="a6146862-5037-4e12-97b4-7c8f6b3c65e9" data-max-width="526" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 14" src="https://cdn.javarush.com/images/article/a6146862-5037-4e12-97b4-7c8f6b3c65e9/1024.jpeg">

<h5>Основные типы данных в C</h5>

<img data-id="41b34ecf-b604-48ca-bbb7-854b32ffe270" data-max-width="740" alt="основные типы данных в C" src="https://cdn.javarush.com/images/article/41b34ecf-b604-48ca-bbb7-854b32ffe270/1024.jpeg">

<h6>Библиотеки С</h6> 
Вы, наверное, уже задались вопросом, что означает первая строка программы на C: 

<code>#include <stdio.h></code>
Какова её роль и можно ли обойтись без неё? 

Строка #include делает очень важную вещь: она подключает библиотеки уже написанного кода к вашей программе. 

Имя подключенной библиотеки идет в угловых скобках (<>) и носит расширение (.h). Если бы не было библиотек, то любое, самое элементарное действие, пришлось бы каждый раз описывать снова и снова. Подключенная нами библиотека <stdio.h> содержит функции ввода/вывода. Именно она позволяет нам использовать функцию printf () для вывода на экран. То есть, если бы мы не написали строку #include <strong><stdio.h></strong>, но оставили в теле программы функцию printf (), при попытке запуска мы бы получили ошибку! Потому что без этой библиотеки компилятор не знает, что такое printf (). 

Есть библиотеки стандартные, они составляют словарный запас языка. Функция printf() не встроена в компьютер, но входит в стандартную библиотеку языка C. То есть некий программист ранее написал её и включил в библиотеку. Теперь другие могут ею пользоваться, не изобретая велосипед. Чтобы компилятор её «понял», подключаем <stdio.h>. 

Есть и другие стандартные библиотеки, используемые в процессе прохождения CS50. Например, библиотека строк, где описаны операции со строками (определение длины, сложение и прочее).

По сравнению с другими популярными языками программирования, количество стандартных библиотек C очень невелико. Но есть самописные, чаще всего — более узкоспециализированные библиотеки. Так, библиотека <cs50.h> была создана специально для студентов CS50. 

<strong>Самое время сделать важное замечание:</strong> помимо написания программ, решения задач с помощью собственного кода, хороший разработчик обладает еще одним важным навыком: знанием инструментов, уже написанных и умением использовать их (чужие библиотеки), чтобы не тратить время на изобретение «колеса».

Так, если вы находитесь в процессе решения нудной или сложной задачи, которая при этом кажется довольно распространенной, приучайтесь задавать себе вопрос: «а не написал ли её решение кто-нибудь другой?» Велики шансы, что так оно и есть, и вы можете найти эту функцию в существующей библиотеке.

В технических терминах, библиотека — это двоичный файл, полученный путем объединения в коллекцию объектных файлов, используя компоновщик. Объектные файлы — это те файлы с расширением (*.o), которые вы получаете при компиляции приложений. 

<h6>Структура библиотек C</h6>
Когда программист пишет библиотеку, код распределяется по двум типам файлов — заголовочный файл (header, расширение *.h) и файл реализации (implementation, расширение *.c). Заголовочный файл содержит код, описывающий ресурсы библиотеки, которые вы можете использовать. То есть описания переменных, функций, структур, типов и прочее. Если вам интересно, что содержит та или иная библиотека, нужно заглянуть именно в заголовочный файл. В терминале CS50 IDE (и других средах Linux) вы можете вызвать приложение less для просмотра файлов и открыть с его помощью интересующую вас библиотеку: 

<code>less /usr/include/stdio.h</code>
Файл откроется прямо в терминале. Правда, для новичков он будет очень трудночитаемым. 

<img data-id="1d178892-963f-4ff1-b671-23a10a24bcb9" data-max-width="740" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 15" src="https://cdn.javarush.com/images/article/1d178892-963f-4ff1-b671-23a10a24bcb9/1024.jpeg">
 

Чтобы выйти из less, нажмите q на клавиатуре. Заголовочный файл не содержит код функций, что служит примером очень важного понятия — сокрытия данных или инкапсуляции. Пользователю системы незачем знать «внутренности» библиотек, ему достаточно, чтобы она работала. Если вы прошерстите stdio.h, то не найдете там реализации printf(), хотя как её использовать, вы уже знаете. 

Это сделано для того, чтобы защитить данные от вмешательства, которое порой может плохо отразиться на системе. Так, если кто-то изменит реализацию функции printf() в библиотеке, это отразится на всех тех программах, которые её используют. 

Любознательным будет интересно, где спрятана реализация. Согласно конвенции (соглашения, принятые в мире программирования) такой код хранят в файле с расширением (*.c). После компиляции библиотеки на основе двух файлов с одинаковым именем, но разным расширением создается объектный файл, который собран так, чтобы создать файл с двоичным кодом библиотеки.  

<img data-id="8a831116-28b2-49d8-9f9f-801bada19736" data-max-width="593" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 16" src="https://cdn.javarush.com/images/article/8a831116-28b2-49d8-9f9f-801bada19736/1024.jpeg">

Автор библиотеки передает программисту, который хочет её использовать, два файла — с двоичным кодом, а также заголовочный файл. Таким образом, файл с исходным кодом программисту не нужен. Точнее, он может быть нужен, если программист хочет что-то поменять в самой библиотеке и перекомпилировать её под собственные нужды. 

Чтобы воспользоваться функциями библиотеки в своей программе нужно проделать следующее: 

1. Включить заголовочный файл в программу с помощью строки #include  
В случае стандартных библиотек достаточно указать имя библиотеки в угловых скобках: 

<code>#include <имя_библиотеки.h></code>
Если библиотека, которую вы хотите подключить, лежит в той же папке, что и ваша программа, подключайте её следующим образом: 

<code>#include “имя_библиотеки.h”</code>
2.Присоединить бинарный файл для компиляции. 
Это очень важный шаг, поскольку, как мы говорили выше, заголовочный файл не содержит реализации элементов библиотеки.  Чтобы это сделать, нужно вызвать компилятор clang с флагом –l и идущим непосредственно за ним названием библиотеки. Например, компонуем библиотеку cs50: 

<code>clang hello –lcs50</code>
Clang — один из компиляторов. Для компиляции можно также использовать уже знакомую вам программу make. По сути, она вызывает clang с определенными аргументами командной строки. 

<h5>И снова Hello C: разбор синтаксиса простейших программ</h5> 
Директива #include подключает библиотеку ввода/вывода <stdio.h>. 

Программы в C состоят из функций, а те — из операторов и переменных. Функция — это кусок кода, в котором уже есть или подаются какие-то данные, а какие-то данные получают в результате её исполнения. 

Фигурные скобки { } ограничивают тело функции — описание того, что она должна делать. 

printf() из стандартной библиотеки stdio выводит любую строку на экран. Строки заключаются в двойные кавычки, а символ “\n” означает перевод курсора на новую строку. 

Пример: функция «посчитать квадрат целого числа». Передаем функции данные, в нашем случае — число, которое нужно возвести в квадрат. Затем в ней прописывается алгоритм умножения числа на самое себя, и результат этого умножения она выдает на выходе. 

<code>int sqr(int a)
{
return a*a;   
}</code>
int sqr(int a) — название функции. В скобках — её аргумент a, это то, что подается на вход функции. Это как переменная в уравнении. То есть, если мы хотим узнать квадрат числа 5, то мы вызовем нашу функцию в виде sqr(5) и получим результат 25.    

int — тип данных (от англ. integer — целые числа). Наша функция написана так, что мы не можем вызвать её с аргументом a = 5.5. Такая попытка выдаст ошибку, поскольку 5.5 — число дробное, а наше число должно быть целым. int перед именем функции означает тип, который должна эта функция возвращать. Он не обязательно совпадает с типом аргумента. 
Пример: функция, которая отнимает от целого числа 0.5: 
         
<code>double bit_less(int a)
{
double b; 
b = a – 0.5; 
return b; 
}</code>
int main (void) — название главной функции. В одной программе может быть много функций, но, чтобы начать её выполнять, нужна функция под названием main. Слово void в скобках означает, что у этой функции нет аргументов.

<strong>Внимание!</strong> main всегда возвращает int, но return для неё не обязателен.

Пример функции не возвращающей значения: 

<code>void sayhello(void)
{
printf(“hello everyone!\n”); 
}</code>

При вызове функции в главной программе, она выведет приветствие. 

Давайте напишем одну программу, в которой будет несколько функций. Тех, что мы уже создали выше. Две созданные нами функции вызовем через главную функцию main(). 

В C, как и любом языке, есть такой элемент, как комментарий или примечание в коле программы, предназначенное не для компьютера, а для понимания людей. Например, описание, что именно делает код. Компилятор комментариев не видит. Комментирование программ — очень важный момент, поскольку порой разобраться в чужом (и даже своем) коде очень сложно. 

<code>//пример однострочного комментария 
/** а это – 
многострочного **/ 

#include <stdio.h> 
//функция возведения в квадрат числа a 
int sqr(int a)
{
return a*a;   
}
//выводит приветствие
void test(void) 
{
    printf ("hello everyone!\n"); 
}
//главная функция
int main(void) 
{
test(); 
printf("%d\n", sqr(5));    
}</code>
Почти всё, что есть в этой программе вы уже видели. Две функции — возведения в квадрат и приветствия и  главная функция main, где мы последовательно вызываем эти две функции. 

В результате выполнения программы у нас сначала выведется приветствие, на следующей строке — квадрат 5. Обратите внимание, функция test() вызывается с пустыми скобками, потому что её аргументы определены как void.

<h5>Еще немного о вводе/выводе в C</h5>  
Вы, наверное, уже успели заметить странные символы %d и %f в скобках оператора printf. 

Дело в том, что функция printf выводит данные в следующем обобщенном виде:

     <code>рrintf ("управляющая строка", аргумент1, аргумент2,...);</code>

Управляющая строка содержит компоненты трех типов: 
<ul>
    <li>символы, которые выводятся на экран дисплея;</li> 
    <li>спецификаторы преобразования, которые вызывают вывод на экран очередного аргумента из последующего списка;</li> 
    <li>управляющие символьные константы.</li>
</ul>

Спецификатор преобразования начинается со знака % и заканчивается символом, задающим преобразование. Некоторые из таких символов: 

<ul>
    <li>с: значением аргумента является символ;</li>
    <li>d или i: десятичное целое число;</li> 
    <li>f: десятичное число с плавающей точкой;</li>
    <li>s: строка символов.</li> 
</ul>

То есть, %d означает, что на экране появится целое десятичное, а %f — десятичное с плавающей запятой.

Что если нам нужно, чтобы пользователь ввёл данные с клавиатуры? 
Для этого можно использовать функцию scanf( ), прототип которой также лежит в библиотеке stdio. 
Чтобы считать с экрана вещественное число, в программе нужно написать строку 

<code>scanf("%d", &a);</code>

Давайте перепишем нашу программу так, чтобы пользователь сам вводил число, которое нужно возвести в квадрат.    
<img data-id="878c3986-677e-48f7-841f-aa210ea856bc" data-max-width="496" alt="Дополнительные материалы к лекциям CS50: Week 1 (лекции 3 и 4) - 17" src="https://cdn.javarush.com/images/article/878c3986-677e-48f7-841f-aa210ea856bc/1024.jpeg">