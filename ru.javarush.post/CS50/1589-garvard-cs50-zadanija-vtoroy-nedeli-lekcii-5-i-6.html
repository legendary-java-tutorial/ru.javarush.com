Гарвард CS50: задания второй недели (лекции 5 и 6)
<p>----------------------------------------</p>


Лекции CS50 лежат здесь: http://javarush.ru/cs50.html. В этом материале — 3 задания, теоретические сведения к ним и руководство к действию.  

Цели

•	У
<p>----------------------------------------</p>
<img data-id="d22c4e71-1f11-428b-af81-2d5d2265bb96" data-max-width="740" alt="cs50 задания к лекциям 5 и 6" src="https://cdn.javarush.com/images/article/d22c4e71-1f11-428b-af81-2d5d2265bb96/1024.jpeg">

Лекции CS50 лежат здесь: <a href="https://cdn.javarush.com/images/article/155cea79-acfd-4968-9361-ad585e939b82/original.pngcs50.html">https://cdn.javarush.com/images/article/155cea79-acfd-4968-9361-ad585e939b82/original.pngcs50.html</a>. В этом материале — 3 задания, теоретические сведения к ним и руководство к действию.  

<h4>Цели</h4>

•	Углубиться в функции и библиотеки
•	Познакомиться с криптографией, реализовать пару простых шифров

<h4>Дополнительные материалы</h4> 
https://reference.cs50.net/ — разъяснение функций библиотек, используемых во время обучения. На английском. 
<a href="http://computer.howstuffworks.com/c.htm" rel="nofollow" >http://computer.howstuffworks.com/c.htm</a> стр. 11 – 14 и 39   

<h4>Подготовка</h4> 
Залогиньтесь на cs50.io, выполните 

<code>update50</code>
чтобы убедиться в актуальности версии вашего рабочего пространства. Если вы случайно закрыли терминальное окно, зайдите в меню View и убедитесь, что напротив пункта Console стоит галочка (поставьте её, если это не так).

<img data-id="4df836f2-afce-416d-a7a7-a4c133745ef9" data-max-width="422" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 1" src="https://cdn.javarush.com/images/article/4df836f2-afce-416d-a7a7-a4c133745ef9/1024.jpeg">
 
Кликните на(+), внутри зеленого круга на рамке терминального окна, выберите <strong>New Terminal</strong>.
 
<img data-id="04a36441-3e0c-4ede-9494-eda108a39693" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 2" src="https://cdn.javarush.com/images/article/04a36441-3e0c-4ede-9494-eda108a39693/1024.jpeg">

Создайте рабочую директорию:

<code>mkdir ~/workspace/pset2</code>
Обратите внимание: между <strong>mkdir</strong> и <strong>~/workspace/pset2</strong> есть пробел. Напомним, <strong>~</strong> означает корневой каталог, <strong>~/workspace</strong> — папка, называемая рабочим пространством, находится внутри корневого каталога, <strong>~/workspace/pset2</strong> — директория по имени <strong>pset2</strong> внутри <strong>~/workspace</strong>. 
Теперь выполните: 

<code>cd ~/workspace/pset2</code>
чтобы перейти в новую директорию. 

Командная строка выглядит примерно так: 

<code>username:~/workspace/pset2 $</code>
Если что-то не так, повторите шаги. Также можете вызвать команду

<code>history</code>
чтобы просмотреть последние несколько команд в хронологическом порядке. Также вы можете, установив курсор на командную строку и нажимая стрелку «вверх» на клавиатуре, просматривать все команды в порядке от последней введенной к первой. С помощью кнопки «вниз» вы можете идти обратно. Кстати, вместо того, чтобы каждый раз набирать одни и те же команды, вы можете прокручивать уже набранные команды и выполнять их снова, нажимая на Enter. Вы могли заметить, что Дэвид на лекциях делает именно так. 

Задачи второй недели нужно сохранять в <strong>pset2</strong>. 

<h4>Задание 0. Инициализация</h4> 
Ознакомимся со строками поближе. В файле <strong>initials.c</strong> напишите программу, которая запрашивает имя пользователя (с помощью функции GetString получаем имя в виде строки) и затем выводит первые буквы имени (или имен) и фамилии в верхнем регистре без пробелов, точек и прочих знаков, только с переводом строки (<strong>\n</strong>). Предполагаем, что пользователи вводят исключительно буквы (в нижнем или верхнем регистре, или обоих сразу) плюс по одному пробелу между словами. Считайте, что ребята с именами Joseph Gordon-Levitt, Conan O’Brien или David J. Malan не будут пользоваться программой. 

<code>username:~/workspace/pset2 $ ./initials
<u>Zamyla Chan</u>
ZC
username:~/workspace/pset2 $ ./initials
robert thomas bowden
RTB</code>
Для проверки корректности работы программы вызывайте check50: 

<code>check50 2015.fall.pset2.initials initials.c</code>
Хотите поиграться с реализацией программы, подготовленной сотрудниками CS50? Набирайте строку: 

<code>~cs50/pset2/initials</code>

<h5>Криптография</h5> 
Криптография, наука о шифровке и дешифровке информации... На самом деле зашифрованные послания существуют с древних времён, и использовались армиями для передачи секретных сообщений. Ну и сейчас ваши пароли в Facebook и других сетях хранятся в зашифрованном виде.  

<h4>Задание 1. Аве, Цезарь!</h4> 
<h5>Теоретические сведения</h5>
Мы изучим один из простейших шифров — шифр Цезаря, названный в честь римского императора. В этом шифре каждая буква текста заменяется на другую, которая находится на фиксированное число букв ниже в алфавите. Это фиксированное число букв называется <strong>ключом</strong>. Так, ключ 1 переводит букву латиницы C в букву D, а Z — по циклу в A. Если ключ 3, то буква C перейдет в F, а Z — в C. 

<strong>Примеры:</strong> используем шифр Цезаря с ключом 5 на слове cat.

<code>c -> h
a -> f
t -> y 
Caesar (cat, 5) = hfy</code> 
Ключ = 7, слово = computer

<code>c->j
o->v
m->t
p->w
u->b
t->a
e->l
r->y
Caesar(computer,7) = jvtwbaly</code>

<img data-id="1d76c87e-3c60-46ea-88ce-da138bada6b9" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 3" src="https://cdn.javarush.com/images/article/1d76c87e-3c60-46ea-88ce-da138bada6b9/1024.jpeg">
 
Шифр Цезаря прост, но, увы, ненадёжен (это взаимосвязанные вещи!): для английского алфавита — всего 25 вариантов шифровки, перебрать все варианты легко даже без компьютера. Тем не менее, шифр Цезаря часто используют в качестве шага в других шифрах, таких, как шифр Виженера (о нём — в следующем пункте).

«Математизируем» шифр Цезаря. Обозначим незашифрованный текст буквой p, pi — буква в тексте p, которая находится на позиции с номером i. Назовем секретный ключ буквой k, с — зашифрованный текст, а ci — буква в шифрованном тексте, которая находится на позиции i. Тогда вычислить каждую букву шифра можно по формуле: 

<code>ci = (pi + k) % 26</code>
Привыкайте к такой формализации, она позволяет программировать алгоритм и выражает смысл шифра точно и сжато. 
Если ключ k = 13 а изначальный текст p — "Be sure to drink your Ovaltine!", вот какой шифр мы получим:

<code>Or fher gb qevax lbhe Binygvar!</code>

Обратите внимание, O (первая буква в шифрованном тексте) смещена на 13 позиций от буквы B (первая буква в оригинальном тексте). То же самое с буквой r (вторая буква в шифровке) смещена на 13 букв от e (вторая буква в оригинале). Третья буква в шифровке, f, смещена на 13 букв от s (третья в оригинале), тут мы ходим по кругу от z до a.

Шифр Цезаря с ключом 13 имеет специальное название <a href="https://ru.wikipedia.org/wiki/ROT13" rel="nofollow" >ROT13</a>. Он симметричный: применив его дважды, мы вернемся к изначальному тексту. Конечно, есть еще и ROT26, этот вообще супер-секьюрный, но только если вы нечетко выражаете свои мысли=).  

<h5>Условие</h5> 
Написать в файле <strong>caesar.c</strong>, программу, шифрующую текст с помощью шифра Цезаря. На вход программы подавайте один аргумент командной строки: не негативное целое число. Для простоты назовем его k. Если пользователь выполняет программу без аргументов командной строки или более, чем с одним аргументом, приложение должно возмутиться и вернуть значение 1 (обычно так обозначают ошибки):
 
<code>return 1;</code>
Во всех других случаях программа запрашивает у пользователя текст, который нужно зашифровать, затем выводит на экран текст, зашифрованный ключом k (т.е., смещенный на k позиций вправо по циклу). Если в тексте есть символы, выходящие за пределы английского алфавита, их программа не меняет. После вывода шифрованного текста, приложение завершает работу,<strong>main</strong> возвращает 0: 

<code>return 0;</code>
Если <strong>main</strong> не возвращает нуль явно, он возвращается автоматически (на самом деле int — тип, возвращаемый main, но об этом в другой раз). Согласно конвенции (правилам хорошего тона в программировании), если вы явно возвращаете 1 чтобы указать на ошибку, то нужно вернуть и 0 в качестве указателя на успешное завершение работы программы. 

Хотя в английском алфавите только 26 букв, k может быть и больше 26. По сути, ключ k = 27 даст тот же результат, что и k = 1, но нужно позволить пользователю вводить любое неотрицательное число, не превышающее 2^31 – 26 (оно должно поместиться в int). Программа также должна учитывать, что строчные буквы шифруются строчными, а прописные — прописными. 

С чего начинаем? Поскольку приложение должно принять значение k непосредственно в строке аргументов, заголовок функции main у нас имеет следующий вид: 

<code>int main(int argc, string argv[])</code>
Из шестой лекции вы знаете, что <strong>argv</strong> — это массив строк. Массив можно представить, как ряд шкафчиков-ячеек в спортзале. В каждом из них спрятано некоторое значение. В нашем случае, внутри каждой ячейки лежит аргумент типа 

<code>string</code>
Чтобы открыть первый шкафчик, используем argv[0], второй — argv[1] и так далее. Если у нас есть n замков, то нам нужно остановиться на argv[n - 1], поскольку argv[n] уже не существует (или существует, но принадлежит кому-то ещё, нам лучше его не трогать). 

Таким образом, вы можете получить доступ к аргументу k следующим образом: 

<code>string k = argv[1];</code>
Мы полагаем, что там действительно что-то есть! Напомним, argc — переменная типа int, равная количеству строк argv. Значит, лучше проверить значение argc прежде, чем пытаться открыть ячейку, ведь может статься, что её не существует. 

В идеале argc = 2. Почему так? Внутри argv[0] обычно находится имя программы. То есть, argc всегда не меньше 1. Но нашей программе нужно, чтобы пользователь предоставил аргумент командной строки k, следовательно, argc = 2. Естественно, если пользователь в командной строке введет более одного аргумента, argc также подрастает и может быть больше, чем 2.

Если пользователь вводит целое число в строку, это еще не значит, что внесенное значение будет автоматически сохранено в тип int. Точнее, оно НЕ будет. Оно будет string, даже если выглядит точь-в-точь, как int! Так что нам нужно конвертировать string в int самостоятельно. К счастью, существует функция atoi, созданная для этих целей. Её синтаксис:

<code>int k = atoi(argv[1]);</code>
Обратите внимание: k имеет тип int, поэтому с ним можно провернуть арифметические действия. С этой функцией не нужно беспокоиться, введет ли пользователь целое число, или, скажем, foo: в таком случае atoi возвратит 0.

Функция atoi объявлена в библиотеке <strong>stdlib.h</strong>, поэтому не забудьте прописать её директивой #include в начале программы. Код и без этого скомпиллируется, поскольку мы уже включили эту функцию в библиотеку <strong>cs50.h</strong>. Тем не менее, лучше доверять нативным библиотекам. 

Итак, вы получили k, сохраненное как int. Теперь запросим ввод текста. Если вы делали задания первой недели, то уже знакомы с функцией библиотеки CS50, которая называется GetString. Она-то нам и поможет. 

После того, как вы получили k и начальный текст, приступим к шифрованию. Напомним, вы можете пройтись по всем символам строки и напечатать их с помощью следующего цикла: 

<code>for (int i = 0, n = strlen(p); i < n; i++)
{
    printf("%c", p[i]);
}
</code>
Другими словами, точно так же, как <strong>argv</strong> — массив строк, <strong>string</strong> является массивом символов. Поэтому мы можем использовать квадратные скобки для доступа к отдельным элементам строки точно так же, как получать отдельные строки в argv. Конечно, нет ничего криптографического в печати каждого из символов. Или, технически, когда k  = 0. Но мы же должны помочь Цезарю зашифровать его текст! Аве, Цезарь!

Чтобы использовать strlen, нужно подключить ещё одну <a href="https://reference.cs50.net/string.h/strlen" rel="nofollow" >библиотеку</a>. 

Поскольку мы автоматизируем некоторые проверочные тесты, программа должна себя вести себя ровно следующим образом: 

<code>username:~/workspace/pset2 $ ./caesar 13
Be sure to drink your Ovaltine!
Or fher gb qevax lbhe Binygvar!</code>

Помимо <strong>atoi</strong>, вы можете найти другие классные функции в библиотеках <strong>ctype.h</strong> и <strong>stdlib.h</strong>. Для этого перейдите по <a href="https://reference.cs50.net/" rel="nofollow" >ссылке</a> и поройтесь там немного. Например, <strong>isdigit</strong>  — явно что-то интересное=). 
Когда переходите от Z к A (или от z к a), не забывайте об операторе деления по модулю <strong>%</strong> в языке С. Также изучите <a href="http://asciitable.com/" rel="nofollow" >таблицу</a>, она показывает символы ASCII не только для букв. 

Чтобы проверить правильность работы программы с <strong>check50</strong>, выполните следующее:

<code>check50 2015.fall.pset2.caesar caesar.c</code>
А если вам интересно поиграть с кодом, сделанным сотрудниками СS50, выполните команду: 

<code>~cs50/pset2/caesar</code>

Кстати, <a href="uggc://jjj.lbhghor.pbz/jngpu?i=bUt5FWLEUN0">uggc://jjj.lbhghor.pbz/jngpu?i=bUt5FWLEUN0</a>.

<h5>Разбор задания</h5>
<ol>
    <li>Получить ключ</li>
    <li>Получить текст</li>
    <li>Зашифровать</li>
    <li>Вывести на экран зашифрованное сообщение</li> 
</ol>

1.	Формируем функцию main так, чтобы пользователь вводил ключ в командной строке и проверяем ключ на корректность.

<code>int main(int argc, string argv[])</code>
argc: 
•	int 
•	количество аргументов, введенных в командную строку
•	если argc = 2 все ок. Если нет, выводим инструкцию и закрываем программу.
•	Если argc = 2 проверяем, является ли ключ целочисленным  
•	Argv — это массив строк, список с введенными в него аргументами

Массив — структура данных, содержащая разные данные одного типа в разных ячейках. 

<img data-id="51959b19-2030-4dc1-95b3-f5463852bd86" data-max-width="685" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 4" src="https://cdn.javarush.com/images/article/51959b19-2030-4dc1-95b3-f5463852bd86/1024.jpeg">
  
Например, пользователь ввел строку blastoff Team Rocket, тогда:
 
<img data-id="b05b164f-876a-4791-a95b-95fe442f65f0" data-max-width="587" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 5" src="https://cdn.javarush.com/images/article/b05b164f-876a-4791-a95b-95fe442f65f0/1024.jpeg">

Переводим с помощью функции atoi() полученное в целое число. Если это невозможно, функция вернет 0. 

<img data-id="875e8303-3591-42ba-b225-249cd38760c2" data-max-width="442" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 6" src="https://cdn.javarush.com/images/article/875e8303-3591-42ba-b225-249cd38760c2/1024.jpeg"> 

2.	Запрос у пользователя текста. Это просто: всё, что вводит пользователь, является строкой. 
3.	Шифрование. Алгоритм прост, но как пояснить компьютеру, какие буквы идут одна за другой? Самое время вспомнить о таблице ASCII! 
 
<img data-id="3c2376ca-6e56-4532-a50e-d4f70ab1ec4e" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 7" src="https://cdn.javarush.com/images/article/3c2376ca-6e56-4532-a50e-d4f70ab1ec4e/1024.jpeg">

Однако в строке могут быть не только буквы… Прежде, чем перейти к изменению строк, представьте, что нужно поменять только один символ.  Мы хотим сменить буквы из начального текста, а не знаки или цифры. Что мы должны сделать? Для начала нам нужно проверить, есть ли этот символ в алфавите. Это можно сделать с помощью функции <strong>isalpha()</strong>. 

Если символ входит в алфавит, эта функция возвращает значение true и false во всех других случаях. Еще две полезные функции — <strong>isupper ()</strong> и <strong>islower()</strong> возвращают true в случае, если буква прописная или строчная соответственно. Таким образом: 

<code>Isalpha(‘Z’) -> true
Isalpha(‘;’) -> false
Isupper(‘Z’) ->true
Isupper(‘z’) -> false
Islower(‘Z’) -> false
Islower(‘z’)->true</code> 

Если isalpha возвращает true, нам нужно поменять этот символ с помощью ключа.  
Рассмотрим и разберем в качестве примера программу Замили, ассистента CS50.  

<code>/*
 * asciimath.c
 * by Zamyla Chan
 *
 * Calculates the addition of a char and an integer,
 * and displays both the resultant character and its
 * ASCII value.
 *
 * Usage: ./asciimath key [char]
 *
 */

#include <cs50.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, string argv[])
{

    if (argc != 2)
    	
    	{
 printf("print the key next time \n"); 
        return 1;
    	}
    // key is the second command line argument 

  
    int key = atoi(argv[1]); //преобразование строки в int 

    int letter = 'A';
    
    printf("\nCalculating '%c' + %d...\n", letter, key);
    
    int result = (letter + key);
        
    printf("The ASCII value of %c is %d.\n\n", result, result);
   
    return 0;
    

}</code>
Вас может удивить, почему ‘A’ — это целое число, тогда как она явно является буквой. Оказывается символы и целые числа — взаимозаменяемы. Поставив букву A в одиночные кавычки можно получить её ASCII-код в int. Будьте внимательны: вам нужны именно одинарные кавычки, без них компилятор будет искать переменную по имени A, а не символ. 

Затем в строке

<code>int result = (letter + key);</code>

мы прибавляем значение ключа к ASCII-коду буквы и сохраняем их в переменной целого типа. Даже если результат имеет тип int, оператор printf использует плейсхолдер %с для символов. Таким образом, программа печатает символ, связанный с целочисленным результатом. Во втором случае мы выводим на экран число с помощью плейсхолдера %d.     

Вы можете ввести этот код в сs50 IDE и поиграться с ним. Проверим работу asciimath для разных ключей. Возьмем значение 25, увидим следующую картинку: 

<img data-max-width="242" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 8" src="https://cdn.javarush.com/images/article/a8cbcd04-74f1-4fe6-8ec5-c96c78f05946/original.jpeg">

А теперь пусть ключ будет 26: 

<img data-max-width="240" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 9" src="https://cdn.javarush.com/images/article/4cd0fbe0-6881-4f63-9088-ff883fd30298/original.jpeg"> 

Мы получили [, а вовсе не букву A. Это просто следующий символ ASCII после Z. Так что простое прибавление ключа работать не будет. Нам нужно использовать формулу шифра, чтобы возвращаться в начало алфавита как только буквы закончатся.  
 
Помните, мы уже писали выше: 

<code>ci = (pi + k) % 26</code>
Где ci — буква номер i в шифрованном тексте, pi — буква номер i в незашифрованном тексте, k — ключ, а %26 — остаток от деления на 26 (или «деление по модулю 26»). 

Давайте применим эту формулу для буквы Y. Возьмем k = 2. Посчитаем (‘Y’ + 2) %26
ASCII-код буквы ‘Y’= 89. Тогда
(‘Y’ + 2) %26 = (89 + 2)%26 = 91%26 = 13 

Но это вовсе не ASCII-значение нужной нам буквы A, которое равно 65. 

Теперь давайте придадим каждой букве алфавита значение от 0 до 25 по порядку. В таком случае Y = 24. 
(24+2)%26 = 0 
Буква А как раз имеет такой индекс. Таким образом, эта формула относится к алфавитному индексу букв, а не их ASCII-значений. 

Для печати зашифрованного символа вам нужно будет его ASCII-значение. И разберитесь с тем, как переключаться между ASCII-значением и номером в алфавите. 
После того, как мы выяснили формулу для одного символа, нужно применить её для каждой буквы во вводимой с клавиатуры строке. Но только если это буквы! 
И помните, для больших и малых букв нужны разные значения. Тут пригодятся функции isupper и islower. У вас может быть две формулы, одна для больших букв, другая — для малых, функции помогут выбрать, какую из них применить. 

Как применить формулу к каждому отдельному символу в строке? Помним, что строка — это просто массив символов. Определить количество итераций в цикле поможет функция <strong>strlen</strong> (длина строки).     

<img data-id="97e1a401-4ecf-4653-b087-01ad086cc64f" data-max-width="699" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 10" src="https://cdn.javarush.com/images/article/97e1a401-4ecf-4653-b087-01ad086cc64f/1024.jpeg">
   
<h4>Задание 2. Parlez-vous français?</h4>
<h5>Теория</h5> 
Шифр Виженера несколько безопаснее шифра Цезаря: в качестве ключа в нем используется слово и его сложно взломать вручную с помощью одного только частотного анализа или перебора. Каждая буква ключа генерирует число, и в результате мы получаем несколько несколько ключей для сдвига букв. 

<strong>Пример:</strong> 

<code>p = Meet me in the park at eleven am 
В качестве ключевого слова возьмем 
k = bacon
Длина сообщения p = 25 
В то время как длина k = 5 
Поэтому его нужно повторять 5 раз.</code> 
 
<img data-id="81a20544-e365-4918-b32f-c8eb6d94503a" data-max-width="704" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 11" src="https://cdn.javarush.com/images/article/81a20544-e365-4918-b32f-c8eb6d94503a/1024.jpeg">

Если число букв в сообщении не делится на ключ нацело, мы в последнем применении ключа используем только его часть: 

<img data-id="0abc57da-6609-4e37-873a-d14aa73019c9" data-max-width="341" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 12" src="https://cdn.javarush.com/images/article/0abc57da-6609-4e37-873a-d14aa73019c9/1024.jpeg">
     
Чтобы найти значение для смещения, используем позиции каждой буквы нашего ключа bacon в алфавите (от a до z). Считаем с нуля, как истинные программисты. И каждую букву в оригинальном тексте смещаем на заданное число, как в шифре Цезаря, возвращаясь при надобности после Z в начало алфавита. Таким образом, M сместится на 1, первая e вообще не сместится, а вторая сместится на 2 позиции. Ниже вы видите изначальное сообщение, расписанный ключ и результат его применения. 

<img data-id="2c7f7c2d-4b61-4452-a6bf-d64f76b60dc7" data-max-width="731" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 13" src="https://cdn.javarush.com/images/article/2c7f7c2d-4b61-4452-a6bf-d64f76b60dc7/1024.jpeg">
 
Шифр Виженера, конечно, понадежнее, но если вы знаете длину ключа, его сломать довольно просто. Как её выявить? Если оригинальный текст достаточно длинный, чтобы некоторые слова встречались в нем несколько раз, то вы увидите некоторые повторения: 
 
<img data-id="550d86ac-b353-4cb3-9c6b-978272d86bd5" data-max-width="543" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 14" src="https://cdn.javarush.com/images/article/550d86ac-b353-4cb3-9c6b-978272d86bd5/1024.jpeg">

Также можно использовать полный перебор, но вариантов немало: 26^n – 1 где n — длина неизвестного ключа. Но обычно это немало. Правда, для компьютера это не проблема.
А теперь математика шифра: 

Пусть р – некоторый текст, k — ключевое слово, kj — j-я буква ключа, pi — буква под номером i в оригинальном тексте, ci — буква под номером i в шифровке. Тогда:

<code>ci = (pi + kj) % 26</code>
<h5>Задание</h5>
<strong>Условие</strong> 

Написать программу vigenere.c, которая шифрует сообщение с помощью шифра Виженера. На вход программы подаем один аргумент командной строки: ключевое слово k, состоящее из букв английского алфавита. Если приложение запускается более чем с одним аргументом или с аргументом не входящим в алфавит, нужно вывести информацию об ошибке с завершением программы. То есть main будет возвращать 1 — в таком случае наши автоматические тесты поймут, что здесь все хорошо, и это условие учтено. Если всё хорошо, программа должна перейти к запросу строки текста p, который мы и шифруем полученным выше ключом k, напечатать результат и завершить выполнение программы, возвратив значение 0. 
  
<strong>Уточнение</strong> 

Нужно сделать так, чтобы в ключе k символы A и a обозначались как 0, B и b как 1, ..., Z и z как 25. Программа должна применять шифр Виженера только к буквам текста p. Остальные символы (цифры, знаки препинания, пробелы) нужно вывести без изменений. Если алгоритм собирается применить j-й символ <strong>k</strong> к i-му символу <strong>p</strong>, не входящему в алфавит, применяем этот j-й символ ключа к следующему алфавитному символу в тексте; вы не можете просто оставить его и перейти к другому символу в k. Наконец, программа должна сохранить регистр каждой буквы в <strong>p</strong>. 

<h5>Не знаете, с чего начать?</h5> 

<img data-id="61e4b6f6-ec30-49e2-a4a4-5d5c48027ca7" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 15" src="https://cdn.javarush.com/images/article/61e4b6f6-ec30-49e2-a4a4-5d5c48027ca7/1024.jpeg">

<h6>Вот вам несколько советов от Замили, ассистента курса CS50</h6> 
К счастью, программа очень похожа на шифр Цезаря, только в качестве ключа используется не целое число, а строка. Если вы успешно реализовали шифр имени римского правителя, он может стать прекрасным стартом для реализации второго задания. Вы, вероятно, уже смекнули, что шифр Виженера с одной буквой в качестве ключа — это тот же шифр Цезаря. 
В алгоритме Виженера применяются те же шаги, что и в «Цезаре»:  
	<ol>
    <li>Получить ключ
           	<ul>
    <li>кодовое слово — это второй аргумент командной строки argv[1]</li> 
    <li>  	        должен входить в алфавит: функция isalpha</li>
</ul>
</li> 
    <li>	Получить текст</li> 
    <li>	Зашифровать</li> 
    <li>	Напечатать шифрованный текст</li>
</ol>
Итак, второй аргумент командной строки argv[1] проверим на принадлежность к алфавитным символам. Делаем это с помощью уже знакомой <strong>isalpha</strong>. Если ключ корректен, получаем от пользователя строку и начинаем шифровать. 

Формула шифра Виженера похожа на формулу шифра Цезаря. Каким образом вы преобразуете букву на соответствующее смещение шифра? Попробуйте сравнить значения по таблице ASCII. 

<img data-id="9fd90aea-da77-4990-b55e-a92bfb0eb952" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 16" src="https://cdn.javarush.com/images/article/9fd90aea-da77-4990-b55e-a92bfb0eb952/1024.jpeg">
 
Скорее всего, у вас получится отыскать закономерность между буквами и их алфавитными индексами используя последовательности в таблице. Догадались, как отнять одну букву от другой, чтобы получить желаемый результат? Смещения для больших и малых букв одинаковы, так что вам придется определить две похожие формулы для определения смещения для строчных и отдельно для прописных букв. 
Также не забудьте, что цикл прохода по тексту должен игнорировать символы, не входящие в английский алфавит. И не забудьте сохранить регистр букв. 
Если посмотреть на формулу шифра: 

<code>ci = (pi + kj) % 26</code>
вы увидите две индексные переменные, i и j. Одна сохраняет позицию в исходном тексте, другая — в ключе. Если ваш текст длиннее ключа, индекс по ключу проходит с конца ключа снова в его начало. 
Как это сделать? С помощью операции деления по модулю! Результат операции — остаток от деления двух чисел. Практическая польза этой операции в программировании просто огромна! 

Представьте, что многочисленную группу людей нужно разделить на три подгруппы. Один из способов это сделать — попросить их рассчитаться на первый-второй-третий.   
 
<img data-id="7f962f3b-a4eb-4fc4-bc70-8f5e7faa8412" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 17" src="https://cdn.javarush.com/images/article/7f962f3b-a4eb-4fc4-bc70-8f5e7faa8412/1024.jpeg">

То есть, первый человек относится к первой группе, второй — ко второй, третий — к третьей, четвертый — снова к первой и так далее. Вы можете использовать деление по модулю чтобы произвести эту же операцию.  Пронумеруем те же три группы с нуля. Вот как это делается:  

<img data-id="cb275c01-ca68-4047-8916-31f47f867f9b" data-max-width="737" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 18" src="https://cdn.javarush.com/images/article/cb275c01-ca68-4047-8916-31f47f867f9b/1024.jpeg">  

Если вы возьмете индекс и поделите его по модулю максимального значения, полученный результат никогда не будет больше или равен этому значению. 

Попробуйте применить этот принцип для возвращения ключевого слова в начало!  Только вместо сортировки по группам вам нужен индекс ключевого слова, чтобы вы могли правильную букву для смещения, не выходя за длину ключа.   

Так как мы автоматизируем некоторые тесты вашего кода, программа должна вести себя так, как показано ниже:

<code>jharvard@appliance (~/Dropbox/pset2): ./vigenere bacon
Meet me at the park at eleven am
Negh zf av huf pcfx bt gzrwep oz</code>

Как еще можно протестировать программу, кроме ручного вычисления зашифрованного текста? Мы добрые: для этого мы написали программу <strong>devigenere</strong>. Она принимает один и только один аргумент командной строки (ключевое слово), а её работа заключается в том, чтобы принять зашифрованный текст в качестве входных данных и вернуть обычный.
Запустите её: 

<code>~cs50/pset2/devigenere k</code>
Где k — ключевое слово. 
Если вы хотите проверить правильность вашей программы с помощью check50, выполните:

<code>check50 2014.fall.pset2.vigenere vigenere.c</code>

А если хотите оценить нашу реализацию vigenere, наберите:

<code>~cs50/pset2/vigenere</code>

<h4>Как подтвердить правильность кода и получить оценки</h4>

<strong>Внимание!</strong> Если вам важно проверить только правильность задач, после того, воспользуйтесь cs50check. Если же вы ходите получить оценки на платформе edx, проделайте процедуру, описанную ниже. Имейте в виду, эта процедура для проверки задач использует ту же cs50check. Разница только в том, что она запоминает результаты и подсчитывает общую оценку. 
    
<ol>
    <li>Залогиньтесь в <a href="https://id.cs50.net/authorize?state=foo&response_type=code&redirect_uri=https%3A%2F%2Fcs50.io%2Fauth%2Fcs50_callback&scope=openid%20profile%20email&client_id=prod" rel="nofollow" >CS50 IDE</a></li> 
    <li>Рядом с левым верхним углом <strong>CS50 IDE</strong>, там, где расположен её файловый браузер (не в терминальном окне), кликните правой клавишей мыши по вашему файлу <strong>initials.c</strong>, находящемуся в директории <strong>pset2</strong> и нажмите <strong>Download</strong>. Вы должны увидеть, что браузер загрузил <strong>initials.c</strong>.</li>
    <li>Повторите для <strong>caesar.c</strong>.</li>
    <li>Повторите для <strong>vigenere.c</strong>.</li>
    <li>В отдельном окне или вкладке залогиньтесь в <a href="http://apps.cs50.edx.org/cs50x/2016/@/portal" rel="nofollow" >CS50 Submit</a></li>
    <li>Кликните по иконке <strong>Submit</strong> в левом верхнем углу экрана.

<img data-id="fd2b9306-dfa4-4c59-ac0e-66e87a613727" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 19" src="https://cdn.javarush.com/images/article/fd2b9306-dfa4-4c59-ac0e-66e87a613727/1024.jpeg">

</li> 
    <li>В списке папок слева кликните по директории <strong>Problem Set 2</strong>, затем нажмите на кнопку <strong>Upload New Submission</strong>. Она находится справа.

<img data-id="4da35da3-94be-4a93-941f-705d7a174fd6" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 20" src="https://cdn.javarush.com/images/article/4da35da3-94be-4a93-941f-705d7a174fd6/1024.jpeg">

</li> 
    <li>На появившемся экране кликните по кнопке <strong>Add files</strong>…. Откроется окно выбора файлов с вашего компьютера.

<img data-id="1ab36598-f33e-4f15-9bc3-1d8700d1d530" data-max-width="740" alt="Гарвард CS50: задания второй недели (лекции 5 и 6) - 21" src="https://cdn.javarush.com/images/article/1ab36598-f33e-4f15-9bc3-1d8700d1d530/1024.jpeg">

</li>
    <li>Перейдите к той папке, где вы храните <strong>initials.c</strong>. Скорее всего, он находится в папке <strong>Downloads</strong> ("Загрузки") или там, куда ваш браузер складывает файлы по умолчанию. Когда найдете <strong>initials.c</strong>, кликните по нему один раз чтобы выбрать, затем кликните Open («Открыть»).</li>
    <li>Кликните <strong>Add files</strong> ещё разок.</li> 
    <li>Найдите <strong>caesar.c</strong> и откройте его.</li> 
    <li>Проделайте то же самое для файла <strong>vigenere.c</strong>.</li> 
    <li>Нажмите Start upload. Ваши файлы будут загружены на серверы <strong>CS50</strong>.</li> 
    <li>На появившемся экране вы должны увидеть окно <strong>No File Selected</strong>. Если вы переведете курсор мыши влево, вы увидите список загрузившихся файлов. Для подтверждения кликните по каждому из них. Если вы в чём-то не уверены, вы можете перезагрузить файлы, повторив те ж шаги. Вы это можете делать сколько угодно раз до конца 2016 года.</li>  
</ol>