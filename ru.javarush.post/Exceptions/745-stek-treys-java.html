Стек-трейс Java
<p>----------------------------------------</p>
Виртуальная Машина Java (в дальнейшем JVM) обрабатывая код, запускает методы  один за другим, начиная с метода main. Когда она доходит до очередного метода, говорится, что этот метод находится на вершине стека. После полного выполнения метода, он удаляется из стека ...
<p>----------------------------------------</p>
Виртуальная Машина Java (в дальнейшем JVM) обрабатывая код, запускает методы  один за другим, начиная с метода <code>main</code>. Когда она доходит до очередного метода, говорится, что этот метод находится на вершине стека. После полного выполнения метода, он удаляется из стека, и сменяется следующим в очереди. Для демонстрации принципа, наберите данный код:
<img data-id="eb0231c6-f6d4-4285-a48d-2c7c34750df3" data-max-width="850" alt="Стек-трейс Java - 1" src="https://cdn.javarush.com/images/article/eb0231c6-f6d4-4285-a48d-2c7c34750df3/1024.jpeg">
<pre class="lang-java line-numbers"><code>
package errorhandling;

public class errorChecking {
    public static void main(String[] args) {
        System.out.println("Метод Main успешно запущен");
        m1();
        System.out.println("Метод Main заканчивает свою работу");
    }

    static void m1() {
        System.out.println("Первый метод передаёт привет!(m1)");
        m2();
    }

    static void m2() {
        System.out.println("Второй метод передаёт привет(m2)");
    }
}
</code></pre>
У нас три метода: метод <code>main</code>,  метод <code>m1</code> и метод <code>m2</code>. Когда программа стартует, на вершине стека расположен метод <code>main</code>. Внутри метода <code>main</code>, вызывается метод <code>m1</code>. Вызываясь, он прыгает на верхушку стека. Метод <code>m1</code> в свою очередь вызывает метод <code>m2</code>. Теперь уже метод <code>m2</code>, прыгает на верхушку стека, временно отстраняя <code>m1</code>. На секунду представьте это — <code>main</code>, сверху <code>m1</code> и на вершине <code>m2</code>! Сделав свои дела, <code>m2</code> завершается, и контроль возвращается обратно к <code>m1</code>. Метод <code>m1</code>, завершаясь, тоже удаляется из стека, и управление вновь получает метод <code>main</code>.

Запустите вашу программу и посмотрите на окно вывода:

<em>Метод Main успешно запущен
Первый метод передаёт привет!(m1)
Второй метод передаёт привет(m2)
Метод Main заканчивает свою работу</em>

Если что-то пойдёт не так в методе <code>m2</code>, JVM (Виртуальная Машина Джава, вы помните, да?) будет искать обработчиков ошибок, например блок <code>try … catch</code>. Если в методе <code>m1</code> обработчика ошибок нет, то исключение будет передано методу <code>m1</code>, в надежде, что он сумеет её обработать. Если и здесь не обнаружит обработчика ошибок,то исключение снова перейдёт по стеку вверх, на этот раз в метод <code>main</code>. Если метод <code>main</code> не взаимодействует с исключением, вы получите странное сообщение об ошибке, напечатанное в окне вывода. В качестве примера, приведите ваш метод <code>m2</code> к следующему виду:

<pre class="lang-java line-numbers"><code>
static void m2() {
    int x = 10;
    int y = 0;
    double z = x / y;
    System.out.println( z );
    System.out.println("Method Two - m2");
}
</code></pre>
Этот метод содержит ошибку деления на ноль.
А вот полный вариант программы, сверьтесь со своим:

<pre class="lang-java line-numbers"><code>
package errorhandling;

public class errorChecking {
    public static void main(String[] args) {
        System.out.println("Метод Main успешно запущен");
        m1();
        System.out.println("Метод Main заканчивает свою работу");
    }

    static void m1() {
        System.out.println("Первый метод передаёт привет!(m1)");
        m2();
    }

    static void m2() {
        int x = 10;
        int y = 0;
        double z = x / y;
        System.out.println( z );
        System.out.println("Method Two - m2");
    }
}
</code></pre>
Запустите программу и посмотрите, что выдаст вам окно вывода:

<em>Метод Main успешно запущен
Первый метод передаёт привет!(m1)
Exception in thread "main" java.lang.ArithmeticException: / by zero

	at errorhandling.errorChecking.m2(&lt;u&gt;errorChecking.java:17&lt;/u&gt;)
	at errorhandling.errorChecking.m1(&lt;u&gt;Solution.java:11&lt;/u&gt;)
	at errorhandling.errorChecking.main(&lt;u&gt;&gt;Solution.java:5&lt;/u&gt;)	

Process finished with exit code 1</em>

Вы смотрите на нечто, называемое стек-трейс. Три строки, подчёркнутые голубым, ссылаются на ваши методы, и могут быть найдены в:

<code>имя_пакета.имя_класса.имя_метода</code>

Первая сверху строка — это место, где ошибка возникла — в методе <code>m2</code>. Java проследила, что бы она была обработана <code>ArithmeticException</code>, которая вылавливает ошибки деления на ноль. В методах <code>m2</code>, <code>m1</code> и <code>main</code> нет обработчика ошибок. Так что программа обработала её обработчиком ошибок по-умолчанию.

Измените ваш метод <code>m1</code> на следующий:

<pre class="lang-java line-numbers"><code>
try {
    System.out.println("Первый метод передаёт привет!(m1)");
    m2( );
}
catch (ArithmeticException err) {
    System.out.println(err.getMessage());
}
</code></pre>
Теперь мы обернули метод <code>m2</code> в блок <code>try</code>. В части <code>catch</code>, мы используем тип исключения, что был выявлен в стек-трейсе — <code>ArithmeticException</code>.

Запустите код снова, и в окне вывода увидите следующее:

<em>Метод Main успешно запущен
Первый метод передаёт привет!(m1)
/ by zero
Метод Main заканчивает свою работу</em>

Заметьте, что сообщение об ошибке вывелось как: "<em><strong>/ by zero</strong></em>". Метод <code>m2</code> не был выполнен полностью, а был остановлен, когда возникла ошибка. Затем контроль был передан обратно <code>m1</code>. Это произошло благодаря тому, что блок <code>catch</code> сам  распознавал ошибку, JVM не стала обращаться к стандартному обработчику ошибок, а вывела сообщение находящееся между фигурными скобками блока <code>catch</code>.

Обратите внимание, что сама программа не была остановлена. Контроль, как обычно перешёл к методу <code>main</code>, откуда <code>m1</code> был вызван. И последняя строка метода <code>main</code>, таки смогла вывести на экран "<em><strong>End Main method</strong></em>". Это имеет очень-очень важное значение. Если бы вам нужно было значение из <code>m1</code>, для последующей работы где-то в <code>main</code>. И если значения там не окажется, то ваша программа может отработать совсем не так, как вы ожидаете.

Когда вы увидите стек-трейс в окне вывода, просто знайте, что первая строка — это то место, где проблема возникла, а остальные строки (если конечно они есть), куда исключение было передано вверх по стеку, обычно заканчивая методом <code>main</code>.

Перевод с сайта <a href="http://www.homeandlearn.co.uk/java/java_stack_trace.html" rel="nofollow">homeandlearn.co.uk</a>
Говорим спасибо: Серегею Сысоеву, Treefeed...