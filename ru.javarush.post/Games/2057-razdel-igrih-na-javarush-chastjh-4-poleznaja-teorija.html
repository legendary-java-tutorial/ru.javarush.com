Раздел "Игры" на JavaRush: Полезная теория
<p>----------------------------------------</p>
Это четвертая часть гайда по разделу "Игры" на JavaRush. В нем вы найдете полезную информацию о том, как работать с этим типом задач. Работа с игровым движком JavaRush подразумевает использование наследования. Но что делать, если вы не знаете, что это такое? С одной стороны ...
<p>----------------------------------------</p>
В <strong>разделе «Игры»</strong> на JavaRush вы найдете увлекательные проекты по написанию популярных компьютерных игр. Хотите создать свою версию популярных «2048», «Сапера», «Змейки» и других игр? Это просто. Мы превратили написание игр в пошаговый процесс.<img data-id="0e6312e8-a627-4aca-89f0-7e74817a0d78" data-max-width="710" alt="Раздел " src="https://cdn.javarush.com/images/article/0e6312e8-a627-4aca-89f0-7e74817a0d78/1024.jpeg">Чтобы попробовать себя в роли гейм-разработчика, не обязательно быть продвинутым программистом, но определенный набор Java-знаний все же необходим. Здесь вы найдете <strong>информацию, которая будет полезна при написании игр</strong>.
<h2 id="Наследование">1. Наследование</h2>Работа с игровым движком JavaRush подразумевает использование наследования. Но что делать, если вы не знаете, что это такое? С одной стороны, нужно в этой теме разобраться: она изучается на <strong>11 уровне</strong>. С другой стороны, движок специально спроектировали очень простым, поэтому можно обойтись поверхностным знанием наследования.

Итак, что же такое наследование. Если очень упростить, наследование — это связь между двумя классами. Один из них становится родителем, а второй — потомком (классом-наследником). При этом класс-родитель может даже не знать, что у него есть классы-потомки. Т.е. особой выгоды от наличия классов-наследников он не получает. 

А вот классу-потомку наследование дает много преимуществ. И главное из них — в том, что все переменные и методы класса-родителя появляются в классе-потомке, как будто код класса-родителя скопировали в класс-потомок. Это не совсем так, но для упрощенного понимания наследования пойдет.

Вот несколько примеров, чтобы лучше понять наследование.

<strong>Пример 1:</strong> самое простое наследование.
<table>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-user"><strong>Родитель</strong></span> {

}
</code></pre>
</td>
<td rowspan="2"><strong>Класс <span class="text-green">Потомок</span> унаследован от класса <span class="text-user">Родитель</span> с помощью ключевого слова <span class="text-red">extends</span>.</strong>
</td>
</tr>
<tr>
<td>
<pre class='lang-java line-numbers'><code>
public class <span class="text-green"><strong>Потомок</strong></span> <span class="text-red"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

}
</code></pre>	
</td>
</tr>
</table><strong>Пример 2:</strong> использование переменных класса-родителя.
<table>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-user"><strong>Родитель</strong></span> {

   public int <span class="text-corporate"><strong>age</strong></span>;
   public String <span class="text-viola"><strong>name</strong></span>;
}
</code></pre>
</td>
<td rowspan="2"><strong>Класс <span class="text-green">Потомок</span> может использовать переменные <span class="text-corporate">age</span> и <span class="text-viola">name</span> класса <span class="text-user">Родитель</span> как будто они объявлены в нем.</strong></td>
</tr>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-green"><strong>Потомок</strong></span> <span class="text-red"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

   public void printInfo() {

     System.out.println(<span class="text-viola"><strong>name</strong></span>+" "+<span class="text-corporate"><strong>age</strong></span>);
   }
}
</code></pre>
</td>
</tr>
</table>
<strong>Пример 3:</strong> использование методов класса-родителя.
<table>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-user"><strong>Родитель</strong></span> {

   public int <span class="text-corporate"><strong>age</strong></span>;
   public String <span class="text-viola"><strong>name</strong></span>;

   public <span class="text-viola">getName</span>() {
      return <span class="text-viola"><strong>name</strong></span>;
   }
}
</code></pre>
</td>
<td rowspan="2"><strong>Класс <span class="text-green">Потомок</span> может использовать переменные и методы класса <span class="text-user">Родитель</span> как будто они объявлены в нем. В этом примере мы используем метод <span class="text-viola">getName</span>().</strong>
</td>
</tr>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-green"><strong>Потомок</strong></span> <span class="text-red"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

   public void printInfo() {

     System.out.println(<span class="text-viola">getName()</span>+" "+<span class="text-corporate"><strong>age</strong></span>);
   }
}
</code></pre>	
</td>
</tr>
</table>Вот как выглядит класс <span class="text-green"><strong>Потомок</strong></span> с точки зрения компилятора:

<pre class='lang-java line-numbers'><code>
public class <span class="text-green"><strong>Потомок</strong></span> <span class="text-red"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

   public int age; //  унаследованная переменная
   public String name; //  унаследованная переменная

   public getName() { //  унаследованный метод.
      return name;
  }
   public void printInfo() {

     System.out.println(<span class="text-viola">getName()</span>+" "+<span class="text-corporate"><strong>age</strong></span>);
   }
}
</code></pre><h2 id="Переопределение методов">2. Переопределение методов</h2>Иногда бывают ситуации, что мы унаследовали наш класс Потомок от какого-то очень полезного нам класса Родителя вместе со всеми переменными и методами, но вот некоторые методы работают не совсем так, как нам хочется. Или совсем не так, как нам не хочется.

Что делать в этой ситуации? Можем переопределить не понравившийся нам метод. Делается это очень просто: в нашем классе Потомке просто объявляем метод с такой же сигнатурой (заголовком), что и метод класса Родителя и пишем в нем наш код.

<strong>Пример 1: </strong>переопределение метода.
<table>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-user"><strong>Родитель</strong></span> {

   public String <span class="text-viola"><strong>name</strong></span>;

   public void <span class="text-viola">setName</span> (String nameNew) {
       name = nameNew;
  }

   public <span class="text-viola">getName</span>() {
      return <span class="text-viola"><strong>name</strong></span>;
  }
}
</code></pre>
</td>
<td rowspan="2"><strong>Метод printInfo() выведет на экран фразу <span class="text-green">"Luke, No!!!"</span></strong>
</td>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-green"><strong>Потомок</strong></span> <span class="text-ted"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

   public void <span class="text-viola">setName</span> (String nameNew) {
       <span class="text-viola"><strong>name</strong></span> = nameNew + <span class="text-green">",No!!!"</span>;
  }

   public void printInfo() {

      <span class="text-viola">setName</span>("Luke");
      System.out.println( <span class="text-viola"><strong>getName()</strong></span>);
   }
}
</code></pre>
</td>
</tr>
</table>Вот как выглядит класс <span class="text-green"><strong>Потомок</strong></span> с точки зрения компилятора:

<pre class='lang-java line-numbers'><code>
<strong>public</strong></span> <span class="text-green"><strong>Потомок</strong></span> <span class="text-red"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

   <span style="color:grey">public String name; //  унаследованная переменная</span>

   public void <span class="text-viola">setName</span> (String nameNew) { //  Переопределенный метод взамен унаследованного
   
       <span class="text-viola" ><strong>name</strong></span> = nameNew + <span class="text-green">", No!!!"</span>;
   }
   <span style="color:grey"">public getName() { //  унаследованный метод.

      return name;
   }</span>
   public void printInfo() {

     <span class="text-viola">setName</span>("Luke");
     System.out.println(<span class="text-viola">getName()</span>);
   }
}
</code></pre>
<strong>Пример 2:</strong> немного магии наследования (и переопределения методов).
<table>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-user"><strong>Родитель</strong></span> {

   public <span class="text-viola">getName</span>() {
      return <span class="text-green"><strong>"Luke"</strong></span>;
  }
   public void printInfo() {

     System.out.println(<span class="text-viola">getName</span><strong>()</strong>);
   }
}
</code></pre>	
</td>
</tr>
<tr>
<td><pre class='lang-java line-numbers'><code>
public class <span class="text-green"><strong>Потомок</strong></span> <span class="text-red"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

   public <span class="text-viola">getName</span>() {
      return <span class="text-green"><strong>"I'm your father, Luke"</strong></span>;
  }
}
</code></pre>
</td>
</tr>
</table>В данном примере: если в классе Потомок не переопределен метод <code>printInfo</code> (из класса Родителя), при вызове этого метода у объекта класса Потомок будет вызван его метод <code>getName()</code>, а не <code>getName()</code> класса Родителя.
<table>
<tr>
<td><pre class='lang-java line-numbers'><code>
<span class="text-user"><strong>Родитель</strong></span> parent = new <span class="text-user"><strong>Родитель</strong></span> ();
parent.printnInfo();
</code></pre>
</td>
<td>Этот код выведен на экран надпись <span class="text-green"><strong>"Luke"</strong></span>.
</td>
</tr>
<tr>
<td><pre class='lang-java line-numbers'><code>
<span class="text-green"><strong>Потомок</strong></span> child = new <span class="text-green"><strong>Потомок</strong></span> ();
child.printnInfo();
</code></pre>
</td>
<td>Этот код выведен на экран надпись <span class="text-green"><strong>"I'm your father, Luke;"</strong></span>.
</td>
</tr>
</table>Вот как выглядит класс <span class="text-green"><strong>Потомок</strong></span> с точки зрения компилятора:

<pre class='lang-java line-numbers'><code>
public class <span class="text-green"><strong>Потомок</strong></span> <span class="text-red"><strong>extends</strong></span> <span class="text-user"><strong>Родитель</strong></span> {

   public <span class="text-viola">getName</span>() {
      return <span class="text-green"><strong>"I'm your father, Luke"</strong></span>;
   }
   public void printInfo() {

     System.out.println(getName());
   }
}
</code></pre><h2 id="Списки">3. Списки</h2>Если вы еще не познакомились со списками (List), вот вам краткая информация. Полную информацию вы можете найти на <strong>6-7 уровнях курса JavaRush</strong>.

<strong>Списки имеют много общего с массивами:</strong>
<ul>
<li>могут хранить много данных определенного типа;</li>
<li>позволяют получать элементы по их индексу/номеру;</li>
<li>индексы элементов начинаются с 0.</li>
</ul><strong>Преимущества списков:</strong>

В отличие от массивов, списки могут динамически менять размер. Сразу после создания список имеет размер 0. По мере добавления элементов в список, его размер увеличивается. Пример создания списка:

<pre class='lang-java line-numbers'><code>
ArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;(); // создание нового списка типа ArrayList
</code></pre>
Значение в угловых скобках — это тип данных, которые может хранить список.

Вот некоторые методы для работы со списком:
<table class="table table--striped">
<tr>
<th>Код
</th>
<th>Краткое описание действий кода
</th>
</tr>
<tr>
<td><code><strong>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</strong></code>
</td>
<td>Создание нового списка строк
</td>
</tr>
<tr>
<td><code><strong>list.add("name");</strong></code>
</td>
<td>Добавить элемент в конец списка
</td>
</tr>
<tr>
<td><code><strong>list.add(0, "name");</strong></code>
</td>
<td>Добавить элемент в начало списка
</td>
</tr>
<tr>
<td><code><strong>String name = list.get(5);</strong></code>
</td>
<td>Получить элемент по его индексу
</td>
</tr>
<tr>
<td><code><strong>list.set(5, "new name");</strong></code>
</td>
<td>Изменить элемент по его индексу
</td>
</tr>
<tr>
<td><code><strong>int count = list.size();</strong></code>
</td>
<td>Получить количество элементов в списке
</td>
</tr>
<tr>
<td><code><strong>list.remove(4);</strong></code>
</td>
<td>Удалить элемент из списка
</td>
</tr>
</table>Больше о списках можете узнать из этих статей:
<ol>
<li><a href='https://javarush.com/groups/posts/1934-klass-arraylist' target='_blank'>Класс ArrayList</a></li>
<li><a href='https://javarush.com/groups/posts/1936-rabota-arraylist-v-kartinkakh--' target='_blank'>Работа ArrayList в картинках</a></li>
<li><a href='https://javarush.com/groups/posts/1935-udalenie-ehlementa-iz-spiska-arraylist' target='_blank'>Удаление элемента из списка ArrayList</a></li>
</ol><h2 id="Массивы">4. Массивы</h2>Что такое матрица? Матрица — не что иное как прямоугольная таблица, которая может быть заполнена данными. Другими словами, это двумерный массив. Как вы, наверное, знаете, массивы в Java являются объектами. Стандартный одномерный массив типа <code>int</code> выглядит так:

<pre class='lang-java line-numbers'><code>
<strong>int [] array = {12, 32, 43, 54, 15, 36, 67, 28};</strong>
</code></pre>
Представим это визуально:
<table>
<tr>
<th>0
</th>
<th>1
</th>
<th>2
</th>
<th>3
</th>
<th>4
</th>
<th>5
</th>
<th>6
</td>
<th>7
</th>
</tr>
<tr>
<td>12
</td>
<td>32
</td>
<td>43
</td>
<td>54
</td>
<td>15
</td>
<td>36
</td>
<td>67
</td>
<td>28
</td>
</tr>
</table>Верхняя строка указывает адреса ячеек. То есть, чтобы получить число 67, нужно обратиться к элементу массива с индексом 6:

<pre class='lang-java line-numbers'><code>
int number = array[6];
</code></pre>
Здесь все очень просто. Двумерный массив является массивом одномерных массивов. Если вы об этом слышите впервые, остановитесь и представьте это у себя в голове. Двумерный массив примерно выглядит так:
<table style="text-align:center;">
<tr>
<th>0
</th>
<th rowspan="8"><span style="writing-mode: tb-rl; transform:rotate(180deg); font-size:20px;">Одномерный&nbsp;массив</span></th>
<td>Одномерный массив
</td>
</tr>
<tr>
<th>1
</th>
<td>Одномерный массив
</td>
</tr>
<tr>
<th>2
</th>
<td>Одномерный массив
</td>
</tr>
<tr>
<th>3
</th>
<td>Одномерный массив
</td>
</tr>
<tr>
<th>4
</th>
<td>Одномерный массив
</td>
</tr>
<tr>
<th>5
</th>
<td>Одномерный массив
</td>
</tr>
<tr>
<th>6
</th>
<td>Одномерный массив
</td>
</tr>
<tr>
<th>7
</th>
<td>Одномерный массив
</td>
</tr>
</table>В коде:

<pre class='lang-java line-numbers'><code>
int [][] matrix = {
<div style="margin-left:230px;">{65, 99, 87, 90, 156, 75, 98, 78},
{76, 15, 76, 91, 66, 90, 15, 77},
{65, 96, 17, 25, 36, 75, 54, 78},
{59, 45, 68, 14, 57, 1, 9, 63},
{81, 74, 47, 52, 42, 785, 56, 96},
{66, 74, 58, 16, 98, 140, 55, 77},
{120, 99, 13, 90, 78, 98, 14, 78},
{20, 18, 74, 91, 96, 104, 105, 77}
}</div>
</code></pre>
<table style="text-align:center;" class="table table--striped">
<tr>
<th rowspan="2">0
</th>
<th>0
</th>
<th>1
</th>
<th>2
</th>
<th>3
</th>
<th>4
</th>
<th>5
</th>
<th>6
</th>
<th>7
</th>
</tr>
<tr>
<td>65
</td>
<td>99
</td>
<td>87
</td>
<td>90
</td>
<td>156
</td>
<td>75
</td>
<td>98
</td>
<td>78
</td>
</tr>
<tr>
<th rowspan="2">1
</th>
<td>0
</td>
<td>1
</td>
<td>2
</td>
<td>3
</td>
<td>4
</td>
<td>5
</td>
<td>6
</td>
<td>7
</td>
</tr>
<tr>
<td>76
</td>
<td>15
</td>
<td>76
</td>
<td>91
</td>
<td>66
</td>
<td>90
</td>
<td>15
</td>
<td>77
</td>
</tr>
<tr>
<th rowspan="2">2
</th>
<td>0
</td>
<td>1
</td>
<td>2
</td>
<td>3
</td>
<td>4
</td>
<td>5
</td>
<td>6
</td>
<td>7
</td>
</tr>
<tr>
<td>65
</td>
<td>96
</td>
<td>17
</td>
<td>25
</td>
<td>36
</td>
<td>75
</td>
<td>54
</td>
<td>78
</td>
</tr>
<tr>
<th rowspan="2">3
</th>
<td>0
</td>
<td>1
</td>
<td>2
</td>
<td>3
</td>
<td>4
</td>
<td>5
</td>
<td>6
</td>
<td>7
</td>
</tr>
<tr>
<td>59
</td>
<td>45
</td>
<td>68
</td>
<td>14
</td>
<td>57
</td>
<td>1
</td>
<td>9
</td>
<td>63
</td>
</tr>
<tr>
<th rowspan="2">4
</th>
<td>0
</td>
<td>1
</td>
<td>2
</td>
<td>3
</td>
<td>4
</td>
<td>5
</td>
<td>6
</td>
<td>7
</td>
</tr>
<tr>
<td>81
</td>
<td>74
</td>
<td style="background-color:orange;">47
</td>
<td>52
</td>
<td>42
</td>
<td>785
</td>
<td>56
</td>
<td>96
</td>
</tr>
<tr>
<th rowspan="2">5
</th>
<td>0
</td>
<td>1
</td>
<td>2
</td>
<td>3
</td>
<td>4
</td>
<td>5
</td>
<td>6
</td>
<td>7
</td>
</tr>
<tr>
<td>66
</td>
<td>74
</td>
<td>58
</td>
<td>16
</td>
<td>98
</td>
<td>140
</td>
<td>55
</td>
<td>77
</td>
</tr>
<tr>
<th rowspan="2">6
</th>
<td>0
</td>
<td>1
</td>
<td>2
</td>
<td>3
</td>
<td>4
</td>
<td>5
</td>
<td>6
</td>
<td>7
</td>
</tr>
<tr>
<td>120
</td>
<td>99
</td>
<td>13
</td>
<td>90
</td>
<td>78
</td>
<td>98
</td>
<td>14
</td>
<td>78
</td>
</tr>
<tr>
<th rowspan="2">7
</th>
<td>0
</td>
<td>1
</td>
<td>2
</td>
<td>3
</td>
<td>4
</td>
<td>5
</td>
<td>6
</td>
<td>7
</td>
</tr>
<tr>
<td>20
</td>
<td>18
</td>
<td>74
</td>
<td>91
</td>
<td>96
</td>
<td>104
</td>
<td>105
</td>
<td>77
</td>
</tr>
</table>Чтобы получить значение 47, нужно обратиться к элементу матрицы по адресу [4][2].

<pre class='lang-java line-numbers'><code>
int number = matrix[4][2];
</code></pre>
Если вы заметили, координаты матрицы отличаются от классической прямоугольной системы координат (Декартовой системы координат). <strong>При обращении к матрице сначала вы указываете y, а потом x</strong>, в то время как в математике принято сначала указывать x (x, y).

Возможно, вы задаетесь вопросом: «А почему бы не перевернуть матрицу в своем воображении и не обращаться к элементам привычным путем через (x, y)? От этого же содержимое матрицы не изменится».

Да, ничего не изменится. Но в мире программирования к матрицам принято обращаться в форме «сначала y, потом x». Это нужно принять как должное.

Теперь давайте поговорим о проецировании матрицы на наш движок (класс <code>Game</code>). Как вам известно, у движка есть много методов, которые изменяют клетки игрового поля по заданным координатам. Например, метод <code><strong>setCellValue(int x, int y, String value)</strong></code>. Он устанавливает определенной клетке с координатами (x, y) значение <code>value</code>. Как вы заметили, этот метод вначале принимает именно x, как в классической системе координат. Аналогичным образом работают и остальные методы движка. При разработке игр, часто будет появляться необходимость воспроизводить состояние матрицы на экране. Как же это сделать? 

Во-первых, в цикле нужно перебрать все элементы матрицы.

Во-вторых, для каждого из них вызвать метод для отображения с ИНВЕРТИРОВАНЫМИ координатами.

Пример:

<pre class='lang-java line-numbers'><code>
    private void drawScene() {
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix[i].length; j++) {
                setCellValue(j, i, String.valueOf(matrix[i][j]));
            }
        }
    }
</code></pre>
Естественно, инверсия работает в двух направлениях. В метод <code>setCellValue</code> можно передать (i, j), но при этом из матрицы взять элемент [j][i].

Инверсия может показаться немного трудной, но о ней нужно помнить. И всегда, если возникают какие-то проблемы, стоит взять бумажку с ручкой, начертить матрицу и воспроизвести, какие процессы с ней происходят.
<h2 id="Случайные числа">5. Случайные числа</h2><strong>Как работать с генератором случайных чисел?</strong>

В классе <code>Game</code> определен метод <code><strong>getRandomNumber(int)</strong></code>. Под капотом он использует класс <code>Random</code> из пакета java.util, но принцип работы с генератором случайных чисел от этого не меняется. 

В качестве аргумента <code>getRandomNumber(int)</code> принимает целое число. Это число будет верхней границей, которую может вернуть генератор. Нижней границей является 0. 

<mark>Важно!</mark>

Генератор НИКОГДА не вернет верхнее граничное число. Например, если вызвать <code>getRandomNumber(3)</code> он случайным образом может вернуть 0, 1, 2. Как видите, 3 он вернуть не может. Такое использование генератора является довольно простым, но очень эффективным во многих случаях. 

<strong>Вам нужно получить случайное число в каких-то пределах:</strong>

Представьте, что вам необходимо какое-нибудь трехзначное число (100..999). Как вы уже знаете, минимальное возвращаемое число — 0. Значит, вам нужно будет к нему добавить 100. Но в таком случае необходимо позаботиться о том, чтобы не перешагнуть верхнюю границу. Чтобы получить 999 как максимальное случайное значение, следует вызывать метод <code>getRandomNumber(int)</code> с аргументом 1000. Но мы помним о последующем добавлении 100: значит и верхнюю границу следует понизить на 100. То есть, код для получения случайного трехзначного числа будет выглядеть так:

<pre class='lang-java line-numbers'><code>
<strong>int number = 100 + getRandomNumber(900);</strong>
</code></pre>
Но для упрощения подобной процедуры в движке предусмотрен метод <code>getRandomNumber(int, int)</code>, который в качестве первого аргумента принимает минимальное для возврата число. Используя этот метод, предыдущий пример можно переписать: 

<pre class='lang-java line-numbers'><code>
int number = getRandomNumber(100, 1000);
</code></pre>
Случайные числа могут использоваться для получения случайного элемента массива:

<pre class='lang-java line-numbers'><code>
String [] names = {"Андрей", "Валентин", "Сергей"}; 
String randomName = names[getRandomNumber(names.length)]
</code></pre>
<strong>Вызов определенных событий с некой вероятностью.</strong>

У человека утро начинается по возможными сценариям:

Проспал – 50%;
Встал вовремя – 40%;
Встал на час раньше положенного – 10%. 

Представьте, что вы пишете эмулятор человеческого утра. Вам нужно вызывать события с определенной вероятностью. Для этого, опять-таки, надо воспользоваться генератором случайных чисел. Реализации могут быть разные, но самая простая должна происходить по следующему алгоритму:
<ol>
<li>устанавливаем пределы, в которых нужно сгенерировать число;</li>
<li>генерируем случайное число;</li>
<li>обрабатываем полученное число.</li>
</ol>Итак, в данном случае пределом будет 10. Вызовем метод <code>getRandomNumber(10)</code> и проанализируем, что он нам может вернуть. Вернуть он может 10 цифр (от 0 до 9) и каждую с одинаковой вероятностью — 10%. 

Теперь нам нужно скомбинировать все возможные результаты и сопоставить их с нашими возможными событиями. Комбинаций может быть очень много, в зависимости от вашей фантазии, но самая очевидная звучит: «Если случайное число лежит в пределах [0..4] — вызов события «Проспал», если число в пределах [5..8] — «Встал вовремя», и только если число 9, тогда «Встал на час раньше положенного». 

Все очень просто: в пределах [0..4]  лежит 5 чисел, каждое из которых может вернуться с вероятностью 10%, что в сумме и будет 50%; в пределах [5..8] лежит 4 числа, ну и 9 — единственное число, которое появляется с вероятность 10%. 

В коде вся эта хитромудрая конструкция выглядит еще проще:

<pre class='lang-java line-numbers'><code>
        int randomNumber = getRandomNumber(10);
        if (randomNumber &lt; 5) {
            System.out.println("Проспал ");
        } else if (randomNumber &lt; 9) {
            System.out.println("Встал вовремя ");
        } else {
            System.out.println("Встал на час раньше положенного ");
        }
</code></pre>
Вообще, вариантов применения случайных чисел может быть очень много. Все зависит только от вашей фантазии. Но наиболее эффективно их применять, если нужно многократно получать какой-нибудь результат. Тогда этот результат будет отличаться от предыдущего. С какой-то вероятностью, естественно.

На этом все!

Если вы хотите узнать о разделе "Игры" больше, вот полезная документация, которая может в этом помочь:
<ul>
<li><a href='https://javarush.com/groups/posts/2052-razdel-igrih-na-javarush-chastjh-1-populjarnihe-voprosih' target='_blank'>Раздел "Игры" на JavaRush: Популярные вопросы</a></li>
<li><a href='https://javarush.com/groups/posts/2056-razdel-igrih-na-javarush-chastjh-3-obrabotka-sobihtiy' target='_blank'>Раздел "Игры" на JavaRush: Обработка событий</a></li>
<li><a href='https://javarush.com/groups/posts/2055-razdel-igrih-na-javarush-chastjh-2-opisanie-igrovogo-dvizhka' target='_blank'>Раздел "Игры" на JavaRush: Игровой движок</a></li>
</ul>